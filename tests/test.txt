#define _GNU_SOURCE
#ifndef UTILS_H
#define UTILS_H

#include "hunk.h"
#include <arpa/inet.h>
#include <fcntl.h>
#include <liburing.h>
#include <netdb.h>
#include <signal.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/poll.h>
#include <sys/prctl.h>
#include <sys/socket.h>
#include <sys/sysinfo.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

#define MP_BLOCK  4
#define MAX_CONNS 4096
#define KB        1024
#define NIOS      32

#define IN_POOL(ptr)                 ((void *)ptr >= pool.bpool && (void *)ptr <= (pool.bpool + (pool.npages * pool.pagesize)))
#define ALIGN_TO_PAGESIZE(buff_size) (((buff_size) + (pool.pagesize - 1)) & ~(pool.pagesize - 1))
#define BYTES_TO_BLOCKS(buff_size)   (((buff_size) + (MP_BLOCK - 1)) / MP_BLOCK)
#define CEIL_BLOCKS(nblocks)         ((nblocks + 63) & ~63)
#define CEIL_PAGES(size)             (((size) + ((pool.pagesize) - 1)) & ~((pool.pagesize) - 1))

#define BIT_IS_FREE(word, bit)   (((word) >> (bit)) & 1)
#define MARK_BIT_USED(word, bit) ((word) &= ~(1ULL << (bit)))
#define MARK_BIT_FREE(word, bit) ((word) |= (1ULL << (bit)))
#define FIND_FREE_BIT(word)      ((uint64_t)(word) & -(uint64_t)(word))
#define STRLEN(s)                (sizeof(s) - 1)

#define IOVEC_NBLOCKS (BYTES_TO_BLOCKS(NIOS * sizeof(struct iovec)))
#define MSG_NBLOCKS   (BYTES_TO_BLOCKS(sizeof(struct msghdr)))
#define ZC_RES        KB *KB

#define DEBUG 0
#if DEBUG
#define LOG(...) fprintf(logfd, __VA_ARGS__)
#else
#define LOG(...) ((void)0)
#endif

typedef enum UOP {
  WRITEV = IORING_OP_WRITEV,
  SENDMSG = IORING_OP_SENDMSG,
  RECVMSG = IORING_OP_RECVMSG,
  ACCEPT = IORING_OP_ACCEPT,
  SEND = IORING_OP_SEND,
  RECV = IORING_OP_RECV,
  SENDZC = IORING_OP_SEND_ZC,
  SENDMSGZC = IORING_OP_SENDMSG_ZC,
  PEEK = 50,
  FRECVMSG,
  INSPLICE,
  OUTSPLICE
} UOP;

typedef enum CFS {
  CF_IN_POOL = (1 << 0),       // Connection is in the pool
  CF_IN_HEAP = (1 << 1),       // Connection is in the heap
  CF_SKIP_SOCK = (1 << 2),     // Don't close the socket
  CF_USE_ONCE = (1 << 3),      // Destroy after using
  CF_HANDLER_READY = (1 << 4), // Ready to call the handler
} CFS;

typedef struct conn_t {
  // Socket file descriptor
  int fd;

  // Amount of data left in the current operation
  uint64_t data_left;

  // The index of the connection struct
  uint32_t cindex;

  // The last time the connection was readable
  uint64_t last_read;

  // The last time the connection was writeable
  uint64_t last_write;

  // The operation currently being processed
  uint8_t op;

  // Connection flags
  int flags;

  // Splice fd_in
  int in_fd;

  // Splice fd_out
  int out_fd;

  void *recv_conn;
  void *send_conn;

  struct iovec *ios;
  struct iovec *rec;
  uint16_t nios;

  struct msghdr *msg;
  uint16_t zc_notifs;

  uint16_t head_size;
} conn_t;

typedef struct MPool {
  // The allocated pool of blocks
  void *bpool;

  // The allocated pool of connections
  conn_t *cpool;

  // The size of the pool in pages
  uint32_t npages;

  // The size of the pool in blocks
  uint32_t nblocks;

  // The locations of each page in the pool
  void **blocks;

  // The availability of each block
  uint64_t *freebs;

  // The locations of each conn in the pool
  conn_t **conns;

  // The availability of each conn
  uint64_t *freecs;

  // Clean up callback function
  void (*callback)(conn_t *conn);

  // The page size used
  uint32_t pagesize;

  // Socket read timeout
  uint32_t rtimeout;

  // Socket write timeout
  uint32_t wtimeout;
} MPool;

extern int pipe_sz;
extern int pipe_in, pipe_out, nullfd;
extern FILE *logfd;
extern struct io_uring ring;
extern MPool pool;
extern conn_t *current_recv;
extern conn_t *current_send;

/*
 * Prepare and submit a recv uring op
 */
static inline int urecv(conn_t *conn, void *buffer, size_t buff_size, int flags) {
  if (!conn || conn->fd == -1)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (flags == MSG_PEEK) ? PEEK : RECV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;

  io_uring_prep_recv(sqe, conn->fd, buffer, buff_size, flags);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a multi-shot accept uring op
 */
static inline int umaccept(int listenfd) {
  if (listenfd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = ACCEPT;
  io_uring_prep_multishot_accept(sqe, listenfd, NULL, NULL, SOCK_NONBLOCK);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a splice uring op
 */
static inline int usplice(conn_t *conn, int fd_in, int64_t off_in, int fd_out, int64_t off_out, size_t len) {
  if (!len || !conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = (__u64)conn;
  io_uring_prep_splice(sqe, fd_in, off_in, fd_out, off_out, len, 0);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a writev uring op
 */
static inline int uwritev(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = WRITEV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  io_uring_prep_writev(sqe, conn->fd, &conn->ios[iov_index], nios, -1);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a send uring op
 */
static inline int usend(conn_t *conn, char *res_buff, size_t buff_size, bool zc) {
  if (!conn || conn->fd <= 0 || buff_size == 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (zc) ? SENDZC : SEND;
  conn->data_left = buff_size;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  if (zc)
    io_uring_prep_send_zc(sqe, conn->fd, res_buff, buff_size, 0, 0);
  else
    io_uring_prep_send(sqe, conn->fd, res_buff, buff_size, 0);
  return io_uring_submit(&ring);
}

static inline int ufrecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = FRECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;

  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, rec->iov_len);
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int urecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = RECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int usendmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  bool zc = (conn->data_left > ZC_RES) ? true : false;
  conn->op = (zc) ? SENDMSGZC : SENDMSG;

  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  if (zc) {
    io_uring_prep_sendmsg_zc(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
    conn->zc_notifs++;
  } else {
    io_uring_prep_sendmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  }
  return io_uring_submit(&ring);
}

/*
 * Create and initialize a server socket
 */
static inline int tcp_listen(uint16_t port) {
  int enable;
  int listenfd;
  if ((listenfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    return -1;

  int flags = fcntl(listenfd, F_GETFL, 0);
  fcntl(listenfd, F_SETFL, flags | O_NONBLOCK);
  struct sockaddr_in servaddr;
  memset(&servaddr, 0, sizeof(servaddr));
  servaddr.sin_family = AF_INET;
  servaddr.sin_addr.s_addr = INADDR_ANY;
  servaddr.sin_port = htons(port);

  enable = 1;
  if (setsockopt(listenfd, SOL_SOCKET, SO_REUSEPORT, &enable, sizeof(enable)) < 0)
    return -1;

  if (bind(listenfd, (struct sockaddr *)&servaddr, sizeof(servaddr)) < 0)
    return -1;

  if (listen(listenfd, SOMAXCONN) < 0)
    return -1;

  return listenfd;
}

/*
 * Calculate the difference between two pointers
 */
static inline uintptr_t ptr_diff(uintptr_t p1, uintptr_t p2) { return (uintptr_t)(p1 > p2) ? (p1 - p2) : (p2 - p1); }

static inline size_t get_nroutes(Route *routes) {
  Route *route;
  for (size_t i = 0;; i++) {
    route = &routes[i];
    if (!route->path && !route->handler && !route->method)
      return i;
  }
}

static inline long get_content_length(char *src, char *end) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return -1;
    key = line;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, "Content-Length") != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;

    *line_end = '\0';
    long res = atol(value);
    *line_end = '\r';

    return res;
  }
  return -1;
}

static inline bool have_header(char *src, char *end, const char *header_key, const char *header_value) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    key = line;
    while (*key == ' ')
      key++;
    while (*header_key == ' ')
      header_key++;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return false;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, header_key) != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;
    while (*header_value == ' ')
      header_value++;

    *line_end = '\0';
    bool res = (strcasecmp(value, header_value) == 0);
    *line_end = '\r';

    return res;
  }

  return false;
}

static inline const char *method_str(Method method) {
  switch (method) {
  case GET:
    return "GET";
    break;
  case HEAD:
    return "HEAD";
    break;
  case POST:
    return "POST";
    break;
  case PUT:
    return "PUT";
    break;
  case DELETE:
    return "DELETE";
    break;
  case CONNECT:
    return "CONNECT";
    break;
  case OPTIONS:
    return "OPTIONS";
    break;
  case TRACE:
    return "TRACE";
    break;
  case PATCH:
    return "PATCH";
    break;
  default:
    return NULL;
  }
}

static inline uint8_t method_len(Method method) {
  switch (method) {
  case GET:
    return 3;
    break;
  case HEAD:
    return 4;
    break;
  case POST:
    return 4;
    break;
  case PUT:
    return 3;
    break;
  case DELETE:
    return 6;
    break;
  case CONNECT:
    return 7;
    break;
  case OPTIONS:
    return 7;
    break;
  case TRACE:
    return 5;
    break;
  case PATCH:
    return 5;
    break;
  default:
    return 0;
  }
}

static inline size_t round_to_blocks(size_t size) {
  size_t nblocks = BYTES_TO_BLOCKS(size);
  nblocks = CEIL_BLOCKS(nblocks);
  return nblocks;
}

/*
 * Count the digits in unsigned 64-bit int
 */
static inline int countd(uint64_t num) {
  if (num < 10ULL)
    return 1;
  if (num < 100ULL)
    return 2;
  if (num < 1000ULL)
    return 3;
  if (num < 10000ULL)
    return 4;
  if (num < 100000ULL)
    return 5;
  if (num < 1000000ULL)
    return 6;
  if (num < 10000000ULL)
    return 7;
  if (num < 100000000ULL)
    return 8;
  if (num < 1000000000ULL)
    return 9;
  if (num < 10000000000ULL)
    return 10;
  if (num < 100000000000ULL)
    return 11;
  if (num < 1000000000000ULL)
    return 12;
  if (num < 10000000000000ULL)
    return 13;
  if (num < 100000000000000ULL)
    return 14;
  if (num < 1000000000000000ULL)
    return 15;
  if (num < 10000000000000000ULL)
    return 16;
  if (num < 100000000000000000ULL)
    return 17;
  if (num < 1000000000000000000ULL)
    return 18;
  if (num < 10000000000000000000ULL)
    return 19;
  return 20;
}

/*
 * Get the time elabsed in ms
 */
static inline uint64_t get_time() {
  struct timespec ts;
  clock_gettime(CLOCK_MONOTONIC, &ts);
  return (uint64_t)(ts.tv_sec) * 1000 + (ts.tv_nsec / 1000000);
}

static inline FILE *log_init(const char *path) {
  FILE *res = fopen(path, "a+");
  setvbuf(res, NULL, _IONBF, 0);
  return res;
}

static inline int16_t pollevs(int connfd) {
  struct pollfd pfd;
  pfd.fd = connfd;
  pfd.events = POLLIN | POLLOUT | POLLERR;
  int res = poll(&pfd, 1, 0);
  if (res < 0)
    return POLLERR;
  return pfd.revents;
}

// FIXME This needs to be updated
static inline conn_t *MP_use_once(size_t nblocks, int fd) {

  void *mem = malloc(sizeof(conn_t) + 8 + (IOVEC_NBLOCKS * MP_BLOCK));
  struct conn_t *conn = (conn_t *)mem;
  memset(conn, 0, sizeof(conn_t));
  conn->ios = mem + sizeof(conn_t) + 8;

  if (nblocks > 0) {
    struct iovec *iov = &conn->ios[conn->nios++];
    mem = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (mem == MAP_FAILED)
      return NULL;
    iov->iov_base = mem;
    iov->iov_len = ALIGN_TO_PAGESIZE(nblocks * MP_BLOCK);
  }

  conn->flags |= CF_IN_HEAP;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;

  return conn;
}

static inline int find_freec() {
  uint64_t *word;
  size_t map_size = (sizeof(uint64_t) * 8);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    word = &pool.freecs[i / map_size];

    if (*word == 0) { // All used
      i += (map_size - 1);
      continue;
    }

    i += __builtin_ctzll(*word);
    MARK_BIT_USED(*word, i);
    return i;
  }

  return -1;
}

static inline int MP_init(size_t npages) {
  if (!npages)
    return -1;

  /*** Setup ***/
  pool.npages = npages;
  pool.pagesize = sysconf(_SC_PAGESIZE);

  /*** Pool ***/
  pool.bpool = mmap(NULL, pool.npages * pool.pagesize, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  if (pool.bpool == MAP_FAILED)
    return -1;
  pool.nblocks = (pool.npages * pool.pagesize) / MP_BLOCK;

  /*** Blocks ***/
  pool.blocks = malloc(sizeof(void *) * pool.nblocks);
  if (!pool.blocks)
    return -1;
  for (size_t i = 0; i < pool.nblocks; i++)
    pool.blocks[i] = pool.bpool + (i * MP_BLOCK);

  /*** Freebs ***/
  // if (posix_memalign((void **)&pool.freebs, 64, bitmap_size * sizeof(uint64_t)) < 0)
  size_t bitmap_size = (pool.nblocks + 63) / 64;
  pool.freebs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freebs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freebs[i] = UINT64_MAX;

  /*** Cpool ***/
  pool.cpool = (conn_t *)malloc(sizeof(conn_t) * MAX_CONNS);
  if (!pool.cpool)
    return -1;

  /*** Conns ***/
  pool.conns = (conn_t **)malloc(sizeof(conn_t *) * MAX_CONNS);
  if (!pool.conns)
    return -1;
  size_t conn_size = sizeof(conn_t);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    pool.conns[i] = (conn_t *)((char *)pool.cpool + (i * conn_size));
    pool.conns[i]->fd = -1;
    pool.conns[i]->in_fd = -1;
    pool.conns[i]->out_fd = -1;
  }

  /*** Freecs ***/
  bitmap_size = (MAX_CONNS + 63) / 64;
  pool.freecs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freecs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freecs[i] = UINT64_MAX;

  return 0;
}

static inline int MP_use_blks(size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t max_start = pool.nblocks - nblocks;
  size_t full_chunks = (nblocks / 64) * 64;

  for (size_t i = 0, c = 0; i <= max_start; i++, c++) {
    bool free = true;

    for (size_t j = 0; j < full_chunks; j += 64) {
      size_t word_index = (i + j) / 64;
      if (pool.freebs[word_index] != UINT64_MAX) {
        free = false;
        i += 63;
        break;
      }
    }

    for (size_t j = full_chunks; j < nblocks; j++) {
      size_t bit_index = i + j;
      size_t word_index = bit_index / 64;
      size_t bit_in_word = bit_index % 64;

      if (!BIT_IS_FREE(pool.freebs[word_index], bit_in_word)) {
        free = false;
        i += j;
        break;
      }
    }

    if (free) {
      for (size_t j = 0; j < full_chunks; j += 64) {
        size_t word_index = (i + j) / 64;
        pool.freebs[word_index] = 0;
      }

      for (size_t j = full_chunks; j < nblocks; j++) {
        size_t bit_index = i + j;
        size_t word_index = bit_index / 64;
        size_t bit_in_word = bit_index % 64;

        MARK_BIT_USED(pool.freebs[word_index], bit_in_word);
      }

      return i;
    }
  }

  return -1;
}

static inline int MP_free_blks(size_t bindex, size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t full_chunks = (nblocks / 64) * 64;
  for (size_t i = 0; i < full_chunks; i += 64) {
    size_t word_index = (bindex + i) / 64;
    pool.freebs[word_index] = UINT64_MAX;
  }

  for (size_t i = full_chunks; i < nblocks; i++) {
    size_t bit_index = bindex + i;
    size_t word_index = bit_index / 64;
    size_t bit_in_word = bit_index % 64;

    MARK_BIT_FREE(pool.freebs[word_index], bit_in_word);
  }

  memset(pool.blocks[bindex], 0, nblocks * MP_BLOCK);
  return 0;
}

static inline conn_t *MP_use(size_t nblocks, int fd, bool once) {
  if (fd <= 0)
    return NULL;
  if (once)
    return MP_use_once(nblocks, fd);

  int cindex = find_freec();
  if (cindex < 0) {
    LOG("Err: cindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  conn_t *conn = pool.conns[cindex];

  int ios_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (ios_bindex < 0) {
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }

  struct iovec *ios = pool.blocks[ios_bindex];
  conn->ios = ios;

  int rec_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (rec_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct iovec *rec = pool.blocks[rec_bindex];
  conn->rec = rec;

  int msg_bindex = MP_use_blks(MSG_NBLOCKS);
  if (msg_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct msghdr *msg = pool.blocks[msg_bindex];
  conn->msg = msg;

  if (nblocks > 0) {
    int bindex = MP_use_blks(nblocks);
    if (bindex < 0) {
      MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
      MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
      MP_free_blks(msg_bindex, IOVEC_NBLOCKS);
      MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
      LOG("Err: bindex < 0; will use MP_use_once\n");
      return MP_use_once(nblocks, fd);
    }

    size_t iov_index = conn->nios++;
    struct iovec *iov = &conn->ios[iov_index];
    struct iovec *rec = &conn->rec[iov_index];
    iov->iov_base = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
  }

  conn->msg->msg_iov = conn->ios;
  conn->msg->msg_iovlen = conn->nios;
  conn->cindex = cindex;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;
  return conn;
}

static inline void MP_shed(conn_t *conn, size_t iov_index, size_t nios) {
  struct iovec *iov, *rec;
  size_t bindex, nblocks, index;

  for (size_t i = 0; i < nios; i++) {
    index = iov_index + i;
    iov = &conn->ios[index];
    rec = &conn->rec[index];
    if (!rec || !rec->iov_base)
      continue;
    if (!IN_POOL(rec->iov_base)) {
      munmap(rec->iov_base, rec->iov_len / pool.pagesize);
    } else {
      bindex = ptr_diff((uintptr_t)rec->iov_base, (uintptr_t)pool.bpool) / MP_BLOCK;
      nblocks = rec->iov_len / MP_BLOCK;
      MP_free_blks(bindex, nblocks);
    }
    memset(iov, 0, sizeof(struct iovec));
    memset(rec, 0, sizeof(struct iovec));
    conn->nios--;
  }
}

static inline int MP_expand(conn_t *conn, size_t nblocks, bool once) {
  void *bptr;
  int iov_index, bindex;
  struct iovec *iov, *rec;

  iov_index = conn->nios++;
  iov = &conn->ios[iov_index];
  rec = &conn->rec[iov_index];

  if (nblocks == 0)
    return iov_index;

  if (once) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_base = bptr;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
    return iov_index;
  }

  bindex = MP_use_blks(nblocks);
  if (bindex < 0) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_len = iov->iov_len;
  } else {
    bptr = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_len = iov->iov_len;
  }

  iov->iov_base = bptr;
  rec->iov_base = iov->iov_base;
  return iov_index;
}

static inline int MP_free(conn_t *conn) {
  if (!conn)
    return -1;
  size_t bindex, nblocks;
  uint64_t *word;

  MP_shed(conn, 0, conn->nios);
  if (conn->flags & CF_IN_HEAP) {
    if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
      close(conn->fd);
    free(conn);
    return 0;
  }

  word = &pool.freecs[conn->cindex / 64];
  if (conn->cindex > MAX_CONNS)
    return -1;
  else if (BIT_IS_FREE(*word, conn->cindex))
    return 0;

  bindex = ptr_diff((uintptr_t)conn->ios, (uintptr_t)pool.bpool) / MP_BLOCK;
  nblocks = IOVEC_NBLOCKS;
  MP_free_blks(bindex, nblocks);

  bindex = ptr_diff((uintptr_t)conn->rec, (uintptr_t)pool.bpool) / MP_BLOCK;
  MP_free_blks(bindex, nblocks);

  if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
    close(conn->fd);

  MARK_BIT_FREE(*word, conn->cindex);
  memset(conn, 0, sizeof(conn_t));
  conn->fd = -1;
  conn->in_fd = -1;
  conn->out_fd = -1;
  return 0;
}

static inline void MP_clear(conn_t *conn) {
  conn_t *recv_conn = conn->recv_conn;
  conn_t *send_conn = conn->send_conn;
  if (recv_conn)
    MP_free(recv_conn);
  if (send_conn)
    MP_free(send_conn);
}

static inline void MP_exit(MPool *pool) {
  munmap(pool->bpool, pool->npages);
  free(pool->cpool);
  free(pool->blocks);
  free(pool->conns);
  free(pool->freebs);
  free(pool->freecs);
}

static inline void MP_timeout() {
  conn_t *conn;
  int16_t res;
  uint64_t now;
  size_t windex = 0;
  uint64_t *word = &pool.freecs[0];
  for (size_t i = 0; i < MAX_CONNS; i++) {
    if ((i / 64) < windex)
      word = &pool.freecs[++windex];

    if (*word == UINTMAX_MAX) {
      i = (i / 64) * 64 + 64;
      continue;
    }

    conn = pool.conns[i];
    if (!conn || conn->fd == -1)
      continue;

    res = pollevs(conn->fd);

    now = get_time();
    if (res & POLLERR) {
      MP_clear(conn);
      continue;
    }
    if (res & POLLIN) {
      if (pool.rtimeout > 0 && (now - conn->last_read) >= pool.rtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (res & POLLOUT) {
      if (pool.wtimeout > 0 && (now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (!(res & POLLIN || res & POLLOUT)) {
      if ((pool.rtimeout > 0 && now - conn->last_read) >= pool.rtimeout
          || (pool.wtimeout > 0 && now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
  }
}

/*
 * Calculate the length of a status string
 */
static inline size_t status_len(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return 8;
  case STATUSSWITCHINGPROTOCOLS:
    return 19;
  case STATUSPROCESSING:
    return 10;
  case STATUSEARLYHINTS:
    return 11;
  case STATUSOK:
    return 2;
  case STATUSCREATED:
    return 7;
  case STATUSACCEPTED:
    return 8;
  case STATUSNONAUTHORITATIVE:
    return 29;
  case STATUSNOCONTENT:
    return 10;
  case STATUSRESETCONTENT:
    return 13;
  case STATUSPARTIALCONTENT:
    return 15;
  case STATUSMULTISTATUS:
    return 12;
  case STATUSALREADYREPORTED:
    return 16;
  case STATUSIMUSED:
    return 7;
  case STATUSMULTIPLECHOICES:
    return 16;
  case STATUSMOVEDPERMANENTLY:
    return 17;
  case STATUSFOUND:
    return 5;
  case STATUSSEEOTHER:
    return 9;
  case STATUSNOTMODIFIED:
    return 12;
  case STATUSUSEPROXY:
    return 9;
  case STATUSTEMPORARYREDIRECT:
    return 18;
  case STATUSPERMANENTREDIRECT:
    return 18;
  case STATUSBADREQUEST:
    return 11;
  case STATUSUNAUTHORIZED:
    return 12;
  case STATUSPAYMENTREQUIRED:
    return 16;
  case STATUSFORBIDDEN:
    return 9;
  case STATUSNOTFOUND:
    return 9;
  case STATUSMETHODNOTALLOWED:
    return 18;
  case STATUSNOTACCEPTABLE:
    return 14;
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return 29;
  case STATUSREQUESTTIMEOUT:
    return 15;
  case STATUSCONFLICT:
    return 8;
  case STATUSGONE:
    return 4;
  case STATUSLENGTHREQUIRED:
    return 15;
  case STATUSPRECONDITIONFAILED:
    return 19;
  case CONTENTTOOLARGE:
    return 17;
  case STATUSURITOOLONG:
    return 12;
  case STATUSUNSUPPORTEDMEDIATYPE:
    return 22;
  case STATUSRANGENOTSATISFIABLE:
    return 21;
  case STATUSEXPECTATIONFAILED:
    return 18;
  case STATUSMISDIRECTEDREQUEST:
    return 19;
  case STATUSUNPROCESSABLECONTENT:
    return 21;
  case STATUSLOCKED:
    return 6;
  case STATUSFAILEDDEPENDENCY:
    return 17;
  case STATUSTOOEARLY:
    return 9;
  case STATUSUPGRADEREQUIRED:
    return 16;
  case STATUSPRECONDITIONREQUIRED:
    return 21;
  case STATUSTOOMANYREQUESTS:
    return 17;
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return 31;
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return 29;
  case STATUSInternalServerError:
    return 21;
  case STATUSNOTIMPLEMENTED:
    return 15;
  case STATUSBADGATEWAY:
    return 11;
  case STATUSSERVICEUNAVAILABLE:
    return 19;
  case STATUSGATEWAYTIMEOUT:
    return 15;
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return 26;
  case STATUSVARIANTALSONEGOTIATES:
    return 23;
  case STATUSINSUFFICIENTSTORAGE:
    return 20;
  case STATUSLOOPDETECTED:
    return 13;
  case STATUSNOTEXTENDED:
    return 12;
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return 31;
  default:
    return 0;
  }
}

/*
 * Return the status code string as string literal
 */
static inline char *status_str(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return "Continue";
  case STATUSSWITCHINGPROTOCOLS:
    return "Switching Protocols";
  case STATUSPROCESSING:
    return "Processing";
  case STATUSEARLYHINTS:
    return "Early Hints";
  case STATUSOK:
    return "OK";
  case STATUSCREATED:
    return "Created";
  case STATUSACCEPTED:
    return "Accepted";
  case STATUSNONAUTHORITATIVE:
    return "Non-Authoritative Information";
  case STATUSNOCONTENT:
    return "No Content";
  case STATUSRESETCONTENT:
    return "Reset Content";
  case STATUSPARTIALCONTENT:
    return "Partial Content";
  case STATUSMULTISTATUS:
    return "Multi-Status";
  case STATUSALREADYREPORTED:
    return "Already Reported";
  case STATUSIMUSED:
    return "Im Used";
  case STATUSMULTIPLECHOICES:
    return "Multiple Choices";
  case STATUSMOVEDPERMANENTLY:
    return "Moved Permanently";
  case STATUSFOUND:
    return "Found";
  case STATUSSEEOTHER:
    return "See Other";
  case STATUSNOTMODIFIED:
    return "Not Modified";
  case STATUSUSEPROXY:
    return "Use Proxy";
  case STATUSTEMPORARYREDIRECT:
    return "Temporary Redirect";
  case STATUSPERMANENTREDIRECT:
    return "Permanent Redirect";
  case STATUSBADREQUEST:
    return "Bad Request";
  case STATUSUNAUTHORIZED:
    return "Unauthorized";
  case STATUSPAYMENTREQUIRED:
    return "Payment Required";
  case STATUSFORBIDDEN:
    return "Forbidden";
  case STATUSNOTFOUND:
    return "Not Found";
  case STATUSMETHODNOTALLOWED:
    return "Method Not Allowed";
  case STATUSNOTACCEPTABLE:
    return "Not Acceptable";
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return "Proxy Authentication Required";
  case STATUSREQUESTTIMEOUT:
    return "Request Timeout";
  case STATUSCONFLICT:
    return "Conflict";
  case STATUSGONE:
    return "Gone";
  case STATUSLENGTHREQUIRED:
    return "Length Required";
  case STATUSPRECONDITIONFAILED:
    return "Precondition Failed";
  case CONTENTTOOLARGE:
    return "Content Too Large";
  case STATUSURITOOLONG:
    return "URI Too Long";
  case STATUSUNSUPPORTEDMEDIATYPE:
    return "Unsupported Media Type";
  case STATUSRANGENOTSATISFIABLE:
    return "Range Not Satisfiable";
  case STATUSEXPECTATIONFAILED:
    return "Expectation Failed";
  case STATUSMISDIRECTEDREQUEST:
    return "Misdirected Request";
  case STATUSUNPROCESSABLECONTENT:
    return "Unprocessable Content";
  case STATUSLOCKED:
    return "Locked";
  case STATUSFAILEDDEPENDENCY:
    return "Failed Dependency";
  case STATUSTOOEARLY:
    return "Too Early";
  case STATUSUPGRADEREQUIRED:
    return "Upgrade Required";
  case STATUSPRECONDITIONREQUIRED:
    return "Precondition Required";
  case STATUSTOOMANYREQUESTS:
    return "Too Many Requests";
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return "Request Header Fields Too Large";
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return "Unavailable For Legal Reasons";
  case STATUSInternalServerError:
    return "Internal Server Error";
  case STATUSNOTIMPLEMENTED:
    return "Not Implemented";
  case STATUSBADGATEWAY:
    return "Bad Gateway";
  case STATUSSERVICEUNAVAILABLE:
    return "Service Unavailable";
  case STATUSGATEWAYTIMEOUT:
    return "Gateway Timeout";
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return "HTTP Version Not Supported";
  case STATUSVARIANTALSONEGOTIATES:
    return "Variant Also Negotiates";
  case STATUSINSUFFICIENTSTORAGE:
    return "Insufficient Storage";
  case STATUSLOOPDETECTED:
    return "Loop Detected";
  case STATUSNOTEXTENDED:
    return "Not Extended";
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return "Network Authentication Required";
  default:
    return 0;
  }
}

/*
 * Return true if routes match
 */
static inline bool route_equ(Route *route, Request *req) {
  return route->method == req->method && strncmp(route->path, req->path, strlen(route->path)) == 0;
}

/*
 * Return the matching route index on success. -1 on failure
 */
static inline int match_route(Server *serv, Request *req) {
  for (size_t i = 0; i < serv->_nroutes; i++) {
    Route route = serv->routes[i];
    if (!req->path || !route.path)
      continue;
    if (route_equ(&route, req))
      return i;
    else if (req->method == HEAD && route.method == GET && strcmp(route.path, req->path) == 0)
      return i;
  }
  return -1;
}

/*
 * Return true if the response should contain the Content-Length header
 */
static inline bool should_have_content_length(Request *req, ResWriter *res) {
  return (req->method != CONNECT              // CONNECT request
          && res->status != STATUSNOCONTENT   // 204 response
          && res->status != STATUSNOTMODIFIED // 304 response
          && res->status >= 200);             // 1xx response
}

/*
 * Format http response from the ResWriter.
 * Return response size on success, 0 on failure.
 */
static inline size_t fmt_res(Request *req, ResWriter *res, char *buffer, size_t buffer_size) {
  if (!res || !buffer || buffer_size == 0)
    return 0;

  size_t res_len, total = 0;
  char *dst = buffer;
  size_t maxlen = buffer_size;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t body_length = res->len;

  res_len = snprintf(dst, maxlen, "HTTP/1.1 %d %s", (int)res->status, status_str(res->status));
  total += res_len;
  dst += res_len;
  maxlen -= res_len;

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    res_len = snprintf(dst, maxlen, "\r\n%s: %s", header->key, header->value);
    total += res_len;
    dst += res_len;
    maxlen -= res_len;
  }

  if (have_content_length) {
    res_len = snprintf(dst, maxlen, "\r\nContent-Length: %lu", body_length);
    total += res_len, dst += res_len, maxlen -= res_len;
  }

  memcpy(dst, "\r\n\r\n", 4);
  total += 4, dst += 4, maxlen -= 4;

  return total;
}

static inline size_t res_len(Request *req, ResWriter *res) {
  if (!req || !res)
    return 0;

  if (!res->status)
    res->status = STATUSOK;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t result = 0;
  result += STRLEN("HTTP/1.1 ");     // HTTP version
  result += 4;                       // Status code + space
  result += status_len(res->status); // Status name

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    result += 2;                       // "\r\n"
    result += strlen(header->key) + 2; // Header key + ':' + space
    result += strlen(header->value);   // header value
  }

  if (have_content_length) {
    result += 2;                          // "\r\n"
    result += STRLEN("Content-Length: "); // Header key
    result += countd(res->len);           // Header value
  }

  result += 4; // "\r\n\r\n"

  return result;
}

static inline int send_empty_res(Status status) {
  size_t res_len = STRLEN("HTTP/1.1 ")        // HTTP version
                   + countd((uint64_t)status) // status code
                   + 1                        // space
                   + (int)status_len(status)  // status string
                   + 4;                       // \r\n\r\n

  conn_t *conn = current_send;
  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, res_len);
  if (snprintf((char *)rec->iov_base, res_len + 1, "HTTP/1.1 %d %s\r\n\r\n", (int)status, status_str(status))
      != (int)res_len)
    return -1;

  return usendmsg(conn, 0, 1);
}

static inline ssize_t read_socket(int sockfd, size_t len) {
  if (len == 0 || sockfd <= 0)
    return 0;
  char buff[1024 * 8];
  return read(sockfd, buff, 1024 * 8);
}

static inline int read_method(Method *method, void *src) {
  if (memcmp(src, "GET", 3) == 0)
    *method = GET;
  else if (memcmp(src, "POST", 4) == 0)
    *method = POST;
  else if (memcmp(src, "HEAD", 4) == 0)
    *method = HEAD;
  else if (memcmp(src, "PUT", 3) == 0)
    *method = PUT;
  else if (memcmp(src, "DELETE", 6) == 0)
    *method = DELETE;
  else if (memcmp(src, "CONNECT", 7) == 0)
    *method = CONNECT;
  else if (memcmp(src, "OPTIONS", 7) == 0)
    *method = OPTIONS;
  else if (memcmp(src, "TRACE", 5) == 0)
    *method = TRACE;
  else if (memcmp(src, "PATCH", 5) == 0)
    *method = PATCH;
  else
    return -1;

  return 0;
}

static inline int sendmsg_res(Request *req, ResWriter *res) {
  conn_t *conn;
  size_t head_size, res_size;
  struct iovec *iov;

  conn = current_send;
  iov = &conn->ios[0];
  head_size = res_len(req, res);
  if (head_size == 0)
    return -1;

  conn->data_left += head_size;
  res_size = fmt_res(req, res, iov->iov_base, (head_size + 1));
  if (res_size != head_size)
    return -1;
  iov->iov_len = res_size;

  return usendmsg(conn, 0, conn->nios);
}

static inline int read_req(Request *req, char *req_buffer) {
  if (!req_buffer)
    return -1;
  /*** Method ***/
  char *sep = strchr(req_buffer, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }
  *sep = '\0';
  if (read_method(&req->method, req_buffer) < 0)
    return -1;

  /*** Path ***/
  char *fullpath = sep + 1;
  sep = strchr(fullpath, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }

  *sep = '\0';
  req->path = fullpath;
  /*** Params ***/
  char *paramStart = strchr(fullpath, '?');
  if (paramStart) {
    *paramStart++ = '\0';
    int params_count = 0;
    params_count = HK_parse_params(paramStart, req->params, MAX_URL_PARAMETERS);
    if (params_count > 0)
      req->params_count = params_count;
    else
      req->params_count = 0;
  } else {
    req->params = NULL;
    req->params_count = 0;
  }

  /*** Headers ***/
  char *headStart = strstr(sep + 1, "\r\n");
  char *headEnd = strstr(sep + 1, "\r\n\r\n");
  if (!headStart) {
    LOG("read_req: !headStart\n");
    return -1;
  };

  memset(headStart, 0, 2);
  headStart += 2;
  memset(headEnd, 0, 4);
  headEnd += 4;

  int headers_count = HK_parse_headers(headStart, req->headers, MAX_REQ_HEADERS);
  if (headers_count <= 0)
    return -1;
  req->headers_count = headers_count;

  /*** Host ***/
  int index = HK_get_header(req, "Host");
  if (index < 0)
    return -1;
  char *host = req->headers[index].value;
  req->hostname = host;

  /*** Port ***/
  char *colon = strchr(host, ':');
  if (colon) {
    *colon++ = '\0';
    req->port = atoi(colon);
  } else {
    req->port = PORT;
  }
  return 0;
}
static inline int process_req(Server *serv, conn_t *conn) {
  if (!conn || conn->fd == -1)
    return -1;

  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;
  if (read_req(&req, conn->ios[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    LOG("Err: route_index == -1\n");
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;
  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  sendmsg_res(&req, &res);

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int new_conn(int connfd) {
  if (connfd <= 0)
    return -1;

  current_recv = MP_use(KB * 2, connfd, false);
  current_send = MP_use(KB * 2, connfd, false);

  current_recv->recv_conn = current_recv;
  current_recv->send_conn = current_send;

  current_send->send_conn = current_send;
  current_send->recv_conn = current_recv;

  conn_t *conn = current_recv;
  if (ufrecvmsg(conn, 0, 1) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

static inline int resubmit_sendmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return usendmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int resubmir_recvmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    // FIXME the len should be increased
    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return urecvmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int handle_sendmsg_complete(conn_t *conn) {
  struct iovec *iov, *rec;

  MP_shed(conn, 1, conn->nios - 1);
  iov = &conn->ios[0];
  rec = &conn->rec[0];
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;

  return ufrecvmsg(conn->recv_conn, 0, 1);
}

static inline int handle_sendmsg(conn_t *conn, int res, bool zc) {
  if (!conn || conn->fd == -1)
    return -1;

  conn->data_left -= res;
  if (conn->data_left > 0)
    return resubmit_sendmsg(conn, res);

  if (zc)
    return 0;

  return handle_sendmsg_complete(conn);
}

static inline int handle_insplice(conn_t *conn) {
  conn->op = OUTSPLICE;
  return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
}
static inline int handle_outsplice(conn_t *conn, int res) {
  conn->data_left -= res;
  if (conn->data_left > 0) {
    conn->op = INSPLICE;
    return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
  }

  conn_t *recv_conn = conn->recv_conn;
  struct iovec *iov = &recv_conn->ios[0];
  memset(iov->iov_base, 0, iov->iov_len);
  if (urecv(recv_conn, iov->iov_base, iov->iov_len, MSG_PEEK) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

/*
static inline int handle_recv(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  void *bptr = conn->ios[0].iov_base;
  void *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  void *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  return process_req(serv, conn);
}
*/
static inline int find_route(Server *serv, char *bptr) {
  Request req = {0};
  if (read_method(&req.method, bptr) < 0) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  };
  char *space = strchr(bptr, ' ');
  req.path = (space + 1);
  space = strchr(req.path, ' ');
  *space = '\0';
  int route_index = match_route(serv, &req);
  *space = ' ';
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }
  return route_index;
}

static inline int run_handler(Server *serv, conn_t *conn, bool uses_body) {
  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;

  if (read_req(&req, conn->rec[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  if (uses_body) {
    int h_index = HK_get_header(&req, "Content-Length");
    long body_size = atol(req.headers[h_index].value);
    if (body_size >= 0) {
      req.body.ptr = conn->rec[1].iov_base;
      req.body.size = body_size;
    } else {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    }
  }

  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  sendmsg_res(&req, &res);

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int handle_frecvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  char *bptr = (char *)conn->ios[0].iov_base;
  char *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  char *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  size_t head_size = (headEnd + 4) - bptr;
  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  int route_index = find_route(serv, bptr);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  bool uses_body = serv->routes[route_index].uses_body;
  long body_size = get_content_length(headstart + 2, headEnd + 4);
  if (body_size == -1) {
    if (uses_body) {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    } else {
      body_size = 0;
    }
  }

  conn->head_size = head_size;
  if (!uses_body) {
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  if (res == (int)(head_size + body_size)) {
    size_t iov_index = MP_expand(conn, round_to_blocks(body_size), false);
    memcpy(conn->rec[iov_index].iov_base, headEnd + 4, body_size);
    conn->ios[iov_index].iov_len = body_size;
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  conn->data_left = body_size - (res - head_size);
  bool once = ((size_t)body_size > (size_t)((pool.nblocks * MP_BLOCK) / 10));
  size_t iov_index = MP_expand(conn, round_to_blocks(body_size), once);
  memcpy(conn->rec[iov_index].iov_base, headEnd + 4, (res - head_size));
  conn->ios[iov_index].iov_base += (res - head_size);

  return urecvmsg(conn, iov_index, 1);
}

static inline int handle_recvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  if (conn->data_left > 0) {
    conn->data_left -= res;
    if (conn->data_left == 0) {
      conn->flags &= CF_HANDLER_READY;
      return run_handler(serv, conn, true);
    }

    conn->flags &= ~CF_HANDLER_READY;
    conn->ios[1].iov_base += res;
    return urecvmsg(conn, 1, 1);
  }

  conn->flags &= CF_HANDLER_READY;
  return run_handler(serv, conn, true);
}

static inline int serv_init(Server *serv) {
#if DEBUG
  logfd = log_init("log.txt");
  if (!logfd) {
    printf("log_init failed");
    return -1;
  }
#endif
  serv->_nroutes = get_nroutes(serv->routes);

  int pipefd[2];
  if (pipe(pipefd) < 0)
    return -1;
  pipe_in = pipefd[0];
  pipe_out = pipefd[1];
  nullfd = open("/dev/null", O_WRONLY);
  pipe_sz = fcntl(pipefd[0], F_GETPIPE_SZ);
  if (pipe_sz < 0)
    return -1;

  pool.rtimeout = serv->rtimeout;
  pool.wtimeout = serv->wtimeout;
  if (MP_init(MAX_CONNS * 8) < 0)
    return -1;
  LOG("pool initialized\n");

  if (io_uring_queue_init(MAX_CONNS, &ring, 0) < 0)
    return -1;
  LOG("uring initialized\n");

  int listenfd;
  if ((listenfd = tcp_listen(serv->port)) < 0)
    return -1;
  LOG("socket initialized\n");

  return umaccept(listenfd);
}

static inline int serv_listen(Server *serv) {
  // uint64_t last_check = get_time();
  while (true) {
    // uint64_t now = get_time();
    // if ((now - last_check) >= 200) {
    //   last_check = now;
    //   LOG("CM: CM_check ran\n");
    //   MP_timeout();
    // }

    LOG("SQ ready: %u, CQ ready: %u\n", io_uring_sq_ready(&ring), io_uring_cq_ready(&ring));
    struct io_uring_cqe *cqe;
    if (io_uring_wait_cqe(&ring, &cqe) < 0)
      continue;

    int res = cqe->res;
    LOG("res = %d\n", res);
    conn_t *conn = NULL;
    if (cqe->user_data > 100) {
      conn = (conn_t *)cqe->user_data;
      current_recv = (conn_t *)conn->recv_conn;
      current_send = (conn_t *)conn->send_conn;
    }

    if (res > 0) {
      if (cqe->user_data == ACCEPT) {
        LOG("new conn created\n");
        new_conn(res);
      } else if (conn && conn->fd != -1) {
        LOG("conn[%d]: conn.fd = %d; conn.op = %d\n", conn->cindex, conn->fd, conn->op);
        switch (conn->op) {
        case FRECVMSG:
          if (handle_frecvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case RECVMSG:
          if (handle_recvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case SENDMSG:
        case SENDMSGZC:
          // conn->last_write = get_time();
          bool zc = (conn->op == SENDMSGZC);
          if (handle_sendmsg(conn, res, zc) < 0)
            MP_clear(conn);
          break;
        case INSPLICE:
          if (handle_insplice(conn) < 0)
            MP_clear(conn);
          break;
        case OUTSPLICE:
          if (handle_outsplice(conn, res) < 0)
            MP_clear(conn);
          break;
        }
      }
    } else if (res == 0) {
      if (conn && conn->fd != -1) {
        switch (conn->op) {
        case SENDMSGZC:
          conn->zc_notifs--;
          if (conn->zc_notifs == 0 && handle_sendmsg_complete(conn) < 0)
            MP_clear(conn);
          break;
        case RECV:
          MP_clear(conn);
          break;
        }
      }
    } else {
      if (conn && conn->fd != -1) {
        if (res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR) {
          LOG("conn && conn->fd != -1 && res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR\n");
          MP_clear(conn);
        } else {
          LOG("res == -EAGAIN || res == -EWOULDBLOCK || res == -EINTR\n");
          conn = conn->recv_conn;
          struct iovec *iov = &conn->ios[0];
          memset(iov->iov_base, 0, iov->iov_len);
          if (urecv(conn, iov->iov_base, iov->iov_len, 0) < 0)
            MP_clear(conn);
        }
      }
    }

    LOG("uring operation seen\n");
    io_uring_cqe_seen(&ring, cqe);
  }

  io_uring_queue_exit(&ring);
  MP_exit(&pool);
  return 0;
}

/*** Helper ***/
static inline int _HK_write(void *data, size_t size) {
  size_t nblocks;
  int iov_index;
  conn_t *conn;
  struct iovec *iov;
  bool once;

  conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  nblocks = round_to_blocks(size);
  iov_index = MP_expand(conn, nblocks, once);
  iov = &conn->ios[iov_index];

  memcpy(iov->iov_base, data, size);
  iov->iov_len = size;
  conn->data_left += size;

  return 0;
}
static inline int _HK_write_body(Request *req, size_t offset, size_t size) {
  if (size > req->body.size || offset > req->body.size)
    return -1;

  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  int iov_index = MP_expand(conn, 0, false);
  struct iovec *iov = &conn->ios[iov_index];
  struct iovec *rec = &conn->rec[iov_index];
  rec->iov_base = req->body.ptr + offset;
  rec->iov_len = size;
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;
  conn->data_left += rec->iov_len;
  return 0;
}
/*
static inline int _HK_mem(size_t size, HKMem *mem) {
  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  bool once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  size_t nblocks = round_to_blocks(size);
  int iov_index = MP_expand(conn, nblocks, once);
  struct iovec *iov = &conn->ios[iov_index];
  mem->ptr = iov->iov_base;
  mem->size = iov->iov_len;
  mem->_iov_index = iov_index;
  mem->_flags = (IN_POOL(iov->iov_base)) ? CF_IN_POOL : CF_IN_HEAP;
  return 0;
}

static inline void _HK_send(HKMem *mem, size_t size) {
  conn_t *conn = current_send;
  struct iovec *iov = &conn->ios[mem->_iov_index];
  iov->iov_len = size;
  conn->data_left += size;
}
  */
#endif#define _GNU_SOURCE
#ifndef UTILS_H
#define UTILS_H

#include "hunk.h"
#include <arpa/inet.h>
#include <fcntl.h>
#include <liburing.h>
#include <netdb.h>
#include <signal.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/poll.h>
#include <sys/prctl.h>
#include <sys/socket.h>
#include <sys/sysinfo.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

#define MP_BLOCK  4
#define MAX_CONNS 4096
#define KB        1024
#define NIOS      32

#define IN_POOL(ptr)                 ((void *)ptr >= pool.bpool && (void *)ptr <= (pool.bpool + (pool.npages * pool.pagesize)))
#define ALIGN_TO_PAGESIZE(buff_size) (((buff_size) + (pool.pagesize - 1)) & ~(pool.pagesize - 1))
#define BYTES_TO_BLOCKS(buff_size)   (((buff_size) + (MP_BLOCK - 1)) / MP_BLOCK)
#define CEIL_BLOCKS(nblocks)         ((nblocks + 63) & ~63)
#define CEIL_PAGES(size)             (((size) + ((pool.pagesize) - 1)) & ~((pool.pagesize) - 1))

#define BIT_IS_FREE(word, bit)   (((word) >> (bit)) & 1)
#define MARK_BIT_USED(word, bit) ((word) &= ~(1ULL << (bit)))
#define MARK_BIT_FREE(word, bit) ((word) |= (1ULL << (bit)))
#define FIND_FREE_BIT(word)      ((uint64_t)(word) & -(uint64_t)(word))
#define STRLEN(s)                (sizeof(s) - 1)

#define IOVEC_NBLOCKS (BYTES_TO_BLOCKS(NIOS * sizeof(struct iovec)))
#define MSG_NBLOCKS   (BYTES_TO_BLOCKS(sizeof(struct msghdr)))
#define ZC_RES        KB *KB

#define DEBUG 0
#if DEBUG
#define LOG(...) fprintf(logfd, __VA_ARGS__)
#else
#define LOG(...) ((void)0)
#endif

typedef enum UOP {
  WRITEV = IORING_OP_WRITEV,
  SENDMSG = IORING_OP_SENDMSG,
  RECVMSG = IORING_OP_RECVMSG,
  ACCEPT = IORING_OP_ACCEPT,
  SEND = IORING_OP_SEND,
  RECV = IORING_OP_RECV,
  SENDZC = IORING_OP_SEND_ZC,
  SENDMSGZC = IORING_OP_SENDMSG_ZC,
  PEEK = 50,
  FRECVMSG,
  INSPLICE,
  OUTSPLICE
} UOP;

typedef enum CFS {
  CF_IN_POOL = (1 << 0),       // Connection is in the pool
  CF_IN_HEAP = (1 << 1),       // Connection is in the heap
  CF_SKIP_SOCK = (1 << 2),     // Don't close the socket
  CF_USE_ONCE = (1 << 3),      // Destroy after using
  CF_HANDLER_READY = (1 << 4), // Ready to call the handler
} CFS;

typedef struct conn_t {
  // Socket file descriptor
  int fd;

  // Amount of data left in the current operation
  uint64_t data_left;

  // The index of the connection struct
  uint32_t cindex;

  // The last time the connection was readable
  uint64_t last_read;

  // The last time the connection was writeable
  uint64_t last_write;

  // The operation currently being processed
  uint8_t op;

  // Connection flags
  int flags;

  // Splice fd_in
  int in_fd;

  // Splice fd_out
  int out_fd;

  void *recv_conn;
  void *send_conn;

  struct iovec *ios;
  struct iovec *rec;
  uint16_t nios;

  struct msghdr *msg;
  uint16_t zc_notifs;

  uint16_t head_size;
} conn_t;

typedef struct MPool {
  // The allocated pool of blocks
  void *bpool;

  // The allocated pool of connections
  conn_t *cpool;

  // The size of the pool in pages
  uint32_t npages;

  // The size of the pool in blocks
  uint32_t nblocks;

  // The locations of each page in the pool
  void **blocks;

  // The availability of each block
  uint64_t *freebs;

  // The locations of each conn in the pool
  conn_t **conns;

  // The availability of each conn
  uint64_t *freecs;

  // Clean up callback function
  void (*callback)(conn_t *conn);

  // The page size used
  uint32_t pagesize;

  // Socket read timeout
  uint32_t rtimeout;

  // Socket write timeout
  uint32_t wtimeout;
} MPool;

extern int pipe_sz;
extern int pipe_in, pipe_out, nullfd;
extern FILE *logfd;
extern struct io_uring ring;
extern MPool pool;
extern conn_t *current_recv;
extern conn_t *current_send;

/*
 * Prepare and submit a recv uring op
 */
static inline int urecv(conn_t *conn, void *buffer, size_t buff_size, int flags) {
  if (!conn || conn->fd == -1)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (flags == MSG_PEEK) ? PEEK : RECV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;

  io_uring_prep_recv(sqe, conn->fd, buffer, buff_size, flags);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a multi-shot accept uring op
 */
static inline int umaccept(int listenfd) {
  if (listenfd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = ACCEPT;
  io_uring_prep_multishot_accept(sqe, listenfd, NULL, NULL, SOCK_NONBLOCK);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a splice uring op
 */
static inline int usplice(conn_t *conn, int fd_in, int64_t off_in, int fd_out, int64_t off_out, size_t len) {
  if (!len || !conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = (__u64)conn;
  io_uring_prep_splice(sqe, fd_in, off_in, fd_out, off_out, len, 0);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a writev uring op
 */
static inline int uwritev(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = WRITEV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  io_uring_prep_writev(sqe, conn->fd, &conn->ios[iov_index], nios, -1);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a send uring op
 */
static inline int usend(conn_t *conn, char *res_buff, size_t buff_size, bool zc) {
  if (!conn || conn->fd <= 0 || buff_size == 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (zc) ? SENDZC : SEND;
  conn->data_left = buff_size;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  if (zc)
    io_uring_prep_send_zc(sqe, conn->fd, res_buff, buff_size, 0, 0);
  else
    io_uring_prep_send(sqe, conn->fd, res_buff, buff_size, 0);
  return io_uring_submit(&ring);
}

static inline int ufrecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = FRECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;

  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, rec->iov_len);
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int urecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = RECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int usendmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  bool zc = (conn->data_left > ZC_RES) ? true : false;
  conn->op = (zc) ? SENDMSGZC : SENDMSG;

  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  if (zc) {
    io_uring_prep_sendmsg_zc(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
    conn->zc_notifs++;
  } else {
    io_uring_prep_sendmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  }
  return io_uring_submit(&ring);
}

/*
 * Create and initialize a server socket
 */
static inline int tcp_listen(uint16_t port) {
  int enable;
  int listenfd;
  if ((listenfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    return -1;

  int flags = fcntl(listenfd, F_GETFL, 0);
  fcntl(listenfd, F_SETFL, flags | O_NONBLOCK);
  struct sockaddr_in servaddr;
  memset(&servaddr, 0, sizeof(servaddr));
  servaddr.sin_family = AF_INET;
  servaddr.sin_addr.s_addr = INADDR_ANY;
  servaddr.sin_port = htons(port);

  enable = 1;
  if (setsockopt(listenfd, SOL_SOCKET, SO_REUSEPORT, &enable, sizeof(enable)) < 0)
    return -1;

  if (bind(listenfd, (struct sockaddr *)&servaddr, sizeof(servaddr)) < 0)
    return -1;

  if (listen(listenfd, SOMAXCONN) < 0)
    return -1;

  return listenfd;
}

/*
 * Calculate the difference between two pointers
 */
static inline uintptr_t ptr_diff(uintptr_t p1, uintptr_t p2) { return (uintptr_t)(p1 > p2) ? (p1 - p2) : (p2 - p1); }

static inline size_t get_nroutes(Route *routes) {
  Route *route;
  for (size_t i = 0;; i++) {
    route = &routes[i];
    if (!route->path && !route->handler && !route->method)
      return i;
  }
}

static inline long get_content_length(char *src, char *end) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return -1;
    key = line;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, "Content-Length") != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;

    *line_end = '\0';
    long res = atol(value);
    *line_end = '\r';

    return res;
  }
  return -1;
}

static inline bool have_header(char *src, char *end, const char *header_key, const char *header_value) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    key = line;
    while (*key == ' ')
      key++;
    while (*header_key == ' ')
      header_key++;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return false;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, header_key) != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;
    while (*header_value == ' ')
      header_value++;

    *line_end = '\0';
    bool res = (strcasecmp(value, header_value) == 0);
    *line_end = '\r';

    return res;
  }

  return false;
}

static inline const char *method_str(Method method) {
  switch (method) {
  case GET:
    return "GET";
    break;
  case HEAD:
    return "HEAD";
    break;
  case POST:
    return "POST";
    break;
  case PUT:
    return "PUT";
    break;
  case DELETE:
    return "DELETE";
    break;
  case CONNECT:
    return "CONNECT";
    break;
  case OPTIONS:
    return "OPTIONS";
    break;
  case TRACE:
    return "TRACE";
    break;
  case PATCH:
    return "PATCH";
    break;
  default:
    return NULL;
  }
}

static inline uint8_t method_len(Method method) {
  switch (method) {
  case GET:
    return 3;
    break;
  case HEAD:
    return 4;
    break;
  case POST:
    return 4;
    break;
  case PUT:
    return 3;
    break;
  case DELETE:
    return 6;
    break;
  case CONNECT:
    return 7;
    break;
  case OPTIONS:
    return 7;
    break;
  case TRACE:
    return 5;
    break;
  case PATCH:
    return 5;
    break;
  default:
    return 0;
  }
}

static inline size_t round_to_blocks(size_t size) {
  size_t nblocks = BYTES_TO_BLOCKS(size);
  nblocks = CEIL_BLOCKS(nblocks);
  return nblocks;
}

/*
 * Count the digits in unsigned 64-bit int
 */
static inline int countd(uint64_t num) {
  if (num < 10ULL)
    return 1;
  if (num < 100ULL)
    return 2;
  if (num < 1000ULL)
    return 3;
  if (num < 10000ULL)
    return 4;
  if (num < 100000ULL)
    return 5;
  if (num < 1000000ULL)
    return 6;
  if (num < 10000000ULL)
    return 7;
  if (num < 100000000ULL)
    return 8;
  if (num < 1000000000ULL)
    return 9;
  if (num < 10000000000ULL)
    return 10;
  if (num < 100000000000ULL)
    return 11;
  if (num < 1000000000000ULL)
    return 12;
  if (num < 10000000000000ULL)
    return 13;
  if (num < 100000000000000ULL)
    return 14;
  if (num < 1000000000000000ULL)
    return 15;
  if (num < 10000000000000000ULL)
    return 16;
  if (num < 100000000000000000ULL)
    return 17;
  if (num < 1000000000000000000ULL)
    return 18;
  if (num < 10000000000000000000ULL)
    return 19;
  return 20;
}

/*
 * Get the time elabsed in ms
 */
static inline uint64_t get_time() {
  struct timespec ts;
  clock_gettime(CLOCK_MONOTONIC, &ts);
  return (uint64_t)(ts.tv_sec) * 1000 + (ts.tv_nsec / 1000000);
}

static inline FILE *log_init(const char *path) {
  FILE *res = fopen(path, "a+");
  setvbuf(res, NULL, _IONBF, 0);
  return res;
}

static inline int16_t pollevs(int connfd) {
  struct pollfd pfd;
  pfd.fd = connfd;
  pfd.events = POLLIN | POLLOUT | POLLERR;
  int res = poll(&pfd, 1, 0);
  if (res < 0)
    return POLLERR;
  return pfd.revents;
}

// FIXME This needs to be updated
static inline conn_t *MP_use_once(size_t nblocks, int fd) {

  void *mem = malloc(sizeof(conn_t) + 8 + (IOVEC_NBLOCKS * MP_BLOCK));
  struct conn_t *conn = (conn_t *)mem;
  memset(conn, 0, sizeof(conn_t));
  conn->ios = mem + sizeof(conn_t) + 8;

  if (nblocks > 0) {
    struct iovec *iov = &conn->ios[conn->nios++];
    mem = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (mem == MAP_FAILED)
      return NULL;
    iov->iov_base = mem;
    iov->iov_len = ALIGN_TO_PAGESIZE(nblocks * MP_BLOCK);
  }

  conn->flags |= CF_IN_HEAP;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;

  return conn;
}

static inline int find_freec() {
  uint64_t *word;
  size_t map_size = (sizeof(uint64_t) * 8);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    word = &pool.freecs[i / map_size];

    if (*word == 0) { // All used
      i += (map_size - 1);
      continue;
    }

    i += __builtin_ctzll(*word);
    MARK_BIT_USED(*word, i);
    return i;
  }

  return -1;
}

static inline int MP_init(size_t npages) {
  if (!npages)
    return -1;

  /*** Setup ***/
  pool.npages = npages;
  pool.pagesize = sysconf(_SC_PAGESIZE);

  /*** Pool ***/
  pool.bpool = mmap(NULL, pool.npages * pool.pagesize, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  if (pool.bpool == MAP_FAILED)
    return -1;
  pool.nblocks = (pool.npages * pool.pagesize) / MP_BLOCK;

  /*** Blocks ***/
  pool.blocks = malloc(sizeof(void *) * pool.nblocks);
  if (!pool.blocks)
    return -1;
  for (size_t i = 0; i < pool.nblocks; i++)
    pool.blocks[i] = pool.bpool + (i * MP_BLOCK);

  /*** Freebs ***/
  // if (posix_memalign((void **)&pool.freebs, 64, bitmap_size * sizeof(uint64_t)) < 0)
  size_t bitmap_size = (pool.nblocks + 63) / 64;
  pool.freebs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freebs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freebs[i] = UINT64_MAX;

  /*** Cpool ***/
  pool.cpool = (conn_t *)malloc(sizeof(conn_t) * MAX_CONNS);
  if (!pool.cpool)
    return -1;

  /*** Conns ***/
  pool.conns = (conn_t **)malloc(sizeof(conn_t *) * MAX_CONNS);
  if (!pool.conns)
    return -1;
  size_t conn_size = sizeof(conn_t);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    pool.conns[i] = (conn_t *)((char *)pool.cpool + (i * conn_size));
    pool.conns[i]->fd = -1;
    pool.conns[i]->in_fd = -1;
    pool.conns[i]->out_fd = -1;
  }

  /*** Freecs ***/
  bitmap_size = (MAX_CONNS + 63) / 64;
  pool.freecs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freecs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freecs[i] = UINT64_MAX;

  return 0;
}

static inline int MP_use_blks(size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t max_start = pool.nblocks - nblocks;
  size_t full_chunks = (nblocks / 64) * 64;

  for (size_t i = 0, c = 0; i <= max_start; i++, c++) {
    bool free = true;

    for (size_t j = 0; j < full_chunks; j += 64) {
      size_t word_index = (i + j) / 64;
      if (pool.freebs[word_index] != UINT64_MAX) {
        free = false;
        i += 63;
        break;
      }
    }

    for (size_t j = full_chunks; j < nblocks; j++) {
      size_t bit_index = i + j;
      size_t word_index = bit_index / 64;
      size_t bit_in_word = bit_index % 64;

      if (!BIT_IS_FREE(pool.freebs[word_index], bit_in_word)) {
        free = false;
        i += j;
        break;
      }
    }

    if (free) {
      for (size_t j = 0; j < full_chunks; j += 64) {
        size_t word_index = (i + j) / 64;
        pool.freebs[word_index] = 0;
      }

      for (size_t j = full_chunks; j < nblocks; j++) {
        size_t bit_index = i + j;
        size_t word_index = bit_index / 64;
        size_t bit_in_word = bit_index % 64;

        MARK_BIT_USED(pool.freebs[word_index], bit_in_word);
      }

      return i;
    }
  }

  return -1;
}

static inline int MP_free_blks(size_t bindex, size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t full_chunks = (nblocks / 64) * 64;
  for (size_t i = 0; i < full_chunks; i += 64) {
    size_t word_index = (bindex + i) / 64;
    pool.freebs[word_index] = UINT64_MAX;
  }

  for (size_t i = full_chunks; i < nblocks; i++) {
    size_t bit_index = bindex + i;
    size_t word_index = bit_index / 64;
    size_t bit_in_word = bit_index % 64;

    MARK_BIT_FREE(pool.freebs[word_index], bit_in_word);
  }

  memset(pool.blocks[bindex], 0, nblocks * MP_BLOCK);
  return 0;
}

static inline conn_t *MP_use(size_t nblocks, int fd, bool once) {
  if (fd <= 0)
    return NULL;
  if (once)
    return MP_use_once(nblocks, fd);

  int cindex = find_freec();
  if (cindex < 0) {
    LOG("Err: cindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  conn_t *conn = pool.conns[cindex];

  int ios_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (ios_bindex < 0) {
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }

  struct iovec *ios = pool.blocks[ios_bindex];
  conn->ios = ios;

  int rec_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (rec_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct iovec *rec = pool.blocks[rec_bindex];
  conn->rec = rec;

  int msg_bindex = MP_use_blks(MSG_NBLOCKS);
  if (msg_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct msghdr *msg = pool.blocks[msg_bindex];
  conn->msg = msg;

  if (nblocks > 0) {
    int bindex = MP_use_blks(nblocks);
    if (bindex < 0) {
      MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
      MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
      MP_free_blks(msg_bindex, IOVEC_NBLOCKS);
      MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
      LOG("Err: bindex < 0; will use MP_use_once\n");
      return MP_use_once(nblocks, fd);
    }

    size_t iov_index = conn->nios++;
    struct iovec *iov = &conn->ios[iov_index];
    struct iovec *rec = &conn->rec[iov_index];
    iov->iov_base = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
  }

  conn->msg->msg_iov = conn->ios;
  conn->msg->msg_iovlen = conn->nios;
  conn->cindex = cindex;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;
  return conn;
}

static inline void MP_shed(conn_t *conn, size_t iov_index, size_t nios) {
  struct iovec *iov, *rec;
  size_t bindex, nblocks, index;

  for (size_t i = 0; i < nios; i++) {
    index = iov_index + i;
    iov = &conn->ios[index];
    rec = &conn->rec[index];
    if (!rec || !rec->iov_base)
      continue;
    if (!IN_POOL(rec->iov_base)) {
      munmap(rec->iov_base, rec->iov_len / pool.pagesize);
    } else {
      bindex = ptr_diff((uintptr_t)rec->iov_base, (uintptr_t)pool.bpool) / MP_BLOCK;
      nblocks = rec->iov_len / MP_BLOCK;
      MP_free_blks(bindex, nblocks);
    }
    memset(iov, 0, sizeof(struct iovec));
    memset(rec, 0, sizeof(struct iovec));
    conn->nios--;
  }
}

static inline int MP_expand(conn_t *conn, size_t nblocks, bool once) {
  void *bptr;
  int iov_index, bindex;
  struct iovec *iov, *rec;

  iov_index = conn->nios++;
  iov = &conn->ios[iov_index];
  rec = &conn->rec[iov_index];

  if (nblocks == 0)
    return iov_index;

  if (once) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_base = bptr;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
    return iov_index;
  }

  bindex = MP_use_blks(nblocks);
  if (bindex < 0) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_len = iov->iov_len;
  } else {
    bptr = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_len = iov->iov_len;
  }

  iov->iov_base = bptr;
  rec->iov_base = iov->iov_base;
  return iov_index;
}

static inline int MP_free(conn_t *conn) {
  if (!conn)
    return -1;
  size_t bindex, nblocks;
  uint64_t *word;

  MP_shed(conn, 0, conn->nios);
  if (conn->flags & CF_IN_HEAP) {
    if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
      close(conn->fd);
    free(conn);
    return 0;
  }

  word = &pool.freecs[conn->cindex / 64];
  if (conn->cindex > MAX_CONNS)
    return -1;
  else if (BIT_IS_FREE(*word, conn->cindex))
    return 0;

  bindex = ptr_diff((uintptr_t)conn->ios, (uintptr_t)pool.bpool) / MP_BLOCK;
  nblocks = IOVEC_NBLOCKS;
  MP_free_blks(bindex, nblocks);

  bindex = ptr_diff((uintptr_t)conn->rec, (uintptr_t)pool.bpool) / MP_BLOCK;
  MP_free_blks(bindex, nblocks);

  if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
    close(conn->fd);

  MARK_BIT_FREE(*word, conn->cindex);
  memset(conn, 0, sizeof(conn_t));
  conn->fd = -1;
  conn->in_fd = -1;
  conn->out_fd = -1;
  return 0;
}

static inline void MP_clear(conn_t *conn) {
  conn_t *recv_conn = conn->recv_conn;
  conn_t *send_conn = conn->send_conn;
  if (recv_conn)
    MP_free(recv_conn);
  if (send_conn)
    MP_free(send_conn);
}

static inline void MP_exit(MPool *pool) {
  munmap(pool->bpool, pool->npages);
  free(pool->cpool);
  free(pool->blocks);
  free(pool->conns);
  free(pool->freebs);
  free(pool->freecs);
}

static inline void MP_timeout() {
  conn_t *conn;
  int16_t res;
  uint64_t now;
  size_t windex = 0;
  uint64_t *word = &pool.freecs[0];
  for (size_t i = 0; i < MAX_CONNS; i++) {
    if ((i / 64) < windex)
      word = &pool.freecs[++windex];

    if (*word == UINTMAX_MAX) {
      i = (i / 64) * 64 + 64;
      continue;
    }

    conn = pool.conns[i];
    if (!conn || conn->fd == -1)
      continue;

    res = pollevs(conn->fd);

    now = get_time();
    if (res & POLLERR) {
      MP_clear(conn);
      continue;
    }
    if (res & POLLIN) {
      if (pool.rtimeout > 0 && (now - conn->last_read) >= pool.rtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (res & POLLOUT) {
      if (pool.wtimeout > 0 && (now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (!(res & POLLIN || res & POLLOUT)) {
      if ((pool.rtimeout > 0 && now - conn->last_read) >= pool.rtimeout
          || (pool.wtimeout > 0 && now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
  }
}

/*
 * Calculate the length of a status string
 */
static inline size_t status_len(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return 8;
  case STATUSSWITCHINGPROTOCOLS:
    return 19;
  case STATUSPROCESSING:
    return 10;
  case STATUSEARLYHINTS:
    return 11;
  case STATUSOK:
    return 2;
  case STATUSCREATED:
    return 7;
  case STATUSACCEPTED:
    return 8;
  case STATUSNONAUTHORITATIVE:
    return 29;
  case STATUSNOCONTENT:
    return 10;
  case STATUSRESETCONTENT:
    return 13;
  case STATUSPARTIALCONTENT:
    return 15;
  case STATUSMULTISTATUS:
    return 12;
  case STATUSALREADYREPORTED:
    return 16;
  case STATUSIMUSED:
    return 7;
  case STATUSMULTIPLECHOICES:
    return 16;
  case STATUSMOVEDPERMANENTLY:
    return 17;
  case STATUSFOUND:
    return 5;
  case STATUSSEEOTHER:
    return 9;
  case STATUSNOTMODIFIED:
    return 12;
  case STATUSUSEPROXY:
    return 9;
  case STATUSTEMPORARYREDIRECT:
    return 18;
  case STATUSPERMANENTREDIRECT:
    return 18;
  case STATUSBADREQUEST:
    return 11;
  case STATUSUNAUTHORIZED:
    return 12;
  case STATUSPAYMENTREQUIRED:
    return 16;
  case STATUSFORBIDDEN:
    return 9;
  case STATUSNOTFOUND:
    return 9;
  case STATUSMETHODNOTALLOWED:
    return 18;
  case STATUSNOTACCEPTABLE:
    return 14;
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return 29;
  case STATUSREQUESTTIMEOUT:
    return 15;
  case STATUSCONFLICT:
    return 8;
  case STATUSGONE:
    return 4;
  case STATUSLENGTHREQUIRED:
    return 15;
  case STATUSPRECONDITIONFAILED:
    return 19;
  case CONTENTTOOLARGE:
    return 17;
  case STATUSURITOOLONG:
    return 12;
  case STATUSUNSUPPORTEDMEDIATYPE:
    return 22;
  case STATUSRANGENOTSATISFIABLE:
    return 21;
  case STATUSEXPECTATIONFAILED:
    return 18;
  case STATUSMISDIRECTEDREQUEST:
    return 19;
  case STATUSUNPROCESSABLECONTENT:
    return 21;
  case STATUSLOCKED:
    return 6;
  case STATUSFAILEDDEPENDENCY:
    return 17;
  case STATUSTOOEARLY:
    return 9;
  case STATUSUPGRADEREQUIRED:
    return 16;
  case STATUSPRECONDITIONREQUIRED:
    return 21;
  case STATUSTOOMANYREQUESTS:
    return 17;
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return 31;
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return 29;
  case STATUSInternalServerError:
    return 21;
  case STATUSNOTIMPLEMENTED:
    return 15;
  case STATUSBADGATEWAY:
    return 11;
  case STATUSSERVICEUNAVAILABLE:
    return 19;
  case STATUSGATEWAYTIMEOUT:
    return 15;
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return 26;
  case STATUSVARIANTALSONEGOTIATES:
    return 23;
  case STATUSINSUFFICIENTSTORAGE:
    return 20;
  case STATUSLOOPDETECTED:
    return 13;
  case STATUSNOTEXTENDED:
    return 12;
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return 31;
  default:
    return 0;
  }
}

/*
 * Return the status code string as string literal
 */
static inline char *status_str(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return "Continue";
  case STATUSSWITCHINGPROTOCOLS:
    return "Switching Protocols";
  case STATUSPROCESSING:
    return "Processing";
  case STATUSEARLYHINTS:
    return "Early Hints";
  case STATUSOK:
    return "OK";
  case STATUSCREATED:
    return "Created";
  case STATUSACCEPTED:
    return "Accepted";
  case STATUSNONAUTHORITATIVE:
    return "Non-Authoritative Information";
  case STATUSNOCONTENT:
    return "No Content";
  case STATUSRESETCONTENT:
    return "Reset Content";
  case STATUSPARTIALCONTENT:
    return "Partial Content";
  case STATUSMULTISTATUS:
    return "Multi-Status";
  case STATUSALREADYREPORTED:
    return "Already Reported";
  case STATUSIMUSED:
    return "Im Used";
  case STATUSMULTIPLECHOICES:
    return "Multiple Choices";
  case STATUSMOVEDPERMANENTLY:
    return "Moved Permanently";
  case STATUSFOUND:
    return "Found";
  case STATUSSEEOTHER:
    return "See Other";
  case STATUSNOTMODIFIED:
    return "Not Modified";
  case STATUSUSEPROXY:
    return "Use Proxy";
  case STATUSTEMPORARYREDIRECT:
    return "Temporary Redirect";
  case STATUSPERMANENTREDIRECT:
    return "Permanent Redirect";
  case STATUSBADREQUEST:
    return "Bad Request";
  case STATUSUNAUTHORIZED:
    return "Unauthorized";
  case STATUSPAYMENTREQUIRED:
    return "Payment Required";
  case STATUSFORBIDDEN:
    return "Forbidden";
  case STATUSNOTFOUND:
    return "Not Found";
  case STATUSMETHODNOTALLOWED:
    return "Method Not Allowed";
  case STATUSNOTACCEPTABLE:
    return "Not Acceptable";
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return "Proxy Authentication Required";
  case STATUSREQUESTTIMEOUT:
    return "Request Timeout";
  case STATUSCONFLICT:
    return "Conflict";
  case STATUSGONE:
    return "Gone";
  case STATUSLENGTHREQUIRED:
    return "Length Required";
  case STATUSPRECONDITIONFAILED:
    return "Precondition Failed";
  case CONTENTTOOLARGE:
    return "Content Too Large";
  case STATUSURITOOLONG:
    return "URI Too Long";
  case STATUSUNSUPPORTEDMEDIATYPE:
    return "Unsupported Media Type";
  case STATUSRANGENOTSATISFIABLE:
    return "Range Not Satisfiable";
  case STATUSEXPECTATIONFAILED:
    return "Expectation Failed";
  case STATUSMISDIRECTEDREQUEST:
    return "Misdirected Request";
  case STATUSUNPROCESSABLECONTENT:
    return "Unprocessable Content";
  case STATUSLOCKED:
    return "Locked";
  case STATUSFAILEDDEPENDENCY:
    return "Failed Dependency";
  case STATUSTOOEARLY:
    return "Too Early";
  case STATUSUPGRADEREQUIRED:
    return "Upgrade Required";
  case STATUSPRECONDITIONREQUIRED:
    return "Precondition Required";
  case STATUSTOOMANYREQUESTS:
    return "Too Many Requests";
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return "Request Header Fields Too Large";
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return "Unavailable For Legal Reasons";
  case STATUSInternalServerError:
    return "Internal Server Error";
  case STATUSNOTIMPLEMENTED:
    return "Not Implemented";
  case STATUSBADGATEWAY:
    return "Bad Gateway";
  case STATUSSERVICEUNAVAILABLE:
    return "Service Unavailable";
  case STATUSGATEWAYTIMEOUT:
    return "Gateway Timeout";
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return "HTTP Version Not Supported";
  case STATUSVARIANTALSONEGOTIATES:
    return "Variant Also Negotiates";
  case STATUSINSUFFICIENTSTORAGE:
    return "Insufficient Storage";
  case STATUSLOOPDETECTED:
    return "Loop Detected";
  case STATUSNOTEXTENDED:
    return "Not Extended";
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return "Network Authentication Required";
  default:
    return 0;
  }
}

/*
 * Return true if routes match
 */
static inline bool route_equ(Route *route, Request *req) {
  return route->method == req->method && strncmp(route->path, req->path, strlen(route->path)) == 0;
}

/*
 * Return the matching route index on success. -1 on failure
 */
static inline int match_route(Server *serv, Request *req) {
  for (size_t i = 0; i < serv->_nroutes; i++) {
    Route route = serv->routes[i];
    if (!req->path || !route.path)
      continue;
    if (route_equ(&route, req))
      return i;
    else if (req->method == HEAD && route.method == GET && strcmp(route.path, req->path) == 0)
      return i;
  }
  return -1;
}

/*
 * Return true if the response should contain the Content-Length header
 */
static inline bool should_have_content_length(Request *req, ResWriter *res) {
  return (req->method != CONNECT              // CONNECT request
          && res->status != STATUSNOCONTENT   // 204 response
          && res->status != STATUSNOTMODIFIED // 304 response
          && res->status >= 200);             // 1xx response
}

/*
 * Format http response from the ResWriter.
 * Return response size on success, 0 on failure.
 */
static inline size_t fmt_res(Request *req, ResWriter *res, char *buffer, size_t buffer_size) {
  if (!res || !buffer || buffer_size == 0)
    return 0;

  size_t res_len, total = 0;
  char *dst = buffer;
  size_t maxlen = buffer_size;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t body_length = res->len;

  res_len = snprintf(dst, maxlen, "HTTP/1.1 %d %s", (int)res->status, status_str(res->status));
  total += res_len;
  dst += res_len;
  maxlen -= res_len;

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    res_len = snprintf(dst, maxlen, "\r\n%s: %s", header->key, header->value);
    total += res_len;
    dst += res_len;
    maxlen -= res_len;
  }

  if (have_content_length) {
    res_len = snprintf(dst, maxlen, "\r\nContent-Length: %lu", body_length);
    total += res_len, dst += res_len, maxlen -= res_len;
  }

  memcpy(dst, "\r\n\r\n", 4);
  total += 4, dst += 4, maxlen -= 4;

  return total;
}

static inline size_t res_len(Request *req, ResWriter *res) {
  if (!req || !res)
    return 0;

  if (!res->status)
    res->status = STATUSOK;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t result = 0;
  result += STRLEN("HTTP/1.1 ");     // HTTP version
  result += 4;                       // Status code + space
  result += status_len(res->status); // Status name

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    result += 2;                       // "\r\n"
    result += strlen(header->key) + 2; // Header key + ':' + space
    result += strlen(header->value);   // header value
  }

  if (have_content_length) {
    result += 2;                          // "\r\n"
    result += STRLEN("Content-Length: "); // Header key
    result += countd(res->len);           // Header value
  }

  result += 4; // "\r\n\r\n"

  return result;
}

static inline int send_empty_res(Status status) {
  size_t res_len = STRLEN("HTTP/1.1 ")        // HTTP version
                   + countd((uint64_t)status) // status code
                   + 1                        // space
                   + (int)status_len(status)  // status string
                   + 4;                       // \r\n\r\n

  conn_t *conn = current_send;
  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, res_len);
  if (snprintf((char *)rec->iov_base, res_len + 1, "HTTP/1.1 %d %s\r\n\r\n", (int)status, status_str(status))
      != (int)res_len)
    return -1;

  return usendmsg(conn, 0, 1);
}

static inline ssize_t read_socket(int sockfd, size_t len) {
  if (len == 0 || sockfd <= 0)
    return 0;
  char buff[1024 * 8];
  return read(sockfd, buff, 1024 * 8);
}

static inline int read_method(Method *method, void *src) {
  if (memcmp(src, "GET", 3) == 0)
    *method = GET;
  else if (memcmp(src, "POST", 4) == 0)
    *method = POST;
  else if (memcmp(src, "HEAD", 4) == 0)
    *method = HEAD;
  else if (memcmp(src, "PUT", 3) == 0)
    *method = PUT;
  else if (memcmp(src, "DELETE", 6) == 0)
    *method = DELETE;
  else if (memcmp(src, "CONNECT", 7) == 0)
    *method = CONNECT;
  else if (memcmp(src, "OPTIONS", 7) == 0)
    *method = OPTIONS;
  else if (memcmp(src, "TRACE", 5) == 0)
    *method = TRACE;
  else if (memcmp(src, "PATCH", 5) == 0)
    *method = PATCH;
  else
    return -1;

  return 0;
}

static inline int sendmsg_res(Request *req, ResWriter *res) {
  conn_t *conn;
  size_t head_size, res_size;
  struct iovec *iov;

  conn = current_send;
  iov = &conn->ios[0];
  head_size = res_len(req, res);
  if (head_size == 0)
    return -1;

  conn->data_left += head_size;
  res_size = fmt_res(req, res, iov->iov_base, (head_size + 1));
  if (res_size != head_size)
    return -1;
  iov->iov_len = res_size;

  return usendmsg(conn, 0, conn->nios);
}

static inline int read_req(Request *req, char *req_buffer) {
  if (!req_buffer)
    return -1;
  /*** Method ***/
  char *sep = strchr(req_buffer, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }
  *sep = '\0';
  if (read_method(&req->method, req_buffer) < 0)
    return -1;

  /*** Path ***/
  char *fullpath = sep + 1;
  sep = strchr(fullpath, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }

  *sep = '\0';
  req->path = fullpath;
  /*** Params ***/
  char *paramStart = strchr(fullpath, '?');
  if (paramStart) {
    *paramStart++ = '\0';
    int params_count = 0;
    params_count = HK_parse_params(paramStart, req->params, MAX_URL_PARAMETERS);
    if (params_count > 0)
      req->params_count = params_count;
    else
      req->params_count = 0;
  } else {
    req->params = NULL;
    req->params_count = 0;
  }

  /*** Headers ***/
  char *headStart = strstr(sep + 1, "\r\n");
  char *headEnd = strstr(sep + 1, "\r\n\r\n");
  if (!headStart) {
    LOG("read_req: !headStart\n");
    return -1;
  };

  memset(headStart, 0, 2);
  headStart += 2;
  memset(headEnd, 0, 4);
  headEnd += 4;

  int headers_count = HK_parse_headers(headStart, req->headers, MAX_REQ_HEADERS);
  if (headers_count <= 0)
    return -1;
  req->headers_count = headers_count;

  /*** Host ***/
  int index = HK_get_header(req, "Host");
  if (index < 0)
    return -1;
  char *host = req->headers[index].value;
  req->hostname = host;

  /*** Port ***/
  char *colon = strchr(host, ':');
  if (colon) {
    *colon++ = '\0';
    req->port = atoi(colon);
  } else {
    req->port = PORT;
  }
  return 0;
}
static inline int process_req(Server *serv, conn_t *conn) {
  if (!conn || conn->fd == -1)
    return -1;

  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;
  if (read_req(&req, conn->ios[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    LOG("Err: route_index == -1\n");
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;
  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  sendmsg_res(&req, &res);

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int new_conn(int connfd) {
  if (connfd <= 0)
    return -1;

  current_recv = MP_use(KB * 2, connfd, false);
  current_send = MP_use(KB * 2, connfd, false);

  current_recv->recv_conn = current_recv;
  current_recv->send_conn = current_send;

  current_send->send_conn = current_send;
  current_send->recv_conn = current_recv;

  conn_t *conn = current_recv;
  if (ufrecvmsg(conn, 0, 1) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

static inline int resubmit_sendmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return usendmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int resubmir_recvmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    // FIXME the len should be increased
    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return urecvmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int handle_sendmsg_complete(conn_t *conn) {
  struct iovec *iov, *rec;

  MP_shed(conn, 1, conn->nios - 1);
  iov = &conn->ios[0];
  rec = &conn->rec[0];
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;

  return ufrecvmsg(conn->recv_conn, 0, 1);
}

static inline int handle_sendmsg(conn_t *conn, int res, bool zc) {
  if (!conn || conn->fd == -1)
    return -1;

  conn->data_left -= res;
  if (conn->data_left > 0)
    return resubmit_sendmsg(conn, res);

  if (zc)
    return 0;

  return handle_sendmsg_complete(conn);
}

static inline int handle_insplice(conn_t *conn) {
  conn->op = OUTSPLICE;
  return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
}
static inline int handle_outsplice(conn_t *conn, int res) {
  conn->data_left -= res;
  if (conn->data_left > 0) {
    conn->op = INSPLICE;
    return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
  }

  conn_t *recv_conn = conn->recv_conn;
  struct iovec *iov = &recv_conn->ios[0];
  memset(iov->iov_base, 0, iov->iov_len);
  if (urecv(recv_conn, iov->iov_base, iov->iov_len, MSG_PEEK) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

/*
static inline int handle_recv(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  void *bptr = conn->ios[0].iov_base;
  void *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  void *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  return process_req(serv, conn);
}
*/
static inline int find_route(Server *serv, char *bptr) {
  Request req = {0};
  if (read_method(&req.method, bptr) < 0) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  };
  char *space = strchr(bptr, ' ');
  req.path = (space + 1);
  space = strchr(req.path, ' ');
  *space = '\0';
  int route_index = match_route(serv, &req);
  *space = ' ';
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }
  return route_index;
}

static inline int run_handler(Server *serv, conn_t *conn, bool uses_body) {
  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;

  if (read_req(&req, conn->rec[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  if (uses_body) {
    int h_index = HK_get_header(&req, "Content-Length");
    long body_size = atol(req.headers[h_index].value);
    if (body_size >= 0) {
      req.body.ptr = conn->rec[1].iov_base;
      req.body.size = body_size;
    } else {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    }
  }

  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  sendmsg_res(&req, &res);

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int handle_frecvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  char *bptr = (char *)conn->ios[0].iov_base;
  char *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  char *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  size_t head_size = (headEnd + 4) - bptr;
  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  int route_index = find_route(serv, bptr);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  bool uses_body = serv->routes[route_index].uses_body;
  long body_size = get_content_length(headstart + 2, headEnd + 4);
  if (body_size == -1) {
    if (uses_body) {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    } else {
      body_size = 0;
    }
  }

  conn->head_size = head_size;
  if (!uses_body) {
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  if (res == (int)(head_size + body_size)) {
    size_t iov_index = MP_expand(conn, round_to_blocks(body_size), false);
    memcpy(conn->rec[iov_index].iov_base, headEnd + 4, body_size);
    conn->ios[iov_index].iov_len = body_size;
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  conn->data_left = body_size - (res - head_size);
  bool once = ((size_t)body_size > (size_t)((pool.nblocks * MP_BLOCK) / 10));
  size_t iov_index = MP_expand(conn, round_to_blocks(body_size), once);
  memcpy(conn->rec[iov_index].iov_base, headEnd + 4, (res - head_size));
  conn->ios[iov_index].iov_base += (res - head_size);

  return urecvmsg(conn, iov_index, 1);
}

static inline int handle_recvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  if (conn->data_left > 0) {
    conn->data_left -= res;
    if (conn->data_left == 0) {
      conn->flags &= CF_HANDLER_READY;
      return run_handler(serv, conn, true);
    }

    conn->flags &= ~CF_HANDLER_READY;
    conn->ios[1].iov_base += res;
    return urecvmsg(conn, 1, 1);
  }

  conn->flags &= CF_HANDLER_READY;
  return run_handler(serv, conn, true);
}

static inline int serv_init(Server *serv) {
#if DEBUG
  logfd = log_init("log.txt");
  if (!logfd) {
    printf("log_init failed");
    return -1;
  }
#endif
  serv->_nroutes = get_nroutes(serv->routes);

  int pipefd[2];
  if (pipe(pipefd) < 0)
    return -1;
  pipe_in = pipefd[0];
  pipe_out = pipefd[1];
  nullfd = open("/dev/null", O_WRONLY);
  pipe_sz = fcntl(pipefd[0], F_GETPIPE_SZ);
  if (pipe_sz < 0)
    return -1;

  pool.rtimeout = serv->rtimeout;
  pool.wtimeout = serv->wtimeout;
  if (MP_init(MAX_CONNS * 8) < 0)
    return -1;
  LOG("pool initialized\n");

  if (io_uring_queue_init(MAX_CONNS, &ring, 0) < 0)
    return -1;
  LOG("uring initialized\n");

  int listenfd;
  if ((listenfd = tcp_listen(serv->port)) < 0)
    return -1;
  LOG("socket initialized\n");

  return umaccept(listenfd);
}

static inline int serv_listen(Server *serv) {
  // uint64_t last_check = get_time();
  while (true) {
    // uint64_t now = get_time();
    // if ((now - last_check) >= 200) {
    //   last_check = now;
    //   LOG("CM: CM_check ran\n");
    //   MP_timeout();
    // }

    LOG("SQ ready: %u, CQ ready: %u\n", io_uring_sq_ready(&ring), io_uring_cq_ready(&ring));
    struct io_uring_cqe *cqe;
    if (io_uring_wait_cqe(&ring, &cqe) < 0)
      continue;

    int res = cqe->res;
    LOG("res = %d\n", res);
    conn_t *conn = NULL;
    if (cqe->user_data > 100) {
      conn = (conn_t *)cqe->user_data;
      current_recv = (conn_t *)conn->recv_conn;
      current_send = (conn_t *)conn->send_conn;
    }

    if (res > 0) {
      if (cqe->user_data == ACCEPT) {
        LOG("new conn created\n");
        new_conn(res);
      } else if (conn && conn->fd != -1) {
        LOG("conn[%d]: conn.fd = %d; conn.op = %d\n", conn->cindex, conn->fd, conn->op);
        switch (conn->op) {
        case FRECVMSG:
          if (handle_frecvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case RECVMSG:
          if (handle_recvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case SENDMSG:
        case SENDMSGZC:
          // conn->last_write = get_time();
          bool zc = (conn->op == SENDMSGZC);
          if (handle_sendmsg(conn, res, zc) < 0)
            MP_clear(conn);
          break;
        case INSPLICE:
          if (handle_insplice(conn) < 0)
            MP_clear(conn);
          break;
        case OUTSPLICE:
          if (handle_outsplice(conn, res) < 0)
            MP_clear(conn);
          break;
        }
      }
    } else if (res == 0) {
      if (conn && conn->fd != -1) {
        switch (conn->op) {
        case SENDMSGZC:
          conn->zc_notifs--;
          if (conn->zc_notifs == 0 && handle_sendmsg_complete(conn) < 0)
            MP_clear(conn);
          break;
        case RECV:
          MP_clear(conn);
          break;
        }
      }
    } else {
      if (conn && conn->fd != -1) {
        if (res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR) {
          LOG("conn && conn->fd != -1 && res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR\n");
          MP_clear(conn);
        } else {
          LOG("res == -EAGAIN || res == -EWOULDBLOCK || res == -EINTR\n");
          conn = conn->recv_conn;
          struct iovec *iov = &conn->ios[0];
          memset(iov->iov_base, 0, iov->iov_len);
          if (urecv(conn, iov->iov_base, iov->iov_len, 0) < 0)
            MP_clear(conn);
        }
      }
    }

    LOG("uring operation seen\n");
    io_uring_cqe_seen(&ring, cqe);
  }

  io_uring_queue_exit(&ring);
  MP_exit(&pool);
  return 0;
}

/*** Helper ***/
static inline int _HK_write(void *data, size_t size) {
  size_t nblocks;
  int iov_index;
  conn_t *conn;
  struct iovec *iov;
  bool once;

  conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  nblocks = round_to_blocks(size);
  iov_index = MP_expand(conn, nblocks, once);
  iov = &conn->ios[iov_index];

  memcpy(iov->iov_base, data, size);
  iov->iov_len = size;
  conn->data_left += size;

  return 0;
}
static inline int _HK_write_body(Request *req, size_t offset, size_t size) {
  if (size > req->body.size || offset > req->body.size)
    return -1;

  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  int iov_index = MP_expand(conn, 0, false);
  struct iovec *iov = &conn->ios[iov_index];
  struct iovec *rec = &conn->rec[iov_index];
  rec->iov_base = req->body.ptr + offset;
  rec->iov_len = size;
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;
  conn->data_left += rec->iov_len;
  return 0;
}
/*
static inline int _HK_mem(size_t size, HKMem *mem) {
  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  bool once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  size_t nblocks = round_to_blocks(size);
  int iov_index = MP_expand(conn, nblocks, once);
  struct iovec *iov = &conn->ios[iov_index];
  mem->ptr = iov->iov_base;
  mem->size = iov->iov_len;
  mem->_iov_index = iov_index;
  mem->_flags = (IN_POOL(iov->iov_base)) ? CF_IN_POOL : CF_IN_HEAP;
  return 0;
}

static inline void _HK_send(HKMem *mem, size_t size) {
  conn_t *conn = current_send;
  struct iovec *iov = &conn->ios[mem->_iov_index];
  iov->iov_len = size;
  conn->data_left += size;
}
  */
#endif#define _GNU_SOURCE
#ifndef UTILS_H
#define UTILS_H

#include "hunk.h"
#include <arpa/inet.h>
#include <fcntl.h>
#include <liburing.h>
#include <netdb.h>
#include <signal.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/poll.h>
#include <sys/prctl.h>
#include <sys/socket.h>
#include <sys/sysinfo.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

#define MP_BLOCK  4
#define MAX_CONNS 4096
#define KB        1024
#define NIOS      32

#define IN_POOL(ptr)                 ((void *)ptr >= pool.bpool && (void *)ptr <= (pool.bpool + (pool.npages * pool.pagesize)))
#define ALIGN_TO_PAGESIZE(buff_size) (((buff_size) + (pool.pagesize - 1)) & ~(pool.pagesize - 1))
#define BYTES_TO_BLOCKS(buff_size)   (((buff_size) + (MP_BLOCK - 1)) / MP_BLOCK)
#define CEIL_BLOCKS(nblocks)         ((nblocks + 63) & ~63)
#define CEIL_PAGES(size)             (((size) + ((pool.pagesize) - 1)) & ~((pool.pagesize) - 1))

#define BIT_IS_FREE(word, bit)   (((word) >> (bit)) & 1)
#define MARK_BIT_USED(word, bit) ((word) &= ~(1ULL << (bit)))
#define MARK_BIT_FREE(word, bit) ((word) |= (1ULL << (bit)))
#define FIND_FREE_BIT(word)      ((uint64_t)(word) & -(uint64_t)(word))
#define STRLEN(s)                (sizeof(s) - 1)

#define IOVEC_NBLOCKS (BYTES_TO_BLOCKS(NIOS * sizeof(struct iovec)))
#define MSG_NBLOCKS   (BYTES_TO_BLOCKS(sizeof(struct msghdr)))
#define ZC_RES        KB *KB

#define DEBUG 0
#if DEBUG
#define LOG(...) fprintf(logfd, __VA_ARGS__)
#else
#define LOG(...) ((void)0)
#endif

typedef enum UOP {
  WRITEV = IORING_OP_WRITEV,
  SENDMSG = IORING_OP_SENDMSG,
  RECVMSG = IORING_OP_RECVMSG,
  ACCEPT = IORING_OP_ACCEPT,
  SEND = IORING_OP_SEND,
  RECV = IORING_OP_RECV,
  SENDZC = IORING_OP_SEND_ZC,
  SENDMSGZC = IORING_OP_SENDMSG_ZC,
  PEEK = 50,
  FRECVMSG,
  INSPLICE,
  OUTSPLICE
} UOP;

typedef enum CFS {
  CF_IN_POOL = (1 << 0),       // Connection is in the pool
  CF_IN_HEAP = (1 << 1),       // Connection is in the heap
  CF_SKIP_SOCK = (1 << 2),     // Don't close the socket
  CF_USE_ONCE = (1 << 3),      // Destroy after using
  CF_HANDLER_READY = (1 << 4), // Ready to call the handler
} CFS;

typedef struct conn_t {
  // Socket file descriptor
  int fd;

  // Amount of data left in the current operation
  uint64_t data_left;

  // The index of the connection struct
  uint32_t cindex;

  // The last time the connection was readable
  uint64_t last_read;

  // The last time the connection was writeable
  uint64_t last_write;

  // The operation currently being processed
  uint8_t op;

  // Connection flags
  int flags;

  // Splice fd_in
  int in_fd;

  // Splice fd_out
  int out_fd;

  void *recv_conn;
  void *send_conn;

  struct iovec *ios;
  struct iovec *rec;
  uint16_t nios;

  struct msghdr *msg;
  uint16_t zc_notifs;

  uint16_t head_size;
} conn_t;

typedef struct MPool {
  // The allocated pool of blocks
  void *bpool;

  // The allocated pool of connections
  conn_t *cpool;

  // The size of the pool in pages
  uint32_t npages;

  // The size of the pool in blocks
  uint32_t nblocks;

  // The locations of each page in the pool
  void **blocks;

  // The availability of each block
  uint64_t *freebs;

  // The locations of each conn in the pool
  conn_t **conns;

  // The availability of each conn
  uint64_t *freecs;

  // Clean up callback function
  void (*callback)(conn_t *conn);

  // The page size used
  uint32_t pagesize;

  // Socket read timeout
  uint32_t rtimeout;

  // Socket write timeout
  uint32_t wtimeout;
} MPool;

extern int pipe_sz;
extern int pipe_in, pipe_out, nullfd;
extern FILE *logfd;
extern struct io_uring ring;
extern MPool pool;
extern conn_t *current_recv;
extern conn_t *current_send;

/*
 * Prepare and submit a recv uring op
 */
static inline int urecv(conn_t *conn, void *buffer, size_t buff_size, int flags) {
  if (!conn || conn->fd == -1)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (flags == MSG_PEEK) ? PEEK : RECV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;

  io_uring_prep_recv(sqe, conn->fd, buffer, buff_size, flags);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a multi-shot accept uring op
 */
static inline int umaccept(int listenfd) {
  if (listenfd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = ACCEPT;
  io_uring_prep_multishot_accept(sqe, listenfd, NULL, NULL, SOCK_NONBLOCK);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a splice uring op
 */
static inline int usplice(conn_t *conn, int fd_in, int64_t off_in, int fd_out, int64_t off_out, size_t len) {
  if (!len || !conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = (__u64)conn;
  io_uring_prep_splice(sqe, fd_in, off_in, fd_out, off_out, len, 0);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a writev uring op
 */
static inline int uwritev(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = WRITEV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  io_uring_prep_writev(sqe, conn->fd, &conn->ios[iov_index], nios, -1);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a send uring op
 */
static inline int usend(conn_t *conn, char *res_buff, size_t buff_size, bool zc) {
  if (!conn || conn->fd <= 0 || buff_size == 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (zc) ? SENDZC : SEND;
  conn->data_left = buff_size;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  if (zc)
    io_uring_prep_send_zc(sqe, conn->fd, res_buff, buff_size, 0, 0);
  else
    io_uring_prep_send(sqe, conn->fd, res_buff, buff_size, 0);
  return io_uring_submit(&ring);
}

static inline int ufrecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = FRECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;

  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, rec->iov_len);
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int urecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = RECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int usendmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  bool zc = (conn->data_left > ZC_RES) ? true : false;
  conn->op = (zc) ? SENDMSGZC : SENDMSG;

  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  if (zc) {
    io_uring_prep_sendmsg_zc(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
    conn->zc_notifs++;
  } else {
    io_uring_prep_sendmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  }
  return io_uring_submit(&ring);
}

/*
 * Create and initialize a server socket
 */
static inline int tcp_listen(uint16_t port) {
  int enable;
  int listenfd;
  if ((listenfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    return -1;

  int flags = fcntl(listenfd, F_GETFL, 0);
  fcntl(listenfd, F_SETFL, flags | O_NONBLOCK);
  struct sockaddr_in servaddr;
  memset(&servaddr, 0, sizeof(servaddr));
  servaddr.sin_family = AF_INET;
  servaddr.sin_addr.s_addr = INADDR_ANY;
  servaddr.sin_port = htons(port);

  enable = 1;
  if (setsockopt(listenfd, SOL_SOCKET, SO_REUSEPORT, &enable, sizeof(enable)) < 0)
    return -1;

  if (bind(listenfd, (struct sockaddr *)&servaddr, sizeof(servaddr)) < 0)
    return -1;

  if (listen(listenfd, SOMAXCONN) < 0)
    return -1;

  return listenfd;
}

/*
 * Calculate the difference between two pointers
 */
static inline uintptr_t ptr_diff(uintptr_t p1, uintptr_t p2) { return (uintptr_t)(p1 > p2) ? (p1 - p2) : (p2 - p1); }

static inline size_t get_nroutes(Route *routes) {
  Route *route;
  for (size_t i = 0;; i++) {
    route = &routes[i];
    if (!route->path && !route->handler && !route->method)
      return i;
  }
}

static inline long get_content_length(char *src, char *end) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return -1;
    key = line;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, "Content-Length") != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;

    *line_end = '\0';
    long res = atol(value);
    *line_end = '\r';

    return res;
  }
  return -1;
}

static inline bool have_header(char *src, char *end, const char *header_key, const char *header_value) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    key = line;
    while (*key == ' ')
      key++;
    while (*header_key == ' ')
      header_key++;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return false;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, header_key) != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;
    while (*header_value == ' ')
      header_value++;

    *line_end = '\0';
    bool res = (strcasecmp(value, header_value) == 0);
    *line_end = '\r';

    return res;
  }

  return false;
}

static inline const char *method_str(Method method) {
  switch (method) {
  case GET:
    return "GET";
    break;
  case HEAD:
    return "HEAD";
    break;
  case POST:
    return "POST";
    break;
  case PUT:
    return "PUT";
    break;
  case DELETE:
    return "DELETE";
    break;
  case CONNECT:
    return "CONNECT";
    break;
  case OPTIONS:
    return "OPTIONS";
    break;
  case TRACE:
    return "TRACE";
    break;
  case PATCH:
    return "PATCH";
    break;
  default:
    return NULL;
  }
}

static inline uint8_t method_len(Method method) {
  switch (method) {
  case GET:
    return 3;
    break;
  case HEAD:
    return 4;
    break;
  case POST:
    return 4;
    break;
  case PUT:
    return 3;
    break;
  case DELETE:
    return 6;
    break;
  case CONNECT:
    return 7;
    break;
  case OPTIONS:
    return 7;
    break;
  case TRACE:
    return 5;
    break;
  case PATCH:
    return 5;
    break;
  default:
    return 0;
  }
}

static inline size_t round_to_blocks(size_t size) {
  size_t nblocks = BYTES_TO_BLOCKS(size);
  nblocks = CEIL_BLOCKS(nblocks);
  return nblocks;
}

/*
 * Count the digits in unsigned 64-bit int
 */
static inline int countd(uint64_t num) {
  if (num < 10ULL)
    return 1;
  if (num < 100ULL)
    return 2;
  if (num < 1000ULL)
    return 3;
  if (num < 10000ULL)
    return 4;
  if (num < 100000ULL)
    return 5;
  if (num < 1000000ULL)
    return 6;
  if (num < 10000000ULL)
    return 7;
  if (num < 100000000ULL)
    return 8;
  if (num < 1000000000ULL)
    return 9;
  if (num < 10000000000ULL)
    return 10;
  if (num < 100000000000ULL)
    return 11;
  if (num < 1000000000000ULL)
    return 12;
  if (num < 10000000000000ULL)
    return 13;
  if (num < 100000000000000ULL)
    return 14;
  if (num < 1000000000000000ULL)
    return 15;
  if (num < 10000000000000000ULL)
    return 16;
  if (num < 100000000000000000ULL)
    return 17;
  if (num < 1000000000000000000ULL)
    return 18;
  if (num < 10000000000000000000ULL)
    return 19;
  return 20;
}

/*
 * Get the time elabsed in ms
 */
static inline uint64_t get_time() {
  struct timespec ts;
  clock_gettime(CLOCK_MONOTONIC, &ts);
  return (uint64_t)(ts.tv_sec) * 1000 + (ts.tv_nsec / 1000000);
}

static inline FILE *log_init(const char *path) {
  FILE *res = fopen(path, "a+");
  setvbuf(res, NULL, _IONBF, 0);
  return res;
}

static inline int16_t pollevs(int connfd) {
  struct pollfd pfd;
  pfd.fd = connfd;
  pfd.events = POLLIN | POLLOUT | POLLERR;
  int res = poll(&pfd, 1, 0);
  if (res < 0)
    return POLLERR;
  return pfd.revents;
}

// FIXME This needs to be updated
static inline conn_t *MP_use_once(size_t nblocks, int fd) {

  void *mem = malloc(sizeof(conn_t) + 8 + (IOVEC_NBLOCKS * MP_BLOCK));
  struct conn_t *conn = (conn_t *)mem;
  memset(conn, 0, sizeof(conn_t));
  conn->ios = mem + sizeof(conn_t) + 8;

  if (nblocks > 0) {
    struct iovec *iov = &conn->ios[conn->nios++];
    mem = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (mem == MAP_FAILED)
      return NULL;
    iov->iov_base = mem;
    iov->iov_len = ALIGN_TO_PAGESIZE(nblocks * MP_BLOCK);
  }

  conn->flags |= CF_IN_HEAP;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;

  return conn;
}

static inline int find_freec() {
  uint64_t *word;
  size_t map_size = (sizeof(uint64_t) * 8);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    word = &pool.freecs[i / map_size];

    if (*word == 0) { // All used
      i += (map_size - 1);
      continue;
    }

    i += __builtin_ctzll(*word);
    MARK_BIT_USED(*word, i);
    return i;
  }

  return -1;
}

static inline int MP_init(size_t npages) {
  if (!npages)
    return -1;

  /*** Setup ***/
  pool.npages = npages;
  pool.pagesize = sysconf(_SC_PAGESIZE);

  /*** Pool ***/
  pool.bpool = mmap(NULL, pool.npages * pool.pagesize, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  if (pool.bpool == MAP_FAILED)
    return -1;
  pool.nblocks = (pool.npages * pool.pagesize) / MP_BLOCK;

  /*** Blocks ***/
  pool.blocks = malloc(sizeof(void *) * pool.nblocks);
  if (!pool.blocks)
    return -1;
  for (size_t i = 0; i < pool.nblocks; i++)
    pool.blocks[i] = pool.bpool + (i * MP_BLOCK);

  /*** Freebs ***/
  // if (posix_memalign((void **)&pool.freebs, 64, bitmap_size * sizeof(uint64_t)) < 0)
  size_t bitmap_size = (pool.nblocks + 63) / 64;
  pool.freebs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freebs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freebs[i] = UINT64_MAX;

  /*** Cpool ***/
  pool.cpool = (conn_t *)malloc(sizeof(conn_t) * MAX_CONNS);
  if (!pool.cpool)
    return -1;

  /*** Conns ***/
  pool.conns = (conn_t **)malloc(sizeof(conn_t *) * MAX_CONNS);
  if (!pool.conns)
    return -1;
  size_t conn_size = sizeof(conn_t);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    pool.conns[i] = (conn_t *)((char *)pool.cpool + (i * conn_size));
    pool.conns[i]->fd = -1;
    pool.conns[i]->in_fd = -1;
    pool.conns[i]->out_fd = -1;
  }

  /*** Freecs ***/
  bitmap_size = (MAX_CONNS + 63) / 64;
  pool.freecs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freecs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freecs[i] = UINT64_MAX;

  return 0;
}

static inline int MP_use_blks(size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t max_start = pool.nblocks - nblocks;
  size_t full_chunks = (nblocks / 64) * 64;

  for (size_t i = 0, c = 0; i <= max_start; i++, c++) {
    bool free = true;

    for (size_t j = 0; j < full_chunks; j += 64) {
      size_t word_index = (i + j) / 64;
      if (pool.freebs[word_index] != UINT64_MAX) {
        free = false;
        i += 63;
        break;
      }
    }

    for (size_t j = full_chunks; j < nblocks; j++) {
      size_t bit_index = i + j;
      size_t word_index = bit_index / 64;
      size_t bit_in_word = bit_index % 64;

      if (!BIT_IS_FREE(pool.freebs[word_index], bit_in_word)) {
        free = false;
        i += j;
        break;
      }
    }

    if (free) {
      for (size_t j = 0; j < full_chunks; j += 64) {
        size_t word_index = (i + j) / 64;
        pool.freebs[word_index] = 0;
      }

      for (size_t j = full_chunks; j < nblocks; j++) {
        size_t bit_index = i + j;
        size_t word_index = bit_index / 64;
        size_t bit_in_word = bit_index % 64;

        MARK_BIT_USED(pool.freebs[word_index], bit_in_word);
      }

      return i;
    }
  }

  return -1;
}

static inline int MP_free_blks(size_t bindex, size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t full_chunks = (nblocks / 64) * 64;
  for (size_t i = 0; i < full_chunks; i += 64) {
    size_t word_index = (bindex + i) / 64;
    pool.freebs[word_index] = UINT64_MAX;
  }

  for (size_t i = full_chunks; i < nblocks; i++) {
    size_t bit_index = bindex + i;
    size_t word_index = bit_index / 64;
    size_t bit_in_word = bit_index % 64;

    MARK_BIT_FREE(pool.freebs[word_index], bit_in_word);
  }

  memset(pool.blocks[bindex], 0, nblocks * MP_BLOCK);
  return 0;
}

static inline conn_t *MP_use(size_t nblocks, int fd, bool once) {
  if (fd <= 0)
    return NULL;
  if (once)
    return MP_use_once(nblocks, fd);

  int cindex = find_freec();
  if (cindex < 0) {
    LOG("Err: cindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  conn_t *conn = pool.conns[cindex];

  int ios_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (ios_bindex < 0) {
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }

  struct iovec *ios = pool.blocks[ios_bindex];
  conn->ios = ios;

  int rec_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (rec_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct iovec *rec = pool.blocks[rec_bindex];
  conn->rec = rec;

  int msg_bindex = MP_use_blks(MSG_NBLOCKS);
  if (msg_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct msghdr *msg = pool.blocks[msg_bindex];
  conn->msg = msg;

  if (nblocks > 0) {
    int bindex = MP_use_blks(nblocks);
    if (bindex < 0) {
      MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
      MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
      MP_free_blks(msg_bindex, IOVEC_NBLOCKS);
      MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
      LOG("Err: bindex < 0; will use MP_use_once\n");
      return MP_use_once(nblocks, fd);
    }

    size_t iov_index = conn->nios++;
    struct iovec *iov = &conn->ios[iov_index];
    struct iovec *rec = &conn->rec[iov_index];
    iov->iov_base = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
  }

  conn->msg->msg_iov = conn->ios;
  conn->msg->msg_iovlen = conn->nios;
  conn->cindex = cindex;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;
  return conn;
}

static inline void MP_shed(conn_t *conn, size_t iov_index, size_t nios) {
  struct iovec *iov, *rec;
  size_t bindex, nblocks, index;

  for (size_t i = 0; i < nios; i++) {
    index = iov_index + i;
    iov = &conn->ios[index];
    rec = &conn->rec[index];
    if (!rec || !rec->iov_base)
      continue;
    if (!IN_POOL(rec->iov_base)) {
      munmap(rec->iov_base, rec->iov_len / pool.pagesize);
    } else {
      bindex = ptr_diff((uintptr_t)rec->iov_base, (uintptr_t)pool.bpool) / MP_BLOCK;
      nblocks = rec->iov_len / MP_BLOCK;
      MP_free_blks(bindex, nblocks);
    }
    memset(iov, 0, sizeof(struct iovec));
    memset(rec, 0, sizeof(struct iovec));
    conn->nios--;
  }
}

static inline int MP_expand(conn_t *conn, size_t nblocks, bool once) {
  void *bptr;
  int iov_index, bindex;
  struct iovec *iov, *rec;

  iov_index = conn->nios++;
  iov = &conn->ios[iov_index];
  rec = &conn->rec[iov_index];

  if (nblocks == 0)
    return iov_index;

  if (once) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_base = bptr;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
    return iov_index;
  }

  bindex = MP_use_blks(nblocks);
  if (bindex < 0) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_len = iov->iov_len;
  } else {
    bptr = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_len = iov->iov_len;
  }

  iov->iov_base = bptr;
  rec->iov_base = iov->iov_base;
  return iov_index;
}

static inline int MP_free(conn_t *conn) {
  if (!conn)
    return -1;
  size_t bindex, nblocks;
  uint64_t *word;

  MP_shed(conn, 0, conn->nios);
  if (conn->flags & CF_IN_HEAP) {
    if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
      close(conn->fd);
    free(conn);
    return 0;
  }

  word = &pool.freecs[conn->cindex / 64];
  if (conn->cindex > MAX_CONNS)
    return -1;
  else if (BIT_IS_FREE(*word, conn->cindex))
    return 0;

  bindex = ptr_diff((uintptr_t)conn->ios, (uintptr_t)pool.bpool) / MP_BLOCK;
  nblocks = IOVEC_NBLOCKS;
  MP_free_blks(bindex, nblocks);

  bindex = ptr_diff((uintptr_t)conn->rec, (uintptr_t)pool.bpool) / MP_BLOCK;
  MP_free_blks(bindex, nblocks);

  if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
    close(conn->fd);

  MARK_BIT_FREE(*word, conn->cindex);
  memset(conn, 0, sizeof(conn_t));
  conn->fd = -1;
  conn->in_fd = -1;
  conn->out_fd = -1;
  return 0;
}

static inline void MP_clear(conn_t *conn) {
  conn_t *recv_conn = conn->recv_conn;
  conn_t *send_conn = conn->send_conn;
  if (recv_conn)
    MP_free(recv_conn);
  if (send_conn)
    MP_free(send_conn);
}

static inline void MP_exit(MPool *pool) {
  munmap(pool->bpool, pool->npages);
  free(pool->cpool);
  free(pool->blocks);
  free(pool->conns);
  free(pool->freebs);
  free(pool->freecs);
}

static inline void MP_timeout() {
  conn_t *conn;
  int16_t res;
  uint64_t now;
  size_t windex = 0;
  uint64_t *word = &pool.freecs[0];
  for (size_t i = 0; i < MAX_CONNS; i++) {
    if ((i / 64) < windex)
      word = &pool.freecs[++windex];

    if (*word == UINTMAX_MAX) {
      i = (i / 64) * 64 + 64;
      continue;
    }

    conn = pool.conns[i];
    if (!conn || conn->fd == -1)
      continue;

    res = pollevs(conn->fd);

    now = get_time();
    if (res & POLLERR) {
      MP_clear(conn);
      continue;
    }
    if (res & POLLIN) {
      if (pool.rtimeout > 0 && (now - conn->last_read) >= pool.rtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (res & POLLOUT) {
      if (pool.wtimeout > 0 && (now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (!(res & POLLIN || res & POLLOUT)) {
      if ((pool.rtimeout > 0 && now - conn->last_read) >= pool.rtimeout
          || (pool.wtimeout > 0 && now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
  }
}

/*
 * Calculate the length of a status string
 */
static inline size_t status_len(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return 8;
  case STATUSSWITCHINGPROTOCOLS:
    return 19;
  case STATUSPROCESSING:
    return 10;
  case STATUSEARLYHINTS:
    return 11;
  case STATUSOK:
    return 2;
  case STATUSCREATED:
    return 7;
  case STATUSACCEPTED:
    return 8;
  case STATUSNONAUTHORITATIVE:
    return 29;
  case STATUSNOCONTENT:
    return 10;
  case STATUSRESETCONTENT:
    return 13;
  case STATUSPARTIALCONTENT:
    return 15;
  case STATUSMULTISTATUS:
    return 12;
  case STATUSALREADYREPORTED:
    return 16;
  case STATUSIMUSED:
    return 7;
  case STATUSMULTIPLECHOICES:
    return 16;
  case STATUSMOVEDPERMANENTLY:
    return 17;
  case STATUSFOUND:
    return 5;
  case STATUSSEEOTHER:
    return 9;
  case STATUSNOTMODIFIED:
    return 12;
  case STATUSUSEPROXY:
    return 9;
  case STATUSTEMPORARYREDIRECT:
    return 18;
  case STATUSPERMANENTREDIRECT:
    return 18;
  case STATUSBADREQUEST:
    return 11;
  case STATUSUNAUTHORIZED:
    return 12;
  case STATUSPAYMENTREQUIRED:
    return 16;
  case STATUSFORBIDDEN:
    return 9;
  case STATUSNOTFOUND:
    return 9;
  case STATUSMETHODNOTALLOWED:
    return 18;
  case STATUSNOTACCEPTABLE:
    return 14;
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return 29;
  case STATUSREQUESTTIMEOUT:
    return 15;
  case STATUSCONFLICT:
    return 8;
  case STATUSGONE:
    return 4;
  case STATUSLENGTHREQUIRED:
    return 15;
  case STATUSPRECONDITIONFAILED:
    return 19;
  case CONTENTTOOLARGE:
    return 17;
  case STATUSURITOOLONG:
    return 12;
  case STATUSUNSUPPORTEDMEDIATYPE:
    return 22;
  case STATUSRANGENOTSATISFIABLE:
    return 21;
  case STATUSEXPECTATIONFAILED:
    return 18;
  case STATUSMISDIRECTEDREQUEST:
    return 19;
  case STATUSUNPROCESSABLECONTENT:
    return 21;
  case STATUSLOCKED:
    return 6;
  case STATUSFAILEDDEPENDENCY:
    return 17;
  case STATUSTOOEARLY:
    return 9;
  case STATUSUPGRADEREQUIRED:
    return 16;
  case STATUSPRECONDITIONREQUIRED:
    return 21;
  case STATUSTOOMANYREQUESTS:
    return 17;
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return 31;
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return 29;
  case STATUSInternalServerError:
    return 21;
  case STATUSNOTIMPLEMENTED:
    return 15;
  case STATUSBADGATEWAY:
    return 11;
  case STATUSSERVICEUNAVAILABLE:
    return 19;
  case STATUSGATEWAYTIMEOUT:
    return 15;
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return 26;
  case STATUSVARIANTALSONEGOTIATES:
    return 23;
  case STATUSINSUFFICIENTSTORAGE:
    return 20;
  case STATUSLOOPDETECTED:
    return 13;
  case STATUSNOTEXTENDED:
    return 12;
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return 31;
  default:
    return 0;
  }
}

/*
 * Return the status code string as string literal
 */
static inline char *status_str(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return "Continue";
  case STATUSSWITCHINGPROTOCOLS:
    return "Switching Protocols";
  case STATUSPROCESSING:
    return "Processing";
  case STATUSEARLYHINTS:
    return "Early Hints";
  case STATUSOK:
    return "OK";
  case STATUSCREATED:
    return "Created";
  case STATUSACCEPTED:
    return "Accepted";
  case STATUSNONAUTHORITATIVE:
    return "Non-Authoritative Information";
  case STATUSNOCONTENT:
    return "No Content";
  case STATUSRESETCONTENT:
    return "Reset Content";
  case STATUSPARTIALCONTENT:
    return "Partial Content";
  case STATUSMULTISTATUS:
    return "Multi-Status";
  case STATUSALREADYREPORTED:
    return "Already Reported";
  case STATUSIMUSED:
    return "Im Used";
  case STATUSMULTIPLECHOICES:
    return "Multiple Choices";
  case STATUSMOVEDPERMANENTLY:
    return "Moved Permanently";
  case STATUSFOUND:
    return "Found";
  case STATUSSEEOTHER:
    return "See Other";
  case STATUSNOTMODIFIED:
    return "Not Modified";
  case STATUSUSEPROXY:
    return "Use Proxy";
  case STATUSTEMPORARYREDIRECT:
    return "Temporary Redirect";
  case STATUSPERMANENTREDIRECT:
    return "Permanent Redirect";
  case STATUSBADREQUEST:
    return "Bad Request";
  case STATUSUNAUTHORIZED:
    return "Unauthorized";
  case STATUSPAYMENTREQUIRED:
    return "Payment Required";
  case STATUSFORBIDDEN:
    return "Forbidden";
  case STATUSNOTFOUND:
    return "Not Found";
  case STATUSMETHODNOTALLOWED:
    return "Method Not Allowed";
  case STATUSNOTACCEPTABLE:
    return "Not Acceptable";
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return "Proxy Authentication Required";
  case STATUSREQUESTTIMEOUT:
    return "Request Timeout";
  case STATUSCONFLICT:
    return "Conflict";
  case STATUSGONE:
    return "Gone";
  case STATUSLENGTHREQUIRED:
    return "Length Required";
  case STATUSPRECONDITIONFAILED:
    return "Precondition Failed";
  case CONTENTTOOLARGE:
    return "Content Too Large";
  case STATUSURITOOLONG:
    return "URI Too Long";
  case STATUSUNSUPPORTEDMEDIATYPE:
    return "Unsupported Media Type";
  case STATUSRANGENOTSATISFIABLE:
    return "Range Not Satisfiable";
  case STATUSEXPECTATIONFAILED:
    return "Expectation Failed";
  case STATUSMISDIRECTEDREQUEST:
    return "Misdirected Request";
  case STATUSUNPROCESSABLECONTENT:
    return "Unprocessable Content";
  case STATUSLOCKED:
    return "Locked";
  case STATUSFAILEDDEPENDENCY:
    return "Failed Dependency";
  case STATUSTOOEARLY:
    return "Too Early";
  case STATUSUPGRADEREQUIRED:
    return "Upgrade Required";
  case STATUSPRECONDITIONREQUIRED:
    return "Precondition Required";
  case STATUSTOOMANYREQUESTS:
    return "Too Many Requests";
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return "Request Header Fields Too Large";
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return "Unavailable For Legal Reasons";
  case STATUSInternalServerError:
    return "Internal Server Error";
  case STATUSNOTIMPLEMENTED:
    return "Not Implemented";
  case STATUSBADGATEWAY:
    return "Bad Gateway";
  case STATUSSERVICEUNAVAILABLE:
    return "Service Unavailable";
  case STATUSGATEWAYTIMEOUT:
    return "Gateway Timeout";
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return "HTTP Version Not Supported";
  case STATUSVARIANTALSONEGOTIATES:
    return "Variant Also Negotiates";
  case STATUSINSUFFICIENTSTORAGE:
    return "Insufficient Storage";
  case STATUSLOOPDETECTED:
    return "Loop Detected";
  case STATUSNOTEXTENDED:
    return "Not Extended";
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return "Network Authentication Required";
  default:
    return 0;
  }
}

/*
 * Return true if routes match
 */
static inline bool route_equ(Route *route, Request *req) {
  return route->method == req->method && strncmp(route->path, req->path, strlen(route->path)) == 0;
}

/*
 * Return the matching route index on success. -1 on failure
 */
static inline int match_route(Server *serv, Request *req) {
  for (size_t i = 0; i < serv->_nroutes; i++) {
    Route route = serv->routes[i];
    if (!req->path || !route.path)
      continue;
    if (route_equ(&route, req))
      return i;
    else if (req->method == HEAD && route.method == GET && strcmp(route.path, req->path) == 0)
      return i;
  }
  return -1;
}

/*
 * Return true if the response should contain the Content-Length header
 */
static inline bool should_have_content_length(Request *req, ResWriter *res) {
  return (req->method != CONNECT              // CONNECT request
          && res->status != STATUSNOCONTENT   // 204 response
          && res->status != STATUSNOTMODIFIED // 304 response
          && res->status >= 200);             // 1xx response
}

/*
 * Format http response from the ResWriter.
 * Return response size on success, 0 on failure.
 */
static inline size_t fmt_res(Request *req, ResWriter *res, char *buffer, size_t buffer_size) {
  if (!res || !buffer || buffer_size == 0)
    return 0;

  size_t res_len, total = 0;
  char *dst = buffer;
  size_t maxlen = buffer_size;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t body_length = res->len;

  res_len = snprintf(dst, maxlen, "HTTP/1.1 %d %s", (int)res->status, status_str(res->status));
  total += res_len;
  dst += res_len;
  maxlen -= res_len;

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    res_len = snprintf(dst, maxlen, "\r\n%s: %s", header->key, header->value);
    total += res_len;
    dst += res_len;
    maxlen -= res_len;
  }

  if (have_content_length) {
    res_len = snprintf(dst, maxlen, "\r\nContent-Length: %lu", body_length);
    total += res_len, dst += res_len, maxlen -= res_len;
  }

  memcpy(dst, "\r\n\r\n", 4);
  total += 4, dst += 4, maxlen -= 4;

  return total;
}

static inline size_t res_len(Request *req, ResWriter *res) {
  if (!req || !res)
    return 0;

  if (!res->status)
    res->status = STATUSOK;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t result = 0;
  result += STRLEN("HTTP/1.1 ");     // HTTP version
  result += 4;                       // Status code + space
  result += status_len(res->status); // Status name

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    result += 2;                       // "\r\n"
    result += strlen(header->key) + 2; // Header key + ':' + space
    result += strlen(header->value);   // header value
  }

  if (have_content_length) {
    result += 2;                          // "\r\n"
    result += STRLEN("Content-Length: "); // Header key
    result += countd(res->len);           // Header value
  }

  result += 4; // "\r\n\r\n"

  return result;
}

static inline int send_empty_res(Status status) {
  size_t res_len = STRLEN("HTTP/1.1 ")        // HTTP version
                   + countd((uint64_t)status) // status code
                   + 1                        // space
                   + (int)status_len(status)  // status string
                   + 4;                       // \r\n\r\n

  conn_t *conn = current_send;
  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, res_len);
  if (snprintf((char *)rec->iov_base, res_len + 1, "HTTP/1.1 %d %s\r\n\r\n", (int)status, status_str(status))
      != (int)res_len)
    return -1;

  return usendmsg(conn, 0, 1);
}

static inline ssize_t read_socket(int sockfd, size_t len) {
  if (len == 0 || sockfd <= 0)
    return 0;
  char buff[1024 * 8];
  return read(sockfd, buff, 1024 * 8);
}

static inline int read_method(Method *method, void *src) {
  if (memcmp(src, "GET", 3) == 0)
    *method = GET;
  else if (memcmp(src, "POST", 4) == 0)
    *method = POST;
  else if (memcmp(src, "HEAD", 4) == 0)
    *method = HEAD;
  else if (memcmp(src, "PUT", 3) == 0)
    *method = PUT;
  else if (memcmp(src, "DELETE", 6) == 0)
    *method = DELETE;
  else if (memcmp(src, "CONNECT", 7) == 0)
    *method = CONNECT;
  else if (memcmp(src, "OPTIONS", 7) == 0)
    *method = OPTIONS;
  else if (memcmp(src, "TRACE", 5) == 0)
    *method = TRACE;
  else if (memcmp(src, "PATCH", 5) == 0)
    *method = PATCH;
  else
    return -1;

  return 0;
}

static inline int sendmsg_res(Request *req, ResWriter *res) {
  conn_t *conn;
  size_t head_size, res_size;
  struct iovec *iov;

  conn = current_send;
  iov = &conn->ios[0];
  head_size = res_len(req, res);
  if (head_size == 0)
    return -1;

  conn->data_left += head_size;
  res_size = fmt_res(req, res, iov->iov_base, (head_size + 1));
  if (res_size != head_size)
    return -1;
  iov->iov_len = res_size;

  return usendmsg(conn, 0, conn->nios);
}

static inline int read_req(Request *req, char *req_buffer) {
  if (!req_buffer)
    return -1;
  /*** Method ***/
  char *sep = strchr(req_buffer, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }
  *sep = '\0';
  if (read_method(&req->method, req_buffer) < 0)
    return -1;

  /*** Path ***/
  char *fullpath = sep + 1;
  sep = strchr(fullpath, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }

  *sep = '\0';
  req->path = fullpath;
  /*** Params ***/
  char *paramStart = strchr(fullpath, '?');
  if (paramStart) {
    *paramStart++ = '\0';
    int params_count = 0;
    params_count = HK_parse_params(paramStart, req->params, MAX_URL_PARAMETERS);
    if (params_count > 0)
      req->params_count = params_count;
    else
      req->params_count = 0;
  } else {
    req->params = NULL;
    req->params_count = 0;
  }

  /*** Headers ***/
  char *headStart = strstr(sep + 1, "\r\n");
  char *headEnd = strstr(sep + 1, "\r\n\r\n");
  if (!headStart) {
    LOG("read_req: !headStart\n");
    return -1;
  };

  memset(headStart, 0, 2);
  headStart += 2;
  memset(headEnd, 0, 4);
  headEnd += 4;

  int headers_count = HK_parse_headers(headStart, req->headers, MAX_REQ_HEADERS);
  if (headers_count <= 0)
    return -1;
  req->headers_count = headers_count;

  /*** Host ***/
  int index = HK_get_header(req, "Host");
  if (index < 0)
    return -1;
  char *host = req->headers[index].value;
  req->hostname = host;

  /*** Port ***/
  char *colon = strchr(host, ':');
  if (colon) {
    *colon++ = '\0';
    req->port = atoi(colon);
  } else {
    req->port = PORT;
  }
  return 0;
}
static inline int process_req(Server *serv, conn_t *conn) {
  if (!conn || conn->fd == -1)
    return -1;

  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;
  if (read_req(&req, conn->ios[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    LOG("Err: route_index == -1\n");
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;
  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  sendmsg_res(&req, &res);

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int new_conn(int connfd) {
  if (connfd <= 0)
    return -1;

  current_recv = MP_use(KB * 2, connfd, false);
  current_send = MP_use(KB * 2, connfd, false);

  current_recv->recv_conn = current_recv;
  current_recv->send_conn = current_send;

  current_send->send_conn = current_send;
  current_send->recv_conn = current_recv;

  conn_t *conn = current_recv;
  if (ufrecvmsg(conn, 0, 1) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

static inline int resubmit_sendmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return usendmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int resubmir_recvmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    // FIXME the len should be increased
    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return urecvmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int handle_sendmsg_complete(conn_t *conn) {
  struct iovec *iov, *rec;

  MP_shed(conn, 1, conn->nios - 1);
  iov = &conn->ios[0];
  rec = &conn->rec[0];
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;

  return ufrecvmsg(conn->recv_conn, 0, 1);
}

static inline int handle_sendmsg(conn_t *conn, int res, bool zc) {
  if (!conn || conn->fd == -1)
    return -1;

  conn->data_left -= res;
  if (conn->data_left > 0)
    return resubmit_sendmsg(conn, res);

  if (zc)
    return 0;

  return handle_sendmsg_complete(conn);
}

static inline int handle_insplice(conn_t *conn) {
  conn->op = OUTSPLICE;
  return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
}
static inline int handle_outsplice(conn_t *conn, int res) {
  conn->data_left -= res;
  if (conn->data_left > 0) {
    conn->op = INSPLICE;
    return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
  }

  conn_t *recv_conn = conn->recv_conn;
  struct iovec *iov = &recv_conn->ios[0];
  memset(iov->iov_base, 0, iov->iov_len);
  if (urecv(recv_conn, iov->iov_base, iov->iov_len, MSG_PEEK) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

/*
static inline int handle_recv(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  void *bptr = conn->ios[0].iov_base;
  void *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  void *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  return process_req(serv, conn);
}
*/
static inline int find_route(Server *serv, char *bptr) {
  Request req = {0};
  if (read_method(&req.method, bptr) < 0) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  };
  char *space = strchr(bptr, ' ');
  req.path = (space + 1);
  space = strchr(req.path, ' ');
  *space = '\0';
  int route_index = match_route(serv, &req);
  *space = ' ';
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }
  return route_index;
}

static inline int run_handler(Server *serv, conn_t *conn, bool uses_body) {
  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;

  if (read_req(&req, conn->rec[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  if (uses_body) {
    int h_index = HK_get_header(&req, "Content-Length");
    long body_size = atol(req.headers[h_index].value);
    if (body_size >= 0) {
      req.body.ptr = conn->rec[1].iov_base;
      req.body.size = body_size;
    } else {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    }
  }

  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  sendmsg_res(&req, &res);

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int handle_frecvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  char *bptr = (char *)conn->ios[0].iov_base;
  char *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  char *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  size_t head_size = (headEnd + 4) - bptr;
  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  int route_index = find_route(serv, bptr);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  bool uses_body = serv->routes[route_index].uses_body;
  long body_size = get_content_length(headstart + 2, headEnd + 4);
  if (body_size == -1) {
    if (uses_body) {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    } else {
      body_size = 0;
    }
  }

  conn->head_size = head_size;
  if (!uses_body) {
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  if (res == (int)(head_size + body_size)) {
    size_t iov_index = MP_expand(conn, round_to_blocks(body_size), false);
    memcpy(conn->rec[iov_index].iov_base, headEnd + 4, body_size);
    conn->ios[iov_index].iov_len = body_size;
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  conn->data_left = body_size - (res - head_size);
  bool once = ((size_t)body_size > (size_t)((pool.nblocks * MP_BLOCK) / 10));
  size_t iov_index = MP_expand(conn, round_to_blocks(body_size), once);
  memcpy(conn->rec[iov_index].iov_base, headEnd + 4, (res - head_size));
  conn->ios[iov_index].iov_base += (res - head_size);

  return urecvmsg(conn, iov_index, 1);
}

static inline int handle_recvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  if (conn->data_left > 0) {
    conn->data_left -= res;
    if (conn->data_left == 0) {
      conn->flags &= CF_HANDLER_READY;
      return run_handler(serv, conn, true);
    }

    conn->flags &= ~CF_HANDLER_READY;
    conn->ios[1].iov_base += res;
    return urecvmsg(conn, 1, 1);
  }

  conn->flags &= CF_HANDLER_READY;
  return run_handler(serv, conn, true);
}

static inline int serv_init(Server *serv) {
#if DEBUG
  logfd = log_init("log.txt");
  if (!logfd) {
    printf("log_init failed");
    return -1;
  }
#endif
  serv->_nroutes = get_nroutes(serv->routes);

  int pipefd[2];
  if (pipe(pipefd) < 0)
    return -1;
  pipe_in = pipefd[0];
  pipe_out = pipefd[1];
  nullfd = open("/dev/null", O_WRONLY);
  pipe_sz = fcntl(pipefd[0], F_GETPIPE_SZ);
  if (pipe_sz < 0)
    return -1;

  pool.rtimeout = serv->rtimeout;
  pool.wtimeout = serv->wtimeout;
  if (MP_init(MAX_CONNS * 8) < 0)
    return -1;
  LOG("pool initialized\n");

  if (io_uring_queue_init(MAX_CONNS, &ring, 0) < 0)
    return -1;
  LOG("uring initialized\n");

  int listenfd;
  if ((listenfd = tcp_listen(serv->port)) < 0)
    return -1;
  LOG("socket initialized\n");

  return umaccept(listenfd);
}

static inline int serv_listen(Server *serv) {
  // uint64_t last_check = get_time();
  while (true) {
    // uint64_t now = get_time();
    // if ((now - last_check) >= 200) {
    //   last_check = now;
    //   LOG("CM: CM_check ran\n");
    //   MP_timeout();
    // }

    LOG("SQ ready: %u, CQ ready: %u\n", io_uring_sq_ready(&ring), io_uring_cq_ready(&ring));
    struct io_uring_cqe *cqe;
    if (io_uring_wait_cqe(&ring, &cqe) < 0)
      continue;

    int res = cqe->res;
    LOG("res = %d\n", res);
    conn_t *conn = NULL;
    if (cqe->user_data > 100) {
      conn = (conn_t *)cqe->user_data;
      current_recv = (conn_t *)conn->recv_conn;
      current_send = (conn_t *)conn->send_conn;
    }

    if (res > 0) {
      if (cqe->user_data == ACCEPT) {
        LOG("new conn created\n");
        new_conn(res);
      } else if (conn && conn->fd != -1) {
        LOG("conn[%d]: conn.fd = %d; conn.op = %d\n", conn->cindex, conn->fd, conn->op);
        switch (conn->op) {
        case FRECVMSG:
          if (handle_frecvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case RECVMSG:
          if (handle_recvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case SENDMSG:
        case SENDMSGZC:
          // conn->last_write = get_time();
          bool zc = (conn->op == SENDMSGZC);
          if (handle_sendmsg(conn, res, zc) < 0)
            MP_clear(conn);
          break;
        case INSPLICE:
          if (handle_insplice(conn) < 0)
            MP_clear(conn);
          break;
        case OUTSPLICE:
          if (handle_outsplice(conn, res) < 0)
            MP_clear(conn);
          break;
        }
      }
    } else if (res == 0) {
      if (conn && conn->fd != -1) {
        switch (conn->op) {
        case SENDMSGZC:
          conn->zc_notifs--;
          if (conn->zc_notifs == 0 && handle_sendmsg_complete(conn) < 0)
            MP_clear(conn);
          break;
        case RECV:
          MP_clear(conn);
          break;
        }
      }
    } else {
      if (conn && conn->fd != -1) {
        if (res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR) {
          LOG("conn && conn->fd != -1 && res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR\n");
          MP_clear(conn);
        } else {
          LOG("res == -EAGAIN || res == -EWOULDBLOCK || res == -EINTR\n");
          conn = conn->recv_conn;
          struct iovec *iov = &conn->ios[0];
          memset(iov->iov_base, 0, iov->iov_len);
          if (urecv(conn, iov->iov_base, iov->iov_len, 0) < 0)
            MP_clear(conn);
        }
      }
    }

    LOG("uring operation seen\n");
    io_uring_cqe_seen(&ring, cqe);
  }

  io_uring_queue_exit(&ring);
  MP_exit(&pool);
  return 0;
}

/*** Helper ***/
static inline int _HK_write(void *data, size_t size) {
  size_t nblocks;
  int iov_index;
  conn_t *conn;
  struct iovec *iov;
  bool once;

  conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  nblocks = round_to_blocks(size);
  iov_index = MP_expand(conn, nblocks, once);
  iov = &conn->ios[iov_index];

  memcpy(iov->iov_base, data, size);
  iov->iov_len = size;
  conn->data_left += size;

  return 0;
}
static inline int _HK_write_body(Request *req, size_t offset, size_t size) {
  if (size > req->body.size || offset > req->body.size)
    return -1;

  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  int iov_index = MP_expand(conn, 0, false);
  struct iovec *iov = &conn->ios[iov_index];
  struct iovec *rec = &conn->rec[iov_index];
  rec->iov_base = req->body.ptr + offset;
  rec->iov_len = size;
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;
  conn->data_left += rec->iov_len;
  return 0;
}
/*
static inline int _HK_mem(size_t size, HKMem *mem) {
  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  bool once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  size_t nblocks = round_to_blocks(size);
  int iov_index = MP_expand(conn, nblocks, once);
  struct iovec *iov = &conn->ios[iov_index];
  mem->ptr = iov->iov_base;
  mem->size = iov->iov_len;
  mem->_iov_index = iov_index;
  mem->_flags = (IN_POOL(iov->iov_base)) ? CF_IN_POOL : CF_IN_HEAP;
  return 0;
}

static inline void _HK_send(HKMem *mem, size_t size) {
  conn_t *conn = current_send;
  struct iovec *iov = &conn->ios[mem->_iov_index];
  iov->iov_len = size;
  conn->data_left += size;
}
  */
#endif#define _GNU_SOURCE
#ifndef UTILS_H
#define UTILS_H

#include "hunk.h"
#include <arpa/inet.h>
#include <fcntl.h>
#include <liburing.h>
#include <netdb.h>
#include <signal.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/poll.h>
#include <sys/prctl.h>
#include <sys/socket.h>
#include <sys/sysinfo.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

#define MP_BLOCK  4
#define MAX_CONNS 4096
#define KB        1024
#define NIOS      32

#define IN_POOL(ptr)                 ((void *)ptr >= pool.bpool && (void *)ptr <= (pool.bpool + (pool.npages * pool.pagesize)))
#define ALIGN_TO_PAGESIZE(buff_size) (((buff_size) + (pool.pagesize - 1)) & ~(pool.pagesize - 1))
#define BYTES_TO_BLOCKS(buff_size)   (((buff_size) + (MP_BLOCK - 1)) / MP_BLOCK)
#define CEIL_BLOCKS(nblocks)         ((nblocks + 63) & ~63)
#define CEIL_PAGES(size)             (((size) + ((pool.pagesize) - 1)) & ~((pool.pagesize) - 1))

#define BIT_IS_FREE(word, bit)   (((word) >> (bit)) & 1)
#define MARK_BIT_USED(word, bit) ((word) &= ~(1ULL << (bit)))
#define MARK_BIT_FREE(word, bit) ((word) |= (1ULL << (bit)))
#define FIND_FREE_BIT(word)      ((uint64_t)(word) & -(uint64_t)(word))
#define STRLEN(s)                (sizeof(s) - 1)

#define IOVEC_NBLOCKS (BYTES_TO_BLOCKS(NIOS * sizeof(struct iovec)))
#define MSG_NBLOCKS   (BYTES_TO_BLOCKS(sizeof(struct msghdr)))
#define ZC_RES        KB *KB

#define DEBUG 0
#if DEBUG
#define LOG(...) fprintf(logfd, __VA_ARGS__)
#else
#define LOG(...) ((void)0)
#endif

typedef enum UOP {
  WRITEV = IORING_OP_WRITEV,
  SENDMSG = IORING_OP_SENDMSG,
  RECVMSG = IORING_OP_RECVMSG,
  ACCEPT = IORING_OP_ACCEPT,
  SEND = IORING_OP_SEND,
  RECV = IORING_OP_RECV,
  SENDZC = IORING_OP_SEND_ZC,
  SENDMSGZC = IORING_OP_SENDMSG_ZC,
  PEEK = 50,
  FRECVMSG,
  INSPLICE,
  OUTSPLICE
} UOP;

typedef enum CFS {
  CF_IN_POOL = (1 << 0),       // Connection is in the pool
  CF_IN_HEAP = (1 << 1),       // Connection is in the heap
  CF_SKIP_SOCK = (1 << 2),     // Don't close the socket
  CF_USE_ONCE = (1 << 3),      // Destroy after using
  CF_HANDLER_READY = (1 << 4), // Ready to call the handler
} CFS;

typedef struct conn_t {
  // Socket file descriptor
  int fd;

  // Amount of data left in the current operation
  uint64_t data_left;

  // The index of the connection struct
  uint32_t cindex;

  // The last time the connection was readable
  uint64_t last_read;

  // The last time the connection was writeable
  uint64_t last_write;

  // The operation currently being processed
  uint8_t op;

  // Connection flags
  int flags;

  // Splice fd_in
  int in_fd;

  // Splice fd_out
  int out_fd;

  void *recv_conn;
  void *send_conn;

  struct iovec *ios;
  struct iovec *rec;
  uint16_t nios;

  struct msghdr *msg;
  uint16_t zc_notifs;

  uint16_t head_size;
} conn_t;

typedef struct MPool {
  // The allocated pool of blocks
  void *bpool;

  // The allocated pool of connections
  conn_t *cpool;

  // The size of the pool in pages
  uint32_t npages;

  // The size of the pool in blocks
  uint32_t nblocks;

  // The locations of each page in the pool
  void **blocks;

  // The availability of each block
  uint64_t *freebs;

  // The locations of each conn in the pool
  conn_t **conns;

  // The availability of each conn
  uint64_t *freecs;

  // Clean up callback function
  void (*callback)(conn_t *conn);

  // The page size used
  uint32_t pagesize;

  // Socket read timeout
  uint32_t rtimeout;

  // Socket write timeout
  uint32_t wtimeout;
} MPool;

extern int pipe_sz;
extern int pipe_in, pipe_out, nullfd;
extern FILE *logfd;
extern struct io_uring ring;
extern MPool pool;
extern conn_t *current_recv;
extern conn_t *current_send;

/*
 * Prepare and submit a recv uring op
 */
static inline int urecv(conn_t *conn, void *buffer, size_t buff_size, int flags) {
  if (!conn || conn->fd == -1)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (flags == MSG_PEEK) ? PEEK : RECV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;

  io_uring_prep_recv(sqe, conn->fd, buffer, buff_size, flags);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a multi-shot accept uring op
 */
static inline int umaccept(int listenfd) {
  if (listenfd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = ACCEPT;
  io_uring_prep_multishot_accept(sqe, listenfd, NULL, NULL, SOCK_NONBLOCK);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a splice uring op
 */
static inline int usplice(conn_t *conn, int fd_in, int64_t off_in, int fd_out, int64_t off_out, size_t len) {
  if (!len || !conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = (__u64)conn;
  io_uring_prep_splice(sqe, fd_in, off_in, fd_out, off_out, len, 0);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a writev uring op
 */
static inline int uwritev(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = WRITEV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  io_uring_prep_writev(sqe, conn->fd, &conn->ios[iov_index], nios, -1);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a send uring op
 */
static inline int usend(conn_t *conn, char *res_buff, size_t buff_size, bool zc) {
  if (!conn || conn->fd <= 0 || buff_size == 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (zc) ? SENDZC : SEND;
  conn->data_left = buff_size;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  if (zc)
    io_uring_prep_send_zc(sqe, conn->fd, res_buff, buff_size, 0, 0);
  else
    io_uring_prep_send(sqe, conn->fd, res_buff, buff_size, 0);
  return io_uring_submit(&ring);
}

static inline int ufrecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = FRECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;

  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, rec->iov_len);
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int urecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = RECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int usendmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  bool zc = (conn->data_left > ZC_RES) ? true : false;
  conn->op = (zc) ? SENDMSGZC : SENDMSG;

  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  if (zc) {
    io_uring_prep_sendmsg_zc(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
    conn->zc_notifs++;
  } else {
    io_uring_prep_sendmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  }
  return io_uring_submit(&ring);
}

/*
 * Create and initialize a server socket
 */
static inline int tcp_listen(uint16_t port) {
  int enable;
  int listenfd;
  if ((listenfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    return -1;

  int flags = fcntl(listenfd, F_GETFL, 0);
  fcntl(listenfd, F_SETFL, flags | O_NONBLOCK);
  struct sockaddr_in servaddr;
  memset(&servaddr, 0, sizeof(servaddr));
  servaddr.sin_family = AF_INET;
  servaddr.sin_addr.s_addr = INADDR_ANY;
  servaddr.sin_port = htons(port);

  enable = 1;
  if (setsockopt(listenfd, SOL_SOCKET, SO_REUSEPORT, &enable, sizeof(enable)) < 0)
    return -1;

  if (bind(listenfd, (struct sockaddr *)&servaddr, sizeof(servaddr)) < 0)
    return -1;

  if (listen(listenfd, SOMAXCONN) < 0)
    return -1;

  return listenfd;
}

/*
 * Calculate the difference between two pointers
 */
static inline uintptr_t ptr_diff(uintptr_t p1, uintptr_t p2) { return (uintptr_t)(p1 > p2) ? (p1 - p2) : (p2 - p1); }

static inline size_t get_nroutes(Route *routes) {
  Route *route;
  for (size_t i = 0;; i++) {
    route = &routes[i];
    if (!route->path && !route->handler && !route->method)
      return i;
  }
}

static inline long get_content_length(char *src, char *end) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return -1;
    key = line;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, "Content-Length") != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;

    *line_end = '\0';
    long res = atol(value);
    *line_end = '\r';

    return res;
  }
  return -1;
}

static inline bool have_header(char *src, char *end, const char *header_key, const char *header_value) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    key = line;
    while (*key == ' ')
      key++;
    while (*header_key == ' ')
      header_key++;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return false;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, header_key) != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;
    while (*header_value == ' ')
      header_value++;

    *line_end = '\0';
    bool res = (strcasecmp(value, header_value) == 0);
    *line_end = '\r';

    return res;
  }

  return false;
}

static inline const char *method_str(Method method) {
  switch (method) {
  case GET:
    return "GET";
    break;
  case HEAD:
    return "HEAD";
    break;
  case POST:
    return "POST";
    break;
  case PUT:
    return "PUT";
    break;
  case DELETE:
    return "DELETE";
    break;
  case CONNECT:
    return "CONNECT";
    break;
  case OPTIONS:
    return "OPTIONS";
    break;
  case TRACE:
    return "TRACE";
    break;
  case PATCH:
    return "PATCH";
    break;
  default:
    return NULL;
  }
}

static inline uint8_t method_len(Method method) {
  switch (method) {
  case GET:
    return 3;
    break;
  case HEAD:
    return 4;
    break;
  case POST:
    return 4;
    break;
  case PUT:
    return 3;
    break;
  case DELETE:
    return 6;
    break;
  case CONNECT:
    return 7;
    break;
  case OPTIONS:
    return 7;
    break;
  case TRACE:
    return 5;
    break;
  case PATCH:
    return 5;
    break;
  default:
    return 0;
  }
}

static inline size_t round_to_blocks(size_t size) {
  size_t nblocks = BYTES_TO_BLOCKS(size);
  nblocks = CEIL_BLOCKS(nblocks);
  return nblocks;
}

/*
 * Count the digits in unsigned 64-bit int
 */
static inline int countd(uint64_t num) {
  if (num < 10ULL)
    return 1;
  if (num < 100ULL)
    return 2;
  if (num < 1000ULL)
    return 3;
  if (num < 10000ULL)
    return 4;
  if (num < 100000ULL)
    return 5;
  if (num < 1000000ULL)
    return 6;
  if (num < 10000000ULL)
    return 7;
  if (num < 100000000ULL)
    return 8;
  if (num < 1000000000ULL)
    return 9;
  if (num < 10000000000ULL)
    return 10;
  if (num < 100000000000ULL)
    return 11;
  if (num < 1000000000000ULL)
    return 12;
  if (num < 10000000000000ULL)
    return 13;
  if (num < 100000000000000ULL)
    return 14;
  if (num < 1000000000000000ULL)
    return 15;
  if (num < 10000000000000000ULL)
    return 16;
  if (num < 100000000000000000ULL)
    return 17;
  if (num < 1000000000000000000ULL)
    return 18;
  if (num < 10000000000000000000ULL)
    return 19;
  return 20;
}

/*
 * Get the time elabsed in ms
 */
static inline uint64_t get_time() {
  struct timespec ts;
  clock_gettime(CLOCK_MONOTONIC, &ts);
  return (uint64_t)(ts.tv_sec) * 1000 + (ts.tv_nsec / 1000000);
}

static inline FILE *log_init(const char *path) {
  FILE *res = fopen(path, "a+");
  setvbuf(res, NULL, _IONBF, 0);
  return res;
}

static inline int16_t pollevs(int connfd) {
  struct pollfd pfd;
  pfd.fd = connfd;
  pfd.events = POLLIN | POLLOUT | POLLERR;
  int res = poll(&pfd, 1, 0);
  if (res < 0)
    return POLLERR;
  return pfd.revents;
}

// FIXME This needs to be updated
static inline conn_t *MP_use_once(size_t nblocks, int fd) {

  void *mem = malloc(sizeof(conn_t) + 8 + (IOVEC_NBLOCKS * MP_BLOCK));
  struct conn_t *conn = (conn_t *)mem;
  memset(conn, 0, sizeof(conn_t));
  conn->ios = mem + sizeof(conn_t) + 8;

  if (nblocks > 0) {
    struct iovec *iov = &conn->ios[conn->nios++];
    mem = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (mem == MAP_FAILED)
      return NULL;
    iov->iov_base = mem;
    iov->iov_len = ALIGN_TO_PAGESIZE(nblocks * MP_BLOCK);
  }

  conn->flags |= CF_IN_HEAP;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;

  return conn;
}

static inline int find_freec() {
  uint64_t *word;
  size_t map_size = (sizeof(uint64_t) * 8);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    word = &pool.freecs[i / map_size];

    if (*word == 0) { // All used
      i += (map_size - 1);
      continue;
    }

    i += __builtin_ctzll(*word);
    MARK_BIT_USED(*word, i);
    return i;
  }

  return -1;
}

static inline int MP_init(size_t npages) {
  if (!npages)
    return -1;

  /*** Setup ***/
  pool.npages = npages;
  pool.pagesize = sysconf(_SC_PAGESIZE);

  /*** Pool ***/
  pool.bpool = mmap(NULL, pool.npages * pool.pagesize, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  if (pool.bpool == MAP_FAILED)
    return -1;
  pool.nblocks = (pool.npages * pool.pagesize) / MP_BLOCK;

  /*** Blocks ***/
  pool.blocks = malloc(sizeof(void *) * pool.nblocks);
  if (!pool.blocks)
    return -1;
  for (size_t i = 0; i < pool.nblocks; i++)
    pool.blocks[i] = pool.bpool + (i * MP_BLOCK);

  /*** Freebs ***/
  // if (posix_memalign((void **)&pool.freebs, 64, bitmap_size * sizeof(uint64_t)) < 0)
  size_t bitmap_size = (pool.nblocks + 63) / 64;
  pool.freebs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freebs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freebs[i] = UINT64_MAX;

  /*** Cpool ***/
  pool.cpool = (conn_t *)malloc(sizeof(conn_t) * MAX_CONNS);
  if (!pool.cpool)
    return -1;

  /*** Conns ***/
  pool.conns = (conn_t **)malloc(sizeof(conn_t *) * MAX_CONNS);
  if (!pool.conns)
    return -1;
  size_t conn_size = sizeof(conn_t);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    pool.conns[i] = (conn_t *)((char *)pool.cpool + (i * conn_size));
    pool.conns[i]->fd = -1;
    pool.conns[i]->in_fd = -1;
    pool.conns[i]->out_fd = -1;
  }

  /*** Freecs ***/
  bitmap_size = (MAX_CONNS + 63) / 64;
  pool.freecs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freecs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freecs[i] = UINT64_MAX;

  return 0;
}

static inline int MP_use_blks(size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t max_start = pool.nblocks - nblocks;
  size_t full_chunks = (nblocks / 64) * 64;

  for (size_t i = 0, c = 0; i <= max_start; i++, c++) {
    bool free = true;

    for (size_t j = 0; j < full_chunks; j += 64) {
      size_t word_index = (i + j) / 64;
      if (pool.freebs[word_index] != UINT64_MAX) {
        free = false;
        i += 63;
        break;
      }
    }

    for (size_t j = full_chunks; j < nblocks; j++) {
      size_t bit_index = i + j;
      size_t word_index = bit_index / 64;
      size_t bit_in_word = bit_index % 64;

      if (!BIT_IS_FREE(pool.freebs[word_index], bit_in_word)) {
        free = false;
        i += j;
        break;
      }
    }

    if (free) {
      for (size_t j = 0; j < full_chunks; j += 64) {
        size_t word_index = (i + j) / 64;
        pool.freebs[word_index] = 0;
      }

      for (size_t j = full_chunks; j < nblocks; j++) {
        size_t bit_index = i + j;
        size_t word_index = bit_index / 64;
        size_t bit_in_word = bit_index % 64;

        MARK_BIT_USED(pool.freebs[word_index], bit_in_word);
      }

      return i;
    }
  }

  return -1;
}

static inline int MP_free_blks(size_t bindex, size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t full_chunks = (nblocks / 64) * 64;
  for (size_t i = 0; i < full_chunks; i += 64) {
    size_t word_index = (bindex + i) / 64;
    pool.freebs[word_index] = UINT64_MAX;
  }

  for (size_t i = full_chunks; i < nblocks; i++) {
    size_t bit_index = bindex + i;
    size_t word_index = bit_index / 64;
    size_t bit_in_word = bit_index % 64;

    MARK_BIT_FREE(pool.freebs[word_index], bit_in_word);
  }

  memset(pool.blocks[bindex], 0, nblocks * MP_BLOCK);
  return 0;
}

static inline conn_t *MP_use(size_t nblocks, int fd, bool once) {
  if (fd <= 0)
    return NULL;
  if (once)
    return MP_use_once(nblocks, fd);

  int cindex = find_freec();
  if (cindex < 0) {
    LOG("Err: cindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  conn_t *conn = pool.conns[cindex];

  int ios_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (ios_bindex < 0) {
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }

  struct iovec *ios = pool.blocks[ios_bindex];
  conn->ios = ios;

  int rec_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (rec_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct iovec *rec = pool.blocks[rec_bindex];
  conn->rec = rec;

  int msg_bindex = MP_use_blks(MSG_NBLOCKS);
  if (msg_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct msghdr *msg = pool.blocks[msg_bindex];
  conn->msg = msg;

  if (nblocks > 0) {
    int bindex = MP_use_blks(nblocks);
    if (bindex < 0) {
      MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
      MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
      MP_free_blks(msg_bindex, IOVEC_NBLOCKS);
      MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
      LOG("Err: bindex < 0; will use MP_use_once\n");
      return MP_use_once(nblocks, fd);
    }

    size_t iov_index = conn->nios++;
    struct iovec *iov = &conn->ios[iov_index];
    struct iovec *rec = &conn->rec[iov_index];
    iov->iov_base = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
  }

  conn->msg->msg_iov = conn->ios;
  conn->msg->msg_iovlen = conn->nios;
  conn->cindex = cindex;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;
  return conn;
}

static inline void MP_shed(conn_t *conn, size_t iov_index, size_t nios) {
  struct iovec *iov, *rec;
  size_t bindex, nblocks, index;

  for (size_t i = 0; i < nios; i++) {
    index = iov_index + i;
    iov = &conn->ios[index];
    rec = &conn->rec[index];
    if (!rec || !rec->iov_base)
      continue;
    if (!IN_POOL(rec->iov_base)) {
      munmap(rec->iov_base, rec->iov_len / pool.pagesize);
    } else {
      bindex = ptr_diff((uintptr_t)rec->iov_base, (uintptr_t)pool.bpool) / MP_BLOCK;
      nblocks = rec->iov_len / MP_BLOCK;
      MP_free_blks(bindex, nblocks);
    }
    memset(iov, 0, sizeof(struct iovec));
    memset(rec, 0, sizeof(struct iovec));
    conn->nios--;
  }
}

static inline int MP_expand(conn_t *conn, size_t nblocks, bool once) {
  void *bptr;
  int iov_index, bindex;
  struct iovec *iov, *rec;

  iov_index = conn->nios++;
  iov = &conn->ios[iov_index];
  rec = &conn->rec[iov_index];

  if (nblocks == 0)
    return iov_index;

  if (once) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_base = bptr;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
    return iov_index;
  }

  bindex = MP_use_blks(nblocks);
  if (bindex < 0) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_len = iov->iov_len;
  } else {
    bptr = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_len = iov->iov_len;
  }

  iov->iov_base = bptr;
  rec->iov_base = iov->iov_base;
  return iov_index;
}

static inline int MP_free(conn_t *conn) {
  if (!conn)
    return -1;
  size_t bindex, nblocks;
  uint64_t *word;

  MP_shed(conn, 0, conn->nios);
  if (conn->flags & CF_IN_HEAP) {
    if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
      close(conn->fd);
    free(conn);
    return 0;
  }

  word = &pool.freecs[conn->cindex / 64];
  if (conn->cindex > MAX_CONNS)
    return -1;
  else if (BIT_IS_FREE(*word, conn->cindex))
    return 0;

  bindex = ptr_diff((uintptr_t)conn->ios, (uintptr_t)pool.bpool) / MP_BLOCK;
  nblocks = IOVEC_NBLOCKS;
  MP_free_blks(bindex, nblocks);

  bindex = ptr_diff((uintptr_t)conn->rec, (uintptr_t)pool.bpool) / MP_BLOCK;
  MP_free_blks(bindex, nblocks);

  if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
    close(conn->fd);

  MARK_BIT_FREE(*word, conn->cindex);
  memset(conn, 0, sizeof(conn_t));
  conn->fd = -1;
  conn->in_fd = -1;
  conn->out_fd = -1;
  return 0;
}

static inline void MP_clear(conn_t *conn) {
  conn_t *recv_conn = conn->recv_conn;
  conn_t *send_conn = conn->send_conn;
  if (recv_conn)
    MP_free(recv_conn);
  if (send_conn)
    MP_free(send_conn);
}

static inline void MP_exit(MPool *pool) {
  munmap(pool->bpool, pool->npages);
  free(pool->cpool);
  free(pool->blocks);
  free(pool->conns);
  free(pool->freebs);
  free(pool->freecs);
}

static inline void MP_timeout() {
  conn_t *conn;
  int16_t res;
  uint64_t now;
  size_t windex = 0;
  uint64_t *word = &pool.freecs[0];
  for (size_t i = 0; i < MAX_CONNS; i++) {
    if ((i / 64) < windex)
      word = &pool.freecs[++windex];

    if (*word == UINTMAX_MAX) {
      i = (i / 64) * 64 + 64;
      continue;
    }

    conn = pool.conns[i];
    if (!conn || conn->fd == -1)
      continue;

    res = pollevs(conn->fd);

    now = get_time();
    if (res & POLLERR) {
      MP_clear(conn);
      continue;
    }
    if (res & POLLIN) {
      if (pool.rtimeout > 0 && (now - conn->last_read) >= pool.rtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (res & POLLOUT) {
      if (pool.wtimeout > 0 && (now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (!(res & POLLIN || res & POLLOUT)) {
      if ((pool.rtimeout > 0 && now - conn->last_read) >= pool.rtimeout
          || (pool.wtimeout > 0 && now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
  }
}

/*
 * Calculate the length of a status string
 */
static inline size_t status_len(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return 8;
  case STATUSSWITCHINGPROTOCOLS:
    return 19;
  case STATUSPROCESSING:
    return 10;
  case STATUSEARLYHINTS:
    return 11;
  case STATUSOK:
    return 2;
  case STATUSCREATED:
    return 7;
  case STATUSACCEPTED:
    return 8;
  case STATUSNONAUTHORITATIVE:
    return 29;
  case STATUSNOCONTENT:
    return 10;
  case STATUSRESETCONTENT:
    return 13;
  case STATUSPARTIALCONTENT:
    return 15;
  case STATUSMULTISTATUS:
    return 12;
  case STATUSALREADYREPORTED:
    return 16;
  case STATUSIMUSED:
    return 7;
  case STATUSMULTIPLECHOICES:
    return 16;
  case STATUSMOVEDPERMANENTLY:
    return 17;
  case STATUSFOUND:
    return 5;
  case STATUSSEEOTHER:
    return 9;
  case STATUSNOTMODIFIED:
    return 12;
  case STATUSUSEPROXY:
    return 9;
  case STATUSTEMPORARYREDIRECT:
    return 18;
  case STATUSPERMANENTREDIRECT:
    return 18;
  case STATUSBADREQUEST:
    return 11;
  case STATUSUNAUTHORIZED:
    return 12;
  case STATUSPAYMENTREQUIRED:
    return 16;
  case STATUSFORBIDDEN:
    return 9;
  case STATUSNOTFOUND:
    return 9;
  case STATUSMETHODNOTALLOWED:
    return 18;
  case STATUSNOTACCEPTABLE:
    return 14;
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return 29;
  case STATUSREQUESTTIMEOUT:
    return 15;
  case STATUSCONFLICT:
    return 8;
  case STATUSGONE:
    return 4;
  case STATUSLENGTHREQUIRED:
    return 15;
  case STATUSPRECONDITIONFAILED:
    return 19;
  case CONTENTTOOLARGE:
    return 17;
  case STATUSURITOOLONG:
    return 12;
  case STATUSUNSUPPORTEDMEDIATYPE:
    return 22;
  case STATUSRANGENOTSATISFIABLE:
    return 21;
  case STATUSEXPECTATIONFAILED:
    return 18;
  case STATUSMISDIRECTEDREQUEST:
    return 19;
  case STATUSUNPROCESSABLECONTENT:
    return 21;
  case STATUSLOCKED:
    return 6;
  case STATUSFAILEDDEPENDENCY:
    return 17;
  case STATUSTOOEARLY:
    return 9;
  case STATUSUPGRADEREQUIRED:
    return 16;
  case STATUSPRECONDITIONREQUIRED:
    return 21;
  case STATUSTOOMANYREQUESTS:
    return 17;
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return 31;
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return 29;
  case STATUSInternalServerError:
    return 21;
  case STATUSNOTIMPLEMENTED:
    return 15;
  case STATUSBADGATEWAY:
    return 11;
  case STATUSSERVICEUNAVAILABLE:
    return 19;
  case STATUSGATEWAYTIMEOUT:
    return 15;
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return 26;
  case STATUSVARIANTALSONEGOTIATES:
    return 23;
  case STATUSINSUFFICIENTSTORAGE:
    return 20;
  case STATUSLOOPDETECTED:
    return 13;
  case STATUSNOTEXTENDED:
    return 12;
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return 31;
  default:
    return 0;
  }
}

/*
 * Return the status code string as string literal
 */
static inline char *status_str(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return "Continue";
  case STATUSSWITCHINGPROTOCOLS:
    return "Switching Protocols";
  case STATUSPROCESSING:
    return "Processing";
  case STATUSEARLYHINTS:
    return "Early Hints";
  case STATUSOK:
    return "OK";
  case STATUSCREATED:
    return "Created";
  case STATUSACCEPTED:
    return "Accepted";
  case STATUSNONAUTHORITATIVE:
    return "Non-Authoritative Information";
  case STATUSNOCONTENT:
    return "No Content";
  case STATUSRESETCONTENT:
    return "Reset Content";
  case STATUSPARTIALCONTENT:
    return "Partial Content";
  case STATUSMULTISTATUS:
    return "Multi-Status";
  case STATUSALREADYREPORTED:
    return "Already Reported";
  case STATUSIMUSED:
    return "Im Used";
  case STATUSMULTIPLECHOICES:
    return "Multiple Choices";
  case STATUSMOVEDPERMANENTLY:
    return "Moved Permanently";
  case STATUSFOUND:
    return "Found";
  case STATUSSEEOTHER:
    return "See Other";
  case STATUSNOTMODIFIED:
    return "Not Modified";
  case STATUSUSEPROXY:
    return "Use Proxy";
  case STATUSTEMPORARYREDIRECT:
    return "Temporary Redirect";
  case STATUSPERMANENTREDIRECT:
    return "Permanent Redirect";
  case STATUSBADREQUEST:
    return "Bad Request";
  case STATUSUNAUTHORIZED:
    return "Unauthorized";
  case STATUSPAYMENTREQUIRED:
    return "Payment Required";
  case STATUSFORBIDDEN:
    return "Forbidden";
  case STATUSNOTFOUND:
    return "Not Found";
  case STATUSMETHODNOTALLOWED:
    return "Method Not Allowed";
  case STATUSNOTACCEPTABLE:
    return "Not Acceptable";
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return "Proxy Authentication Required";
  case STATUSREQUESTTIMEOUT:
    return "Request Timeout";
  case STATUSCONFLICT:
    return "Conflict";
  case STATUSGONE:
    return "Gone";
  case STATUSLENGTHREQUIRED:
    return "Length Required";
  case STATUSPRECONDITIONFAILED:
    return "Precondition Failed";
  case CONTENTTOOLARGE:
    return "Content Too Large";
  case STATUSURITOOLONG:
    return "URI Too Long";
  case STATUSUNSUPPORTEDMEDIATYPE:
    return "Unsupported Media Type";
  case STATUSRANGENOTSATISFIABLE:
    return "Range Not Satisfiable";
  case STATUSEXPECTATIONFAILED:
    return "Expectation Failed";
  case STATUSMISDIRECTEDREQUEST:
    return "Misdirected Request";
  case STATUSUNPROCESSABLECONTENT:
    return "Unprocessable Content";
  case STATUSLOCKED:
    return "Locked";
  case STATUSFAILEDDEPENDENCY:
    return "Failed Dependency";
  case STATUSTOOEARLY:
    return "Too Early";
  case STATUSUPGRADEREQUIRED:
    return "Upgrade Required";
  case STATUSPRECONDITIONREQUIRED:
    return "Precondition Required";
  case STATUSTOOMANYREQUESTS:
    return "Too Many Requests";
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return "Request Header Fields Too Large";
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return "Unavailable For Legal Reasons";
  case STATUSInternalServerError:
    return "Internal Server Error";
  case STATUSNOTIMPLEMENTED:
    return "Not Implemented";
  case STATUSBADGATEWAY:
    return "Bad Gateway";
  case STATUSSERVICEUNAVAILABLE:
    return "Service Unavailable";
  case STATUSGATEWAYTIMEOUT:
    return "Gateway Timeout";
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return "HTTP Version Not Supported";
  case STATUSVARIANTALSONEGOTIATES:
    return "Variant Also Negotiates";
  case STATUSINSUFFICIENTSTORAGE:
    return "Insufficient Storage";
  case STATUSLOOPDETECTED:
    return "Loop Detected";
  case STATUSNOTEXTENDED:
    return "Not Extended";
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return "Network Authentication Required";
  default:
    return 0;
  }
}

/*
 * Return true if routes match
 */
static inline bool route_equ(Route *route, Request *req) {
  return route->method == req->method && strncmp(route->path, req->path, strlen(route->path)) == 0;
}

/*
 * Return the matching route index on success. -1 on failure
 */
static inline int match_route(Server *serv, Request *req) {
  for (size_t i = 0; i < serv->_nroutes; i++) {
    Route route = serv->routes[i];
    if (!req->path || !route.path)
      continue;
    if (route_equ(&route, req))
      return i;
    else if (req->method == HEAD && route.method == GET && strcmp(route.path, req->path) == 0)
      return i;
  }
  return -1;
}

/*
 * Return true if the response should contain the Content-Length header
 */
static inline bool should_have_content_length(Request *req, ResWriter *res) {
  return (req->method != CONNECT              // CONNECT request
          && res->status != STATUSNOCONTENT   // 204 response
          && res->status != STATUSNOTMODIFIED // 304 response
          && res->status >= 200);             // 1xx response
}

/*
 * Format http response from the ResWriter.
 * Return response size on success, 0 on failure.
 */
static inline size_t fmt_res(Request *req, ResWriter *res, char *buffer, size_t buffer_size) {
  if (!res || !buffer || buffer_size == 0)
    return 0;

  size_t res_len, total = 0;
  char *dst = buffer;
  size_t maxlen = buffer_size;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t body_length = res->len;

  res_len = snprintf(dst, maxlen, "HTTP/1.1 %d %s", (int)res->status, status_str(res->status));
  total += res_len;
  dst += res_len;
  maxlen -= res_len;

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    res_len = snprintf(dst, maxlen, "\r\n%s: %s", header->key, header->value);
    total += res_len;
    dst += res_len;
    maxlen -= res_len;
  }

  if (have_content_length) {
    res_len = snprintf(dst, maxlen, "\r\nContent-Length: %lu", body_length);
    total += res_len, dst += res_len, maxlen -= res_len;
  }

  memcpy(dst, "\r\n\r\n", 4);
  total += 4, dst += 4, maxlen -= 4;

  return total;
}

static inline size_t res_len(Request *req, ResWriter *res) {
  if (!req || !res)
    return 0;

  if (!res->status)
    res->status = STATUSOK;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t result = 0;
  result += STRLEN("HTTP/1.1 ");     // HTTP version
  result += 4;                       // Status code + space
  result += status_len(res->status); // Status name

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    result += 2;                       // "\r\n"
    result += strlen(header->key) + 2; // Header key + ':' + space
    result += strlen(header->value);   // header value
  }

  if (have_content_length) {
    result += 2;                          // "\r\n"
    result += STRLEN("Content-Length: "); // Header key
    result += countd(res->len);           // Header value
  }

  result += 4; // "\r\n\r\n"

  return result;
}

static inline int send_empty_res(Status status) {
  size_t res_len = STRLEN("HTTP/1.1 ")        // HTTP version
                   + countd((uint64_t)status) // status code
                   + 1                        // space
                   + (int)status_len(status)  // status string
                   + 4;                       // \r\n\r\n

  conn_t *conn = current_send;
  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, res_len);
  if (snprintf((char *)rec->iov_base, res_len + 1, "HTTP/1.1 %d %s\r\n\r\n", (int)status, status_str(status))
      != (int)res_len)
    return -1;

  return usendmsg(conn, 0, 1);
}

static inline ssize_t read_socket(int sockfd, size_t len) {
  if (len == 0 || sockfd <= 0)
    return 0;
  char buff[1024 * 8];
  return read(sockfd, buff, 1024 * 8);
}

static inline int read_method(Method *method, void *src) {
  if (memcmp(src, "GET", 3) == 0)
    *method = GET;
  else if (memcmp(src, "POST", 4) == 0)
    *method = POST;
  else if (memcmp(src, "HEAD", 4) == 0)
    *method = HEAD;
  else if (memcmp(src, "PUT", 3) == 0)
    *method = PUT;
  else if (memcmp(src, "DELETE", 6) == 0)
    *method = DELETE;
  else if (memcmp(src, "CONNECT", 7) == 0)
    *method = CONNECT;
  else if (memcmp(src, "OPTIONS", 7) == 0)
    *method = OPTIONS;
  else if (memcmp(src, "TRACE", 5) == 0)
    *method = TRACE;
  else if (memcmp(src, "PATCH", 5) == 0)
    *method = PATCH;
  else
    return -1;

  return 0;
}

static inline int sendmsg_res(Request *req, ResWriter *res) {
  conn_t *conn;
  size_t head_size, res_size;
  struct iovec *iov;

  conn = current_send;
  iov = &conn->ios[0];
  head_size = res_len(req, res);
  if (head_size == 0)
    return -1;

  conn->data_left += head_size;
  res_size = fmt_res(req, res, iov->iov_base, (head_size + 1));
  if (res_size != head_size)
    return -1;
  iov->iov_len = res_size;

  return usendmsg(conn, 0, conn->nios);
}

static inline int read_req(Request *req, char *req_buffer) {
  if (!req_buffer)
    return -1;
  /*** Method ***/
  char *sep = strchr(req_buffer, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }
  *sep = '\0';
  if (read_method(&req->method, req_buffer) < 0)
    return -1;

  /*** Path ***/
  char *fullpath = sep + 1;
  sep = strchr(fullpath, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }

  *sep = '\0';
  req->path = fullpath;
  /*** Params ***/
  char *paramStart = strchr(fullpath, '?');
  if (paramStart) {
    *paramStart++ = '\0';
    int params_count = 0;
    params_count = HK_parse_params(paramStart, req->params, MAX_URL_PARAMETERS);
    if (params_count > 0)
      req->params_count = params_count;
    else
      req->params_count = 0;
  } else {
    req->params = NULL;
    req->params_count = 0;
  }

  /*** Headers ***/
  char *headStart = strstr(sep + 1, "\r\n");
  char *headEnd = strstr(sep + 1, "\r\n\r\n");
  if (!headStart) {
    LOG("read_req: !headStart\n");
    return -1;
  };

  memset(headStart, 0, 2);
  headStart += 2;
  memset(headEnd, 0, 4);
  headEnd += 4;

  int headers_count = HK_parse_headers(headStart, req->headers, MAX_REQ_HEADERS);
  if (headers_count <= 0)
    return -1;
  req->headers_count = headers_count;

  /*** Host ***/
  int index = HK_get_header(req, "Host");
  if (index < 0)
    return -1;
  char *host = req->headers[index].value;
  req->hostname = host;

  /*** Port ***/
  char *colon = strchr(host, ':');
  if (colon) {
    *colon++ = '\0';
    req->port = atoi(colon);
  } else {
    req->port = PORT;
  }
  return 0;
}
static inline int process_req(Server *serv, conn_t *conn) {
  if (!conn || conn->fd == -1)
    return -1;

  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;
  if (read_req(&req, conn->ios[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    LOG("Err: route_index == -1\n");
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;
  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  sendmsg_res(&req, &res);

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int new_conn(int connfd) {
  if (connfd <= 0)
    return -1;

  current_recv = MP_use(KB * 2, connfd, false);
  current_send = MP_use(KB * 2, connfd, false);

  current_recv->recv_conn = current_recv;
  current_recv->send_conn = current_send;

  current_send->send_conn = current_send;
  current_send->recv_conn = current_recv;

  conn_t *conn = current_recv;
  if (ufrecvmsg(conn, 0, 1) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

static inline int resubmit_sendmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return usendmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int resubmir_recvmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    // FIXME the len should be increased
    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return urecvmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int handle_sendmsg_complete(conn_t *conn) {
  struct iovec *iov, *rec;

  MP_shed(conn, 1, conn->nios - 1);
  iov = &conn->ios[0];
  rec = &conn->rec[0];
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;

  return ufrecvmsg(conn->recv_conn, 0, 1);
}

static inline int handle_sendmsg(conn_t *conn, int res, bool zc) {
  if (!conn || conn->fd == -1)
    return -1;

  conn->data_left -= res;
  if (conn->data_left > 0)
    return resubmit_sendmsg(conn, res);

  if (zc)
    return 0;

  return handle_sendmsg_complete(conn);
}

static inline int handle_insplice(conn_t *conn) {
  conn->op = OUTSPLICE;
  return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
}
static inline int handle_outsplice(conn_t *conn, int res) {
  conn->data_left -= res;
  if (conn->data_left > 0) {
    conn->op = INSPLICE;
    return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
  }

  conn_t *recv_conn = conn->recv_conn;
  struct iovec *iov = &recv_conn->ios[0];
  memset(iov->iov_base, 0, iov->iov_len);
  if (urecv(recv_conn, iov->iov_base, iov->iov_len, MSG_PEEK) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

/*
static inline int handle_recv(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  void *bptr = conn->ios[0].iov_base;
  void *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  void *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  return process_req(serv, conn);
}
*/
static inline int find_route(Server *serv, char *bptr) {
  Request req = {0};
  if (read_method(&req.method, bptr) < 0) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  };
  char *space = strchr(bptr, ' ');
  req.path = (space + 1);
  space = strchr(req.path, ' ');
  *space = '\0';
  int route_index = match_route(serv, &req);
  *space = ' ';
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }
  return route_index;
}

static inline int run_handler(Server *serv, conn_t *conn, bool uses_body) {
  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;

  if (read_req(&req, conn->rec[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  if (uses_body) {
    int h_index = HK_get_header(&req, "Content-Length");
    long body_size = atol(req.headers[h_index].value);
    if (body_size >= 0) {
      req.body.ptr = conn->rec[1].iov_base;
      req.body.size = body_size;
    } else {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    }
  }

  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  sendmsg_res(&req, &res);

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int handle_frecvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  char *bptr = (char *)conn->ios[0].iov_base;
  char *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  char *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  size_t head_size = (headEnd + 4) - bptr;
  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  int route_index = find_route(serv, bptr);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  bool uses_body = serv->routes[route_index].uses_body;
  long body_size = get_content_length(headstart + 2, headEnd + 4);
  if (body_size == -1) {
    if (uses_body) {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    } else {
      body_size = 0;
    }
  }

  conn->head_size = head_size;
  if (!uses_body) {
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  if (res == (int)(head_size + body_size)) {
    size_t iov_index = MP_expand(conn, round_to_blocks(body_size), false);
    memcpy(conn->rec[iov_index].iov_base, headEnd + 4, body_size);
    conn->ios[iov_index].iov_len = body_size;
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  conn->data_left = body_size - (res - head_size);
  bool once = ((size_t)body_size > (size_t)((pool.nblocks * MP_BLOCK) / 10));
  size_t iov_index = MP_expand(conn, round_to_blocks(body_size), once);
  memcpy(conn->rec[iov_index].iov_base, headEnd + 4, (res - head_size));
  conn->ios[iov_index].iov_base += (res - head_size);

  return urecvmsg(conn, iov_index, 1);
}

static inline int handle_recvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  if (conn->data_left > 0) {
    conn->data_left -= res;
    if (conn->data_left == 0) {
      conn->flags &= CF_HANDLER_READY;
      return run_handler(serv, conn, true);
    }

    conn->flags &= ~CF_HANDLER_READY;
    conn->ios[1].iov_base += res;
    return urecvmsg(conn, 1, 1);
  }

  conn->flags &= CF_HANDLER_READY;
  return run_handler(serv, conn, true);
}

static inline int serv_init(Server *serv) {
#if DEBUG
  logfd = log_init("log.txt");
  if (!logfd) {
    printf("log_init failed");
    return -1;
  }
#endif
  serv->_nroutes = get_nroutes(serv->routes);

  int pipefd[2];
  if (pipe(pipefd) < 0)
    return -1;
  pipe_in = pipefd[0];
  pipe_out = pipefd[1];
  nullfd = open("/dev/null", O_WRONLY);
  pipe_sz = fcntl(pipefd[0], F_GETPIPE_SZ);
  if (pipe_sz < 0)
    return -1;

  pool.rtimeout = serv->rtimeout;
  pool.wtimeout = serv->wtimeout;
  if (MP_init(MAX_CONNS * 8) < 0)
    return -1;
  LOG("pool initialized\n");

  if (io_uring_queue_init(MAX_CONNS, &ring, 0) < 0)
    return -1;
  LOG("uring initialized\n");

  int listenfd;
  if ((listenfd = tcp_listen(serv->port)) < 0)
    return -1;
  LOG("socket initialized\n");

  return umaccept(listenfd);
}

static inline int serv_listen(Server *serv) {
  // uint64_t last_check = get_time();
  while (true) {
    // uint64_t now = get_time();
    // if ((now - last_check) >= 200) {
    //   last_check = now;
    //   LOG("CM: CM_check ran\n");
    //   MP_timeout();
    // }

    LOG("SQ ready: %u, CQ ready: %u\n", io_uring_sq_ready(&ring), io_uring_cq_ready(&ring));
    struct io_uring_cqe *cqe;
    if (io_uring_wait_cqe(&ring, &cqe) < 0)
      continue;

    int res = cqe->res;
    LOG("res = %d\n", res);
    conn_t *conn = NULL;
    if (cqe->user_data > 100) {
      conn = (conn_t *)cqe->user_data;
      current_recv = (conn_t *)conn->recv_conn;
      current_send = (conn_t *)conn->send_conn;
    }

    if (res > 0) {
      if (cqe->user_data == ACCEPT) {
        LOG("new conn created\n");
        new_conn(res);
      } else if (conn && conn->fd != -1) {
        LOG("conn[%d]: conn.fd = %d; conn.op = %d\n", conn->cindex, conn->fd, conn->op);
        switch (conn->op) {
        case FRECVMSG:
          if (handle_frecvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case RECVMSG:
          if (handle_recvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case SENDMSG:
        case SENDMSGZC:
          // conn->last_write = get_time();
          bool zc = (conn->op == SENDMSGZC);
          if (handle_sendmsg(conn, res, zc) < 0)
            MP_clear(conn);
          break;
        case INSPLICE:
          if (handle_insplice(conn) < 0)
            MP_clear(conn);
          break;
        case OUTSPLICE:
          if (handle_outsplice(conn, res) < 0)
            MP_clear(conn);
          break;
        }
      }
    } else if (res == 0) {
      if (conn && conn->fd != -1) {
        switch (conn->op) {
        case SENDMSGZC:
          conn->zc_notifs--;
          if (conn->zc_notifs == 0 && handle_sendmsg_complete(conn) < 0)
            MP_clear(conn);
          break;
        case RECV:
          MP_clear(conn);
          break;
        }
      }
    } else {
      if (conn && conn->fd != -1) {
        if (res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR) {
          LOG("conn && conn->fd != -1 && res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR\n");
          MP_clear(conn);
        } else {
          LOG("res == -EAGAIN || res == -EWOULDBLOCK || res == -EINTR\n");
          conn = conn->recv_conn;
          struct iovec *iov = &conn->ios[0];
          memset(iov->iov_base, 0, iov->iov_len);
          if (urecv(conn, iov->iov_base, iov->iov_len, 0) < 0)
            MP_clear(conn);
        }
      }
    }

    LOG("uring operation seen\n");
    io_uring_cqe_seen(&ring, cqe);
  }

  io_uring_queue_exit(&ring);
  MP_exit(&pool);
  return 0;
}

/*** Helper ***/
static inline int _HK_write(void *data, size_t size) {
  size_t nblocks;
  int iov_index;
  conn_t *conn;
  struct iovec *iov;
  bool once;

  conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  nblocks = round_to_blocks(size);
  iov_index = MP_expand(conn, nblocks, once);
  iov = &conn->ios[iov_index];

  memcpy(iov->iov_base, data, size);
  iov->iov_len = size;
  conn->data_left += size;

  return 0;
}
static inline int _HK_write_body(Request *req, size_t offset, size_t size) {
  if (size > req->body.size || offset > req->body.size)
    return -1;

  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  int iov_index = MP_expand(conn, 0, false);
  struct iovec *iov = &conn->ios[iov_index];
  struct iovec *rec = &conn->rec[iov_index];
  rec->iov_base = req->body.ptr + offset;
  rec->iov_len = size;
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;
  conn->data_left += rec->iov_len;
  return 0;
}
/*
static inline int _HK_mem(size_t size, HKMem *mem) {
  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  bool once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  size_t nblocks = round_to_blocks(size);
  int iov_index = MP_expand(conn, nblocks, once);
  struct iovec *iov = &conn->ios[iov_index];
  mem->ptr = iov->iov_base;
  mem->size = iov->iov_len;
  mem->_iov_index = iov_index;
  mem->_flags = (IN_POOL(iov->iov_base)) ? CF_IN_POOL : CF_IN_HEAP;
  return 0;
}

static inline void _HK_send(HKMem *mem, size_t size) {
  conn_t *conn = current_send;
  struct iovec *iov = &conn->ios[mem->_iov_index];
  iov->iov_len = size;
  conn->data_left += size;
}
  */
#endif#define _GNU_SOURCE
#ifndef UTILS_H
#define UTILS_H

#include "hunk.h"
#include <arpa/inet.h>
#include <fcntl.h>
#include <liburing.h>
#include <netdb.h>
#include <signal.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/poll.h>
#include <sys/prctl.h>
#include <sys/socket.h>
#include <sys/sysinfo.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

#define MP_BLOCK  4
#define MAX_CONNS 4096
#define KB        1024
#define NIOS      32

#define IN_POOL(ptr)                 ((void *)ptr >= pool.bpool && (void *)ptr <= (pool.bpool + (pool.npages * pool.pagesize)))
#define ALIGN_TO_PAGESIZE(buff_size) (((buff_size) + (pool.pagesize - 1)) & ~(pool.pagesize - 1))
#define BYTES_TO_BLOCKS(buff_size)   (((buff_size) + (MP_BLOCK - 1)) / MP_BLOCK)
#define CEIL_BLOCKS(nblocks)         ((nblocks + 63) & ~63)
#define CEIL_PAGES(size)             (((size) + ((pool.pagesize) - 1)) & ~((pool.pagesize) - 1))

#define BIT_IS_FREE(word, bit)   (((word) >> (bit)) & 1)
#define MARK_BIT_USED(word, bit) ((word) &= ~(1ULL << (bit)))
#define MARK_BIT_FREE(word, bit) ((word) |= (1ULL << (bit)))
#define FIND_FREE_BIT(word)      ((uint64_t)(word) & -(uint64_t)(word))
#define STRLEN(s)                (sizeof(s) - 1)

#define IOVEC_NBLOCKS (BYTES_TO_BLOCKS(NIOS * sizeof(struct iovec)))
#define MSG_NBLOCKS   (BYTES_TO_BLOCKS(sizeof(struct msghdr)))
#define ZC_RES        KB *KB

#define DEBUG 0
#if DEBUG
#define LOG(...) fprintf(logfd, __VA_ARGS__)
#else
#define LOG(...) ((void)0)
#endif

typedef enum UOP {
  WRITEV = IORING_OP_WRITEV,
  SENDMSG = IORING_OP_SENDMSG,
  RECVMSG = IORING_OP_RECVMSG,
  ACCEPT = IORING_OP_ACCEPT,
  SEND = IORING_OP_SEND,
  RECV = IORING_OP_RECV,
  SENDZC = IORING_OP_SEND_ZC,
  SENDMSGZC = IORING_OP_SENDMSG_ZC,
  PEEK = 50,
  FRECVMSG,
  INSPLICE,
  OUTSPLICE
} UOP;

typedef enum CFS {
  CF_IN_POOL = (1 << 0),       // Connection is in the pool
  CF_IN_HEAP = (1 << 1),       // Connection is in the heap
  CF_SKIP_SOCK = (1 << 2),     // Don't close the socket
  CF_USE_ONCE = (1 << 3),      // Destroy after using
  CF_HANDLER_READY = (1 << 4), // Ready to call the handler
} CFS;

typedef struct conn_t {
  // Socket file descriptor
  int fd;

  // Amount of data left in the current operation
  uint64_t data_left;

  // The index of the connection struct
  uint32_t cindex;

  // The last time the connection was readable
  uint64_t last_read;

  // The last time the connection was writeable
  uint64_t last_write;

  // The operation currently being processed
  uint8_t op;

  // Connection flags
  int flags;

  // Splice fd_in
  int in_fd;

  // Splice fd_out
  int out_fd;

  void *recv_conn;
  void *send_conn;

  struct iovec *ios;
  struct iovec *rec;
  uint16_t nios;

  struct msghdr *msg;
  uint16_t zc_notifs;

  uint16_t head_size;
} conn_t;

typedef struct MPool {
  // The allocated pool of blocks
  void *bpool;

  // The allocated pool of connections
  conn_t *cpool;

  // The size of the pool in pages
  uint32_t npages;

  // The size of the pool in blocks
  uint32_t nblocks;

  // The locations of each page in the pool
  void **blocks;

  // The availability of each block
  uint64_t *freebs;

  // The locations of each conn in the pool
  conn_t **conns;

  // The availability of each conn
  uint64_t *freecs;

  // Clean up callback function
  void (*callback)(conn_t *conn);

  // The page size used
  uint32_t pagesize;

  // Socket read timeout
  uint32_t rtimeout;

  // Socket write timeout
  uint32_t wtimeout;
} MPool;

extern int pipe_sz;
extern int pipe_in, pipe_out, nullfd;
extern FILE *logfd;
extern struct io_uring ring;
extern MPool pool;
extern conn_t *current_recv;
extern conn_t *current_send;

/*
 * Prepare and submit a recv uring op
 */
static inline int urecv(conn_t *conn, void *buffer, size_t buff_size, int flags) {
  if (!conn || conn->fd == -1)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (flags == MSG_PEEK) ? PEEK : RECV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;

  io_uring_prep_recv(sqe, conn->fd, buffer, buff_size, flags);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a multi-shot accept uring op
 */
static inline int umaccept(int listenfd) {
  if (listenfd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = ACCEPT;
  io_uring_prep_multishot_accept(sqe, listenfd, NULL, NULL, SOCK_NONBLOCK);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a splice uring op
 */
static inline int usplice(conn_t *conn, int fd_in, int64_t off_in, int fd_out, int64_t off_out, size_t len) {
  if (!len || !conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = (__u64)conn;
  io_uring_prep_splice(sqe, fd_in, off_in, fd_out, off_out, len, 0);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a writev uring op
 */
static inline int uwritev(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = WRITEV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  io_uring_prep_writev(sqe, conn->fd, &conn->ios[iov_index], nios, -1);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a send uring op
 */
static inline int usend(conn_t *conn, char *res_buff, size_t buff_size, bool zc) {
  if (!conn || conn->fd <= 0 || buff_size == 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (zc) ? SENDZC : SEND;
  conn->data_left = buff_size;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  if (zc)
    io_uring_prep_send_zc(sqe, conn->fd, res_buff, buff_size, 0, 0);
  else
    io_uring_prep_send(sqe, conn->fd, res_buff, buff_size, 0);
  return io_uring_submit(&ring);
}

static inline int ufrecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = FRECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;

  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, rec->iov_len);
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int urecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = RECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int usendmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  bool zc = (conn->data_left > ZC_RES) ? true : false;
  conn->op = (zc) ? SENDMSGZC : SENDMSG;

  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  if (zc) {
    io_uring_prep_sendmsg_zc(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
    conn->zc_notifs++;
  } else {
    io_uring_prep_sendmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  }
  return io_uring_submit(&ring);
}

/*
 * Create and initialize a server socket
 */
static inline int tcp_listen(uint16_t port) {
  int enable;
  int listenfd;
  if ((listenfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    return -1;

  int flags = fcntl(listenfd, F_GETFL, 0);
  fcntl(listenfd, F_SETFL, flags | O_NONBLOCK);
  struct sockaddr_in servaddr;
  memset(&servaddr, 0, sizeof(servaddr));
  servaddr.sin_family = AF_INET;
  servaddr.sin_addr.s_addr = INADDR_ANY;
  servaddr.sin_port = htons(port);

  enable = 1;
  if (setsockopt(listenfd, SOL_SOCKET, SO_REUSEPORT, &enable, sizeof(enable)) < 0)
    return -1;

  if (bind(listenfd, (struct sockaddr *)&servaddr, sizeof(servaddr)) < 0)
    return -1;

  if (listen(listenfd, SOMAXCONN) < 0)
    return -1;

  return listenfd;
}

/*
 * Calculate the difference between two pointers
 */
static inline uintptr_t ptr_diff(uintptr_t p1, uintptr_t p2) { return (uintptr_t)(p1 > p2) ? (p1 - p2) : (p2 - p1); }

static inline size_t get_nroutes(Route *routes) {
  Route *route;
  for (size_t i = 0;; i++) {
    route = &routes[i];
    if (!route->path && !route->handler && !route->method)
      return i;
  }
}

static inline long get_content_length(char *src, char *end) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return -1;
    key = line;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, "Content-Length") != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;

    *line_end = '\0';
    long res = atol(value);
    *line_end = '\r';

    return res;
  }
  return -1;
}

static inline bool have_header(char *src, char *end, const char *header_key, const char *header_value) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    key = line;
    while (*key == ' ')
      key++;
    while (*header_key == ' ')
      header_key++;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return false;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, header_key) != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;
    while (*header_value == ' ')
      header_value++;

    *line_end = '\0';
    bool res = (strcasecmp(value, header_value) == 0);
    *line_end = '\r';

    return res;
  }

  return false;
}

static inline const char *method_str(Method method) {
  switch (method) {
  case GET:
    return "GET";
    break;
  case HEAD:
    return "HEAD";
    break;
  case POST:
    return "POST";
    break;
  case PUT:
    return "PUT";
    break;
  case DELETE:
    return "DELETE";
    break;
  case CONNECT:
    return "CONNECT";
    break;
  case OPTIONS:
    return "OPTIONS";
    break;
  case TRACE:
    return "TRACE";
    break;
  case PATCH:
    return "PATCH";
    break;
  default:
    return NULL;
  }
}

static inline uint8_t method_len(Method method) {
  switch (method) {
  case GET:
    return 3;
    break;
  case HEAD:
    return 4;
    break;
  case POST:
    return 4;
    break;
  case PUT:
    return 3;
    break;
  case DELETE:
    return 6;
    break;
  case CONNECT:
    return 7;
    break;
  case OPTIONS:
    return 7;
    break;
  case TRACE:
    return 5;
    break;
  case PATCH:
    return 5;
    break;
  default:
    return 0;
  }
}

static inline size_t round_to_blocks(size_t size) {
  size_t nblocks = BYTES_TO_BLOCKS(size);
  nblocks = CEIL_BLOCKS(nblocks);
  return nblocks;
}

/*
 * Count the digits in unsigned 64-bit int
 */
static inline int countd(uint64_t num) {
  if (num < 10ULL)
    return 1;
  if (num < 100ULL)
    return 2;
  if (num < 1000ULL)
    return 3;
  if (num < 10000ULL)
    return 4;
  if (num < 100000ULL)
    return 5;
  if (num < 1000000ULL)
    return 6;
  if (num < 10000000ULL)
    return 7;
  if (num < 100000000ULL)
    return 8;
  if (num < 1000000000ULL)
    return 9;
  if (num < 10000000000ULL)
    return 10;
  if (num < 100000000000ULL)
    return 11;
  if (num < 1000000000000ULL)
    return 12;
  if (num < 10000000000000ULL)
    return 13;
  if (num < 100000000000000ULL)
    return 14;
  if (num < 1000000000000000ULL)
    return 15;
  if (num < 10000000000000000ULL)
    return 16;
  if (num < 100000000000000000ULL)
    return 17;
  if (num < 1000000000000000000ULL)
    return 18;
  if (num < 10000000000000000000ULL)
    return 19;
  return 20;
}

/*
 * Get the time elabsed in ms
 */
static inline uint64_t get_time() {
  struct timespec ts;
  clock_gettime(CLOCK_MONOTONIC, &ts);
  return (uint64_t)(ts.tv_sec) * 1000 + (ts.tv_nsec / 1000000);
}

static inline FILE *log_init(const char *path) {
  FILE *res = fopen(path, "a+");
  setvbuf(res, NULL, _IONBF, 0);
  return res;
}

static inline int16_t pollevs(int connfd) {
  struct pollfd pfd;
  pfd.fd = connfd;
  pfd.events = POLLIN | POLLOUT | POLLERR;
  int res = poll(&pfd, 1, 0);
  if (res < 0)
    return POLLERR;
  return pfd.revents;
}

// FIXME This needs to be updated
static inline conn_t *MP_use_once(size_t nblocks, int fd) {

  void *mem = malloc(sizeof(conn_t) + 8 + (IOVEC_NBLOCKS * MP_BLOCK));
  struct conn_t *conn = (conn_t *)mem;
  memset(conn, 0, sizeof(conn_t));
  conn->ios = mem + sizeof(conn_t) + 8;

  if (nblocks > 0) {
    struct iovec *iov = &conn->ios[conn->nios++];
    mem = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (mem == MAP_FAILED)
      return NULL;
    iov->iov_base = mem;
    iov->iov_len = ALIGN_TO_PAGESIZE(nblocks * MP_BLOCK);
  }

  conn->flags |= CF_IN_HEAP;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;

  return conn;
}

static inline int find_freec() {
  uint64_t *word;
  size_t map_size = (sizeof(uint64_t) * 8);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    word = &pool.freecs[i / map_size];

    if (*word == 0) { // All used
      i += (map_size - 1);
      continue;
    }

    i += __builtin_ctzll(*word);
    MARK_BIT_USED(*word, i);
    return i;
  }

  return -1;
}

static inline int MP_init(size_t npages) {
  if (!npages)
    return -1;

  /*** Setup ***/
  pool.npages = npages;
  pool.pagesize = sysconf(_SC_PAGESIZE);

  /*** Pool ***/
  pool.bpool = mmap(NULL, pool.npages * pool.pagesize, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  if (pool.bpool == MAP_FAILED)
    return -1;
  pool.nblocks = (pool.npages * pool.pagesize) / MP_BLOCK;

  /*** Blocks ***/
  pool.blocks = malloc(sizeof(void *) * pool.nblocks);
  if (!pool.blocks)
    return -1;
  for (size_t i = 0; i < pool.nblocks; i++)
    pool.blocks[i] = pool.bpool + (i * MP_BLOCK);

  /*** Freebs ***/
  // if (posix_memalign((void **)&pool.freebs, 64, bitmap_size * sizeof(uint64_t)) < 0)
  size_t bitmap_size = (pool.nblocks + 63) / 64;
  pool.freebs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freebs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freebs[i] = UINT64_MAX;

  /*** Cpool ***/
  pool.cpool = (conn_t *)malloc(sizeof(conn_t) * MAX_CONNS);
  if (!pool.cpool)
    return -1;

  /*** Conns ***/
  pool.conns = (conn_t **)malloc(sizeof(conn_t *) * MAX_CONNS);
  if (!pool.conns)
    return -1;
  size_t conn_size = sizeof(conn_t);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    pool.conns[i] = (conn_t *)((char *)pool.cpool + (i * conn_size));
    pool.conns[i]->fd = -1;
    pool.conns[i]->in_fd = -1;
    pool.conns[i]->out_fd = -1;
  }

  /*** Freecs ***/
  bitmap_size = (MAX_CONNS + 63) / 64;
  pool.freecs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freecs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freecs[i] = UINT64_MAX;

  return 0;
}

static inline int MP_use_blks(size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t max_start = pool.nblocks - nblocks;
  size_t full_chunks = (nblocks / 64) * 64;

  for (size_t i = 0, c = 0; i <= max_start; i++, c++) {
    bool free = true;

    for (size_t j = 0; j < full_chunks; j += 64) {
      size_t word_index = (i + j) / 64;
      if (pool.freebs[word_index] != UINT64_MAX) {
        free = false;
        i += 63;
        break;
      }
    }

    for (size_t j = full_chunks; j < nblocks; j++) {
      size_t bit_index = i + j;
      size_t word_index = bit_index / 64;
      size_t bit_in_word = bit_index % 64;

      if (!BIT_IS_FREE(pool.freebs[word_index], bit_in_word)) {
        free = false;
        i += j;
        break;
      }
    }

    if (free) {
      for (size_t j = 0; j < full_chunks; j += 64) {
        size_t word_index = (i + j) / 64;
        pool.freebs[word_index] = 0;
      }

      for (size_t j = full_chunks; j < nblocks; j++) {
        size_t bit_index = i + j;
        size_t word_index = bit_index / 64;
        size_t bit_in_word = bit_index % 64;

        MARK_BIT_USED(pool.freebs[word_index], bit_in_word);
      }

      return i;
    }
  }

  return -1;
}

static inline int MP_free_blks(size_t bindex, size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t full_chunks = (nblocks / 64) * 64;
  for (size_t i = 0; i < full_chunks; i += 64) {
    size_t word_index = (bindex + i) / 64;
    pool.freebs[word_index] = UINT64_MAX;
  }

  for (size_t i = full_chunks; i < nblocks; i++) {
    size_t bit_index = bindex + i;
    size_t word_index = bit_index / 64;
    size_t bit_in_word = bit_index % 64;

    MARK_BIT_FREE(pool.freebs[word_index], bit_in_word);
  }

  memset(pool.blocks[bindex], 0, nblocks * MP_BLOCK);
  return 0;
}

static inline conn_t *MP_use(size_t nblocks, int fd, bool once) {
  if (fd <= 0)
    return NULL;
  if (once)
    return MP_use_once(nblocks, fd);

  int cindex = find_freec();
  if (cindex < 0) {
    LOG("Err: cindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  conn_t *conn = pool.conns[cindex];

  int ios_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (ios_bindex < 0) {
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }

  struct iovec *ios = pool.blocks[ios_bindex];
  conn->ios = ios;

  int rec_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (rec_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct iovec *rec = pool.blocks[rec_bindex];
  conn->rec = rec;

  int msg_bindex = MP_use_blks(MSG_NBLOCKS);
  if (msg_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct msghdr *msg = pool.blocks[msg_bindex];
  conn->msg = msg;

  if (nblocks > 0) {
    int bindex = MP_use_blks(nblocks);
    if (bindex < 0) {
      MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
      MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
      MP_free_blks(msg_bindex, IOVEC_NBLOCKS);
      MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
      LOG("Err: bindex < 0; will use MP_use_once\n");
      return MP_use_once(nblocks, fd);
    }

    size_t iov_index = conn->nios++;
    struct iovec *iov = &conn->ios[iov_index];
    struct iovec *rec = &conn->rec[iov_index];
    iov->iov_base = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
  }

  conn->msg->msg_iov = conn->ios;
  conn->msg->msg_iovlen = conn->nios;
  conn->cindex = cindex;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;
  return conn;
}

static inline void MP_shed(conn_t *conn, size_t iov_index, size_t nios) {
  struct iovec *iov, *rec;
  size_t bindex, nblocks, index;

  for (size_t i = 0; i < nios; i++) {
    index = iov_index + i;
    iov = &conn->ios[index];
    rec = &conn->rec[index];
    if (!rec || !rec->iov_base)
      continue;
    if (!IN_POOL(rec->iov_base)) {
      munmap(rec->iov_base, rec->iov_len / pool.pagesize);
    } else {
      bindex = ptr_diff((uintptr_t)rec->iov_base, (uintptr_t)pool.bpool) / MP_BLOCK;
      nblocks = rec->iov_len / MP_BLOCK;
      MP_free_blks(bindex, nblocks);
    }
    memset(iov, 0, sizeof(struct iovec));
    memset(rec, 0, sizeof(struct iovec));
    conn->nios--;
  }
}

static inline int MP_expand(conn_t *conn, size_t nblocks, bool once) {
  void *bptr;
  int iov_index, bindex;
  struct iovec *iov, *rec;

  iov_index = conn->nios++;
  iov = &conn->ios[iov_index];
  rec = &conn->rec[iov_index];

  if (nblocks == 0)
    return iov_index;

  if (once) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_base = bptr;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
    return iov_index;
  }

  bindex = MP_use_blks(nblocks);
  if (bindex < 0) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_len = iov->iov_len;
  } else {
    bptr = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_len = iov->iov_len;
  }

  iov->iov_base = bptr;
  rec->iov_base = iov->iov_base;
  return iov_index;
}

static inline int MP_free(conn_t *conn) {
  if (!conn)
    return -1;
  size_t bindex, nblocks;
  uint64_t *word;

  MP_shed(conn, 0, conn->nios);
  if (conn->flags & CF_IN_HEAP) {
    if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
      close(conn->fd);
    free(conn);
    return 0;
  }

  word = &pool.freecs[conn->cindex / 64];
  if (conn->cindex > MAX_CONNS)
    return -1;
  else if (BIT_IS_FREE(*word, conn->cindex))
    return 0;

  bindex = ptr_diff((uintptr_t)conn->ios, (uintptr_t)pool.bpool) / MP_BLOCK;
  nblocks = IOVEC_NBLOCKS;
  MP_free_blks(bindex, nblocks);

  bindex = ptr_diff((uintptr_t)conn->rec, (uintptr_t)pool.bpool) / MP_BLOCK;
  MP_free_blks(bindex, nblocks);

  if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
    close(conn->fd);

  MARK_BIT_FREE(*word, conn->cindex);
  memset(conn, 0, sizeof(conn_t));
  conn->fd = -1;
  conn->in_fd = -1;
  conn->out_fd = -1;
  return 0;
}

static inline void MP_clear(conn_t *conn) {
  conn_t *recv_conn = conn->recv_conn;
  conn_t *send_conn = conn->send_conn;
  if (recv_conn)
    MP_free(recv_conn);
  if (send_conn)
    MP_free(send_conn);
}

static inline void MP_exit(MPool *pool) {
  munmap(pool->bpool, pool->npages);
  free(pool->cpool);
  free(pool->blocks);
  free(pool->conns);
  free(pool->freebs);
  free(pool->freecs);
}

static inline void MP_timeout() {
  conn_t *conn;
  int16_t res;
  uint64_t now;
  size_t windex = 0;
  uint64_t *word = &pool.freecs[0];
  for (size_t i = 0; i < MAX_CONNS; i++) {
    if ((i / 64) < windex)
      word = &pool.freecs[++windex];

    if (*word == UINTMAX_MAX) {
      i = (i / 64) * 64 + 64;
      continue;
    }

    conn = pool.conns[i];
    if (!conn || conn->fd == -1)
      continue;

    res = pollevs(conn->fd);

    now = get_time();
    if (res & POLLERR) {
      MP_clear(conn);
      continue;
    }
    if (res & POLLIN) {
      if (pool.rtimeout > 0 && (now - conn->last_read) >= pool.rtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (res & POLLOUT) {
      if (pool.wtimeout > 0 && (now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (!(res & POLLIN || res & POLLOUT)) {
      if ((pool.rtimeout > 0 && now - conn->last_read) >= pool.rtimeout
          || (pool.wtimeout > 0 && now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
  }
}

/*
 * Calculate the length of a status string
 */
static inline size_t status_len(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return 8;
  case STATUSSWITCHINGPROTOCOLS:
    return 19;
  case STATUSPROCESSING:
    return 10;
  case STATUSEARLYHINTS:
    return 11;
  case STATUSOK:
    return 2;
  case STATUSCREATED:
    return 7;
  case STATUSACCEPTED:
    return 8;
  case STATUSNONAUTHORITATIVE:
    return 29;
  case STATUSNOCONTENT:
    return 10;
  case STATUSRESETCONTENT:
    return 13;
  case STATUSPARTIALCONTENT:
    return 15;
  case STATUSMULTISTATUS:
    return 12;
  case STATUSALREADYREPORTED:
    return 16;
  case STATUSIMUSED:
    return 7;
  case STATUSMULTIPLECHOICES:
    return 16;
  case STATUSMOVEDPERMANENTLY:
    return 17;
  case STATUSFOUND:
    return 5;
  case STATUSSEEOTHER:
    return 9;
  case STATUSNOTMODIFIED:
    return 12;
  case STATUSUSEPROXY:
    return 9;
  case STATUSTEMPORARYREDIRECT:
    return 18;
  case STATUSPERMANENTREDIRECT:
    return 18;
  case STATUSBADREQUEST:
    return 11;
  case STATUSUNAUTHORIZED:
    return 12;
  case STATUSPAYMENTREQUIRED:
    return 16;
  case STATUSFORBIDDEN:
    return 9;
  case STATUSNOTFOUND:
    return 9;
  case STATUSMETHODNOTALLOWED:
    return 18;
  case STATUSNOTACCEPTABLE:
    return 14;
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return 29;
  case STATUSREQUESTTIMEOUT:
    return 15;
  case STATUSCONFLICT:
    return 8;
  case STATUSGONE:
    return 4;
  case STATUSLENGTHREQUIRED:
    return 15;
  case STATUSPRECONDITIONFAILED:
    return 19;
  case CONTENTTOOLARGE:
    return 17;
  case STATUSURITOOLONG:
    return 12;
  case STATUSUNSUPPORTEDMEDIATYPE:
    return 22;
  case STATUSRANGENOTSATISFIABLE:
    return 21;
  case STATUSEXPECTATIONFAILED:
    return 18;
  case STATUSMISDIRECTEDREQUEST:
    return 19;
  case STATUSUNPROCESSABLECONTENT:
    return 21;
  case STATUSLOCKED:
    return 6;
  case STATUSFAILEDDEPENDENCY:
    return 17;
  case STATUSTOOEARLY:
    return 9;
  case STATUSUPGRADEREQUIRED:
    return 16;
  case STATUSPRECONDITIONREQUIRED:
    return 21;
  case STATUSTOOMANYREQUESTS:
    return 17;
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return 31;
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return 29;
  case STATUSInternalServerError:
    return 21;
  case STATUSNOTIMPLEMENTED:
    return 15;
  case STATUSBADGATEWAY:
    return 11;
  case STATUSSERVICEUNAVAILABLE:
    return 19;
  case STATUSGATEWAYTIMEOUT:
    return 15;
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return 26;
  case STATUSVARIANTALSONEGOTIATES:
    return 23;
  case STATUSINSUFFICIENTSTORAGE:
    return 20;
  case STATUSLOOPDETECTED:
    return 13;
  case STATUSNOTEXTENDED:
    return 12;
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return 31;
  default:
    return 0;
  }
}

/*
 * Return the status code string as string literal
 */
static inline char *status_str(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return "Continue";
  case STATUSSWITCHINGPROTOCOLS:
    return "Switching Protocols";
  case STATUSPROCESSING:
    return "Processing";
  case STATUSEARLYHINTS:
    return "Early Hints";
  case STATUSOK:
    return "OK";
  case STATUSCREATED:
    return "Created";
  case STATUSACCEPTED:
    return "Accepted";
  case STATUSNONAUTHORITATIVE:
    return "Non-Authoritative Information";
  case STATUSNOCONTENT:
    return "No Content";
  case STATUSRESETCONTENT:
    return "Reset Content";
  case STATUSPARTIALCONTENT:
    return "Partial Content";
  case STATUSMULTISTATUS:
    return "Multi-Status";
  case STATUSALREADYREPORTED:
    return "Already Reported";
  case STATUSIMUSED:
    return "Im Used";
  case STATUSMULTIPLECHOICES:
    return "Multiple Choices";
  case STATUSMOVEDPERMANENTLY:
    return "Moved Permanently";
  case STATUSFOUND:
    return "Found";
  case STATUSSEEOTHER:
    return "See Other";
  case STATUSNOTMODIFIED:
    return "Not Modified";
  case STATUSUSEPROXY:
    return "Use Proxy";
  case STATUSTEMPORARYREDIRECT:
    return "Temporary Redirect";
  case STATUSPERMANENTREDIRECT:
    return "Permanent Redirect";
  case STATUSBADREQUEST:
    return "Bad Request";
  case STATUSUNAUTHORIZED:
    return "Unauthorized";
  case STATUSPAYMENTREQUIRED:
    return "Payment Required";
  case STATUSFORBIDDEN:
    return "Forbidden";
  case STATUSNOTFOUND:
    return "Not Found";
  case STATUSMETHODNOTALLOWED:
    return "Method Not Allowed";
  case STATUSNOTACCEPTABLE:
    return "Not Acceptable";
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return "Proxy Authentication Required";
  case STATUSREQUESTTIMEOUT:
    return "Request Timeout";
  case STATUSCONFLICT:
    return "Conflict";
  case STATUSGONE:
    return "Gone";
  case STATUSLENGTHREQUIRED:
    return "Length Required";
  case STATUSPRECONDITIONFAILED:
    return "Precondition Failed";
  case CONTENTTOOLARGE:
    return "Content Too Large";
  case STATUSURITOOLONG:
    return "URI Too Long";
  case STATUSUNSUPPORTEDMEDIATYPE:
    return "Unsupported Media Type";
  case STATUSRANGENOTSATISFIABLE:
    return "Range Not Satisfiable";
  case STATUSEXPECTATIONFAILED:
    return "Expectation Failed";
  case STATUSMISDIRECTEDREQUEST:
    return "Misdirected Request";
  case STATUSUNPROCESSABLECONTENT:
    return "Unprocessable Content";
  case STATUSLOCKED:
    return "Locked";
  case STATUSFAILEDDEPENDENCY:
    return "Failed Dependency";
  case STATUSTOOEARLY:
    return "Too Early";
  case STATUSUPGRADEREQUIRED:
    return "Upgrade Required";
  case STATUSPRECONDITIONREQUIRED:
    return "Precondition Required";
  case STATUSTOOMANYREQUESTS:
    return "Too Many Requests";
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return "Request Header Fields Too Large";
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return "Unavailable For Legal Reasons";
  case STATUSInternalServerError:
    return "Internal Server Error";
  case STATUSNOTIMPLEMENTED:
    return "Not Implemented";
  case STATUSBADGATEWAY:
    return "Bad Gateway";
  case STATUSSERVICEUNAVAILABLE:
    return "Service Unavailable";
  case STATUSGATEWAYTIMEOUT:
    return "Gateway Timeout";
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return "HTTP Version Not Supported";
  case STATUSVARIANTALSONEGOTIATES:
    return "Variant Also Negotiates";
  case STATUSINSUFFICIENTSTORAGE:
    return "Insufficient Storage";
  case STATUSLOOPDETECTED:
    return "Loop Detected";
  case STATUSNOTEXTENDED:
    return "Not Extended";
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return "Network Authentication Required";
  default:
    return 0;
  }
}

/*
 * Return true if routes match
 */
static inline bool route_equ(Route *route, Request *req) {
  return route->method == req->method && strncmp(route->path, req->path, strlen(route->path)) == 0;
}

/*
 * Return the matching route index on success. -1 on failure
 */
static inline int match_route(Server *serv, Request *req) {
  for (size_t i = 0; i < serv->_nroutes; i++) {
    Route route = serv->routes[i];
    if (!req->path || !route.path)
      continue;
    if (route_equ(&route, req))
      return i;
    else if (req->method == HEAD && route.method == GET && strcmp(route.path, req->path) == 0)
      return i;
  }
  return -1;
}

/*
 * Return true if the response should contain the Content-Length header
 */
static inline bool should_have_content_length(Request *req, ResWriter *res) {
  return (req->method != CONNECT              // CONNECT request
          && res->status != STATUSNOCONTENT   // 204 response
          && res->status != STATUSNOTMODIFIED // 304 response
          && res->status >= 200);             // 1xx response
}

/*
 * Format http response from the ResWriter.
 * Return response size on success, 0 on failure.
 */
static inline size_t fmt_res(Request *req, ResWriter *res, char *buffer, size_t buffer_size) {
  if (!res || !buffer || buffer_size == 0)
    return 0;

  size_t res_len, total = 0;
  char *dst = buffer;
  size_t maxlen = buffer_size;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t body_length = res->len;

  res_len = snprintf(dst, maxlen, "HTTP/1.1 %d %s", (int)res->status, status_str(res->status));
  total += res_len;
  dst += res_len;
  maxlen -= res_len;

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    res_len = snprintf(dst, maxlen, "\r\n%s: %s", header->key, header->value);
    total += res_len;
    dst += res_len;
    maxlen -= res_len;
  }

  if (have_content_length) {
    res_len = snprintf(dst, maxlen, "\r\nContent-Length: %lu", body_length);
    total += res_len, dst += res_len, maxlen -= res_len;
  }

  memcpy(dst, "\r\n\r\n", 4);
  total += 4, dst += 4, maxlen -= 4;

  return total;
}

static inline size_t res_len(Request *req, ResWriter *res) {
  if (!req || !res)
    return 0;

  if (!res->status)
    res->status = STATUSOK;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t result = 0;
  result += STRLEN("HTTP/1.1 ");     // HTTP version
  result += 4;                       // Status code + space
  result += status_len(res->status); // Status name

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    result += 2;                       // "\r\n"
    result += strlen(header->key) + 2; // Header key + ':' + space
    result += strlen(header->value);   // header value
  }

  if (have_content_length) {
    result += 2;                          // "\r\n"
    result += STRLEN("Content-Length: "); // Header key
    result += countd(res->len);           // Header value
  }

  result += 4; // "\r\n\r\n"

  return result;
}

static inline int send_empty_res(Status status) {
  size_t res_len = STRLEN("HTTP/1.1 ")        // HTTP version
                   + countd((uint64_t)status) // status code
                   + 1                        // space
                   + (int)status_len(status)  // status string
                   + 4;                       // \r\n\r\n

  conn_t *conn = current_send;
  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, res_len);
  if (snprintf((char *)rec->iov_base, res_len + 1, "HTTP/1.1 %d %s\r\n\r\n", (int)status, status_str(status))
      != (int)res_len)
    return -1;

  return usendmsg(conn, 0, 1);
}

static inline ssize_t read_socket(int sockfd, size_t len) {
  if (len == 0 || sockfd <= 0)
    return 0;
  char buff[1024 * 8];
  return read(sockfd, buff, 1024 * 8);
}

static inline int read_method(Method *method, void *src) {
  if (memcmp(src, "GET", 3) == 0)
    *method = GET;
  else if (memcmp(src, "POST", 4) == 0)
    *method = POST;
  else if (memcmp(src, "HEAD", 4) == 0)
    *method = HEAD;
  else if (memcmp(src, "PUT", 3) == 0)
    *method = PUT;
  else if (memcmp(src, "DELETE", 6) == 0)
    *method = DELETE;
  else if (memcmp(src, "CONNECT", 7) == 0)
    *method = CONNECT;
  else if (memcmp(src, "OPTIONS", 7) == 0)
    *method = OPTIONS;
  else if (memcmp(src, "TRACE", 5) == 0)
    *method = TRACE;
  else if (memcmp(src, "PATCH", 5) == 0)
    *method = PATCH;
  else
    return -1;

  return 0;
}

static inline int sendmsg_res(Request *req, ResWriter *res) {
  conn_t *conn;
  size_t head_size, res_size;
  struct iovec *iov;

  conn = current_send;
  iov = &conn->ios[0];
  head_size = res_len(req, res);
  if (head_size == 0)
    return -1;

  conn->data_left += head_size;
  res_size = fmt_res(req, res, iov->iov_base, (head_size + 1));
  if (res_size != head_size)
    return -1;
  iov->iov_len = res_size;

  return usendmsg(conn, 0, conn->nios);
}

static inline int read_req(Request *req, char *req_buffer) {
  if (!req_buffer)
    return -1;
  /*** Method ***/
  char *sep = strchr(req_buffer, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }
  *sep = '\0';
  if (read_method(&req->method, req_buffer) < 0)
    return -1;

  /*** Path ***/
  char *fullpath = sep + 1;
  sep = strchr(fullpath, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }

  *sep = '\0';
  req->path = fullpath;
  /*** Params ***/
  char *paramStart = strchr(fullpath, '?');
  if (paramStart) {
    *paramStart++ = '\0';
    int params_count = 0;
    params_count = HK_parse_params(paramStart, req->params, MAX_URL_PARAMETERS);
    if (params_count > 0)
      req->params_count = params_count;
    else
      req->params_count = 0;
  } else {
    req->params = NULL;
    req->params_count = 0;
  }

  /*** Headers ***/
  char *headStart = strstr(sep + 1, "\r\n");
  char *headEnd = strstr(sep + 1, "\r\n\r\n");
  if (!headStart) {
    LOG("read_req: !headStart\n");
    return -1;
  };

  memset(headStart, 0, 2);
  headStart += 2;
  memset(headEnd, 0, 4);
  headEnd += 4;

  int headers_count = HK_parse_headers(headStart, req->headers, MAX_REQ_HEADERS);
  if (headers_count <= 0)
    return -1;
  req->headers_count = headers_count;

  /*** Host ***/
  int index = HK_get_header(req, "Host");
  if (index < 0)
    return -1;
  char *host = req->headers[index].value;
  req->hostname = host;

  /*** Port ***/
  char *colon = strchr(host, ':');
  if (colon) {
    *colon++ = '\0';
    req->port = atoi(colon);
  } else {
    req->port = PORT;
  }
  return 0;
}
static inline int process_req(Server *serv, conn_t *conn) {
  if (!conn || conn->fd == -1)
    return -1;

  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;
  if (read_req(&req, conn->ios[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    LOG("Err: route_index == -1\n");
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;
  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  sendmsg_res(&req, &res);

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int new_conn(int connfd) {
  if (connfd <= 0)
    return -1;

  current_recv = MP_use(KB * 2, connfd, false);
  current_send = MP_use(KB * 2, connfd, false);

  current_recv->recv_conn = current_recv;
  current_recv->send_conn = current_send;

  current_send->send_conn = current_send;
  current_send->recv_conn = current_recv;

  conn_t *conn = current_recv;
  if (ufrecvmsg(conn, 0, 1) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

static inline int resubmit_sendmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return usendmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int resubmir_recvmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    // FIXME the len should be increased
    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return urecvmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int handle_sendmsg_complete(conn_t *conn) {
  struct iovec *iov, *rec;

  MP_shed(conn, 1, conn->nios - 1);
  iov = &conn->ios[0];
  rec = &conn->rec[0];
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;

  return ufrecvmsg(conn->recv_conn, 0, 1);
}

static inline int handle_sendmsg(conn_t *conn, int res, bool zc) {
  if (!conn || conn->fd == -1)
    return -1;

  conn->data_left -= res;
  if (conn->data_left > 0)
    return resubmit_sendmsg(conn, res);

  if (zc)
    return 0;

  return handle_sendmsg_complete(conn);
}

static inline int handle_insplice(conn_t *conn) {
  conn->op = OUTSPLICE;
  return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
}
static inline int handle_outsplice(conn_t *conn, int res) {
  conn->data_left -= res;
  if (conn->data_left > 0) {
    conn->op = INSPLICE;
    return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
  }

  conn_t *recv_conn = conn->recv_conn;
  struct iovec *iov = &recv_conn->ios[0];
  memset(iov->iov_base, 0, iov->iov_len);
  if (urecv(recv_conn, iov->iov_base, iov->iov_len, MSG_PEEK) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

/*
static inline int handle_recv(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  void *bptr = conn->ios[0].iov_base;
  void *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  void *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  return process_req(serv, conn);
}
*/
static inline int find_route(Server *serv, char *bptr) {
  Request req = {0};
  if (read_method(&req.method, bptr) < 0) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  };
  char *space = strchr(bptr, ' ');
  req.path = (space + 1);
  space = strchr(req.path, ' ');
  *space = '\0';
  int route_index = match_route(serv, &req);
  *space = ' ';
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }
  return route_index;
}

static inline int run_handler(Server *serv, conn_t *conn, bool uses_body) {
  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;

  if (read_req(&req, conn->rec[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  if (uses_body) {
    int h_index = HK_get_header(&req, "Content-Length");
    long body_size = atol(req.headers[h_index].value);
    if (body_size >= 0) {
      req.body.ptr = conn->rec[1].iov_base;
      req.body.size = body_size;
    } else {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    }
  }

  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  sendmsg_res(&req, &res);

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int handle_frecvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  char *bptr = (char *)conn->ios[0].iov_base;
  char *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  char *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  size_t head_size = (headEnd + 4) - bptr;
  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  int route_index = find_route(serv, bptr);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  bool uses_body = serv->routes[route_index].uses_body;
  long body_size = get_content_length(headstart + 2, headEnd + 4);
  if (body_size == -1) {
    if (uses_body) {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    } else {
      body_size = 0;
    }
  }

  conn->head_size = head_size;
  if (!uses_body) {
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  if (res == (int)(head_size + body_size)) {
    size_t iov_index = MP_expand(conn, round_to_blocks(body_size), false);
    memcpy(conn->rec[iov_index].iov_base, headEnd + 4, body_size);
    conn->ios[iov_index].iov_len = body_size;
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  conn->data_left = body_size - (res - head_size);
  bool once = ((size_t)body_size > (size_t)((pool.nblocks * MP_BLOCK) / 10));
  size_t iov_index = MP_expand(conn, round_to_blocks(body_size), once);
  memcpy(conn->rec[iov_index].iov_base, headEnd + 4, (res - head_size));
  conn->ios[iov_index].iov_base += (res - head_size);

  return urecvmsg(conn, iov_index, 1);
}

static inline int handle_recvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  if (conn->data_left > 0) {
    conn->data_left -= res;
    if (conn->data_left == 0) {
      conn->flags &= CF_HANDLER_READY;
      return run_handler(serv, conn, true);
    }

    conn->flags &= ~CF_HANDLER_READY;
    conn->ios[1].iov_base += res;
    return urecvmsg(conn, 1, 1);
  }

  conn->flags &= CF_HANDLER_READY;
  return run_handler(serv, conn, true);
}

static inline int serv_init(Server *serv) {
#if DEBUG
  logfd = log_init("log.txt");
  if (!logfd) {
    printf("log_init failed");
    return -1;
  }
#endif
  serv->_nroutes = get_nroutes(serv->routes);

  int pipefd[2];
  if (pipe(pipefd) < 0)
    return -1;
  pipe_in = pipefd[0];
  pipe_out = pipefd[1];
  nullfd = open("/dev/null", O_WRONLY);
  pipe_sz = fcntl(pipefd[0], F_GETPIPE_SZ);
  if (pipe_sz < 0)
    return -1;

  pool.rtimeout = serv->rtimeout;
  pool.wtimeout = serv->wtimeout;
  if (MP_init(MAX_CONNS * 8) < 0)
    return -1;
  LOG("pool initialized\n");

  if (io_uring_queue_init(MAX_CONNS, &ring, 0) < 0)
    return -1;
  LOG("uring initialized\n");

  int listenfd;
  if ((listenfd = tcp_listen(serv->port)) < 0)
    return -1;
  LOG("socket initialized\n");

  return umaccept(listenfd);
}

static inline int serv_listen(Server *serv) {
  // uint64_t last_check = get_time();
  while (true) {
    // uint64_t now = get_time();
    // if ((now - last_check) >= 200) {
    //   last_check = now;
    //   LOG("CM: CM_check ran\n");
    //   MP_timeout();
    // }

    LOG("SQ ready: %u, CQ ready: %u\n", io_uring_sq_ready(&ring), io_uring_cq_ready(&ring));
    struct io_uring_cqe *cqe;
    if (io_uring_wait_cqe(&ring, &cqe) < 0)
      continue;

    int res = cqe->res;
    LOG("res = %d\n", res);
    conn_t *conn = NULL;
    if (cqe->user_data > 100) {
      conn = (conn_t *)cqe->user_data;
      current_recv = (conn_t *)conn->recv_conn;
      current_send = (conn_t *)conn->send_conn;
    }

    if (res > 0) {
      if (cqe->user_data == ACCEPT) {
        LOG("new conn created\n");
        new_conn(res);
      } else if (conn && conn->fd != -1) {
        LOG("conn[%d]: conn.fd = %d; conn.op = %d\n", conn->cindex, conn->fd, conn->op);
        switch (conn->op) {
        case FRECVMSG:
          if (handle_frecvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case RECVMSG:
          if (handle_recvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case SENDMSG:
        case SENDMSGZC:
          // conn->last_write = get_time();
          bool zc = (conn->op == SENDMSGZC);
          if (handle_sendmsg(conn, res, zc) < 0)
            MP_clear(conn);
          break;
        case INSPLICE:
          if (handle_insplice(conn) < 0)
            MP_clear(conn);
          break;
        case OUTSPLICE:
          if (handle_outsplice(conn, res) < 0)
            MP_clear(conn);
          break;
        }
      }
    } else if (res == 0) {
      if (conn && conn->fd != -1) {
        switch (conn->op) {
        case SENDMSGZC:
          conn->zc_notifs--;
          if (conn->zc_notifs == 0 && handle_sendmsg_complete(conn) < 0)
            MP_clear(conn);
          break;
        case RECV:
          MP_clear(conn);
          break;
        }
      }
    } else {
      if (conn && conn->fd != -1) {
        if (res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR) {
          LOG("conn && conn->fd != -1 && res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR\n");
          MP_clear(conn);
        } else {
          LOG("res == -EAGAIN || res == -EWOULDBLOCK || res == -EINTR\n");
          conn = conn->recv_conn;
          struct iovec *iov = &conn->ios[0];
          memset(iov->iov_base, 0, iov->iov_len);
          if (urecv(conn, iov->iov_base, iov->iov_len, 0) < 0)
            MP_clear(conn);
        }
      }
    }

    LOG("uring operation seen\n");
    io_uring_cqe_seen(&ring, cqe);
  }

  io_uring_queue_exit(&ring);
  MP_exit(&pool);
  return 0;
}

/*** Helper ***/
static inline int _HK_write(void *data, size_t size) {
  size_t nblocks;
  int iov_index;
  conn_t *conn;
  struct iovec *iov;
  bool once;

  conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  nblocks = round_to_blocks(size);
  iov_index = MP_expand(conn, nblocks, once);
  iov = &conn->ios[iov_index];

  memcpy(iov->iov_base, data, size);
  iov->iov_len = size;
  conn->data_left += size;

  return 0;
}
static inline int _HK_write_body(Request *req, size_t offset, size_t size) {
  if (size > req->body.size || offset > req->body.size)
    return -1;

  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  int iov_index = MP_expand(conn, 0, false);
  struct iovec *iov = &conn->ios[iov_index];
  struct iovec *rec = &conn->rec[iov_index];
  rec->iov_base = req->body.ptr + offset;
  rec->iov_len = size;
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;
  conn->data_left += rec->iov_len;
  return 0;
}
/*
static inline int _HK_mem(size_t size, HKMem *mem) {
  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  bool once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  size_t nblocks = round_to_blocks(size);
  int iov_index = MP_expand(conn, nblocks, once);
  struct iovec *iov = &conn->ios[iov_index];
  mem->ptr = iov->iov_base;
  mem->size = iov->iov_len;
  mem->_iov_index = iov_index;
  mem->_flags = (IN_POOL(iov->iov_base)) ? CF_IN_POOL : CF_IN_HEAP;
  return 0;
}

static inline void _HK_send(HKMem *mem, size_t size) {
  conn_t *conn = current_send;
  struct iovec *iov = &conn->ios[mem->_iov_index];
  iov->iov_len = size;
  conn->data_left += size;
}
  */
#endif
#define _GNU_SOURCE
#ifndef UTILS_H
#define UTILS_H

#include "hunk.h"
#include <arpa/inet.h>
#include <fcntl.h>
#include <liburing.h>
#include <netdb.h>
#include <signal.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/poll.h>
#include <sys/prctl.h>
#include <sys/socket.h>
#include <sys/sysinfo.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

#define MP_BLOCK  4
#define MAX_CONNS 4096
#define KB        1024
#define NIOS      32

#define IN_POOL(ptr)                 ((void *)ptr >= pool.bpool && (void *)ptr <= (pool.bpool + (pool.npages * pool.pagesize)))
#define ALIGN_TO_PAGESIZE(buff_size) (((buff_size) + (pool.pagesize - 1)) & ~(pool.pagesize - 1))
#define BYTES_TO_BLOCKS(buff_size)   (((buff_size) + (MP_BLOCK - 1)) / MP_BLOCK)
#define CEIL_BLOCKS(nblocks)         ((nblocks + 63) & ~63)
#define CEIL_PAGES(size)             (((size) + ((pool.pagesize) - 1)) & ~((pool.pagesize) - 1))

#define BIT_IS_FREE(word, bit)   (((word) >> (bit)) & 1)
#define MARK_BIT_USED(word, bit) ((word) &= ~(1ULL << (bit)))
#define MARK_BIT_FREE(word, bit) ((word) |= (1ULL << (bit)))
#define FIND_FREE_BIT(word)      ((uint64_t)(word) & -(uint64_t)(word))
#define STRLEN(s)                (sizeof(s) - 1)

#define IOVEC_NBLOCKS (BYTES_TO_BLOCKS(NIOS * sizeof(struct iovec)))
#define MSG_NBLOCKS   (BYTES_TO_BLOCKS(sizeof(struct msghdr)))
#define ZC_RES        KB *KB

#define DEBUG 0
#if DEBUG
#define LOG(...) fprintf(logfd, __VA_ARGS__)
#else
#define LOG(...) ((void)0)
#endif

typedef enum UOP {
  WRITEV = IORING_OP_WRITEV,
  SENDMSG = IORING_OP_SENDMSG,
  RECVMSG = IORING_OP_RECVMSG,
  ACCEPT = IORING_OP_ACCEPT,
  SEND = IORING_OP_SEND,
  RECV = IORING_OP_RECV,
  SENDZC = IORING_OP_SEND_ZC,
  SENDMSGZC = IORING_OP_SENDMSG_ZC,
  PEEK = 50,
  FRECVMSG,
  INSPLICE,
  OUTSPLICE
} UOP;

typedef enum CFS {
  CF_IN_POOL = (1 << 0),       // Connection is in the pool
  CF_IN_HEAP = (1 << 1),       // Connection is in the heap
  CF_SKIP_SOCK = (1 << 2),     // Don't close the socket
  CF_USE_ONCE = (1 << 3),      // Destroy after using
  CF_HANDLER_READY = (1 << 4), // Ready to call the handler
} CFS;

typedef struct conn_t {
  // Socket file descriptor
  int fd;

  // Amount of data left in the current operation
  uint64_t data_left;

  // The index of the connection struct
  uint32_t cindex;

  // The last time the connection was readable
  uint64_t last_read;

  // The last time the connection was writeable
  uint64_t last_write;

  // The operation currently being processed
  uint8_t op;

  // Connection flags
  int flags;

  // Splice fd_in
  int in_fd;

  // Splice fd_out
  int out_fd;

  void *recv_conn;
  void *send_conn;

  struct iovec *ios;
  struct iovec *rec;
  uint16_t nios;

  struct msghdr *msg;
  uint16_t zc_notifs;

  uint16_t head_size;
} conn_t;

typedef struct MPool {
  // The allocated pool of blocks
  void *bpool;

  // The allocated pool of connections
  conn_t *cpool;

  // The size of the pool in pages
  uint32_t npages;

  // The size of the pool in blocks
  uint32_t nblocks;

  // The locations of each page in the pool
  void **blocks;

  // The availability of each block
  uint64_t *freebs;

  // The locations of each conn in the pool
  conn_t **conns;

  // The availability of each conn
  uint64_t *freecs;

  // Clean up callback function
  void (*callback)(conn_t *conn);

  // The page size used
  uint32_t pagesize;

  // Socket read timeout
  uint32_t rtimeout;

  // Socket write timeout
  uint32_t wtimeout;
} MPool;

extern int pipe_sz;
extern int pipe_in, pipe_out, nullfd;
extern FILE *logfd;
extern struct io_uring ring;
extern MPool pool;
extern conn_t *current_recv;
extern conn_t *current_send;

/*
 * Prepare and submit a recv uring op
 */
static inline int urecv(conn_t *conn, void *buffer, size_t buff_size, int flags) {
  if (!conn || conn->fd == -1)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (flags == MSG_PEEK) ? PEEK : RECV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;

  io_uring_prep_recv(sqe, conn->fd, buffer, buff_size, flags);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a multi-shot accept uring op
 */
static inline int umaccept(int listenfd) {
  if (listenfd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = ACCEPT;
  io_uring_prep_multishot_accept(sqe, listenfd, NULL, NULL, SOCK_NONBLOCK);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a splice uring op
 */
static inline int usplice(conn_t *conn, int fd_in, int64_t off_in, int fd_out, int64_t off_out, size_t len) {
  if (!len || !conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = (__u64)conn;
  io_uring_prep_splice(sqe, fd_in, off_in, fd_out, off_out, len, 0);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a writev uring op
 */
static inline int uwritev(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = WRITEV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  io_uring_prep_writev(sqe, conn->fd, &conn->ios[iov_index], nios, -1);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a send uring op
 */
static inline int usend(conn_t *conn, char *res_buff, size_t buff_size, bool zc) {
  if (!conn || conn->fd <= 0 || buff_size == 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (zc) ? SENDZC : SEND;
  conn->data_left = buff_size;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  if (zc)
    io_uring_prep_send_zc(sqe, conn->fd, res_buff, buff_size, 0, 0);
  else
    io_uring_prep_send(sqe, conn->fd, res_buff, buff_size, 0);
  return io_uring_submit(&ring);
}

static inline int ufrecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = FRECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;

  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, rec->iov_len);
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int urecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = RECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int usendmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  bool zc = (conn->data_left > ZC_RES) ? true : false;
  conn->op = (zc) ? SENDMSGZC : SENDMSG;

  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  if (zc) {
    io_uring_prep_sendmsg_zc(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
    conn->zc_notifs++;
  } else {
    io_uring_prep_sendmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  }
  return io_uring_submit(&ring);
}

/*
 * Create and initialize a server socket
 */
static inline int tcp_listen(uint16_t port) {
  int enable;
  int listenfd;
  if ((listenfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    return -1;

  int flags = fcntl(listenfd, F_GETFL, 0);
  fcntl(listenfd, F_SETFL, flags | O_NONBLOCK);
  struct sockaddr_in servaddr;
  memset(&servaddr, 0, sizeof(servaddr));
  servaddr.sin_family = AF_INET;
  servaddr.sin_addr.s_addr = INADDR_ANY;
  servaddr.sin_port = htons(port);

  enable = 1;
  if (setsockopt(listenfd, SOL_SOCKET, SO_REUSEPORT, &enable, sizeof(enable)) < 0)
    return -1;

  if (bind(listenfd, (struct sockaddr *)&servaddr, sizeof(servaddr)) < 0)
    return -1;

  if (listen(listenfd, SOMAXCONN) < 0)
    return -1;

  return listenfd;
}

/*
 * Calculate the difference between two pointers
 */
static inline uintptr_t ptr_diff(uintptr_t p1, uintptr_t p2) { return (uintptr_t)(p1 > p2) ? (p1 - p2) : (p2 - p1); }

static inline size_t get_nroutes(Route *routes) {
  Route *route;
  for (size_t i = 0;; i++) {
    route = &routes[i];
    if (!route->path && !route->handler && !route->method)
      return i;
  }
}

static inline long get_content_length(char *src, char *end) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return -1;
    key = line;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, "Content-Length") != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;

    *line_end = '\0';
    long res = atol(value);
    *line_end = '\r';

    return res;
  }
  return -1;
}

static inline bool have_header(char *src, char *end, const char *header_key, const char *header_value) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    key = line;
    while (*key == ' ')
      key++;
    while (*header_key == ' ')
      header_key++;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return false;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, header_key) != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;
    while (*header_value == ' ')
      header_value++;

    *line_end = '\0';
    bool res = (strcasecmp(value, header_value) == 0);
    *line_end = '\r';

    return res;
  }

  return false;
}

static inline const char *method_str(Method method) {
  switch (method) {
  case GET:
    return "GET";
    break;
  case HEAD:
    return "HEAD";
    break;
  case POST:
    return "POST";
    break;
  case PUT:
    return "PUT";
    break;
  case DELETE:
    return "DELETE";
    break;
  case CONNECT:
    return "CONNECT";
    break;
  case OPTIONS:
    return "OPTIONS";
    break;
  case TRACE:
    return "TRACE";
    break;
  case PATCH:
    return "PATCH";
    break;
  default:
    return NULL;
  }
}

static inline uint8_t method_len(Method method) {
  switch (method) {
  case GET:
    return 3;
    break;
  case HEAD:
    return 4;
    break;
  case POST:
    return 4;
    break;
  case PUT:
    return 3;
    break;
  case DELETE:
    return 6;
    break;
  case CONNECT:
    return 7;
    break;
  case OPTIONS:
    return 7;
    break;
  case TRACE:
    return 5;
    break;
  case PATCH:
    return 5;
    break;
  default:
    return 0;
  }
}

static inline size_t round_to_blocks(size_t size) {
  size_t nblocks = BYTES_TO_BLOCKS(size);
  nblocks = CEIL_BLOCKS(nblocks);
  return nblocks;
}

/*
 * Count the digits in unsigned 64-bit int
 */
static inline int countd(uint64_t num) {
  if (num < 10ULL)
    return 1;
  if (num < 100ULL)
    return 2;
  if (num < 1000ULL)
    return 3;
  if (num < 10000ULL)
    return 4;
  if (num < 100000ULL)
    return 5;
  if (num < 1000000ULL)
    return 6;
  if (num < 10000000ULL)
    return 7;
  if (num < 100000000ULL)
    return 8;
  if (num < 1000000000ULL)
    return 9;
  if (num < 10000000000ULL)
    return 10;
  if (num < 100000000000ULL)
    return 11;
  if (num < 1000000000000ULL)
    return 12;
  if (num < 10000000000000ULL)
    return 13;
  if (num < 100000000000000ULL)
    return 14;
  if (num < 1000000000000000ULL)
    return 15;
  if (num < 10000000000000000ULL)
    return 16;
  if (num < 100000000000000000ULL)
    return 17;
  if (num < 1000000000000000000ULL)
    return 18;
  if (num < 10000000000000000000ULL)
    return 19;
  return 20;
}

/*
 * Get the time elabsed in ms
 */
static inline uint64_t get_time() {
  struct timespec ts;
  clock_gettime(CLOCK_MONOTONIC, &ts);
  return (uint64_t)(ts.tv_sec) * 1000 + (ts.tv_nsec / 1000000);
}

static inline FILE *log_init(const char *path) {
  FILE *res = fopen(path, "a+");
  setvbuf(res, NULL, _IONBF, 0);
  return res;
}

static inline int16_t pollevs(int connfd) {
  struct pollfd pfd;
  pfd.fd = connfd;
  pfd.events = POLLIN | POLLOUT | POLLERR;
  int res = poll(&pfd, 1, 0);
  if (res < 0)
    return POLLERR;
  return pfd.revents;
}

// FIXME This needs to be updated
static inline conn_t *MP_use_once(size_t nblocks, int fd) {

  void *mem = malloc(sizeof(conn_t) + 8 + (IOVEC_NBLOCKS * MP_BLOCK));
  struct conn_t *conn = (conn_t *)mem;
  memset(conn, 0, sizeof(conn_t));
  conn->ios = mem + sizeof(conn_t) + 8;

  if (nblocks > 0) {
    struct iovec *iov = &conn->ios[conn->nios++];
    mem = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (mem == MAP_FAILED)
      return NULL;
    iov->iov_base = mem;
    iov->iov_len = ALIGN_TO_PAGESIZE(nblocks * MP_BLOCK);
  }

  conn->flags |= CF_IN_HEAP;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;

  return conn;
}

static inline int find_freec() {
  uint64_t *word;
  size_t map_size = (sizeof(uint64_t) * 8);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    word = &pool.freecs[i / map_size];

    if (*word == 0) { // All used
      i += (map_size - 1);
      continue;
    }

    i += __builtin_ctzll(*word);
    MARK_BIT_USED(*word, i);
    return i;
  }

  return -1;
}

static inline int MP_init(size_t npages) {
  if (!npages)
    return -1;

  /*** Setup ***/
  pool.npages = npages;
  pool.pagesize = sysconf(_SC_PAGESIZE);

  /*** Pool ***/
  pool.bpool = mmap(NULL, pool.npages * pool.pagesize, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  if (pool.bpool == MAP_FAILED)
    return -1;
  pool.nblocks = (pool.npages * pool.pagesize) / MP_BLOCK;

  /*** Blocks ***/
  pool.blocks = malloc(sizeof(void *) * pool.nblocks);
  if (!pool.blocks)
    return -1;
  for (size_t i = 0; i < pool.nblocks; i++)
    pool.blocks[i] = pool.bpool + (i * MP_BLOCK);

  /*** Freebs ***/
  // if (posix_memalign((void **)&pool.freebs, 64, bitmap_size * sizeof(uint64_t)) < 0)
  size_t bitmap_size = (pool.nblocks + 63) / 64;
  pool.freebs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freebs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freebs[i] = UINT64_MAX;

  /*** Cpool ***/
  pool.cpool = (conn_t *)malloc(sizeof(conn_t) * MAX_CONNS);
  if (!pool.cpool)
    return -1;

  /*** Conns ***/
  pool.conns = (conn_t **)malloc(sizeof(conn_t *) * MAX_CONNS);
  if (!pool.conns)
    return -1;
  size_t conn_size = sizeof(conn_t);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    pool.conns[i] = (conn_t *)((char *)pool.cpool + (i * conn_size));
    pool.conns[i]->fd = -1;
    pool.conns[i]->in_fd = -1;
    pool.conns[i]->out_fd = -1;
  }

  /*** Freecs ***/
  bitmap_size = (MAX_CONNS + 63) / 64;
  pool.freecs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freecs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freecs[i] = UINT64_MAX;

  return 0;
}

static inline int MP_use_blks(size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t max_start = pool.nblocks - nblocks;
  size_t full_chunks = (nblocks / 64) * 64;

  for (size_t i = 0, c = 0; i <= max_start; i++, c++) {
    bool free = true;

    for (size_t j = 0; j < full_chunks; j += 64) {
      size_t word_index = (i + j) / 64;
      if (pool.freebs[word_index] != UINT64_MAX) {
        free = false;
        i += 63;
        break;
      }
    }

    for (size_t j = full_chunks; j < nblocks; j++) {
      size_t bit_index = i + j;
      size_t word_index = bit_index / 64;
      size_t bit_in_word = bit_index % 64;

      if (!BIT_IS_FREE(pool.freebs[word_index], bit_in_word)) {
        free = false;
        i += j;
        break;
      }
    }

    if (free) {
      for (size_t j = 0; j < full_chunks; j += 64) {
        size_t word_index = (i + j) / 64;
        pool.freebs[word_index] = 0;
      }

      for (size_t j = full_chunks; j < nblocks; j++) {
        size_t bit_index = i + j;
        size_t word_index = bit_index / 64;
        size_t bit_in_word = bit_index % 64;

        MARK_BIT_USED(pool.freebs[word_index], bit_in_word);
      }

      return i;
    }
  }

  return -1;
}

static inline int MP_free_blks(size_t bindex, size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t full_chunks = (nblocks / 64) * 64;
  for (size_t i = 0; i < full_chunks; i += 64) {
    size_t word_index = (bindex + i) / 64;
    pool.freebs[word_index] = UINT64_MAX;
  }

  for (size_t i = full_chunks; i < nblocks; i++) {
    size_t bit_index = bindex + i;
    size_t word_index = bit_index / 64;
    size_t bit_in_word = bit_index % 64;

    MARK_BIT_FREE(pool.freebs[word_index], bit_in_word);
  }

  memset(pool.blocks[bindex], 0, nblocks * MP_BLOCK);
  return 0;
}

static inline conn_t *MP_use(size_t nblocks, int fd, bool once) {
  if (fd <= 0)
    return NULL;
  if (once)
    return MP_use_once(nblocks, fd);

  int cindex = find_freec();
  if (cindex < 0) {
    LOG("Err: cindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  conn_t *conn = pool.conns[cindex];

  int ios_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (ios_bindex < 0) {
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }

  struct iovec *ios = pool.blocks[ios_bindex];
  conn->ios = ios;

  int rec_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (rec_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct iovec *rec = pool.blocks[rec_bindex];
  conn->rec = rec;

  int msg_bindex = MP_use_blks(MSG_NBLOCKS);
  if (msg_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct msghdr *msg = pool.blocks[msg_bindex];
  conn->msg = msg;

  if (nblocks > 0) {
    int bindex = MP_use_blks(nblocks);
    if (bindex < 0) {
      MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
      MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
      MP_free_blks(msg_bindex, IOVEC_NBLOCKS);
      MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
      LOG("Err: bindex < 0; will use MP_use_once\n");
      return MP_use_once(nblocks, fd);
    }

    size_t iov_index = conn->nios++;
    struct iovec *iov = &conn->ios[iov_index];
    struct iovec *rec = &conn->rec[iov_index];
    iov->iov_base = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
  }

  conn->msg->msg_iov = conn->ios;
  conn->msg->msg_iovlen = conn->nios;
  conn->cindex = cindex;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;
  return conn;
}

static inline void MP_shed(conn_t *conn, size_t iov_index, size_t nios) {
  struct iovec *iov, *rec;
  size_t bindex, nblocks, index;

  for (size_t i = 0; i < nios; i++) {
    index = iov_index + i;
    iov = &conn->ios[index];
    rec = &conn->rec[index];
    if (!rec || !rec->iov_base)
      continue;
    if (!IN_POOL(rec->iov_base)) {
      munmap(rec->iov_base, rec->iov_len / pool.pagesize);
    } else {
      bindex = ptr_diff((uintptr_t)rec->iov_base, (uintptr_t)pool.bpool) / MP_BLOCK;
      nblocks = rec->iov_len / MP_BLOCK;
      MP_free_blks(bindex, nblocks);
    }
    memset(iov, 0, sizeof(struct iovec));
    memset(rec, 0, sizeof(struct iovec));
    conn->nios--;
  }
}

static inline int MP_expand(conn_t *conn, size_t nblocks, bool once) {
  void *bptr;
  int iov_index, bindex;
  struct iovec *iov, *rec;

  iov_index = conn->nios++;
  iov = &conn->ios[iov_index];
  rec = &conn->rec[iov_index];

  if (nblocks == 0)
    return iov_index;

  if (once) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_base = bptr;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
    return iov_index;
  }

  bindex = MP_use_blks(nblocks);
  if (bindex < 0) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_len = iov->iov_len;
  } else {
    bptr = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_len = iov->iov_len;
  }

  iov->iov_base = bptr;
  rec->iov_base = iov->iov_base;
  return iov_index;
}

static inline int MP_free(conn_t *conn) {
  if (!conn)
    return -1;
  size_t bindex, nblocks;
  uint64_t *word;

  MP_shed(conn, 0, conn->nios);
  if (conn->flags & CF_IN_HEAP) {
    if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
      close(conn->fd);
    free(conn);
    return 0;
  }

  word = &pool.freecs[conn->cindex / 64];
  if (conn->cindex > MAX_CONNS)
    return -1;
  else if (BIT_IS_FREE(*word, conn->cindex))
    return 0;

  bindex = ptr_diff((uintptr_t)conn->ios, (uintptr_t)pool.bpool) / MP_BLOCK;
  nblocks = IOVEC_NBLOCKS;
  MP_free_blks(bindex, nblocks);

  bindex = ptr_diff((uintptr_t)conn->rec, (uintptr_t)pool.bpool) / MP_BLOCK;
  MP_free_blks(bindex, nblocks);

  if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
    close(conn->fd);

  MARK_BIT_FREE(*word, conn->cindex);
  memset(conn, 0, sizeof(conn_t));
  conn->fd = -1;
  conn->in_fd = -1;
  conn->out_fd = -1;
  return 0;
}

static inline void MP_clear(conn_t *conn) {
  conn_t *recv_conn = conn->recv_conn;
  conn_t *send_conn = conn->send_conn;
  if (recv_conn)
    MP_free(recv_conn);
  if (send_conn)
    MP_free(send_conn);
}

static inline void MP_exit(MPool *pool) {
  munmap(pool->bpool, pool->npages);
  free(pool->cpool);
  free(pool->blocks);
  free(pool->conns);
  free(pool->freebs);
  free(pool->freecs);
}

static inline void MP_timeout() {
  conn_t *conn;
  int16_t res;
  uint64_t now;
  size_t windex = 0;
  uint64_t *word = &pool.freecs[0];
  for (size_t i = 0; i < MAX_CONNS; i++) {
    if ((i / 64) < windex)
      word = &pool.freecs[++windex];

    if (*word == UINTMAX_MAX) {
      i = (i / 64) * 64 + 64;
      continue;
    }

    conn = pool.conns[i];
    if (!conn || conn->fd == -1)
      continue;

    res = pollevs(conn->fd);

    now = get_time();
    if (res & POLLERR) {
      MP_clear(conn);
      continue;
    }
    if (res & POLLIN) {
      if (pool.rtimeout > 0 && (now - conn->last_read) >= pool.rtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (res & POLLOUT) {
      if (pool.wtimeout > 0 && (now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (!(res & POLLIN || res & POLLOUT)) {
      if ((pool.rtimeout > 0 && now - conn->last_read) >= pool.rtimeout
          || (pool.wtimeout > 0 && now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
  }
}

/*
 * Calculate the length of a status string
 */
static inline size_t status_len(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return 8;
  case STATUSSWITCHINGPROTOCOLS:
    return 19;
  case STATUSPROCESSING:
    return 10;
  case STATUSEARLYHINTS:
    return 11;
  case STATUSOK:
    return 2;
  case STATUSCREATED:
    return 7;
  case STATUSACCEPTED:
    return 8;
  case STATUSNONAUTHORITATIVE:
    return 29;
  case STATUSNOCONTENT:
    return 10;
  case STATUSRESETCONTENT:
    return 13;
  case STATUSPARTIALCONTENT:
    return 15;
  case STATUSMULTISTATUS:
    return 12;
  case STATUSALREADYREPORTED:
    return 16;
  case STATUSIMUSED:
    return 7;
  case STATUSMULTIPLECHOICES:
    return 16;
  case STATUSMOVEDPERMANENTLY:
    return 17;
  case STATUSFOUND:
    return 5;
  case STATUSSEEOTHER:
    return 9;
  case STATUSNOTMODIFIED:
    return 12;
  case STATUSUSEPROXY:
    return 9;
  case STATUSTEMPORARYREDIRECT:
    return 18;
  case STATUSPERMANENTREDIRECT:
    return 18;
  case STATUSBADREQUEST:
    return 11;
  case STATUSUNAUTHORIZED:
    return 12;
  case STATUSPAYMENTREQUIRED:
    return 16;
  case STATUSFORBIDDEN:
    return 9;
  case STATUSNOTFOUND:
    return 9;
  case STATUSMETHODNOTALLOWED:
    return 18;
  case STATUSNOTACCEPTABLE:
    return 14;
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return 29;
  case STATUSREQUESTTIMEOUT:
    return 15;
  case STATUSCONFLICT:
    return 8;
  case STATUSGONE:
    return 4;
  case STATUSLENGTHREQUIRED:
    return 15;
  case STATUSPRECONDITIONFAILED:
    return 19;
  case CONTENTTOOLARGE:
    return 17;
  case STATUSURITOOLONG:
    return 12;
  case STATUSUNSUPPORTEDMEDIATYPE:
    return 22;
  case STATUSRANGENOTSATISFIABLE:
    return 21;
  case STATUSEXPECTATIONFAILED:
    return 18;
  case STATUSMISDIRECTEDREQUEST:
    return 19;
  case STATUSUNPROCESSABLECONTENT:
    return 21;
  case STATUSLOCKED:
    return 6;
  case STATUSFAILEDDEPENDENCY:
    return 17;
  case STATUSTOOEARLY:
    return 9;
  case STATUSUPGRADEREQUIRED:
    return 16;
  case STATUSPRECONDITIONREQUIRED:
    return 21;
  case STATUSTOOMANYREQUESTS:
    return 17;
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return 31;
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return 29;
  case STATUSInternalServerError:
    return 21;
  case STATUSNOTIMPLEMENTED:
    return 15;
  case STATUSBADGATEWAY:
    return 11;
  case STATUSSERVICEUNAVAILABLE:
    return 19;
  case STATUSGATEWAYTIMEOUT:
    return 15;
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return 26;
  case STATUSVARIANTALSONEGOTIATES:
    return 23;
  case STATUSINSUFFICIENTSTORAGE:
    return 20;
  case STATUSLOOPDETECTED:
    return 13;
  case STATUSNOTEXTENDED:
    return 12;
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return 31;
  default:
    return 0;
  }
}

/*
 * Return the status code string as string literal
 */
static inline char *status_str(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return "Continue";
  case STATUSSWITCHINGPROTOCOLS:
    return "Switching Protocols";
  case STATUSPROCESSING:
    return "Processing";
  case STATUSEARLYHINTS:
    return "Early Hints";
  case STATUSOK:
    return "OK";
  case STATUSCREATED:
    return "Created";
  case STATUSACCEPTED:
    return "Accepted";
  case STATUSNONAUTHORITATIVE:
    return "Non-Authoritative Information";
  case STATUSNOCONTENT:
    return "No Content";
  case STATUSRESETCONTENT:
    return "Reset Content";
  case STATUSPARTIALCONTENT:
    return "Partial Content";
  case STATUSMULTISTATUS:
    return "Multi-Status";
  case STATUSALREADYREPORTED:
    return "Already Reported";
  case STATUSIMUSED:
    return "Im Used";
  case STATUSMULTIPLECHOICES:
    return "Multiple Choices";
  case STATUSMOVEDPERMANENTLY:
    return "Moved Permanently";
  case STATUSFOUND:
    return "Found";
  case STATUSSEEOTHER:
    return "See Other";
  case STATUSNOTMODIFIED:
    return "Not Modified";
  case STATUSUSEPROXY:
    return "Use Proxy";
  case STATUSTEMPORARYREDIRECT:
    return "Temporary Redirect";
  case STATUSPERMANENTREDIRECT:
    return "Permanent Redirect";
  case STATUSBADREQUEST:
    return "Bad Request";
  case STATUSUNAUTHORIZED:
    return "Unauthorized";
  case STATUSPAYMENTREQUIRED:
    return "Payment Required";
  case STATUSFORBIDDEN:
    return "Forbidden";
  case STATUSNOTFOUND:
    return "Not Found";
  case STATUSMETHODNOTALLOWED:
    return "Method Not Allowed";
  case STATUSNOTACCEPTABLE:
    return "Not Acceptable";
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return "Proxy Authentication Required";
  case STATUSREQUESTTIMEOUT:
    return "Request Timeout";
  case STATUSCONFLICT:
    return "Conflict";
  case STATUSGONE:
    return "Gone";
  case STATUSLENGTHREQUIRED:
    return "Length Required";
  case STATUSPRECONDITIONFAILED:
    return "Precondition Failed";
  case CONTENTTOOLARGE:
    return "Content Too Large";
  case STATUSURITOOLONG:
    return "URI Too Long";
  case STATUSUNSUPPORTEDMEDIATYPE:
    return "Unsupported Media Type";
  case STATUSRANGENOTSATISFIABLE:
    return "Range Not Satisfiable";
  case STATUSEXPECTATIONFAILED:
    return "Expectation Failed";
  case STATUSMISDIRECTEDREQUEST:
    return "Misdirected Request";
  case STATUSUNPROCESSABLECONTENT:
    return "Unprocessable Content";
  case STATUSLOCKED:
    return "Locked";
  case STATUSFAILEDDEPENDENCY:
    return "Failed Dependency";
  case STATUSTOOEARLY:
    return "Too Early";
  case STATUSUPGRADEREQUIRED:
    return "Upgrade Required";
  case STATUSPRECONDITIONREQUIRED:
    return "Precondition Required";
  case STATUSTOOMANYREQUESTS:
    return "Too Many Requests";
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return "Request Header Fields Too Large";
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return "Unavailable For Legal Reasons";
  case STATUSInternalServerError:
    return "Internal Server Error";
  case STATUSNOTIMPLEMENTED:
    return "Not Implemented";
  case STATUSBADGATEWAY:
    return "Bad Gateway";
  case STATUSSERVICEUNAVAILABLE:
    return "Service Unavailable";
  case STATUSGATEWAYTIMEOUT:
    return "Gateway Timeout";
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return "HTTP Version Not Supported";
  case STATUSVARIANTALSONEGOTIATES:
    return "Variant Also Negotiates";
  case STATUSINSUFFICIENTSTORAGE:
    return "Insufficient Storage";
  case STATUSLOOPDETECTED:
    return "Loop Detected";
  case STATUSNOTEXTENDED:
    return "Not Extended";
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return "Network Authentication Required";
  default:
    return 0;
  }
}

/*
 * Return true if routes match
 */
static inline bool route_equ(Route *route, Request *req) {
  return route->method == req->method && strncmp(route->path, req->path, strlen(route->path)) == 0;
}

/*
 * Return the matching route index on success. -1 on failure
 */
static inline int match_route(Server *serv, Request *req) {
  for (size_t i = 0; i < serv->_nroutes; i++) {
    Route route = serv->routes[i];
    if (!req->path || !route.path)
      continue;
    if (route_equ(&route, req))
      return i;
    else if (req->method == HEAD && route.method == GET && strcmp(route.path, req->path) == 0)
      return i;
  }
  return -1;
}

/*
 * Return true if the response should contain the Content-Length header
 */
static inline bool should_have_content_length(Request *req, ResWriter *res) {
  return (req->method != CONNECT              // CONNECT request
          && res->status != STATUSNOCONTENT   // 204 response
          && res->status != STATUSNOTMODIFIED // 304 response
          && res->status >= 200);             // 1xx response
}

/*
 * Format http response from the ResWriter.
 * Return response size on success, 0 on failure.
 */
static inline size_t fmt_res(Request *req, ResWriter *res, char *buffer, size_t buffer_size) {
  if (!res || !buffer || buffer_size == 0)
    return 0;

  size_t res_len, total = 0;
  char *dst = buffer;
  size_t maxlen = buffer_size;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t body_length = res->len;

  res_len = snprintf(dst, maxlen, "HTTP/1.1 %d %s", (int)res->status, status_str(res->status));
  total += res_len;
  dst += res_len;
  maxlen -= res_len;

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    res_len = snprintf(dst, maxlen, "\r\n%s: %s", header->key, header->value);
    total += res_len;
    dst += res_len;
    maxlen -= res_len;
  }

  if (have_content_length) {
    res_len = snprintf(dst, maxlen, "\r\nContent-Length: %lu", body_length);
    total += res_len, dst += res_len, maxlen -= res_len;
  }

  memcpy(dst, "\r\n\r\n", 4);
  total += 4, dst += 4, maxlen -= 4;

  return total;
}

static inline size_t res_len(Request *req, ResWriter *res) {
  if (!req || !res)
    return 0;

  if (!res->status)
    res->status = STATUSOK;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t result = 0;
  result += STRLEN("HTTP/1.1 ");     // HTTP version
  result += 4;                       // Status code + space
  result += status_len(res->status); // Status name

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    result += 2;                       // "\r\n"
    result += strlen(header->key) + 2; // Header key + ':' + space
    result += strlen(header->value);   // header value
  }

  if (have_content_length) {
    result += 2;                          // "\r\n"
    result += STRLEN("Content-Length: "); // Header key
    result += countd(res->len);           // Header value
  }

  result += 4; // "\r\n\r\n"

  return result;
}

static inline int send_empty_res(Status status) {
  size_t res_len = STRLEN("HTTP/1.1 ")        // HTTP version
                   + countd((uint64_t)status) // status code
                   + 1                        // space
                   + (int)status_len(status)  // status string
                   + 4;                       // \r\n\r\n

  conn_t *conn = current_send;
  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, res_len);
  if (snprintf((char *)rec->iov_base, res_len + 1, "HTTP/1.1 %d %s\r\n\r\n", (int)status, status_str(status))
      != (int)res_len)
    return -1;

  return usendmsg(conn, 0, 1);
}

static inline ssize_t read_socket(int sockfd, size_t len) {
  if (len == 0 || sockfd <= 0)
    return 0;
  char buff[1024 * 8];
  return read(sockfd, buff, 1024 * 8);
}

static inline int read_method(Method *method, void *src) {
  if (memcmp(src, "GET", 3) == 0)
    *method = GET;
  else if (memcmp(src, "POST", 4) == 0)
    *method = POST;
  else if (memcmp(src, "HEAD", 4) == 0)
    *method = HEAD;
  else if (memcmp(src, "PUT", 3) == 0)
    *method = PUT;
  else if (memcmp(src, "DELETE", 6) == 0)
    *method = DELETE;
  else if (memcmp(src, "CONNECT", 7) == 0)
    *method = CONNECT;
  else if (memcmp(src, "OPTIONS", 7) == 0)
    *method = OPTIONS;
  else if (memcmp(src, "TRACE", 5) == 0)
    *method = TRACE;
  else if (memcmp(src, "PATCH", 5) == 0)
    *method = PATCH;
  else
    return -1;

  return 0;
}

static inline int sendmsg_res(Request *req, ResWriter *res) {
  conn_t *conn;
  size_t head_size, res_size;
  struct iovec *iov;

  conn = current_send;
  iov = &conn->ios[0];
  head_size = res_len(req, res);
  if (head_size == 0)
    return -1;

  conn->data_left += head_size;
  res_size = fmt_res(req, res, iov->iov_base, (head_size + 1));
  if (res_size != head_size)
    return -1;
  iov->iov_len = res_size;

  return usendmsg(conn, 0, conn->nios);
}

static inline int read_req(Request *req, char *req_buffer) {
  if (!req_buffer)
    return -1;
  /*** Method ***/
  char *sep = strchr(req_buffer, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }
  *sep = '\0';
  if (read_method(&req->method, req_buffer) < 0)
    return -1;

  /*** Path ***/
  char *fullpath = sep + 1;
  sep = strchr(fullpath, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }

  *sep = '\0';
  req->path = fullpath;
  /*** Params ***/
  char *paramStart = strchr(fullpath, '?');
  if (paramStart) {
    *paramStart++ = '\0';
    int params_count = 0;
    params_count = HK_parse_params(paramStart, req->params, MAX_URL_PARAMETERS);
    if (params_count > 0)
      req->params_count = params_count;
    else
      req->params_count = 0;
  } else {
    req->params = NULL;
    req->params_count = 0;
  }

  /*** Headers ***/
  char *headStart = strstr(sep + 1, "\r\n");
  char *headEnd = strstr(sep + 1, "\r\n\r\n");
  if (!headStart) {
    LOG("read_req: !headStart\n");
    return -1;
  };

  memset(headStart, 0, 2);
  headStart += 2;
  memset(headEnd, 0, 4);
  headEnd += 4;

  int headers_count = HK_parse_headers(headStart, req->headers, MAX_REQ_HEADERS);
  if (headers_count <= 0)
    return -1;
  req->headers_count = headers_count;

  /*** Host ***/
  int index = HK_get_header(req, "Host");
  if (index < 0)
    return -1;
  char *host = req->headers[index].value;
  req->hostname = host;

  /*** Port ***/
  char *colon = strchr(host, ':');
  if (colon) {
    *colon++ = '\0';
    req->port = atoi(colon);
  } else {
    req->port = PORT;
  }
  return 0;
}
static inline int process_req(Server *serv, conn_t *conn) {
  if (!conn || conn->fd == -1)
    return -1;

  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;
  if (read_req(&req, conn->ios[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    LOG("Err: route_index == -1\n");
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;
  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  sendmsg_res(&req, &res);

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int new_conn(int connfd) {
  if (connfd <= 0)
    return -1;

  current_recv = MP_use(KB * 2, connfd, false);
  current_send = MP_use(KB * 2, connfd, false);

  current_recv->recv_conn = current_recv;
  current_recv->send_conn = current_send;

  current_send->send_conn = current_send;
  current_send->recv_conn = current_recv;

  conn_t *conn = current_recv;
  if (ufrecvmsg(conn, 0, 1) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

static inline int resubmit_sendmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return usendmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int resubmir_recvmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    // FIXME the len should be increased
    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return urecvmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int handle_sendmsg_complete(conn_t *conn) {
  struct iovec *iov, *rec;

  MP_shed(conn, 1, conn->nios - 1);
  iov = &conn->ios[0];
  rec = &conn->rec[0];
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;

  return ufrecvmsg(conn->recv_conn, 0, 1);
}

static inline int handle_sendmsg(conn_t *conn, int res, bool zc) {
  if (!conn || conn->fd == -1)
    return -1;

  conn->data_left -= res;
  if (conn->data_left > 0)
    return resubmit_sendmsg(conn, res);

  if (zc)
    return 0;

  return handle_sendmsg_complete(conn);
}

static inline int handle_insplice(conn_t *conn) {
  conn->op = OUTSPLICE;
  return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
}
static inline int handle_outsplice(conn_t *conn, int res) {
  conn->data_left -= res;
  if (conn->data_left > 0) {
    conn->op = INSPLICE;
    return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
  }

  conn_t *recv_conn = conn->recv_conn;
  struct iovec *iov = &recv_conn->ios[0];
  memset(iov->iov_base, 0, iov->iov_len);
  if (urecv(recv_conn, iov->iov_base, iov->iov_len, MSG_PEEK) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

/*
static inline int handle_recv(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  void *bptr = conn->ios[0].iov_base;
  void *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  void *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  return process_req(serv, conn);
}
*/
static inline int find_route(Server *serv, char *bptr) {
  Request req = {0};
  if (read_method(&req.method, bptr) < 0) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  };
  char *space = strchr(bptr, ' ');
  req.path = (space + 1);
  space = strchr(req.path, ' ');
  *space = '\0';
  int route_index = match_route(serv, &req);
  *space = ' ';
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }
  return route_index;
}

static inline int run_handler(Server *serv, conn_t *conn, bool uses_body) {
  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;

  if (read_req(&req, conn->rec[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  if (uses_body) {
    int h_index = HK_get_header(&req, "Content-Length");
    long body_size = atol(req.headers[h_index].value);
    if (body_size >= 0) {
      req.body.ptr = conn->rec[1].iov_base;
      req.body.size = body_size;
    } else {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    }
  }

  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  if (sendmsg_res(&req, &res) < 0)
    return -1;

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int handle_frecvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  char *bptr = (char *)conn->ios[0].iov_base;
  char *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  char *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  size_t head_size = (headEnd + 4) - bptr;
  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  int route_index = find_route(serv, bptr);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  bool uses_body = serv->routes[route_index].uses_body;
  long body_size = get_content_length(headstart + 2, headEnd + 4);
  if (body_size == -1) {
    if (uses_body) {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    } else {
      body_size = 0;
    }
  }

  conn->head_size = head_size;
  if (!uses_body) {
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  if (res == (int)(head_size + body_size)) {
    size_t iov_index = MP_expand(conn, round_to_blocks(body_size), false);
    memcpy(conn->rec[iov_index].iov_base, headEnd + 4, body_size);
    conn->ios[iov_index].iov_len = body_size;
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  conn->data_left = body_size - (res - head_size);
  bool once = ((size_t)body_size > (size_t)((pool.nblocks * MP_BLOCK) / 10));
  size_t iov_index = MP_expand(conn, round_to_blocks(body_size), once);
  memcpy(conn->rec[iov_index].iov_base, headEnd + 4, (res - head_size));
  conn->ios[iov_index].iov_base += (res - head_size);

  return urecvmsg(conn, iov_index, 1);
}

static inline int handle_recvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  if (conn->data_left > 0) {
    conn->data_left -= res;
    if (conn->data_left == 0) {
      conn->flags &= CF_HANDLER_READY;
      return run_handler(serv, conn, true);
    }

    conn->flags &= ~CF_HANDLER_READY;
    conn->ios[1].iov_base += res;
    return urecvmsg(conn, 1, 1);
  }

  conn->flags &= CF_HANDLER_READY;
  return run_handler(serv, conn, true);
}

static inline int serv_init(Server *serv) {
#if DEBUG
  logfd = log_init("log.txt");
  if (!logfd) {
    printf("log_init failed");
    return -1;
  }
#endif
  serv->_nroutes = get_nroutes(serv->routes);

  int pipefd[2];
  if (pipe(pipefd) < 0)
    return -1;
  pipe_in = pipefd[0];
  pipe_out = pipefd[1];
  nullfd = open("/dev/null", O_WRONLY);
  pipe_sz = fcntl(pipefd[0], F_GETPIPE_SZ);
  if (pipe_sz < 0)
    return -1;

  pool.rtimeout = serv->rtimeout;
  pool.wtimeout = serv->wtimeout;
  if (MP_init(MAX_CONNS * 8) < 0)
    return -1;
  LOG("pool initialized\n");

  if (io_uring_queue_init(MAX_CONNS, &ring, 0) < 0)
    return -1;
  LOG("uring initialized\n");

  int listenfd;
  if ((listenfd = tcp_listen(serv->port)) < 0)
    return -1;
  LOG("socket initialized\n");

  return umaccept(listenfd);
}

static inline int serv_listen(Server *serv) {
  // uint64_t last_check = get_time();
  while (true) {
    // uint64_t now = get_time();
    // if ((now - last_check) >= 200) {
    //   last_check = now;
    //   LOG("CM: CM_check ran\n");
    //   MP_timeout();
    // }

    LOG("SQ ready: %u, CQ ready: %u\n", io_uring_sq_ready(&ring), io_uring_cq_ready(&ring));
    struct io_uring_cqe *cqe;
    if (io_uring_wait_cqe(&ring, &cqe) < 0)
      continue;

    int res = cqe->res;
    LOG("res = %d\n", res);
    conn_t *conn = NULL;
    if (cqe->user_data > 100) {
      conn = (conn_t *)cqe->user_data;
      current_recv = (conn_t *)conn->recv_conn;
      current_send = (conn_t *)conn->send_conn;
    }

    if (res > 0) {
      if (cqe->user_data == ACCEPT) {
        LOG("new conn created\n");
        new_conn(res);
      } else if (conn && conn->fd != -1) {
        LOG("conn[%d]: conn.fd = %d; conn.op = %d\n", conn->cindex, conn->fd, conn->op);
        switch (conn->op) {
        case FRECVMSG:
          if (handle_frecvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case RECVMSG:
          if (handle_recvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case SENDMSG:
        case SENDMSGZC:
          // conn->last_write = get_time();
          bool zc = (conn->op == SENDMSGZC);
          if (handle_sendmsg(conn, res, zc) < 0)
            MP_clear(conn);
          break;
        case INSPLICE:
          if (handle_insplice(conn) < 0)
            MP_clear(conn);
          break;
        case OUTSPLICE:
          if (handle_outsplice(conn, res) < 0)
            MP_clear(conn);
          break;
        }
      }
    } else if (res == 0) {
      if (conn && conn->fd != -1) {
        switch (conn->op) {
        case SENDMSGZC:
          conn->zc_notifs--;
          if (conn->zc_notifs == 0 && handle_sendmsg_complete(conn) < 0)
            MP_clear(conn);
          break;
        case RECV:
          MP_clear(conn);
          break;
        }
      }
    } else {
      if (conn && conn->fd != -1) {
        if (res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR) {
          LOG("conn && conn->fd != -1 && res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR\n");
          MP_clear(conn);
        } else {
          LOG("res == -EAGAIN || res == -EWOULDBLOCK || res == -EINTR\n");
          conn = conn->recv_conn;
          struct iovec *iov = &conn->ios[0];
          memset(iov->iov_base, 0, iov->iov_len);
          if (urecv(conn, iov->iov_base, iov->iov_len, 0) < 0)
            MP_clear(conn);
        }
      }
    }

    LOG("uring operation seen\n");
    io_uring_cqe_seen(&ring, cqe);
  }

  io_uring_queue_exit(&ring);
  MP_exit(&pool);
  return 0;
}

/*** Helper ***/
static inline int _HK_write(void *data, size_t size) {
  size_t nblocks;
  int iov_index;
  conn_t *conn;
  struct iovec *iov;
  bool once;

  conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  nblocks = round_to_blocks(size);
  iov_index = MP_expand(conn, nblocks, once);
  iov = &conn->ios[iov_index];

  memcpy(iov->iov_base, data, size);
  iov->iov_len = size;
  conn->data_left += size;

  return 0;
}
static inline int _HK_write_body(Request *req, size_t offset, size_t size) {
  if (size > req->body.size || offset > req->body.size)
    return -1;

  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  int iov_index = MP_expand(conn, 0, false);
  struct iovec *iov = &conn->ios[iov_index];
  struct iovec *rec = &conn->rec[iov_index];
  rec->iov_base = req->body.ptr + offset;
  rec->iov_len = size;
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;
  conn->data_left += rec->iov_len;
  return 0;
}
/*
static inline int _HK_mem(size_t size, HKMem *mem) {
  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  bool once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  size_t nblocks = round_to_blocks(size);
  int iov_index = MP_expand(conn, nblocks, once);
  struct iovec *iov = &conn->ios[iov_index];
  mem->ptr = iov->iov_base;
  mem->size = iov->iov_len;
  mem->_iov_index = iov_index;
  mem->_flags = (IN_POOL(iov->iov_base)) ? CF_IN_POOL : CF_IN_HEAP;
  return 0;
}

static inline void _HK_send(HKMem *mem, size_t size) {
  conn_t *conn = current_send;
  struct iovec *iov = &conn->ios[mem->_iov_index];
  iov->iov_len = size;
  conn->data_left += size;
}
  */
#endif#define _GNU_SOURCE
#ifndef UTILS_H
#define UTILS_H

#include "hunk.h"
#include <arpa/inet.h>
#include <fcntl.h>
#include <liburing.h>
#include <netdb.h>
#include <signal.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/poll.h>
#include <sys/prctl.h>
#include <sys/socket.h>
#include <sys/sysinfo.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

#define MP_BLOCK  4
#define MAX_CONNS 4096
#define KB        1024
#define NIOS      32

#define IN_POOL(ptr)                 ((void *)ptr >= pool.bpool && (void *)ptr <= (pool.bpool + (pool.npages * pool.pagesize)))
#define ALIGN_TO_PAGESIZE(buff_size) (((buff_size) + (pool.pagesize - 1)) & ~(pool.pagesize - 1))
#define BYTES_TO_BLOCKS(buff_size)   (((buff_size) + (MP_BLOCK - 1)) / MP_BLOCK)
#define CEIL_BLOCKS(nblocks)         ((nblocks + 63) & ~63)
#define CEIL_PAGES(size)             (((size) + ((pool.pagesize) - 1)) & ~((pool.pagesize) - 1))

#define BIT_IS_FREE(word, bit)   (((word) >> (bit)) & 1)
#define MARK_BIT_USED(word, bit) ((word) &= ~(1ULL << (bit)))
#define MARK_BIT_FREE(word, bit) ((word) |= (1ULL << (bit)))
#define FIND_FREE_BIT(word)      ((uint64_t)(word) & -(uint64_t)(word))
#define STRLEN(s)                (sizeof(s) - 1)

#define IOVEC_NBLOCKS (BYTES_TO_BLOCKS(NIOS * sizeof(struct iovec)))
#define MSG_NBLOCKS   (BYTES_TO_BLOCKS(sizeof(struct msghdr)))
#define ZC_RES        KB *KB

#define DEBUG 0
#if DEBUG
#define LOG(...) fprintf(logfd, __VA_ARGS__)
#else
#define LOG(...) ((void)0)
#endif

typedef enum UOP {
  WRITEV = IORING_OP_WRITEV,
  SENDMSG = IORING_OP_SENDMSG,
  RECVMSG = IORING_OP_RECVMSG,
  ACCEPT = IORING_OP_ACCEPT,
  SEND = IORING_OP_SEND,
  RECV = IORING_OP_RECV,
  SENDZC = IORING_OP_SEND_ZC,
  SENDMSGZC = IORING_OP_SENDMSG_ZC,
  PEEK = 50,
  FRECVMSG,
  INSPLICE,
  OUTSPLICE
} UOP;

typedef enum CFS {
  CF_IN_POOL = (1 << 0),       // Connection is in the pool
  CF_IN_HEAP = (1 << 1),       // Connection is in the heap
  CF_SKIP_SOCK = (1 << 2),     // Don't close the socket
  CF_USE_ONCE = (1 << 3),      // Destroy after using
  CF_HANDLER_READY = (1 << 4), // Ready to call the handler
} CFS;

typedef struct conn_t {
  // Socket file descriptor
  int fd;

  // Amount of data left in the current operation
  uint64_t data_left;

  // The index of the connection struct
  uint32_t cindex;

  // The last time the connection was readable
  uint64_t last_read;

  // The last time the connection was writeable
  uint64_t last_write;

  // The operation currently being processed
  uint8_t op;

  // Connection flags
  int flags;

  // Splice fd_in
  int in_fd;

  // Splice fd_out
  int out_fd;

  void *recv_conn;
  void *send_conn;

  struct iovec *ios;
  struct iovec *rec;
  uint16_t nios;

  struct msghdr *msg;
  uint16_t zc_notifs;

  uint16_t head_size;
} conn_t;

typedef struct MPool {
  // The allocated pool of blocks
  void *bpool;

  // The allocated pool of connections
  conn_t *cpool;

  // The size of the pool in pages
  uint32_t npages;

  // The size of the pool in blocks
  uint32_t nblocks;

  // The locations of each page in the pool
  void **blocks;

  // The availability of each block
  uint64_t *freebs;

  // The locations of each conn in the pool
  conn_t **conns;

  // The availability of each conn
  uint64_t *freecs;

  // Clean up callback function
  void (*callback)(conn_t *conn);

  // The page size used
  uint32_t pagesize;

  // Socket read timeout
  uint32_t rtimeout;

  // Socket write timeout
  uint32_t wtimeout;
} MPool;

extern int pipe_sz;
extern int pipe_in, pipe_out, nullfd;
extern FILE *logfd;
extern struct io_uring ring;
extern MPool pool;
extern conn_t *current_recv;
extern conn_t *current_send;

/*
 * Prepare and submit a recv uring op
 */
static inline int urecv(conn_t *conn, void *buffer, size_t buff_size, int flags) {
  if (!conn || conn->fd == -1)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (flags == MSG_PEEK) ? PEEK : RECV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;

  io_uring_prep_recv(sqe, conn->fd, buffer, buff_size, flags);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a multi-shot accept uring op
 */
static inline int umaccept(int listenfd) {
  if (listenfd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = ACCEPT;
  io_uring_prep_multishot_accept(sqe, listenfd, NULL, NULL, SOCK_NONBLOCK);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a splice uring op
 */
static inline int usplice(conn_t *conn, int fd_in, int64_t off_in, int fd_out, int64_t off_out, size_t len) {
  if (!len || !conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = (__u64)conn;
  io_uring_prep_splice(sqe, fd_in, off_in, fd_out, off_out, len, 0);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a writev uring op
 */
static inline int uwritev(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = WRITEV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  io_uring_prep_writev(sqe, conn->fd, &conn->ios[iov_index], nios, -1);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a send uring op
 */
static inline int usend(conn_t *conn, char *res_buff, size_t buff_size, bool zc) {
  if (!conn || conn->fd <= 0 || buff_size == 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (zc) ? SENDZC : SEND;
  conn->data_left = buff_size;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  if (zc)
    io_uring_prep_send_zc(sqe, conn->fd, res_buff, buff_size, 0, 0);
  else
    io_uring_prep_send(sqe, conn->fd, res_buff, buff_size, 0);
  return io_uring_submit(&ring);
}

static inline int ufrecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = FRECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;

  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, rec->iov_len);
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int urecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = RECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int usendmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  bool zc = (conn->data_left > ZC_RES) ? true : false;
  conn->op = (zc) ? SENDMSGZC : SENDMSG;

  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  if (zc) {
    io_uring_prep_sendmsg_zc(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
    conn->zc_notifs++;
  } else {
    io_uring_prep_sendmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  }
  return io_uring_submit(&ring);
}

/*
 * Create and initialize a server socket
 */
static inline int tcp_listen(uint16_t port) {
  int enable;
  int listenfd;
  if ((listenfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    return -1;

  int flags = fcntl(listenfd, F_GETFL, 0);
  fcntl(listenfd, F_SETFL, flags | O_NONBLOCK);
  struct sockaddr_in servaddr;
  memset(&servaddr, 0, sizeof(servaddr));
  servaddr.sin_family = AF_INET;
  servaddr.sin_addr.s_addr = INADDR_ANY;
  servaddr.sin_port = htons(port);

  enable = 1;
  if (setsockopt(listenfd, SOL_SOCKET, SO_REUSEPORT, &enable, sizeof(enable)) < 0)
    return -1;

  if (bind(listenfd, (struct sockaddr *)&servaddr, sizeof(servaddr)) < 0)
    return -1;

  if (listen(listenfd, SOMAXCONN) < 0)
    return -1;

  return listenfd;
}

/*
 * Calculate the difference between two pointers
 */
static inline uintptr_t ptr_diff(uintptr_t p1, uintptr_t p2) { return (uintptr_t)(p1 > p2) ? (p1 - p2) : (p2 - p1); }

static inline size_t get_nroutes(Route *routes) {
  Route *route;
  for (size_t i = 0;; i++) {
    route = &routes[i];
    if (!route->path && !route->handler && !route->method)
      return i;
  }
}

static inline long get_content_length(char *src, char *end) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return -1;
    key = line;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, "Content-Length") != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;

    *line_end = '\0';
    long res = atol(value);
    *line_end = '\r';

    return res;
  }
  return -1;
}

static inline bool have_header(char *src, char *end, const char *header_key, const char *header_value) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    key = line;
    while (*key == ' ')
      key++;
    while (*header_key == ' ')
      header_key++;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return false;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, header_key) != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;
    while (*header_value == ' ')
      header_value++;

    *line_end = '\0';
    bool res = (strcasecmp(value, header_value) == 0);
    *line_end = '\r';

    return res;
  }

  return false;
}

static inline const char *method_str(Method method) {
  switch (method) {
  case GET:
    return "GET";
    break;
  case HEAD:
    return "HEAD";
    break;
  case POST:
    return "POST";
    break;
  case PUT:
    return "PUT";
    break;
  case DELETE:
    return "DELETE";
    break;
  case CONNECT:
    return "CONNECT";
    break;
  case OPTIONS:
    return "OPTIONS";
    break;
  case TRACE:
    return "TRACE";
    break;
  case PATCH:
    return "PATCH";
    break;
  default:
    return NULL;
  }
}

static inline uint8_t method_len(Method method) {
  switch (method) {
  case GET:
    return 3;
    break;
  case HEAD:
    return 4;
    break;
  case POST:
    return 4;
    break;
  case PUT:
    return 3;
    break;
  case DELETE:
    return 6;
    break;
  case CONNECT:
    return 7;
    break;
  case OPTIONS:
    return 7;
    break;
  case TRACE:
    return 5;
    break;
  case PATCH:
    return 5;
    break;
  default:
    return 0;
  }
}

static inline size_t round_to_blocks(size_t size) {
  size_t nblocks = BYTES_TO_BLOCKS(size);
  nblocks = CEIL_BLOCKS(nblocks);
  return nblocks;
}

/*
 * Count the digits in unsigned 64-bit int
 */
static inline int countd(uint64_t num) {
  if (num < 10ULL)
    return 1;
  if (num < 100ULL)
    return 2;
  if (num < 1000ULL)
    return 3;
  if (num < 10000ULL)
    return 4;
  if (num < 100000ULL)
    return 5;
  if (num < 1000000ULL)
    return 6;
  if (num < 10000000ULL)
    return 7;
  if (num < 100000000ULL)
    return 8;
  if (num < 1000000000ULL)
    return 9;
  if (num < 10000000000ULL)
    return 10;
  if (num < 100000000000ULL)
    return 11;
  if (num < 1000000000000ULL)
    return 12;
  if (num < 10000000000000ULL)
    return 13;
  if (num < 100000000000000ULL)
    return 14;
  if (num < 1000000000000000ULL)
    return 15;
  if (num < 10000000000000000ULL)
    return 16;
  if (num < 100000000000000000ULL)
    return 17;
  if (num < 1000000000000000000ULL)
    return 18;
  if (num < 10000000000000000000ULL)
    return 19;
  return 20;
}

/*
 * Get the time elabsed in ms
 */
static inline uint64_t get_time() {
  struct timespec ts;
  clock_gettime(CLOCK_MONOTONIC, &ts);
  return (uint64_t)(ts.tv_sec) * 1000 + (ts.tv_nsec / 1000000);
}

static inline FILE *log_init(const char *path) {
  FILE *res = fopen(path, "a+");
  setvbuf(res, NULL, _IONBF, 0);
  return res;
}

static inline int16_t pollevs(int connfd) {
  struct pollfd pfd;
  pfd.fd = connfd;
  pfd.events = POLLIN | POLLOUT | POLLERR;
  int res = poll(&pfd, 1, 0);
  if (res < 0)
    return POLLERR;
  return pfd.revents;
}

// FIXME This needs to be updated
static inline conn_t *MP_use_once(size_t nblocks, int fd) {

  void *mem = malloc(sizeof(conn_t) + 8 + (IOVEC_NBLOCKS * MP_BLOCK));
  struct conn_t *conn = (conn_t *)mem;
  memset(conn, 0, sizeof(conn_t));
  conn->ios = mem + sizeof(conn_t) + 8;

  if (nblocks > 0) {
    struct iovec *iov = &conn->ios[conn->nios++];
    mem = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (mem == MAP_FAILED)
      return NULL;
    iov->iov_base = mem;
    iov->iov_len = ALIGN_TO_PAGESIZE(nblocks * MP_BLOCK);
  }

  conn->flags |= CF_IN_HEAP;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;

  return conn;
}

static inline int find_freec() {
  uint64_t *word;
  size_t map_size = (sizeof(uint64_t) * 8);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    word = &pool.freecs[i / map_size];

    if (*word == 0) { // All used
      i += (map_size - 1);
      continue;
    }

    i += __builtin_ctzll(*word);
    MARK_BIT_USED(*word, i);
    return i;
  }

  return -1;
}

static inline int MP_init(size_t npages) {
  if (!npages)
    return -1;

  /*** Setup ***/
  pool.npages = npages;
  pool.pagesize = sysconf(_SC_PAGESIZE);

  /*** Pool ***/
  pool.bpool = mmap(NULL, pool.npages * pool.pagesize, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  if (pool.bpool == MAP_FAILED)
    return -1;
  pool.nblocks = (pool.npages * pool.pagesize) / MP_BLOCK;

  /*** Blocks ***/
  pool.blocks = malloc(sizeof(void *) * pool.nblocks);
  if (!pool.blocks)
    return -1;
  for (size_t i = 0; i < pool.nblocks; i++)
    pool.blocks[i] = pool.bpool + (i * MP_BLOCK);

  /*** Freebs ***/
  // if (posix_memalign((void **)&pool.freebs, 64, bitmap_size * sizeof(uint64_t)) < 0)
  size_t bitmap_size = (pool.nblocks + 63) / 64;
  pool.freebs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freebs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freebs[i] = UINT64_MAX;

  /*** Cpool ***/
  pool.cpool = (conn_t *)malloc(sizeof(conn_t) * MAX_CONNS);
  if (!pool.cpool)
    return -1;

  /*** Conns ***/
  pool.conns = (conn_t **)malloc(sizeof(conn_t *) * MAX_CONNS);
  if (!pool.conns)
    return -1;
  size_t conn_size = sizeof(conn_t);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    pool.conns[i] = (conn_t *)((char *)pool.cpool + (i * conn_size));
    pool.conns[i]->fd = -1;
    pool.conns[i]->in_fd = -1;
    pool.conns[i]->out_fd = -1;
  }

  /*** Freecs ***/
  bitmap_size = (MAX_CONNS + 63) / 64;
  pool.freecs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freecs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freecs[i] = UINT64_MAX;

  return 0;
}

static inline int MP_use_blks(size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t max_start = pool.nblocks - nblocks;
  size_t full_chunks = (nblocks / 64) * 64;

  for (size_t i = 0, c = 0; i <= max_start; i++, c++) {
    bool free = true;

    for (size_t j = 0; j < full_chunks; j += 64) {
      size_t word_index = (i + j) / 64;
      if (pool.freebs[word_index] != UINT64_MAX) {
        free = false;
        i += 63;
        break;
      }
    }

    for (size_t j = full_chunks; j < nblocks; j++) {
      size_t bit_index = i + j;
      size_t word_index = bit_index / 64;
      size_t bit_in_word = bit_index % 64;

      if (!BIT_IS_FREE(pool.freebs[word_index], bit_in_word)) {
        free = false;
        i += j;
        break;
      }
    }

    if (free) {
      for (size_t j = 0; j < full_chunks; j += 64) {
        size_t word_index = (i + j) / 64;
        pool.freebs[word_index] = 0;
      }

      for (size_t j = full_chunks; j < nblocks; j++) {
        size_t bit_index = i + j;
        size_t word_index = bit_index / 64;
        size_t bit_in_word = bit_index % 64;

        MARK_BIT_USED(pool.freebs[word_index], bit_in_word);
      }

      return i;
    }
  }

  return -1;
}

static inline int MP_free_blks(size_t bindex, size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t full_chunks = (nblocks / 64) * 64;
  for (size_t i = 0; i < full_chunks; i += 64) {
    size_t word_index = (bindex + i) / 64;
    pool.freebs[word_index] = UINT64_MAX;
  }

  for (size_t i = full_chunks; i < nblocks; i++) {
    size_t bit_index = bindex + i;
    size_t word_index = bit_index / 64;
    size_t bit_in_word = bit_index % 64;

    MARK_BIT_FREE(pool.freebs[word_index], bit_in_word);
  }

  memset(pool.blocks[bindex], 0, nblocks * MP_BLOCK);
  return 0;
}

static inline conn_t *MP_use(size_t nblocks, int fd, bool once) {
  if (fd <= 0)
    return NULL;
  if (once)
    return MP_use_once(nblocks, fd);

  int cindex = find_freec();
  if (cindex < 0) {
    LOG("Err: cindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  conn_t *conn = pool.conns[cindex];

  int ios_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (ios_bindex < 0) {
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }

  struct iovec *ios = pool.blocks[ios_bindex];
  conn->ios = ios;

  int rec_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (rec_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct iovec *rec = pool.blocks[rec_bindex];
  conn->rec = rec;

  int msg_bindex = MP_use_blks(MSG_NBLOCKS);
  if (msg_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct msghdr *msg = pool.blocks[msg_bindex];
  conn->msg = msg;

  if (nblocks > 0) {
    int bindex = MP_use_blks(nblocks);
    if (bindex < 0) {
      MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
      MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
      MP_free_blks(msg_bindex, IOVEC_NBLOCKS);
      MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
      LOG("Err: bindex < 0; will use MP_use_once\n");
      return MP_use_once(nblocks, fd);
    }

    size_t iov_index = conn->nios++;
    struct iovec *iov = &conn->ios[iov_index];
    struct iovec *rec = &conn->rec[iov_index];
    iov->iov_base = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
  }

  conn->msg->msg_iov = conn->ios;
  conn->msg->msg_iovlen = conn->nios;
  conn->cindex = cindex;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;
  return conn;
}

static inline void MP_shed(conn_t *conn, size_t iov_index, size_t nios) {
  struct iovec *iov, *rec;
  size_t bindex, nblocks, index;

  for (size_t i = 0; i < nios; i++) {
    index = iov_index + i;
    iov = &conn->ios[index];
    rec = &conn->rec[index];
    if (!rec || !rec->iov_base)
      continue;
    if (!IN_POOL(rec->iov_base)) {
      munmap(rec->iov_base, rec->iov_len / pool.pagesize);
    } else {
      bindex = ptr_diff((uintptr_t)rec->iov_base, (uintptr_t)pool.bpool) / MP_BLOCK;
      nblocks = rec->iov_len / MP_BLOCK;
      MP_free_blks(bindex, nblocks);
    }
    memset(iov, 0, sizeof(struct iovec));
    memset(rec, 0, sizeof(struct iovec));
    conn->nios--;
  }
}

static inline int MP_expand(conn_t *conn, size_t nblocks, bool once) {
  void *bptr;
  int iov_index, bindex;
  struct iovec *iov, *rec;

  iov_index = conn->nios++;
  iov = &conn->ios[iov_index];
  rec = &conn->rec[iov_index];

  if (nblocks == 0)
    return iov_index;

  if (once) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_base = bptr;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
    return iov_index;
  }

  bindex = MP_use_blks(nblocks);
  if (bindex < 0) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_len = iov->iov_len;
  } else {
    bptr = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_len = iov->iov_len;
  }

  iov->iov_base = bptr;
  rec->iov_base = iov->iov_base;
  return iov_index;
}

static inline int MP_free(conn_t *conn) {
  if (!conn)
    return -1;
  size_t bindex, nblocks;
  uint64_t *word;

  MP_shed(conn, 0, conn->nios);
  if (conn->flags & CF_IN_HEAP) {
    if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
      close(conn->fd);
    free(conn);
    return 0;
  }

  word = &pool.freecs[conn->cindex / 64];
  if (conn->cindex > MAX_CONNS)
    return -1;
  else if (BIT_IS_FREE(*word, conn->cindex))
    return 0;

  bindex = ptr_diff((uintptr_t)conn->ios, (uintptr_t)pool.bpool) / MP_BLOCK;
  nblocks = IOVEC_NBLOCKS;
  MP_free_blks(bindex, nblocks);

  bindex = ptr_diff((uintptr_t)conn->rec, (uintptr_t)pool.bpool) / MP_BLOCK;
  MP_free_blks(bindex, nblocks);

  if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
    close(conn->fd);

  MARK_BIT_FREE(*word, conn->cindex);
  memset(conn, 0, sizeof(conn_t));
  conn->fd = -1;
  conn->in_fd = -1;
  conn->out_fd = -1;
  return 0;
}

static inline void MP_clear(conn_t *conn) {
  conn_t *recv_conn = conn->recv_conn;
  conn_t *send_conn = conn->send_conn;
  if (recv_conn)
    MP_free(recv_conn);
  if (send_conn)
    MP_free(send_conn);
}

static inline void MP_exit(MPool *pool) {
  munmap(pool->bpool, pool->npages);
  free(pool->cpool);
  free(pool->blocks);
  free(pool->conns);
  free(pool->freebs);
  free(pool->freecs);
}

static inline void MP_timeout() {
  conn_t *conn;
  int16_t res;
  uint64_t now;
  size_t windex = 0;
  uint64_t *word = &pool.freecs[0];
  for (size_t i = 0; i < MAX_CONNS; i++) {
    if ((i / 64) < windex)
      word = &pool.freecs[++windex];

    if (*word == UINTMAX_MAX) {
      i = (i / 64) * 64 + 64;
      continue;
    }

    conn = pool.conns[i];
    if (!conn || conn->fd == -1)
      continue;

    res = pollevs(conn->fd);

    now = get_time();
    if (res & POLLERR) {
      MP_clear(conn);
      continue;
    }
    if (res & POLLIN) {
      if (pool.rtimeout > 0 && (now - conn->last_read) >= pool.rtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (res & POLLOUT) {
      if (pool.wtimeout > 0 && (now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (!(res & POLLIN || res & POLLOUT)) {
      if ((pool.rtimeout > 0 && now - conn->last_read) >= pool.rtimeout
          || (pool.wtimeout > 0 && now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
  }
}

/*
 * Calculate the length of a status string
 */
static inline size_t status_len(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return 8;
  case STATUSSWITCHINGPROTOCOLS:
    return 19;
  case STATUSPROCESSING:
    return 10;
  case STATUSEARLYHINTS:
    return 11;
  case STATUSOK:
    return 2;
  case STATUSCREATED:
    return 7;
  case STATUSACCEPTED:
    return 8;
  case STATUSNONAUTHORITATIVE:
    return 29;
  case STATUSNOCONTENT:
    return 10;
  case STATUSRESETCONTENT:
    return 13;
  case STATUSPARTIALCONTENT:
    return 15;
  case STATUSMULTISTATUS:
    return 12;
  case STATUSALREADYREPORTED:
    return 16;
  case STATUSIMUSED:
    return 7;
  case STATUSMULTIPLECHOICES:
    return 16;
  case STATUSMOVEDPERMANENTLY:
    return 17;
  case STATUSFOUND:
    return 5;
  case STATUSSEEOTHER:
    return 9;
  case STATUSNOTMODIFIED:
    return 12;
  case STATUSUSEPROXY:
    return 9;
  case STATUSTEMPORARYREDIRECT:
    return 18;
  case STATUSPERMANENTREDIRECT:
    return 18;
  case STATUSBADREQUEST:
    return 11;
  case STATUSUNAUTHORIZED:
    return 12;
  case STATUSPAYMENTREQUIRED:
    return 16;
  case STATUSFORBIDDEN:
    return 9;
  case STATUSNOTFOUND:
    return 9;
  case STATUSMETHODNOTALLOWED:
    return 18;
  case STATUSNOTACCEPTABLE:
    return 14;
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return 29;
  case STATUSREQUESTTIMEOUT:
    return 15;
  case STATUSCONFLICT:
    return 8;
  case STATUSGONE:
    return 4;
  case STATUSLENGTHREQUIRED:
    return 15;
  case STATUSPRECONDITIONFAILED:
    return 19;
  case CONTENTTOOLARGE:
    return 17;
  case STATUSURITOOLONG:
    return 12;
  case STATUSUNSUPPORTEDMEDIATYPE:
    return 22;
  case STATUSRANGENOTSATISFIABLE:
    return 21;
  case STATUSEXPECTATIONFAILED:
    return 18;
  case STATUSMISDIRECTEDREQUEST:
    return 19;
  case STATUSUNPROCESSABLECONTENT:
    return 21;
  case STATUSLOCKED:
    return 6;
  case STATUSFAILEDDEPENDENCY:
    return 17;
  case STATUSTOOEARLY:
    return 9;
  case STATUSUPGRADEREQUIRED:
    return 16;
  case STATUSPRECONDITIONREQUIRED:
    return 21;
  case STATUSTOOMANYREQUESTS:
    return 17;
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return 31;
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return 29;
  case STATUSInternalServerError:
    return 21;
  case STATUSNOTIMPLEMENTED:
    return 15;
  case STATUSBADGATEWAY:
    return 11;
  case STATUSSERVICEUNAVAILABLE:
    return 19;
  case STATUSGATEWAYTIMEOUT:
    return 15;
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return 26;
  case STATUSVARIANTALSONEGOTIATES:
    return 23;
  case STATUSINSUFFICIENTSTORAGE:
    return 20;
  case STATUSLOOPDETECTED:
    return 13;
  case STATUSNOTEXTENDED:
    return 12;
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return 31;
  default:
    return 0;
  }
}

/*
 * Return the status code string as string literal
 */
static inline char *status_str(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return "Continue";
  case STATUSSWITCHINGPROTOCOLS:
    return "Switching Protocols";
  case STATUSPROCESSING:
    return "Processing";
  case STATUSEARLYHINTS:
    return "Early Hints";
  case STATUSOK:
    return "OK";
  case STATUSCREATED:
    return "Created";
  case STATUSACCEPTED:
    return "Accepted";
  case STATUSNONAUTHORITATIVE:
    return "Non-Authoritative Information";
  case STATUSNOCONTENT:
    return "No Content";
  case STATUSRESETCONTENT:
    return "Reset Content";
  case STATUSPARTIALCONTENT:
    return "Partial Content";
  case STATUSMULTISTATUS:
    return "Multi-Status";
  case STATUSALREADYREPORTED:
    return "Already Reported";
  case STATUSIMUSED:
    return "Im Used";
  case STATUSMULTIPLECHOICES:
    return "Multiple Choices";
  case STATUSMOVEDPERMANENTLY:
    return "Moved Permanently";
  case STATUSFOUND:
    return "Found";
  case STATUSSEEOTHER:
    return "See Other";
  case STATUSNOTMODIFIED:
    return "Not Modified";
  case STATUSUSEPROXY:
    return "Use Proxy";
  case STATUSTEMPORARYREDIRECT:
    return "Temporary Redirect";
  case STATUSPERMANENTREDIRECT:
    return "Permanent Redirect";
  case STATUSBADREQUEST:
    return "Bad Request";
  case STATUSUNAUTHORIZED:
    return "Unauthorized";
  case STATUSPAYMENTREQUIRED:
    return "Payment Required";
  case STATUSFORBIDDEN:
    return "Forbidden";
  case STATUSNOTFOUND:
    return "Not Found";
  case STATUSMETHODNOTALLOWED:
    return "Method Not Allowed";
  case STATUSNOTACCEPTABLE:
    return "Not Acceptable";
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return "Proxy Authentication Required";
  case STATUSREQUESTTIMEOUT:
    return "Request Timeout";
  case STATUSCONFLICT:
    return "Conflict";
  case STATUSGONE:
    return "Gone";
  case STATUSLENGTHREQUIRED:
    return "Length Required";
  case STATUSPRECONDITIONFAILED:
    return "Precondition Failed";
  case CONTENTTOOLARGE:
    return "Content Too Large";
  case STATUSURITOOLONG:
    return "URI Too Long";
  case STATUSUNSUPPORTEDMEDIATYPE:
    return "Unsupported Media Type";
  case STATUSRANGENOTSATISFIABLE:
    return "Range Not Satisfiable";
  case STATUSEXPECTATIONFAILED:
    return "Expectation Failed";
  case STATUSMISDIRECTEDREQUEST:
    return "Misdirected Request";
  case STATUSUNPROCESSABLECONTENT:
    return "Unprocessable Content";
  case STATUSLOCKED:
    return "Locked";
  case STATUSFAILEDDEPENDENCY:
    return "Failed Dependency";
  case STATUSTOOEARLY:
    return "Too Early";
  case STATUSUPGRADEREQUIRED:
    return "Upgrade Required";
  case STATUSPRECONDITIONREQUIRED:
    return "Precondition Required";
  case STATUSTOOMANYREQUESTS:
    return "Too Many Requests";
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return "Request Header Fields Too Large";
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return "Unavailable For Legal Reasons";
  case STATUSInternalServerError:
    return "Internal Server Error";
  case STATUSNOTIMPLEMENTED:
    return "Not Implemented";
  case STATUSBADGATEWAY:
    return "Bad Gateway";
  case STATUSSERVICEUNAVAILABLE:
    return "Service Unavailable";
  case STATUSGATEWAYTIMEOUT:
    return "Gateway Timeout";
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return "HTTP Version Not Supported";
  case STATUSVARIANTALSONEGOTIATES:
    return "Variant Also Negotiates";
  case STATUSINSUFFICIENTSTORAGE:
    return "Insufficient Storage";
  case STATUSLOOPDETECTED:
    return "Loop Detected";
  case STATUSNOTEXTENDED:
    return "Not Extended";
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return "Network Authentication Required";
  default:
    return 0;
  }
}

/*
 * Return true if routes match
 */
static inline bool route_equ(Route *route, Request *req) {
  return route->method == req->method && strncmp(route->path, req->path, strlen(route->path)) == 0;
}

/*
 * Return the matching route index on success. -1 on failure
 */
static inline int match_route(Server *serv, Request *req) {
  for (size_t i = 0; i < serv->_nroutes; i++) {
    Route route = serv->routes[i];
    if (!req->path || !route.path)
      continue;
    if (route_equ(&route, req))
      return i;
    else if (req->method == HEAD && route.method == GET && strcmp(route.path, req->path) == 0)
      return i;
  }
  return -1;
}

/*
 * Return true if the response should contain the Content-Length header
 */
static inline bool should_have_content_length(Request *req, ResWriter *res) {
  return (req->method != CONNECT              // CONNECT request
          && res->status != STATUSNOCONTENT   // 204 response
          && res->status != STATUSNOTMODIFIED // 304 response
          && res->status >= 200);             // 1xx response
}

/*
 * Format http response from the ResWriter.
 * Return response size on success, 0 on failure.
 */
static inline size_t fmt_res(Request *req, ResWriter *res, char *buffer, size_t buffer_size) {
  if (!res || !buffer || buffer_size == 0)
    return 0;

  size_t res_len, total = 0;
  char *dst = buffer;
  size_t maxlen = buffer_size;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t body_length = res->len;

  res_len = snprintf(dst, maxlen, "HTTP/1.1 %d %s", (int)res->status, status_str(res->status));
  total += res_len;
  dst += res_len;
  maxlen -= res_len;

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    res_len = snprintf(dst, maxlen, "\r\n%s: %s", header->key, header->value);
    total += res_len;
    dst += res_len;
    maxlen -= res_len;
  }

  if (have_content_length) {
    res_len = snprintf(dst, maxlen, "\r\nContent-Length: %lu", body_length);
    total += res_len, dst += res_len, maxlen -= res_len;
  }

  memcpy(dst, "\r\n\r\n", 4);
  total += 4, dst += 4, maxlen -= 4;

  return total;
}

static inline size_t res_len(Request *req, ResWriter *res) {
  if (!req || !res)
    return 0;

  if (!res->status)
    res->status = STATUSOK;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t result = 0;
  result += STRLEN("HTTP/1.1 ");     // HTTP version
  result += 4;                       // Status code + space
  result += status_len(res->status); // Status name

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    result += 2;                       // "\r\n"
    result += strlen(header->key) + 2; // Header key + ':' + space
    result += strlen(header->value);   // header value
  }

  if (have_content_length) {
    result += 2;                          // "\r\n"
    result += STRLEN("Content-Length: "); // Header key
    result += countd(res->len);           // Header value
  }

  result += 4; // "\r\n\r\n"

  return result;
}

static inline int send_empty_res(Status status) {
  size_t res_len = STRLEN("HTTP/1.1 ")        // HTTP version
                   + countd((uint64_t)status) // status code
                   + 1                        // space
                   + (int)status_len(status)  // status string
                   + 4;                       // \r\n\r\n

  conn_t *conn = current_send;
  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, res_len);
  if (snprintf((char *)rec->iov_base, res_len + 1, "HTTP/1.1 %d %s\r\n\r\n", (int)status, status_str(status))
      != (int)res_len)
    return -1;

  return usendmsg(conn, 0, 1);
}

static inline ssize_t read_socket(int sockfd, size_t len) {
  if (len == 0 || sockfd <= 0)
    return 0;
  char buff[1024 * 8];
  return read(sockfd, buff, 1024 * 8);
}

static inline int read_method(Method *method, void *src) {
  if (memcmp(src, "GET", 3) == 0)
    *method = GET;
  else if (memcmp(src, "POST", 4) == 0)
    *method = POST;
  else if (memcmp(src, "HEAD", 4) == 0)
    *method = HEAD;
  else if (memcmp(src, "PUT", 3) == 0)
    *method = PUT;
  else if (memcmp(src, "DELETE", 6) == 0)
    *method = DELETE;
  else if (memcmp(src, "CONNECT", 7) == 0)
    *method = CONNECT;
  else if (memcmp(src, "OPTIONS", 7) == 0)
    *method = OPTIONS;
  else if (memcmp(src, "TRACE", 5) == 0)
    *method = TRACE;
  else if (memcmp(src, "PATCH", 5) == 0)
    *method = PATCH;
  else
    return -1;

  return 0;
}

static inline int sendmsg_res(Request *req, ResWriter *res) {
  conn_t *conn;
  size_t head_size, res_size;
  struct iovec *iov;

  conn = current_send;
  iov = &conn->ios[0];
  head_size = res_len(req, res);
  if (head_size == 0)
    return -1;

  conn->data_left += head_size;
  res_size = fmt_res(req, res, iov->iov_base, (head_size + 1));
  if (res_size != head_size)
    return -1;
  iov->iov_len = res_size;

  return usendmsg(conn, 0, conn->nios);
}

static inline int read_req(Request *req, char *req_buffer) {
  if (!req_buffer)
    return -1;
  /*** Method ***/
  char *sep = strchr(req_buffer, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }
  *sep = '\0';
  if (read_method(&req->method, req_buffer) < 0)
    return -1;

  /*** Path ***/
  char *fullpath = sep + 1;
  sep = strchr(fullpath, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }

  *sep = '\0';
  req->path = fullpath;
  /*** Params ***/
  char *paramStart = strchr(fullpath, '?');
  if (paramStart) {
    *paramStart++ = '\0';
    int params_count = 0;
    params_count = HK_parse_params(paramStart, req->params, MAX_URL_PARAMETERS);
    if (params_count > 0)
      req->params_count = params_count;
    else
      req->params_count = 0;
  } else {
    req->params = NULL;
    req->params_count = 0;
  }

  /*** Headers ***/
  char *headStart = strstr(sep + 1, "\r\n");
  char *headEnd = strstr(sep + 1, "\r\n\r\n");
  if (!headStart) {
    LOG("read_req: !headStart\n");
    return -1;
  };

  memset(headStart, 0, 2);
  headStart += 2;
  memset(headEnd, 0, 4);
  headEnd += 4;

  int headers_count = HK_parse_headers(headStart, req->headers, MAX_REQ_HEADERS);
  if (headers_count <= 0)
    return -1;
  req->headers_count = headers_count;

  /*** Host ***/
  int index = HK_get_header(req, "Host");
  if (index < 0)
    return -1;
  char *host = req->headers[index].value;
  req->hostname = host;

  /*** Port ***/
  char *colon = strchr(host, ':');
  if (colon) {
    *colon++ = '\0';
    req->port = atoi(colon);
  } else {
    req->port = PORT;
  }
  return 0;
}
static inline int process_req(Server *serv, conn_t *conn) {
  if (!conn || conn->fd == -1)
    return -1;

  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;
  if (read_req(&req, conn->ios[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    LOG("Err: route_index == -1\n");
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;
  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  sendmsg_res(&req, &res);

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int new_conn(int connfd) {
  if (connfd <= 0)
    return -1;

  current_recv = MP_use(KB * 2, connfd, false);
  current_send = MP_use(KB * 2, connfd, false);

  current_recv->recv_conn = current_recv;
  current_recv->send_conn = current_send;

  current_send->send_conn = current_send;
  current_send->recv_conn = current_recv;

  conn_t *conn = current_recv;
  if (ufrecvmsg(conn, 0, 1) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

static inline int resubmit_sendmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return usendmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int resubmir_recvmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    // FIXME the len should be increased
    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return urecvmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int handle_sendmsg_complete(conn_t *conn) {
  struct iovec *iov, *rec;

  MP_shed(conn, 1, conn->nios - 1);
  iov = &conn->ios[0];
  rec = &conn->rec[0];
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;

  return ufrecvmsg(conn->recv_conn, 0, 1);
}

static inline int handle_sendmsg(conn_t *conn, int res, bool zc) {
  if (!conn || conn->fd == -1)
    return -1;

  conn->data_left -= res;
  if (conn->data_left > 0)
    return resubmit_sendmsg(conn, res);

  if (zc)
    return 0;

  return handle_sendmsg_complete(conn);
}

static inline int handle_insplice(conn_t *conn) {
  conn->op = OUTSPLICE;
  return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
}
static inline int handle_outsplice(conn_t *conn, int res) {
  conn->data_left -= res;
  if (conn->data_left > 0) {
    conn->op = INSPLICE;
    return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
  }

  conn_t *recv_conn = conn->recv_conn;
  struct iovec *iov = &recv_conn->ios[0];
  memset(iov->iov_base, 0, iov->iov_len);
  if (urecv(recv_conn, iov->iov_base, iov->iov_len, MSG_PEEK) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

/*
static inline int handle_recv(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  void *bptr = conn->ios[0].iov_base;
  void *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  void *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  return process_req(serv, conn);
}
*/
static inline int find_route(Server *serv, char *bptr) {
  Request req = {0};
  if (read_method(&req.method, bptr) < 0) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  };
  char *space = strchr(bptr, ' ');
  req.path = (space + 1);
  space = strchr(req.path, ' ');
  *space = '\0';
  int route_index = match_route(serv, &req);
  *space = ' ';
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }
  return route_index;
}

static inline int run_handler(Server *serv, conn_t *conn, bool uses_body) {
  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;

  if (read_req(&req, conn->rec[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  if (uses_body) {
    int h_index = HK_get_header(&req, "Content-Length");
    long body_size = atol(req.headers[h_index].value);
    if (body_size >= 0) {
      req.body.ptr = conn->rec[1].iov_base;
      req.body.size = body_size;
    } else {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    }
  }

  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  if (sendmsg_res(&req, &res) < 0)
    return -1;

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int handle_frecvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  char *bptr = (char *)conn->ios[0].iov_base;
  char *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  char *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  size_t head_size = (headEnd + 4) - bptr;
  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  int route_index = find_route(serv, bptr);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  bool uses_body = serv->routes[route_index].uses_body;
  long body_size = get_content_length(headstart + 2, headEnd + 4);
  if (body_size == -1) {
    if (uses_body) {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    } else {
      body_size = 0;
    }
  }

  conn->head_size = head_size;
  if (!uses_body) {
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  if (res == (int)(head_size + body_size)) {
    size_t iov_index = MP_expand(conn, round_to_blocks(body_size), false);
    memcpy(conn->rec[iov_index].iov_base, headEnd + 4, body_size);
    conn->ios[iov_index].iov_len = body_size;
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  conn->data_left = body_size - (res - head_size);
  bool once = ((size_t)body_size > (size_t)((pool.nblocks * MP_BLOCK) / 10));
  size_t iov_index = MP_expand(conn, round_to_blocks(body_size), once);
  memcpy(conn->rec[iov_index].iov_base, headEnd + 4, (res - head_size));
  conn->ios[iov_index].iov_base += (res - head_size);

  return urecvmsg(conn, iov_index, 1);
}

static inline int handle_recvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  if (conn->data_left > 0) {
    conn->data_left -= res;
    if (conn->data_left == 0) {
      conn->flags &= CF_HANDLER_READY;
      return run_handler(serv, conn, true);
    }

    conn->flags &= ~CF_HANDLER_READY;
    conn->ios[1].iov_base += res;
    return urecvmsg(conn, 1, 1);
  }

  conn->flags &= CF_HANDLER_READY;
  return run_handler(serv, conn, true);
}

static inline int serv_init(Server *serv) {
#if DEBUG
  logfd = log_init("log.txt");
  if (!logfd) {
    printf("log_init failed");
    return -1;
  }
#endif
  serv->_nroutes = get_nroutes(serv->routes);

  int pipefd[2];
  if (pipe(pipefd) < 0)
    return -1;
  pipe_in = pipefd[0];
  pipe_out = pipefd[1];
  nullfd = open("/dev/null", O_WRONLY);
  pipe_sz = fcntl(pipefd[0], F_GETPIPE_SZ);
  if (pipe_sz < 0)
    return -1;

  pool.rtimeout = serv->rtimeout;
  pool.wtimeout = serv->wtimeout;
  if (MP_init(MAX_CONNS * 8) < 0)
    return -1;
  LOG("pool initialized\n");

  if (io_uring_queue_init(MAX_CONNS, &ring, 0) < 0)
    return -1;
  LOG("uring initialized\n");

  int listenfd;
  if ((listenfd = tcp_listen(serv->port)) < 0)
    return -1;
  LOG("socket initialized\n");

  return umaccept(listenfd);
}

static inline int serv_listen(Server *serv) {
  // uint64_t last_check = get_time();
  while (true) {
    // uint64_t now = get_time();
    // if ((now - last_check) >= 200) {
    //   last_check = now;
    //   LOG("CM: CM_check ran\n");
    //   MP_timeout();
    // }

    LOG("SQ ready: %u, CQ ready: %u\n", io_uring_sq_ready(&ring), io_uring_cq_ready(&ring));
    struct io_uring_cqe *cqe;
    if (io_uring_wait_cqe(&ring, &cqe) < 0)
      continue;

    int res = cqe->res;
    LOG("res = %d\n", res);
    conn_t *conn = NULL;
    if (cqe->user_data > 100) {
      conn = (conn_t *)cqe->user_data;
      current_recv = (conn_t *)conn->recv_conn;
      current_send = (conn_t *)conn->send_conn;
    }

    if (res > 0) {
      if (cqe->user_data == ACCEPT) {
        LOG("new conn created\n");
        new_conn(res);
      } else if (conn && conn->fd != -1) {
        LOG("conn[%d]: conn.fd = %d; conn.op = %d\n", conn->cindex, conn->fd, conn->op);
        switch (conn->op) {
        case FRECVMSG:
          if (handle_frecvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case RECVMSG:
          if (handle_recvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case SENDMSG:
        case SENDMSGZC:
          // conn->last_write = get_time();
          bool zc = (conn->op == SENDMSGZC);
          if (handle_sendmsg(conn, res, zc) < 0)
            MP_clear(conn);
          break;
        case INSPLICE:
          if (handle_insplice(conn) < 0)
            MP_clear(conn);
          break;
        case OUTSPLICE:
          if (handle_outsplice(conn, res) < 0)
            MP_clear(conn);
          break;
        }
      }
    } else if (res == 0) {
      if (conn && conn->fd != -1) {
        switch (conn->op) {
        case SENDMSGZC:
          conn->zc_notifs--;
          if (conn->zc_notifs == 0 && handle_sendmsg_complete(conn) < 0)
            MP_clear(conn);
          break;
        case RECV:
          MP_clear(conn);
          break;
        }
      }
    } else {
      if (conn && conn->fd != -1) {
        if (res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR) {
          LOG("conn && conn->fd != -1 && res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR\n");
          MP_clear(conn);
        } else {
          LOG("res == -EAGAIN || res == -EWOULDBLOCK || res == -EINTR\n");
          conn = conn->recv_conn;
          struct iovec *iov = &conn->ios[0];
          memset(iov->iov_base, 0, iov->iov_len);
          if (urecv(conn, iov->iov_base, iov->iov_len, 0) < 0)
            MP_clear(conn);
        }
      }
    }

    LOG("uring operation seen\n");
    io_uring_cqe_seen(&ring, cqe);
  }

  io_uring_queue_exit(&ring);
  MP_exit(&pool);
  return 0;
}

/*** Helper ***/
static inline int _HK_write(void *data, size_t size) {
  size_t nblocks;
  int iov_index;
  conn_t *conn;
  struct iovec *iov;
  bool once;

  conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  nblocks = round_to_blocks(size);
  iov_index = MP_expand(conn, nblocks, once);
  iov = &conn->ios[iov_index];

  memcpy(iov->iov_base, data, size);
  iov->iov_len = size;
  conn->data_left += size;

  return 0;
}
static inline int _HK_write_body(Request *req, size_t offset, size_t size) {
  if (size > req->body.size || offset > req->body.size)
    return -1;

  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  int iov_index = MP_expand(conn, 0, false);
  struct iovec *iov = &conn->ios[iov_index];
  struct iovec *rec = &conn->rec[iov_index];
  rec->iov_base = req->body.ptr + offset;
  rec->iov_len = size;
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;
  conn->data_left += rec->iov_len;
  return 0;
}
/*
static inline int _HK_mem(size_t size, HKMem *mem) {
  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  bool once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  size_t nblocks = round_to_blocks(size);
  int iov_index = MP_expand(conn, nblocks, once);
  struct iovec *iov = &conn->ios[iov_index];
  mem->ptr = iov->iov_base;
  mem->size = iov->iov_len;
  mem->_iov_index = iov_index;
  mem->_flags = (IN_POOL(iov->iov_base)) ? CF_IN_POOL : CF_IN_HEAP;
  return 0;
}

static inline void _HK_send(HKMem *mem, size_t size) {
  conn_t *conn = current_send;
  struct iovec *iov = &conn->ios[mem->_iov_index];
  iov->iov_len = size;
  conn->data_left += size;
}
  */
#endif#define _GNU_SOURCE
#ifndef UTILS_H
#define UTILS_H

#include "hunk.h"
#include <arpa/inet.h>
#include <fcntl.h>
#include <liburing.h>
#include <netdb.h>
#include <signal.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/poll.h>
#include <sys/prctl.h>
#include <sys/socket.h>
#include <sys/sysinfo.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

#define MP_BLOCK  4
#define MAX_CONNS 4096
#define KB        1024
#define NIOS      32

#define IN_POOL(ptr)                 ((void *)ptr >= pool.bpool && (void *)ptr <= (pool.bpool + (pool.npages * pool.pagesize)))
#define ALIGN_TO_PAGESIZE(buff_size) (((buff_size) + (pool.pagesize - 1)) & ~(pool.pagesize - 1))
#define BYTES_TO_BLOCKS(buff_size)   (((buff_size) + (MP_BLOCK - 1)) / MP_BLOCK)
#define CEIL_BLOCKS(nblocks)         ((nblocks + 63) & ~63)
#define CEIL_PAGES(size)             (((size) + ((pool.pagesize) - 1)) & ~((pool.pagesize) - 1))

#define BIT_IS_FREE(word, bit)   (((word) >> (bit)) & 1)
#define MARK_BIT_USED(word, bit) ((word) &= ~(1ULL << (bit)))
#define MARK_BIT_FREE(word, bit) ((word) |= (1ULL << (bit)))
#define FIND_FREE_BIT(word)      ((uint64_t)(word) & -(uint64_t)(word))
#define STRLEN(s)                (sizeof(s) - 1)

#define IOVEC_NBLOCKS (BYTES_TO_BLOCKS(NIOS * sizeof(struct iovec)))
#define MSG_NBLOCKS   (BYTES_TO_BLOCKS(sizeof(struct msghdr)))
#define ZC_RES        KB *KB

#define DEBUG 0
#if DEBUG
#define LOG(...) fprintf(logfd, __VA_ARGS__)
#else
#define LOG(...) ((void)0)
#endif

typedef enum UOP {
  WRITEV = IORING_OP_WRITEV,
  SENDMSG = IORING_OP_SENDMSG,
  RECVMSG = IORING_OP_RECVMSG,
  ACCEPT = IORING_OP_ACCEPT,
  SEND = IORING_OP_SEND,
  RECV = IORING_OP_RECV,
  SENDZC = IORING_OP_SEND_ZC,
  SENDMSGZC = IORING_OP_SENDMSG_ZC,
  PEEK = 50,
  FRECVMSG,
  INSPLICE,
  OUTSPLICE
} UOP;

typedef enum CFS {
  CF_IN_POOL = (1 << 0),       // Connection is in the pool
  CF_IN_HEAP = (1 << 1),       // Connection is in the heap
  CF_SKIP_SOCK = (1 << 2),     // Don't close the socket
  CF_USE_ONCE = (1 << 3),      // Destroy after using
  CF_HANDLER_READY = (1 << 4), // Ready to call the handler
} CFS;

typedef struct conn_t {
  // Socket file descriptor
  int fd;

  // Amount of data left in the current operation
  uint64_t data_left;

  // The index of the connection struct
  uint32_t cindex;

  // The last time the connection was readable
  uint64_t last_read;

  // The last time the connection was writeable
  uint64_t last_write;

  // The operation currently being processed
  uint8_t op;

  // Connection flags
  int flags;

  // Splice fd_in
  int in_fd;

  // Splice fd_out
  int out_fd;

  void *recv_conn;
  void *send_conn;

  struct iovec *ios;
  struct iovec *rec;
  uint16_t nios;

  struct msghdr *msg;
  uint16_t zc_notifs;

  uint16_t head_size;
} conn_t;

typedef struct MPool {
  // The allocated pool of blocks
  void *bpool;

  // The allocated pool of connections
  conn_t *cpool;

  // The size of the pool in pages
  uint32_t npages;

  // The size of the pool in blocks
  uint32_t nblocks;

  // The locations of each page in the pool
  void **blocks;

  // The availability of each block
  uint64_t *freebs;

  // The locations of each conn in the pool
  conn_t **conns;

  // The availability of each conn
  uint64_t *freecs;

  // Clean up callback function
  void (*callback)(conn_t *conn);

  // The page size used
  uint32_t pagesize;

  // Socket read timeout
  uint32_t rtimeout;

  // Socket write timeout
  uint32_t wtimeout;
} MPool;

extern int pipe_sz;
extern int pipe_in, pipe_out, nullfd;
extern FILE *logfd;
extern struct io_uring ring;
extern MPool pool;
extern conn_t *current_recv;
extern conn_t *current_send;

/*
 * Prepare and submit a recv uring op
 */
static inline int urecv(conn_t *conn, void *buffer, size_t buff_size, int flags) {
  if (!conn || conn->fd == -1)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (flags == MSG_PEEK) ? PEEK : RECV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;

  io_uring_prep_recv(sqe, conn->fd, buffer, buff_size, flags);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a multi-shot accept uring op
 */
static inline int umaccept(int listenfd) {
  if (listenfd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = ACCEPT;
  io_uring_prep_multishot_accept(sqe, listenfd, NULL, NULL, SOCK_NONBLOCK);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a splice uring op
 */
static inline int usplice(conn_t *conn, int fd_in, int64_t off_in, int fd_out, int64_t off_out, size_t len) {
  if (!len || !conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = (__u64)conn;
  io_uring_prep_splice(sqe, fd_in, off_in, fd_out, off_out, len, 0);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a writev uring op
 */
static inline int uwritev(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = WRITEV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  io_uring_prep_writev(sqe, conn->fd, &conn->ios[iov_index], nios, -1);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a send uring op
 */
static inline int usend(conn_t *conn, char *res_buff, size_t buff_size, bool zc) {
  if (!conn || conn->fd <= 0 || buff_size == 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (zc) ? SENDZC : SEND;
  conn->data_left = buff_size;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  if (zc)
    io_uring_prep_send_zc(sqe, conn->fd, res_buff, buff_size, 0, 0);
  else
    io_uring_prep_send(sqe, conn->fd, res_buff, buff_size, 0);
  return io_uring_submit(&ring);
}

static inline int ufrecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = FRECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;

  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, rec->iov_len);
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int urecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = RECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int usendmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  bool zc = (conn->data_left > ZC_RES) ? true : false;
  conn->op = (zc) ? SENDMSGZC : SENDMSG;

  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  if (zc) {
    io_uring_prep_sendmsg_zc(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
    conn->zc_notifs++;
  } else {
    io_uring_prep_sendmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  }
  return io_uring_submit(&ring);
}

/*
 * Create and initialize a server socket
 */
static inline int tcp_listen(uint16_t port) {
  int enable;
  int listenfd;
  if ((listenfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    return -1;

  int flags = fcntl(listenfd, F_GETFL, 0);
  fcntl(listenfd, F_SETFL, flags | O_NONBLOCK);
  struct sockaddr_in servaddr;
  memset(&servaddr, 0, sizeof(servaddr));
  servaddr.sin_family = AF_INET;
  servaddr.sin_addr.s_addr = INADDR_ANY;
  servaddr.sin_port = htons(port);

  enable = 1;
  if (setsockopt(listenfd, SOL_SOCKET, SO_REUSEPORT, &enable, sizeof(enable)) < 0)
    return -1;

  if (bind(listenfd, (struct sockaddr *)&servaddr, sizeof(servaddr)) < 0)
    return -1;

  if (listen(listenfd, SOMAXCONN) < 0)
    return -1;

  return listenfd;
}

/*
 * Calculate the difference between two pointers
 */
static inline uintptr_t ptr_diff(uintptr_t p1, uintptr_t p2) { return (uintptr_t)(p1 > p2) ? (p1 - p2) : (p2 - p1); }

static inline size_t get_nroutes(Route *routes) {
  Route *route;
  for (size_t i = 0;; i++) {
    route = &routes[i];
    if (!route->path && !route->handler && !route->method)
      return i;
  }
}

static inline long get_content_length(char *src, char *end) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return -1;
    key = line;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, "Content-Length") != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;

    *line_end = '\0';
    long res = atol(value);
    *line_end = '\r';

    return res;
  }
  return -1;
}

static inline bool have_header(char *src, char *end, const char *header_key, const char *header_value) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    key = line;
    while (*key == ' ')
      key++;
    while (*header_key == ' ')
      header_key++;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return false;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, header_key) != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;
    while (*header_value == ' ')
      header_value++;

    *line_end = '\0';
    bool res = (strcasecmp(value, header_value) == 0);
    *line_end = '\r';

    return res;
  }

  return false;
}

static inline const char *method_str(Method method) {
  switch (method) {
  case GET:
    return "GET";
    break;
  case HEAD:
    return "HEAD";
    break;
  case POST:
    return "POST";
    break;
  case PUT:
    return "PUT";
    break;
  case DELETE:
    return "DELETE";
    break;
  case CONNECT:
    return "CONNECT";
    break;
  case OPTIONS:
    return "OPTIONS";
    break;
  case TRACE:
    return "TRACE";
    break;
  case PATCH:
    return "PATCH";
    break;
  default:
    return NULL;
  }
}

static inline uint8_t method_len(Method method) {
  switch (method) {
  case GET:
    return 3;
    break;
  case HEAD:
    return 4;
    break;
  case POST:
    return 4;
    break;
  case PUT:
    return 3;
    break;
  case DELETE:
    return 6;
    break;
  case CONNECT:
    return 7;
    break;
  case OPTIONS:
    return 7;
    break;
  case TRACE:
    return 5;
    break;
  case PATCH:
    return 5;
    break;
  default:
    return 0;
  }
}

static inline size_t round_to_blocks(size_t size) {
  size_t nblocks = BYTES_TO_BLOCKS(size);
  nblocks = CEIL_BLOCKS(nblocks);
  return nblocks;
}

/*
 * Count the digits in unsigned 64-bit int
 */
static inline int countd(uint64_t num) {
  if (num < 10ULL)
    return 1;
  if (num < 100ULL)
    return 2;
  if (num < 1000ULL)
    return 3;
  if (num < 10000ULL)
    return 4;
  if (num < 100000ULL)
    return 5;
  if (num < 1000000ULL)
    return 6;
  if (num < 10000000ULL)
    return 7;
  if (num < 100000000ULL)
    return 8;
  if (num < 1000000000ULL)
    return 9;
  if (num < 10000000000ULL)
    return 10;
  if (num < 100000000000ULL)
    return 11;
  if (num < 1000000000000ULL)
    return 12;
  if (num < 10000000000000ULL)
    return 13;
  if (num < 100000000000000ULL)
    return 14;
  if (num < 1000000000000000ULL)
    return 15;
  if (num < 10000000000000000ULL)
    return 16;
  if (num < 100000000000000000ULL)
    return 17;
  if (num < 1000000000000000000ULL)
    return 18;
  if (num < 10000000000000000000ULL)
    return 19;
  return 20;
}

/*
 * Get the time elabsed in ms
 */
static inline uint64_t get_time() {
  struct timespec ts;
  clock_gettime(CLOCK_MONOTONIC, &ts);
  return (uint64_t)(ts.tv_sec) * 1000 + (ts.tv_nsec / 1000000);
}

static inline FILE *log_init(const char *path) {
  FILE *res = fopen(path, "a+");
  setvbuf(res, NULL, _IONBF, 0);
  return res;
}

static inline int16_t pollevs(int connfd) {
  struct pollfd pfd;
  pfd.fd = connfd;
  pfd.events = POLLIN | POLLOUT | POLLERR;
  int res = poll(&pfd, 1, 0);
  if (res < 0)
    return POLLERR;
  return pfd.revents;
}

// FIXME This needs to be updated
static inline conn_t *MP_use_once(size_t nblocks, int fd) {

  void *mem = malloc(sizeof(conn_t) + 8 + (IOVEC_NBLOCKS * MP_BLOCK));
  struct conn_t *conn = (conn_t *)mem;
  memset(conn, 0, sizeof(conn_t));
  conn->ios = mem + sizeof(conn_t) + 8;

  if (nblocks > 0) {
    struct iovec *iov = &conn->ios[conn->nios++];
    mem = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (mem == MAP_FAILED)
      return NULL;
    iov->iov_base = mem;
    iov->iov_len = ALIGN_TO_PAGESIZE(nblocks * MP_BLOCK);
  }

  conn->flags |= CF_IN_HEAP;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;

  return conn;
}

static inline int find_freec() {
  uint64_t *word;
  size_t map_size = (sizeof(uint64_t) * 8);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    word = &pool.freecs[i / map_size];

    if (*word == 0) { // All used
      i += (map_size - 1);
      continue;
    }

    i += __builtin_ctzll(*word);
    MARK_BIT_USED(*word, i);
    return i;
  }

  return -1;
}

static inline int MP_init(size_t npages) {
  if (!npages)
    return -1;

  /*** Setup ***/
  pool.npages = npages;
  pool.pagesize = sysconf(_SC_PAGESIZE);

  /*** Pool ***/
  pool.bpool = mmap(NULL, pool.npages * pool.pagesize, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  if (pool.bpool == MAP_FAILED)
    return -1;
  pool.nblocks = (pool.npages * pool.pagesize) / MP_BLOCK;

  /*** Blocks ***/
  pool.blocks = malloc(sizeof(void *) * pool.nblocks);
  if (!pool.blocks)
    return -1;
  for (size_t i = 0; i < pool.nblocks; i++)
    pool.blocks[i] = pool.bpool + (i * MP_BLOCK);

  /*** Freebs ***/
  // if (posix_memalign((void **)&pool.freebs, 64, bitmap_size * sizeof(uint64_t)) < 0)
  size_t bitmap_size = (pool.nblocks + 63) / 64;
  pool.freebs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freebs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freebs[i] = UINT64_MAX;

  /*** Cpool ***/
  pool.cpool = (conn_t *)malloc(sizeof(conn_t) * MAX_CONNS);
  if (!pool.cpool)
    return -1;

  /*** Conns ***/
  pool.conns = (conn_t **)malloc(sizeof(conn_t *) * MAX_CONNS);
  if (!pool.conns)
    return -1;
  size_t conn_size = sizeof(conn_t);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    pool.conns[i] = (conn_t *)((char *)pool.cpool + (i * conn_size));
    pool.conns[i]->fd = -1;
    pool.conns[i]->in_fd = -1;
    pool.conns[i]->out_fd = -1;
  }

  /*** Freecs ***/
  bitmap_size = (MAX_CONNS + 63) / 64;
  pool.freecs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freecs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freecs[i] = UINT64_MAX;

  return 0;
}

static inline int MP_use_blks(size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t max_start = pool.nblocks - nblocks;
  size_t full_chunks = (nblocks / 64) * 64;

  for (size_t i = 0, c = 0; i <= max_start; i++, c++) {
    bool free = true;

    for (size_t j = 0; j < full_chunks; j += 64) {
      size_t word_index = (i + j) / 64;
      if (pool.freebs[word_index] != UINT64_MAX) {
        free = false;
        i += 63;
        break;
      }
    }

    for (size_t j = full_chunks; j < nblocks; j++) {
      size_t bit_index = i + j;
      size_t word_index = bit_index / 64;
      size_t bit_in_word = bit_index % 64;

      if (!BIT_IS_FREE(pool.freebs[word_index], bit_in_word)) {
        free = false;
        i += j;
        break;
      }
    }

    if (free) {
      for (size_t j = 0; j < full_chunks; j += 64) {
        size_t word_index = (i + j) / 64;
        pool.freebs[word_index] = 0;
      }

      for (size_t j = full_chunks; j < nblocks; j++) {
        size_t bit_index = i + j;
        size_t word_index = bit_index / 64;
        size_t bit_in_word = bit_index % 64;

        MARK_BIT_USED(pool.freebs[word_index], bit_in_word);
      }

      return i;
    }
  }

  return -1;
}

static inline int MP_free_blks(size_t bindex, size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t full_chunks = (nblocks / 64) * 64;
  for (size_t i = 0; i < full_chunks; i += 64) {
    size_t word_index = (bindex + i) / 64;
    pool.freebs[word_index] = UINT64_MAX;
  }

  for (size_t i = full_chunks; i < nblocks; i++) {
    size_t bit_index = bindex + i;
    size_t word_index = bit_index / 64;
    size_t bit_in_word = bit_index % 64;

    MARK_BIT_FREE(pool.freebs[word_index], bit_in_word);
  }

  memset(pool.blocks[bindex], 0, nblocks * MP_BLOCK);
  return 0;
}

static inline conn_t *MP_use(size_t nblocks, int fd, bool once) {
  if (fd <= 0)
    return NULL;
  if (once)
    return MP_use_once(nblocks, fd);

  int cindex = find_freec();
  if (cindex < 0) {
    LOG("Err: cindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  conn_t *conn = pool.conns[cindex];

  int ios_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (ios_bindex < 0) {
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }

  struct iovec *ios = pool.blocks[ios_bindex];
  conn->ios = ios;

  int rec_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (rec_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct iovec *rec = pool.blocks[rec_bindex];
  conn->rec = rec;

  int msg_bindex = MP_use_blks(MSG_NBLOCKS);
  if (msg_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct msghdr *msg = pool.blocks[msg_bindex];
  conn->msg = msg;

  if (nblocks > 0) {
    int bindex = MP_use_blks(nblocks);
    if (bindex < 0) {
      MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
      MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
      MP_free_blks(msg_bindex, IOVEC_NBLOCKS);
      MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
      LOG("Err: bindex < 0; will use MP_use_once\n");
      return MP_use_once(nblocks, fd);
    }

    size_t iov_index = conn->nios++;
    struct iovec *iov = &conn->ios[iov_index];
    struct iovec *rec = &conn->rec[iov_index];
    iov->iov_base = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
  }

  conn->msg->msg_iov = conn->ios;
  conn->msg->msg_iovlen = conn->nios;
  conn->cindex = cindex;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;
  return conn;
}

static inline void MP_shed(conn_t *conn, size_t iov_index, size_t nios) {
  struct iovec *iov, *rec;
  size_t bindex, nblocks, index;

  for (size_t i = 0; i < nios; i++) {
    index = iov_index + i;
    iov = &conn->ios[index];
    rec = &conn->rec[index];
    if (!rec || !rec->iov_base)
      continue;
    if (!IN_POOL(rec->iov_base)) {
      munmap(rec->iov_base, rec->iov_len / pool.pagesize);
    } else {
      bindex = ptr_diff((uintptr_t)rec->iov_base, (uintptr_t)pool.bpool) / MP_BLOCK;
      nblocks = rec->iov_len / MP_BLOCK;
      MP_free_blks(bindex, nblocks);
    }
    memset(iov, 0, sizeof(struct iovec));
    memset(rec, 0, sizeof(struct iovec));
    conn->nios--;
  }
}

static inline int MP_expand(conn_t *conn, size_t nblocks, bool once) {
  void *bptr;
  int iov_index, bindex;
  struct iovec *iov, *rec;

  iov_index = conn->nios++;
  iov = &conn->ios[iov_index];
  rec = &conn->rec[iov_index];

  if (nblocks == 0)
    return iov_index;

  if (once) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_base = bptr;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
    return iov_index;
  }

  bindex = MP_use_blks(nblocks);
  if (bindex < 0) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_len = iov->iov_len;
  } else {
    bptr = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_len = iov->iov_len;
  }

  iov->iov_base = bptr;
  rec->iov_base = iov->iov_base;
  return iov_index;
}

static inline int MP_free(conn_t *conn) {
  if (!conn)
    return -1;
  size_t bindex, nblocks;
  uint64_t *word;

  MP_shed(conn, 0, conn->nios);
  if (conn->flags & CF_IN_HEAP) {
    if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
      close(conn->fd);
    free(conn);
    return 0;
  }

  word = &pool.freecs[conn->cindex / 64];
  if (conn->cindex > MAX_CONNS)
    return -1;
  else if (BIT_IS_FREE(*word, conn->cindex))
    return 0;

  bindex = ptr_diff((uintptr_t)conn->ios, (uintptr_t)pool.bpool) / MP_BLOCK;
  nblocks = IOVEC_NBLOCKS;
  MP_free_blks(bindex, nblocks);

  bindex = ptr_diff((uintptr_t)conn->rec, (uintptr_t)pool.bpool) / MP_BLOCK;
  MP_free_blks(bindex, nblocks);

  if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
    close(conn->fd);

  MARK_BIT_FREE(*word, conn->cindex);
  memset(conn, 0, sizeof(conn_t));
  conn->fd = -1;
  conn->in_fd = -1;
  conn->out_fd = -1;
  return 0;
}

static inline void MP_clear(conn_t *conn) {
  conn_t *recv_conn = conn->recv_conn;
  conn_t *send_conn = conn->send_conn;
  if (recv_conn)
    MP_free(recv_conn);
  if (send_conn)
    MP_free(send_conn);
}

static inline void MP_exit(MPool *pool) {
  munmap(pool->bpool, pool->npages);
  free(pool->cpool);
  free(pool->blocks);
  free(pool->conns);
  free(pool->freebs);
  free(pool->freecs);
}

static inline void MP_timeout() {
  conn_t *conn;
  int16_t res;
  uint64_t now;
  size_t windex = 0;
  uint64_t *word = &pool.freecs[0];
  for (size_t i = 0; i < MAX_CONNS; i++) {
    if ((i / 64) < windex)
      word = &pool.freecs[++windex];

    if (*word == UINTMAX_MAX) {
      i = (i / 64) * 64 + 64;
      continue;
    }

    conn = pool.conns[i];
    if (!conn || conn->fd == -1)
      continue;

    res = pollevs(conn->fd);

    now = get_time();
    if (res & POLLERR) {
      MP_clear(conn);
      continue;
    }
    if (res & POLLIN) {
      if (pool.rtimeout > 0 && (now - conn->last_read) >= pool.rtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (res & POLLOUT) {
      if (pool.wtimeout > 0 && (now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (!(res & POLLIN || res & POLLOUT)) {
      if ((pool.rtimeout > 0 && now - conn->last_read) >= pool.rtimeout
          || (pool.wtimeout > 0 && now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
  }
}

/*
 * Calculate the length of a status string
 */
static inline size_t status_len(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return 8;
  case STATUSSWITCHINGPROTOCOLS:
    return 19;
  case STATUSPROCESSING:
    return 10;
  case STATUSEARLYHINTS:
    return 11;
  case STATUSOK:
    return 2;
  case STATUSCREATED:
    return 7;
  case STATUSACCEPTED:
    return 8;
  case STATUSNONAUTHORITATIVE:
    return 29;
  case STATUSNOCONTENT:
    return 10;
  case STATUSRESETCONTENT:
    return 13;
  case STATUSPARTIALCONTENT:
    return 15;
  case STATUSMULTISTATUS:
    return 12;
  case STATUSALREADYREPORTED:
    return 16;
  case STATUSIMUSED:
    return 7;
  case STATUSMULTIPLECHOICES:
    return 16;
  case STATUSMOVEDPERMANENTLY:
    return 17;
  case STATUSFOUND:
    return 5;
  case STATUSSEEOTHER:
    return 9;
  case STATUSNOTMODIFIED:
    return 12;
  case STATUSUSEPROXY:
    return 9;
  case STATUSTEMPORARYREDIRECT:
    return 18;
  case STATUSPERMANENTREDIRECT:
    return 18;
  case STATUSBADREQUEST:
    return 11;
  case STATUSUNAUTHORIZED:
    return 12;
  case STATUSPAYMENTREQUIRED:
    return 16;
  case STATUSFORBIDDEN:
    return 9;
  case STATUSNOTFOUND:
    return 9;
  case STATUSMETHODNOTALLOWED:
    return 18;
  case STATUSNOTACCEPTABLE:
    return 14;
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return 29;
  case STATUSREQUESTTIMEOUT:
    return 15;
  case STATUSCONFLICT:
    return 8;
  case STATUSGONE:
    return 4;
  case STATUSLENGTHREQUIRED:
    return 15;
  case STATUSPRECONDITIONFAILED:
    return 19;
  case CONTENTTOOLARGE:
    return 17;
  case STATUSURITOOLONG:
    return 12;
  case STATUSUNSUPPORTEDMEDIATYPE:
    return 22;
  case STATUSRANGENOTSATISFIABLE:
    return 21;
  case STATUSEXPECTATIONFAILED:
    return 18;
  case STATUSMISDIRECTEDREQUEST:
    return 19;
  case STATUSUNPROCESSABLECONTENT:
    return 21;
  case STATUSLOCKED:
    return 6;
  case STATUSFAILEDDEPENDENCY:
    return 17;
  case STATUSTOOEARLY:
    return 9;
  case STATUSUPGRADEREQUIRED:
    return 16;
  case STATUSPRECONDITIONREQUIRED:
    return 21;
  case STATUSTOOMANYREQUESTS:
    return 17;
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return 31;
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return 29;
  case STATUSInternalServerError:
    return 21;
  case STATUSNOTIMPLEMENTED:
    return 15;
  case STATUSBADGATEWAY:
    return 11;
  case STATUSSERVICEUNAVAILABLE:
    return 19;
  case STATUSGATEWAYTIMEOUT:
    return 15;
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return 26;
  case STATUSVARIANTALSONEGOTIATES:
    return 23;
  case STATUSINSUFFICIENTSTORAGE:
    return 20;
  case STATUSLOOPDETECTED:
    return 13;
  case STATUSNOTEXTENDED:
    return 12;
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return 31;
  default:
    return 0;
  }
}

/*
 * Return the status code string as string literal
 */
static inline char *status_str(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return "Continue";
  case STATUSSWITCHINGPROTOCOLS:
    return "Switching Protocols";
  case STATUSPROCESSING:
    return "Processing";
  case STATUSEARLYHINTS:
    return "Early Hints";
  case STATUSOK:
    return "OK";
  case STATUSCREATED:
    return "Created";
  case STATUSACCEPTED:
    return "Accepted";
  case STATUSNONAUTHORITATIVE:
    return "Non-Authoritative Information";
  case STATUSNOCONTENT:
    return "No Content";
  case STATUSRESETCONTENT:
    return "Reset Content";
  case STATUSPARTIALCONTENT:
    return "Partial Content";
  case STATUSMULTISTATUS:
    return "Multi-Status";
  case STATUSALREADYREPORTED:
    return "Already Reported";
  case STATUSIMUSED:
    return "Im Used";
  case STATUSMULTIPLECHOICES:
    return "Multiple Choices";
  case STATUSMOVEDPERMANENTLY:
    return "Moved Permanently";
  case STATUSFOUND:
    return "Found";
  case STATUSSEEOTHER:
    return "See Other";
  case STATUSNOTMODIFIED:
    return "Not Modified";
  case STATUSUSEPROXY:
    return "Use Proxy";
  case STATUSTEMPORARYREDIRECT:
    return "Temporary Redirect";
  case STATUSPERMANENTREDIRECT:
    return "Permanent Redirect";
  case STATUSBADREQUEST:
    return "Bad Request";
  case STATUSUNAUTHORIZED:
    return "Unauthorized";
  case STATUSPAYMENTREQUIRED:
    return "Payment Required";
  case STATUSFORBIDDEN:
    return "Forbidden";
  case STATUSNOTFOUND:
    return "Not Found";
  case STATUSMETHODNOTALLOWED:
    return "Method Not Allowed";
  case STATUSNOTACCEPTABLE:
    return "Not Acceptable";
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return "Proxy Authentication Required";
  case STATUSREQUESTTIMEOUT:
    return "Request Timeout";
  case STATUSCONFLICT:
    return "Conflict";
  case STATUSGONE:
    return "Gone";
  case STATUSLENGTHREQUIRED:
    return "Length Required";
  case STATUSPRECONDITIONFAILED:
    return "Precondition Failed";
  case CONTENTTOOLARGE:
    return "Content Too Large";
  case STATUSURITOOLONG:
    return "URI Too Long";
  case STATUSUNSUPPORTEDMEDIATYPE:
    return "Unsupported Media Type";
  case STATUSRANGENOTSATISFIABLE:
    return "Range Not Satisfiable";
  case STATUSEXPECTATIONFAILED:
    return "Expectation Failed";
  case STATUSMISDIRECTEDREQUEST:
    return "Misdirected Request";
  case STATUSUNPROCESSABLECONTENT:
    return "Unprocessable Content";
  case STATUSLOCKED:
    return "Locked";
  case STATUSFAILEDDEPENDENCY:
    return "Failed Dependency";
  case STATUSTOOEARLY:
    return "Too Early";
  case STATUSUPGRADEREQUIRED:
    return "Upgrade Required";
  case STATUSPRECONDITIONREQUIRED:
    return "Precondition Required";
  case STATUSTOOMANYREQUESTS:
    return "Too Many Requests";
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return "Request Header Fields Too Large";
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return "Unavailable For Legal Reasons";
  case STATUSInternalServerError:
    return "Internal Server Error";
  case STATUSNOTIMPLEMENTED:
    return "Not Implemented";
  case STATUSBADGATEWAY:
    return "Bad Gateway";
  case STATUSSERVICEUNAVAILABLE:
    return "Service Unavailable";
  case STATUSGATEWAYTIMEOUT:
    return "Gateway Timeout";
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return "HTTP Version Not Supported";
  case STATUSVARIANTALSONEGOTIATES:
    return "Variant Also Negotiates";
  case STATUSINSUFFICIENTSTORAGE:
    return "Insufficient Storage";
  case STATUSLOOPDETECTED:
    return "Loop Detected";
  case STATUSNOTEXTENDED:
    return "Not Extended";
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return "Network Authentication Required";
  default:
    return 0;
  }
}

/*
 * Return true if routes match
 */
static inline bool route_equ(Route *route, Request *req) {
  return route->method == req->method && strncmp(route->path, req->path, strlen(route->path)) == 0;
}

/*
 * Return the matching route index on success. -1 on failure
 */
static inline int match_route(Server *serv, Request *req) {
  for (size_t i = 0; i < serv->_nroutes; i++) {
    Route route = serv->routes[i];
    if (!req->path || !route.path)
      continue;
    if (route_equ(&route, req))
      return i;
    else if (req->method == HEAD && route.method == GET && strcmp(route.path, req->path) == 0)
      return i;
  }
  return -1;
}

/*
 * Return true if the response should contain the Content-Length header
 */
static inline bool should_have_content_length(Request *req, ResWriter *res) {
  return (req->method != CONNECT              // CONNECT request
          && res->status != STATUSNOCONTENT   // 204 response
          && res->status != STATUSNOTMODIFIED // 304 response
          && res->status >= 200);             // 1xx response
}

/*
 * Format http response from the ResWriter.
 * Return response size on success, 0 on failure.
 */
static inline size_t fmt_res(Request *req, ResWriter *res, char *buffer, size_t buffer_size) {
  if (!res || !buffer || buffer_size == 0)
    return 0;

  size_t res_len, total = 0;
  char *dst = buffer;
  size_t maxlen = buffer_size;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t body_length = res->len;

  res_len = snprintf(dst, maxlen, "HTTP/1.1 %d %s", (int)res->status, status_str(res->status));
  total += res_len;
  dst += res_len;
  maxlen -= res_len;

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    res_len = snprintf(dst, maxlen, "\r\n%s: %s", header->key, header->value);
    total += res_len;
    dst += res_len;
    maxlen -= res_len;
  }

  if (have_content_length) {
    res_len = snprintf(dst, maxlen, "\r\nContent-Length: %lu", body_length);
    total += res_len, dst += res_len, maxlen -= res_len;
  }

  memcpy(dst, "\r\n\r\n", 4);
  total += 4, dst += 4, maxlen -= 4;

  return total;
}

static inline size_t res_len(Request *req, ResWriter *res) {
  if (!req || !res)
    return 0;

  if (!res->status)
    res->status = STATUSOK;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t result = 0;
  result += STRLEN("HTTP/1.1 ");     // HTTP version
  result += 4;                       // Status code + space
  result += status_len(res->status); // Status name

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    result += 2;                       // "\r\n"
    result += strlen(header->key) + 2; // Header key + ':' + space
    result += strlen(header->value);   // header value
  }

  if (have_content_length) {
    result += 2;                          // "\r\n"
    result += STRLEN("Content-Length: "); // Header key
    result += countd(res->len);           // Header value
  }

  result += 4; // "\r\n\r\n"

  return result;
}

static inline int send_empty_res(Status status) {
  size_t res_len = STRLEN("HTTP/1.1 ")        // HTTP version
                   + countd((uint64_t)status) // status code
                   + 1                        // space
                   + (int)status_len(status)  // status string
                   + 4;                       // \r\n\r\n

  conn_t *conn = current_send;
  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, res_len);
  if (snprintf((char *)rec->iov_base, res_len + 1, "HTTP/1.1 %d %s\r\n\r\n", (int)status, status_str(status))
      != (int)res_len)
    return -1;

  return usendmsg(conn, 0, 1);
}

static inline ssize_t read_socket(int sockfd, size_t len) {
  if (len == 0 || sockfd <= 0)
    return 0;
  char buff[1024 * 8];
  return read(sockfd, buff, 1024 * 8);
}

static inline int read_method(Method *method, void *src) {
  if (memcmp(src, "GET", 3) == 0)
    *method = GET;
  else if (memcmp(src, "POST", 4) == 0)
    *method = POST;
  else if (memcmp(src, "HEAD", 4) == 0)
    *method = HEAD;
  else if (memcmp(src, "PUT", 3) == 0)
    *method = PUT;
  else if (memcmp(src, "DELETE", 6) == 0)
    *method = DELETE;
  else if (memcmp(src, "CONNECT", 7) == 0)
    *method = CONNECT;
  else if (memcmp(src, "OPTIONS", 7) == 0)
    *method = OPTIONS;
  else if (memcmp(src, "TRACE", 5) == 0)
    *method = TRACE;
  else if (memcmp(src, "PATCH", 5) == 0)
    *method = PATCH;
  else
    return -1;

  return 0;
}

static inline int sendmsg_res(Request *req, ResWriter *res) {
  conn_t *conn;
  size_t head_size, res_size;
  struct iovec *iov;

  conn = current_send;
  iov = &conn->ios[0];
  head_size = res_len(req, res);
  if (head_size == 0)
    return -1;

  conn->data_left += head_size;
  res_size = fmt_res(req, res, iov->iov_base, (head_size + 1));
  if (res_size != head_size)
    return -1;
  iov->iov_len = res_size;

  return usendmsg(conn, 0, conn->nios);
}

static inline int read_req(Request *req, char *req_buffer) {
  if (!req_buffer)
    return -1;
  /*** Method ***/
  char *sep = strchr(req_buffer, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }
  *sep = '\0';
  if (read_method(&req->method, req_buffer) < 0)
    return -1;

  /*** Path ***/
  char *fullpath = sep + 1;
  sep = strchr(fullpath, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }

  *sep = '\0';
  req->path = fullpath;
  /*** Params ***/
  char *paramStart = strchr(fullpath, '?');
  if (paramStart) {
    *paramStart++ = '\0';
    int params_count = 0;
    params_count = HK_parse_params(paramStart, req->params, MAX_URL_PARAMETERS);
    if (params_count > 0)
      req->params_count = params_count;
    else
      req->params_count = 0;
  } else {
    req->params = NULL;
    req->params_count = 0;
  }

  /*** Headers ***/
  char *headStart = strstr(sep + 1, "\r\n");
  char *headEnd = strstr(sep + 1, "\r\n\r\n");
  if (!headStart) {
    LOG("read_req: !headStart\n");
    return -1;
  };

  memset(headStart, 0, 2);
  headStart += 2;
  memset(headEnd, 0, 4);
  headEnd += 4;

  int headers_count = HK_parse_headers(headStart, req->headers, MAX_REQ_HEADERS);
  if (headers_count <= 0)
    return -1;
  req->headers_count = headers_count;

  /*** Host ***/
  int index = HK_get_header(req, "Host");
  if (index < 0)
    return -1;
  char *host = req->headers[index].value;
  req->hostname = host;

  /*** Port ***/
  char *colon = strchr(host, ':');
  if (colon) {
    *colon++ = '\0';
    req->port = atoi(colon);
  } else {
    req->port = PORT;
  }
  return 0;
}
static inline int process_req(Server *serv, conn_t *conn) {
  if (!conn || conn->fd == -1)
    return -1;

  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;
  if (read_req(&req, conn->ios[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    LOG("Err: route_index == -1\n");
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;
  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  sendmsg_res(&req, &res);

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int new_conn(int connfd) {
  if (connfd <= 0)
    return -1;

  current_recv = MP_use(KB * 2, connfd, false);
  current_send = MP_use(KB * 2, connfd, false);

  current_recv->recv_conn = current_recv;
  current_recv->send_conn = current_send;

  current_send->send_conn = current_send;
  current_send->recv_conn = current_recv;

  conn_t *conn = current_recv;
  if (ufrecvmsg(conn, 0, 1) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

static inline int resubmit_sendmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return usendmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int resubmir_recvmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    // FIXME the len should be increased
    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return urecvmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int handle_sendmsg_complete(conn_t *conn) {
  struct iovec *iov, *rec;

  MP_shed(conn, 1, conn->nios - 1);
  iov = &conn->ios[0];
  rec = &conn->rec[0];
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;

  return ufrecvmsg(conn->recv_conn, 0, 1);
}

static inline int handle_sendmsg(conn_t *conn, int res, bool zc) {
  if (!conn || conn->fd == -1)
    return -1;

  conn->data_left -= res;
  if (conn->data_left > 0)
    return resubmit_sendmsg(conn, res);

  if (zc)
    return 0;

  return handle_sendmsg_complete(conn);
}

static inline int handle_insplice(conn_t *conn) {
  conn->op = OUTSPLICE;
  return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
}
static inline int handle_outsplice(conn_t *conn, int res) {
  conn->data_left -= res;
  if (conn->data_left > 0) {
    conn->op = INSPLICE;
    return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
  }

  conn_t *recv_conn = conn->recv_conn;
  struct iovec *iov = &recv_conn->ios[0];
  memset(iov->iov_base, 0, iov->iov_len);
  if (urecv(recv_conn, iov->iov_base, iov->iov_len, MSG_PEEK) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

/*
static inline int handle_recv(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  void *bptr = conn->ios[0].iov_base;
  void *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  void *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  return process_req(serv, conn);
}
*/
static inline int find_route(Server *serv, char *bptr) {
  Request req = {0};
  if (read_method(&req.method, bptr) < 0) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  };
  char *space = strchr(bptr, ' ');
  req.path = (space + 1);
  space = strchr(req.path, ' ');
  *space = '\0';
  int route_index = match_route(serv, &req);
  *space = ' ';
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }
  return route_index;
}

static inline int run_handler(Server *serv, conn_t *conn, bool uses_body) {
  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;

  if (read_req(&req, conn->rec[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  if (uses_body) {
    int h_index = HK_get_header(&req, "Content-Length");
    long body_size = atol(req.headers[h_index].value);
    if (body_size >= 0) {
      req.body.ptr = conn->rec[1].iov_base;
      req.body.size = body_size;
    } else {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    }
  }

  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  if (sendmsg_res(&req, &res) < 0)
    return -1;

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int handle_frecvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  char *bptr = (char *)conn->ios[0].iov_base;
  char *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  char *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  size_t head_size = (headEnd + 4) - bptr;
  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  int route_index = find_route(serv, bptr);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  bool uses_body = serv->routes[route_index].uses_body;
  long body_size = get_content_length(headstart + 2, headEnd + 4);
  if (body_size == -1) {
    if (uses_body) {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    } else {
      body_size = 0;
    }
  }

  conn->head_size = head_size;
  if (!uses_body) {
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  if (res == (int)(head_size + body_size)) {
    size_t iov_index = MP_expand(conn, round_to_blocks(body_size), false);
    memcpy(conn->rec[iov_index].iov_base, headEnd + 4, body_size);
    conn->ios[iov_index].iov_len = body_size;
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  conn->data_left = body_size - (res - head_size);
  bool once = ((size_t)body_size > (size_t)((pool.nblocks * MP_BLOCK) / 10));
  size_t iov_index = MP_expand(conn, round_to_blocks(body_size), once);
  memcpy(conn->rec[iov_index].iov_base, headEnd + 4, (res - head_size));
  conn->ios[iov_index].iov_base += (res - head_size);

  return urecvmsg(conn, iov_index, 1);
}

static inline int handle_recvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  if (conn->data_left > 0) {
    conn->data_left -= res;
    if (conn->data_left == 0) {
      conn->flags &= CF_HANDLER_READY;
      return run_handler(serv, conn, true);
    }

    conn->flags &= ~CF_HANDLER_READY;
    conn->ios[1].iov_base += res;
    return urecvmsg(conn, 1, 1);
  }

  conn->flags &= CF_HANDLER_READY;
  return run_handler(serv, conn, true);
}

static inline int serv_init(Server *serv) {
#if DEBUG
  logfd = log_init("log.txt");
  if (!logfd) {
    printf("log_init failed");
    return -1;
  }
#endif
  serv->_nroutes = get_nroutes(serv->routes);

  int pipefd[2];
  if (pipe(pipefd) < 0)
    return -1;
  pipe_in = pipefd[0];
  pipe_out = pipefd[1];
  nullfd = open("/dev/null", O_WRONLY);
  pipe_sz = fcntl(pipefd[0], F_GETPIPE_SZ);
  if (pipe_sz < 0)
    return -1;

  pool.rtimeout = serv->rtimeout;
  pool.wtimeout = serv->wtimeout;
  if (MP_init(MAX_CONNS * 8) < 0)
    return -1;
  LOG("pool initialized\n");

  if (io_uring_queue_init(MAX_CONNS, &ring, 0) < 0)
    return -1;
  LOG("uring initialized\n");

  int listenfd;
  if ((listenfd = tcp_listen(serv->port)) < 0)
    return -1;
  LOG("socket initialized\n");

  return umaccept(listenfd);
}

static inline int serv_listen(Server *serv) {
  // uint64_t last_check = get_time();
  while (true) {
    // uint64_t now = get_time();
    // if ((now - last_check) >= 200) {
    //   last_check = now;
    //   LOG("CM: CM_check ran\n");
    //   MP_timeout();
    // }

    LOG("SQ ready: %u, CQ ready: %u\n", io_uring_sq_ready(&ring), io_uring_cq_ready(&ring));
    struct io_uring_cqe *cqe;
    if (io_uring_wait_cqe(&ring, &cqe) < 0)
      continue;

    int res = cqe->res;
    LOG("res = %d\n", res);
    conn_t *conn = NULL;
    if (cqe->user_data > 100) {
      conn = (conn_t *)cqe->user_data;
      current_recv = (conn_t *)conn->recv_conn;
      current_send = (conn_t *)conn->send_conn;
    }

    if (res > 0) {
      if (cqe->user_data == ACCEPT) {
        LOG("new conn created\n");
        new_conn(res);
      } else if (conn && conn->fd != -1) {
        LOG("conn[%d]: conn.fd = %d; conn.op = %d\n", conn->cindex, conn->fd, conn->op);
        switch (conn->op) {
        case FRECVMSG:
          if (handle_frecvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case RECVMSG:
          if (handle_recvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case SENDMSG:
        case SENDMSGZC:
          // conn->last_write = get_time();
          bool zc = (conn->op == SENDMSGZC);
          if (handle_sendmsg(conn, res, zc) < 0)
            MP_clear(conn);
          break;
        case INSPLICE:
          if (handle_insplice(conn) < 0)
            MP_clear(conn);
          break;
        case OUTSPLICE:
          if (handle_outsplice(conn, res) < 0)
            MP_clear(conn);
          break;
        }
      }
    } else if (res == 0) {
      if (conn && conn->fd != -1) {
        switch (conn->op) {
        case SENDMSGZC:
          conn->zc_notifs--;
          if (conn->zc_notifs == 0 && handle_sendmsg_complete(conn) < 0)
            MP_clear(conn);
          break;
        case RECV:
          MP_clear(conn);
          break;
        }
      }
    } else {
      if (conn && conn->fd != -1) {
        if (res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR) {
          LOG("conn && conn->fd != -1 && res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR\n");
          MP_clear(conn);
        } else {
          LOG("res == -EAGAIN || res == -EWOULDBLOCK || res == -EINTR\n");
          conn = conn->recv_conn;
          struct iovec *iov = &conn->ios[0];
          memset(iov->iov_base, 0, iov->iov_len);
          if (urecv(conn, iov->iov_base, iov->iov_len, 0) < 0)
            MP_clear(conn);
        }
      }
    }

    LOG("uring operation seen\n");
    io_uring_cqe_seen(&ring, cqe);
  }

  io_uring_queue_exit(&ring);
  MP_exit(&pool);
  return 0;
}

/*** Helper ***/
static inline int _HK_write(void *data, size_t size) {
  size_t nblocks;
  int iov_index;
  conn_t *conn;
  struct iovec *iov;
  bool once;

  conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  nblocks = round_to_blocks(size);
  iov_index = MP_expand(conn, nblocks, once);
  iov = &conn->ios[iov_index];

  memcpy(iov->iov_base, data, size);
  iov->iov_len = size;
  conn->data_left += size;

  return 0;
}
static inline int _HK_write_body(Request *req, size_t offset, size_t size) {
  if (size > req->body.size || offset > req->body.size)
    return -1;

  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  int iov_index = MP_expand(conn, 0, false);
  struct iovec *iov = &conn->ios[iov_index];
  struct iovec *rec = &conn->rec[iov_index];
  rec->iov_base = req->body.ptr + offset;
  rec->iov_len = size;
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;
  conn->data_left += rec->iov_len;
  return 0;
}
/*
static inline int _HK_mem(size_t size, HKMem *mem) {
  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  bool once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  size_t nblocks = round_to_blocks(size);
  int iov_index = MP_expand(conn, nblocks, once);
  struct iovec *iov = &conn->ios[iov_index];
  mem->ptr = iov->iov_base;
  mem->size = iov->iov_len;
  mem->_iov_index = iov_index;
  mem->_flags = (IN_POOL(iov->iov_base)) ? CF_IN_POOL : CF_IN_HEAP;
  return 0;
}

static inline void _HK_send(HKMem *mem, size_t size) {
  conn_t *conn = current_send;
  struct iovec *iov = &conn->ios[mem->_iov_index];
  iov->iov_len = size;
  conn->data_left += size;
}
  */
#endif#define _GNU_SOURCE
#ifndef UTILS_H
#define UTILS_H

#include "hunk.h"
#include <arpa/inet.h>
#include <fcntl.h>
#include <liburing.h>
#include <netdb.h>
#include <signal.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/poll.h>
#include <sys/prctl.h>
#include <sys/socket.h>
#include <sys/sysinfo.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

#define MP_BLOCK  4
#define MAX_CONNS 4096
#define KB        1024
#define NIOS      32

#define IN_POOL(ptr)                 ((void *)ptr >= pool.bpool && (void *)ptr <= (pool.bpool + (pool.npages * pool.pagesize)))
#define ALIGN_TO_PAGESIZE(buff_size) (((buff_size) + (pool.pagesize - 1)) & ~(pool.pagesize - 1))
#define BYTES_TO_BLOCKS(buff_size)   (((buff_size) + (MP_BLOCK - 1)) / MP_BLOCK)
#define CEIL_BLOCKS(nblocks)         ((nblocks + 63) & ~63)
#define CEIL_PAGES(size)             (((size) + ((pool.pagesize) - 1)) & ~((pool.pagesize) - 1))

#define BIT_IS_FREE(word, bit)   (((word) >> (bit)) & 1)
#define MARK_BIT_USED(word, bit) ((word) &= ~(1ULL << (bit)))
#define MARK_BIT_FREE(word, bit) ((word) |= (1ULL << (bit)))
#define FIND_FREE_BIT(word)      ((uint64_t)(word) & -(uint64_t)(word))
#define STRLEN(s)                (sizeof(s) - 1)

#define IOVEC_NBLOCKS (BYTES_TO_BLOCKS(NIOS * sizeof(struct iovec)))
#define MSG_NBLOCKS   (BYTES_TO_BLOCKS(sizeof(struct msghdr)))
#define ZC_RES        KB *KB

#define DEBUG 0
#if DEBUG
#define LOG(...) fprintf(logfd, __VA_ARGS__)
#else
#define LOG(...) ((void)0)
#endif

typedef enum UOP {
  WRITEV = IORING_OP_WRITEV,
  SENDMSG = IORING_OP_SENDMSG,
  RECVMSG = IORING_OP_RECVMSG,
  ACCEPT = IORING_OP_ACCEPT,
  SEND = IORING_OP_SEND,
  RECV = IORING_OP_RECV,
  SENDZC = IORING_OP_SEND_ZC,
  SENDMSGZC = IORING_OP_SENDMSG_ZC,
  PEEK = 50,
  FRECVMSG,
  INSPLICE,
  OUTSPLICE
} UOP;

typedef enum CFS {
  CF_IN_POOL = (1 << 0),       // Connection is in the pool
  CF_IN_HEAP = (1 << 1),       // Connection is in the heap
  CF_SKIP_SOCK = (1 << 2),     // Don't close the socket
  CF_USE_ONCE = (1 << 3),      // Destroy after using
  CF_HANDLER_READY = (1 << 4), // Ready to call the handler
} CFS;

typedef struct conn_t {
  // Socket file descriptor
  int fd;

  // Amount of data left in the current operation
  uint64_t data_left;

  // The index of the connection struct
  uint32_t cindex;

  // The last time the connection was readable
  uint64_t last_read;

  // The last time the connection was writeable
  uint64_t last_write;

  // The operation currently being processed
  uint8_t op;

  // Connection flags
  int flags;

  // Splice fd_in
  int in_fd;

  // Splice fd_out
  int out_fd;

  void *recv_conn;
  void *send_conn;

  struct iovec *ios;
  struct iovec *rec;
  uint16_t nios;

  struct msghdr *msg;
  uint16_t zc_notifs;

  uint16_t head_size;
} conn_t;

typedef struct MPool {
  // The allocated pool of blocks
  void *bpool;

  // The allocated pool of connections
  conn_t *cpool;

  // The size of the pool in pages
  uint32_t npages;

  // The size of the pool in blocks
  uint32_t nblocks;

  // The locations of each page in the pool
  void **blocks;

  // The availability of each block
  uint64_t *freebs;

  // The locations of each conn in the pool
  conn_t **conns;

  // The availability of each conn
  uint64_t *freecs;

  // Clean up callback function
  void (*callback)(conn_t *conn);

  // The page size used
  uint32_t pagesize;

  // Socket read timeout
  uint32_t rtimeout;

  // Socket write timeout
  uint32_t wtimeout;
} MPool;

extern int pipe_sz;
extern int pipe_in, pipe_out, nullfd;
extern FILE *logfd;
extern struct io_uring ring;
extern MPool pool;
extern conn_t *current_recv;
extern conn_t *current_send;

/*
 * Prepare and submit a recv uring op
 */
static inline int urecv(conn_t *conn, void *buffer, size_t buff_size, int flags) {
  if (!conn || conn->fd == -1)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (flags == MSG_PEEK) ? PEEK : RECV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;

  io_uring_prep_recv(sqe, conn->fd, buffer, buff_size, flags);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a multi-shot accept uring op
 */
static inline int umaccept(int listenfd) {
  if (listenfd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = ACCEPT;
  io_uring_prep_multishot_accept(sqe, listenfd, NULL, NULL, SOCK_NONBLOCK);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a splice uring op
 */
static inline int usplice(conn_t *conn, int fd_in, int64_t off_in, int fd_out, int64_t off_out, size_t len) {
  if (!len || !conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = (__u64)conn;
  io_uring_prep_splice(sqe, fd_in, off_in, fd_out, off_out, len, 0);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a writev uring op
 */
static inline int uwritev(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = WRITEV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  io_uring_prep_writev(sqe, conn->fd, &conn->ios[iov_index], nios, -1);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a send uring op
 */
static inline int usend(conn_t *conn, char *res_buff, size_t buff_size, bool zc) {
  if (!conn || conn->fd <= 0 || buff_size == 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (zc) ? SENDZC : SEND;
  conn->data_left = buff_size;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  if (zc)
    io_uring_prep_send_zc(sqe, conn->fd, res_buff, buff_size, 0, 0);
  else
    io_uring_prep_send(sqe, conn->fd, res_buff, buff_size, 0);
  return io_uring_submit(&ring);
}

static inline int ufrecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = FRECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;

  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, rec->iov_len);
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int urecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = RECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int usendmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  bool zc = (conn->data_left > ZC_RES) ? true : false;
  conn->op = (zc) ? SENDMSGZC : SENDMSG;

  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  if (zc) {
    io_uring_prep_sendmsg_zc(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
    conn->zc_notifs++;
  } else {
    io_uring_prep_sendmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  }
  return io_uring_submit(&ring);
}

/*
 * Create and initialize a server socket
 */
static inline int tcp_listen(uint16_t port) {
  int enable;
  int listenfd;
  if ((listenfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    return -1;

  int flags = fcntl(listenfd, F_GETFL, 0);
  fcntl(listenfd, F_SETFL, flags | O_NONBLOCK);
  struct sockaddr_in servaddr;
  memset(&servaddr, 0, sizeof(servaddr));
  servaddr.sin_family = AF_INET;
  servaddr.sin_addr.s_addr = INADDR_ANY;
  servaddr.sin_port = htons(port);

  enable = 1;
  if (setsockopt(listenfd, SOL_SOCKET, SO_REUSEPORT, &enable, sizeof(enable)) < 0)
    return -1;

  if (bind(listenfd, (struct sockaddr *)&servaddr, sizeof(servaddr)) < 0)
    return -1;

  if (listen(listenfd, SOMAXCONN) < 0)
    return -1;

  return listenfd;
}

/*
 * Calculate the difference between two pointers
 */
static inline uintptr_t ptr_diff(uintptr_t p1, uintptr_t p2) { return (uintptr_t)(p1 > p2) ? (p1 - p2) : (p2 - p1); }

static inline size_t get_nroutes(Route *routes) {
  Route *route;
  for (size_t i = 0;; i++) {
    route = &routes[i];
    if (!route->path && !route->handler && !route->method)
      return i;
  }
}

static inline long get_content_length(char *src, char *end) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return -1;
    key = line;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, "Content-Length") != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;

    *line_end = '\0';
    long res = atol(value);
    *line_end = '\r';

    return res;
  }
  return -1;
}

static inline bool have_header(char *src, char *end, const char *header_key, const char *header_value) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    key = line;
    while (*key == ' ')
      key++;
    while (*header_key == ' ')
      header_key++;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return false;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, header_key) != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;
    while (*header_value == ' ')
      header_value++;

    *line_end = '\0';
    bool res = (strcasecmp(value, header_value) == 0);
    *line_end = '\r';

    return res;
  }

  return false;
}

static inline const char *method_str(Method method) {
  switch (method) {
  case GET:
    return "GET";
    break;
  case HEAD:
    return "HEAD";
    break;
  case POST:
    return "POST";
    break;
  case PUT:
    return "PUT";
    break;
  case DELETE:
    return "DELETE";
    break;
  case CONNECT:
    return "CONNECT";
    break;
  case OPTIONS:
    return "OPTIONS";
    break;
  case TRACE:
    return "TRACE";
    break;
  case PATCH:
    return "PATCH";
    break;
  default:
    return NULL;
  }
}

static inline uint8_t method_len(Method method) {
  switch (method) {
  case GET:
    return 3;
    break;
  case HEAD:
    return 4;
    break;
  case POST:
    return 4;
    break;
  case PUT:
    return 3;
    break;
  case DELETE:
    return 6;
    break;
  case CONNECT:
    return 7;
    break;
  case OPTIONS:
    return 7;
    break;
  case TRACE:
    return 5;
    break;
  case PATCH:
    return 5;
    break;
  default:
    return 0;
  }
}

static inline size_t round_to_blocks(size_t size) {
  size_t nblocks = BYTES_TO_BLOCKS(size);
  nblocks = CEIL_BLOCKS(nblocks);
  return nblocks;
}

/*
 * Count the digits in unsigned 64-bit int
 */
static inline int countd(uint64_t num) {
  if (num < 10ULL)
    return 1;
  if (num < 100ULL)
    return 2;
  if (num < 1000ULL)
    return 3;
  if (num < 10000ULL)
    return 4;
  if (num < 100000ULL)
    return 5;
  if (num < 1000000ULL)
    return 6;
  if (num < 10000000ULL)
    return 7;
  if (num < 100000000ULL)
    return 8;
  if (num < 1000000000ULL)
    return 9;
  if (num < 10000000000ULL)
    return 10;
  if (num < 100000000000ULL)
    return 11;
  if (num < 1000000000000ULL)
    return 12;
  if (num < 10000000000000ULL)
    return 13;
  if (num < 100000000000000ULL)
    return 14;
  if (num < 1000000000000000ULL)
    return 15;
  if (num < 10000000000000000ULL)
    return 16;
  if (num < 100000000000000000ULL)
    return 17;
  if (num < 1000000000000000000ULL)
    return 18;
  if (num < 10000000000000000000ULL)
    return 19;
  return 20;
}

/*
 * Get the time elabsed in ms
 */
static inline uint64_t get_time() {
  struct timespec ts;
  clock_gettime(CLOCK_MONOTONIC, &ts);
  return (uint64_t)(ts.tv_sec) * 1000 + (ts.tv_nsec / 1000000);
}

static inline FILE *log_init(const char *path) {
  FILE *res = fopen(path, "a+");
  setvbuf(res, NULL, _IONBF, 0);
  return res;
}

static inline int16_t pollevs(int connfd) {
  struct pollfd pfd;
  pfd.fd = connfd;
  pfd.events = POLLIN | POLLOUT | POLLERR;
  int res = poll(&pfd, 1, 0);
  if (res < 0)
    return POLLERR;
  return pfd.revents;
}

// FIXME This needs to be updated
static inline conn_t *MP_use_once(size_t nblocks, int fd) {

  void *mem = malloc(sizeof(conn_t) + 8 + (IOVEC_NBLOCKS * MP_BLOCK));
  struct conn_t *conn = (conn_t *)mem;
  memset(conn, 0, sizeof(conn_t));
  conn->ios = mem + sizeof(conn_t) + 8;

  if (nblocks > 0) {
    struct iovec *iov = &conn->ios[conn->nios++];
    mem = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (mem == MAP_FAILED)
      return NULL;
    iov->iov_base = mem;
    iov->iov_len = ALIGN_TO_PAGESIZE(nblocks * MP_BLOCK);
  }

  conn->flags |= CF_IN_HEAP;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;

  return conn;
}

static inline int find_freec() {
  uint64_t *word;
  size_t map_size = (sizeof(uint64_t) * 8);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    word = &pool.freecs[i / map_size];

    if (*word == 0) { // All used
      i += (map_size - 1);
      continue;
    }

    i += __builtin_ctzll(*word);
    MARK_BIT_USED(*word, i);
    return i;
  }

  return -1;
}

static inline int MP_init(size_t npages) {
  if (!npages)
    return -1;

  /*** Setup ***/
  pool.npages = npages;
  pool.pagesize = sysconf(_SC_PAGESIZE);

  /*** Pool ***/
  pool.bpool = mmap(NULL, pool.npages * pool.pagesize, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  if (pool.bpool == MAP_FAILED)
    return -1;
  pool.nblocks = (pool.npages * pool.pagesize) / MP_BLOCK;

  /*** Blocks ***/
  pool.blocks = malloc(sizeof(void *) * pool.nblocks);
  if (!pool.blocks)
    return -1;
  for (size_t i = 0; i < pool.nblocks; i++)
    pool.blocks[i] = pool.bpool + (i * MP_BLOCK);

  /*** Freebs ***/
  // if (posix_memalign((void **)&pool.freebs, 64, bitmap_size * sizeof(uint64_t)) < 0)
  size_t bitmap_size = (pool.nblocks + 63) / 64;
  pool.freebs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freebs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freebs[i] = UINT64_MAX;

  /*** Cpool ***/
  pool.cpool = (conn_t *)malloc(sizeof(conn_t) * MAX_CONNS);
  if (!pool.cpool)
    return -1;

  /*** Conns ***/
  pool.conns = (conn_t **)malloc(sizeof(conn_t *) * MAX_CONNS);
  if (!pool.conns)
    return -1;
  size_t conn_size = sizeof(conn_t);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    pool.conns[i] = (conn_t *)((char *)pool.cpool + (i * conn_size));
    pool.conns[i]->fd = -1;
    pool.conns[i]->in_fd = -1;
    pool.conns[i]->out_fd = -1;
  }

  /*** Freecs ***/
  bitmap_size = (MAX_CONNS + 63) / 64;
  pool.freecs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freecs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freecs[i] = UINT64_MAX;

  return 0;
}

static inline int MP_use_blks(size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t max_start = pool.nblocks - nblocks;
  size_t full_chunks = (nblocks / 64) * 64;

  for (size_t i = 0, c = 0; i <= max_start; i++, c++) {
    bool free = true;

    for (size_t j = 0; j < full_chunks; j += 64) {
      size_t word_index = (i + j) / 64;
      if (pool.freebs[word_index] != UINT64_MAX) {
        free = false;
        i += 63;
        break;
      }
    }

    for (size_t j = full_chunks; j < nblocks; j++) {
      size_t bit_index = i + j;
      size_t word_index = bit_index / 64;
      size_t bit_in_word = bit_index % 64;

      if (!BIT_IS_FREE(pool.freebs[word_index], bit_in_word)) {
        free = false;
        i += j;
        break;
      }
    }

    if (free) {
      for (size_t j = 0; j < full_chunks; j += 64) {
        size_t word_index = (i + j) / 64;
        pool.freebs[word_index] = 0;
      }

      for (size_t j = full_chunks; j < nblocks; j++) {
        size_t bit_index = i + j;
        size_t word_index = bit_index / 64;
        size_t bit_in_word = bit_index % 64;

        MARK_BIT_USED(pool.freebs[word_index], bit_in_word);
      }

      return i;
    }
  }

  return -1;
}

static inline int MP_free_blks(size_t bindex, size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t full_chunks = (nblocks / 64) * 64;
  for (size_t i = 0; i < full_chunks; i += 64) {
    size_t word_index = (bindex + i) / 64;
    pool.freebs[word_index] = UINT64_MAX;
  }

  for (size_t i = full_chunks; i < nblocks; i++) {
    size_t bit_index = bindex + i;
    size_t word_index = bit_index / 64;
    size_t bit_in_word = bit_index % 64;

    MARK_BIT_FREE(pool.freebs[word_index], bit_in_word);
  }

  memset(pool.blocks[bindex], 0, nblocks * MP_BLOCK);
  return 0;
}

static inline conn_t *MP_use(size_t nblocks, int fd, bool once) {
  if (fd <= 0)
    return NULL;
  if (once)
    return MP_use_once(nblocks, fd);

  int cindex = find_freec();
  if (cindex < 0) {
    LOG("Err: cindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  conn_t *conn = pool.conns[cindex];

  int ios_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (ios_bindex < 0) {
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }

  struct iovec *ios = pool.blocks[ios_bindex];
  conn->ios = ios;

  int rec_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (rec_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct iovec *rec = pool.blocks[rec_bindex];
  conn->rec = rec;

  int msg_bindex = MP_use_blks(MSG_NBLOCKS);
  if (msg_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct msghdr *msg = pool.blocks[msg_bindex];
  conn->msg = msg;

  if (nblocks > 0) {
    int bindex = MP_use_blks(nblocks);
    if (bindex < 0) {
      MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
      MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
      MP_free_blks(msg_bindex, IOVEC_NBLOCKS);
      MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
      LOG("Err: bindex < 0; will use MP_use_once\n");
      return MP_use_once(nblocks, fd);
    }

    size_t iov_index = conn->nios++;
    struct iovec *iov = &conn->ios[iov_index];
    struct iovec *rec = &conn->rec[iov_index];
    iov->iov_base = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
  }

  conn->msg->msg_iov = conn->ios;
  conn->msg->msg_iovlen = conn->nios;
  conn->cindex = cindex;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;
  return conn;
}

static inline void MP_shed(conn_t *conn, size_t iov_index, size_t nios) {
  struct iovec *iov, *rec;
  size_t bindex, nblocks, index;

  for (size_t i = 0; i < nios; i++) {
    index = iov_index + i;
    iov = &conn->ios[index];
    rec = &conn->rec[index];
    if (!rec || !rec->iov_base)
      continue;
    if (!IN_POOL(rec->iov_base)) {
      munmap(rec->iov_base, rec->iov_len / pool.pagesize);
    } else {
      bindex = ptr_diff((uintptr_t)rec->iov_base, (uintptr_t)pool.bpool) / MP_BLOCK;
      nblocks = rec->iov_len / MP_BLOCK;
      MP_free_blks(bindex, nblocks);
    }
    memset(iov, 0, sizeof(struct iovec));
    memset(rec, 0, sizeof(struct iovec));
    conn->nios--;
  }
}

static inline int MP_expand(conn_t *conn, size_t nblocks, bool once) {
  void *bptr;
  int iov_index, bindex;
  struct iovec *iov, *rec;

  iov_index = conn->nios++;
  iov = &conn->ios[iov_index];
  rec = &conn->rec[iov_index];

  if (nblocks == 0)
    return iov_index;

  if (once) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_base = bptr;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
    return iov_index;
  }

  bindex = MP_use_blks(nblocks);
  if (bindex < 0) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_len = iov->iov_len;
  } else {
    bptr = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_len = iov->iov_len;
  }

  iov->iov_base = bptr;
  rec->iov_base = iov->iov_base;
  return iov_index;
}

static inline int MP_free(conn_t *conn) {
  if (!conn)
    return -1;
  size_t bindex, nblocks;
  uint64_t *word;

  MP_shed(conn, 0, conn->nios);
  if (conn->flags & CF_IN_HEAP) {
    if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
      close(conn->fd);
    free(conn);
    return 0;
  }

  word = &pool.freecs[conn->cindex / 64];
  if (conn->cindex > MAX_CONNS)
    return -1;
  else if (BIT_IS_FREE(*word, conn->cindex))
    return 0;

  bindex = ptr_diff((uintptr_t)conn->ios, (uintptr_t)pool.bpool) / MP_BLOCK;
  nblocks = IOVEC_NBLOCKS;
  MP_free_blks(bindex, nblocks);

  bindex = ptr_diff((uintptr_t)conn->rec, (uintptr_t)pool.bpool) / MP_BLOCK;
  MP_free_blks(bindex, nblocks);

  if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
    close(conn->fd);

  MARK_BIT_FREE(*word, conn->cindex);
  memset(conn, 0, sizeof(conn_t));
  conn->fd = -1;
  conn->in_fd = -1;
  conn->out_fd = -1;
  return 0;
}

static inline void MP_clear(conn_t *conn) {
  conn_t *recv_conn = conn->recv_conn;
  conn_t *send_conn = conn->send_conn;
  if (recv_conn)
    MP_free(recv_conn);
  if (send_conn)
    MP_free(send_conn);
}

static inline void MP_exit(MPool *pool) {
  munmap(pool->bpool, pool->npages);
  free(pool->cpool);
  free(pool->blocks);
  free(pool->conns);
  free(pool->freebs);
  free(pool->freecs);
}

static inline void MP_timeout() {
  conn_t *conn;
  int16_t res;
  uint64_t now;
  size_t windex = 0;
  uint64_t *word = &pool.freecs[0];
  for (size_t i = 0; i < MAX_CONNS; i++) {
    if ((i / 64) < windex)
      word = &pool.freecs[++windex];

    if (*word == UINTMAX_MAX) {
      i = (i / 64) * 64 + 64;
      continue;
    }

    conn = pool.conns[i];
    if (!conn || conn->fd == -1)
      continue;

    res = pollevs(conn->fd);

    now = get_time();
    if (res & POLLERR) {
      MP_clear(conn);
      continue;
    }
    if (res & POLLIN) {
      if (pool.rtimeout > 0 && (now - conn->last_read) >= pool.rtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (res & POLLOUT) {
      if (pool.wtimeout > 0 && (now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (!(res & POLLIN || res & POLLOUT)) {
      if ((pool.rtimeout > 0 && now - conn->last_read) >= pool.rtimeout
          || (pool.wtimeout > 0 && now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
  }
}

/*
 * Calculate the length of a status string
 */
static inline size_t status_len(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return 8;
  case STATUSSWITCHINGPROTOCOLS:
    return 19;
  case STATUSPROCESSING:
    return 10;
  case STATUSEARLYHINTS:
    return 11;
  case STATUSOK:
    return 2;
  case STATUSCREATED:
    return 7;
  case STATUSACCEPTED:
    return 8;
  case STATUSNONAUTHORITATIVE:
    return 29;
  case STATUSNOCONTENT:
    return 10;
  case STATUSRESETCONTENT:
    return 13;
  case STATUSPARTIALCONTENT:
    return 15;
  case STATUSMULTISTATUS:
    return 12;
  case STATUSALREADYREPORTED:
    return 16;
  case STATUSIMUSED:
    return 7;
  case STATUSMULTIPLECHOICES:
    return 16;
  case STATUSMOVEDPERMANENTLY:
    return 17;
  case STATUSFOUND:
    return 5;
  case STATUSSEEOTHER:
    return 9;
  case STATUSNOTMODIFIED:
    return 12;
  case STATUSUSEPROXY:
    return 9;
  case STATUSTEMPORARYREDIRECT:
    return 18;
  case STATUSPERMANENTREDIRECT:
    return 18;
  case STATUSBADREQUEST:
    return 11;
  case STATUSUNAUTHORIZED:
    return 12;
  case STATUSPAYMENTREQUIRED:
    return 16;
  case STATUSFORBIDDEN:
    return 9;
  case STATUSNOTFOUND:
    return 9;
  case STATUSMETHODNOTALLOWED:
    return 18;
  case STATUSNOTACCEPTABLE:
    return 14;
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return 29;
  case STATUSREQUESTTIMEOUT:
    return 15;
  case STATUSCONFLICT:
    return 8;
  case STATUSGONE:
    return 4;
  case STATUSLENGTHREQUIRED:
    return 15;
  case STATUSPRECONDITIONFAILED:
    return 19;
  case CONTENTTOOLARGE:
    return 17;
  case STATUSURITOOLONG:
    return 12;
  case STATUSUNSUPPORTEDMEDIATYPE:
    return 22;
  case STATUSRANGENOTSATISFIABLE:
    return 21;
  case STATUSEXPECTATIONFAILED:
    return 18;
  case STATUSMISDIRECTEDREQUEST:
    return 19;
  case STATUSUNPROCESSABLECONTENT:
    return 21;
  case STATUSLOCKED:
    return 6;
  case STATUSFAILEDDEPENDENCY:
    return 17;
  case STATUSTOOEARLY:
    return 9;
  case STATUSUPGRADEREQUIRED:
    return 16;
  case STATUSPRECONDITIONREQUIRED:
    return 21;
  case STATUSTOOMANYREQUESTS:
    return 17;
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return 31;
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return 29;
  case STATUSInternalServerError:
    return 21;
  case STATUSNOTIMPLEMENTED:
    return 15;
  case STATUSBADGATEWAY:
    return 11;
  case STATUSSERVICEUNAVAILABLE:
    return 19;
  case STATUSGATEWAYTIMEOUT:
    return 15;
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return 26;
  case STATUSVARIANTALSONEGOTIATES:
    return 23;
  case STATUSINSUFFICIENTSTORAGE:
    return 20;
  case STATUSLOOPDETECTED:
    return 13;
  case STATUSNOTEXTENDED:
    return 12;
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return 31;
  default:
    return 0;
  }
}

/*
 * Return the status code string as string literal
 */
static inline char *status_str(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return "Continue";
  case STATUSSWITCHINGPROTOCOLS:
    return "Switching Protocols";
  case STATUSPROCESSING:
    return "Processing";
  case STATUSEARLYHINTS:
    return "Early Hints";
  case STATUSOK:
    return "OK";
  case STATUSCREATED:
    return "Created";
  case STATUSACCEPTED:
    return "Accepted";
  case STATUSNONAUTHORITATIVE:
    return "Non-Authoritative Information";
  case STATUSNOCONTENT:
    return "No Content";
  case STATUSRESETCONTENT:
    return "Reset Content";
  case STATUSPARTIALCONTENT:
    return "Partial Content";
  case STATUSMULTISTATUS:
    return "Multi-Status";
  case STATUSALREADYREPORTED:
    return "Already Reported";
  case STATUSIMUSED:
    return "Im Used";
  case STATUSMULTIPLECHOICES:
    return "Multiple Choices";
  case STATUSMOVEDPERMANENTLY:
    return "Moved Permanently";
  case STATUSFOUND:
    return "Found";
  case STATUSSEEOTHER:
    return "See Other";
  case STATUSNOTMODIFIED:
    return "Not Modified";
  case STATUSUSEPROXY:
    return "Use Proxy";
  case STATUSTEMPORARYREDIRECT:
    return "Temporary Redirect";
  case STATUSPERMANENTREDIRECT:
    return "Permanent Redirect";
  case STATUSBADREQUEST:
    return "Bad Request";
  case STATUSUNAUTHORIZED:
    return "Unauthorized";
  case STATUSPAYMENTREQUIRED:
    return "Payment Required";
  case STATUSFORBIDDEN:
    return "Forbidden";
  case STATUSNOTFOUND:
    return "Not Found";
  case STATUSMETHODNOTALLOWED:
    return "Method Not Allowed";
  case STATUSNOTACCEPTABLE:
    return "Not Acceptable";
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return "Proxy Authentication Required";
  case STATUSREQUESTTIMEOUT:
    return "Request Timeout";
  case STATUSCONFLICT:
    return "Conflict";
  case STATUSGONE:
    return "Gone";
  case STATUSLENGTHREQUIRED:
    return "Length Required";
  case STATUSPRECONDITIONFAILED:
    return "Precondition Failed";
  case CONTENTTOOLARGE:
    return "Content Too Large";
  case STATUSURITOOLONG:
    return "URI Too Long";
  case STATUSUNSUPPORTEDMEDIATYPE:
    return "Unsupported Media Type";
  case STATUSRANGENOTSATISFIABLE:
    return "Range Not Satisfiable";
  case STATUSEXPECTATIONFAILED:
    return "Expectation Failed";
  case STATUSMISDIRECTEDREQUEST:
    return "Misdirected Request";
  case STATUSUNPROCESSABLECONTENT:
    return "Unprocessable Content";
  case STATUSLOCKED:
    return "Locked";
  case STATUSFAILEDDEPENDENCY:
    return "Failed Dependency";
  case STATUSTOOEARLY:
    return "Too Early";
  case STATUSUPGRADEREQUIRED:
    return "Upgrade Required";
  case STATUSPRECONDITIONREQUIRED:
    return "Precondition Required";
  case STATUSTOOMANYREQUESTS:
    return "Too Many Requests";
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return "Request Header Fields Too Large";
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return "Unavailable For Legal Reasons";
  case STATUSInternalServerError:
    return "Internal Server Error";
  case STATUSNOTIMPLEMENTED:
    return "Not Implemented";
  case STATUSBADGATEWAY:
    return "Bad Gateway";
  case STATUSSERVICEUNAVAILABLE:
    return "Service Unavailable";
  case STATUSGATEWAYTIMEOUT:
    return "Gateway Timeout";
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return "HTTP Version Not Supported";
  case STATUSVARIANTALSONEGOTIATES:
    return "Variant Also Negotiates";
  case STATUSINSUFFICIENTSTORAGE:
    return "Insufficient Storage";
  case STATUSLOOPDETECTED:
    return "Loop Detected";
  case STATUSNOTEXTENDED:
    return "Not Extended";
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return "Network Authentication Required";
  default:
    return 0;
  }
}

/*
 * Return true if routes match
 */
static inline bool route_equ(Route *route, Request *req) {
  return route->method == req->method && strncmp(route->path, req->path, strlen(route->path)) == 0;
}

/*
 * Return the matching route index on success. -1 on failure
 */
static inline int match_route(Server *serv, Request *req) {
  for (size_t i = 0; i < serv->_nroutes; i++) {
    Route route = serv->routes[i];
    if (!req->path || !route.path)
      continue;
    if (route_equ(&route, req))
      return i;
    else if (req->method == HEAD && route.method == GET && strcmp(route.path, req->path) == 0)
      return i;
  }
  return -1;
}

/*
 * Return true if the response should contain the Content-Length header
 */
static inline bool should_have_content_length(Request *req, ResWriter *res) {
  return (req->method != CONNECT              // CONNECT request
          && res->status != STATUSNOCONTENT   // 204 response
          && res->status != STATUSNOTMODIFIED // 304 response
          && res->status >= 200);             // 1xx response
}

/*
 * Format http response from the ResWriter.
 * Return response size on success, 0 on failure.
 */
static inline size_t fmt_res(Request *req, ResWriter *res, char *buffer, size_t buffer_size) {
  if (!res || !buffer || buffer_size == 0)
    return 0;

  size_t res_len, total = 0;
  char *dst = buffer;
  size_t maxlen = buffer_size;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t body_length = res->len;

  res_len = snprintf(dst, maxlen, "HTTP/1.1 %d %s", (int)res->status, status_str(res->status));
  total += res_len;
  dst += res_len;
  maxlen -= res_len;

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    res_len = snprintf(dst, maxlen, "\r\n%s: %s", header->key, header->value);
    total += res_len;
    dst += res_len;
    maxlen -= res_len;
  }

  if (have_content_length) {
    res_len = snprintf(dst, maxlen, "\r\nContent-Length: %lu", body_length);
    total += res_len, dst += res_len, maxlen -= res_len;
  }

  memcpy(dst, "\r\n\r\n", 4);
  total += 4, dst += 4, maxlen -= 4;

  return total;
}

static inline size_t res_len(Request *req, ResWriter *res) {
  if (!req || !res)
    return 0;

  if (!res->status)
    res->status = STATUSOK;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t result = 0;
  result += STRLEN("HTTP/1.1 ");     // HTTP version
  result += 4;                       // Status code + space
  result += status_len(res->status); // Status name

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    result += 2;                       // "\r\n"
    result += strlen(header->key) + 2; // Header key + ':' + space
    result += strlen(header->value);   // header value
  }

  if (have_content_length) {
    result += 2;                          // "\r\n"
    result += STRLEN("Content-Length: "); // Header key
    result += countd(res->len);           // Header value
  }

  result += 4; // "\r\n\r\n"

  return result;
}

static inline int send_empty_res(Status status) {
  size_t res_len = STRLEN("HTTP/1.1 ")        // HTTP version
                   + countd((uint64_t)status) // status code
                   + 1                        // space
                   + (int)status_len(status)  // status string
                   + 4;                       // \r\n\r\n

  conn_t *conn = current_send;
  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, res_len);
  if (snprintf((char *)rec->iov_base, res_len + 1, "HTTP/1.1 %d %s\r\n\r\n", (int)status, status_str(status))
      != (int)res_len)
    return -1;

  return usendmsg(conn, 0, 1);
}

static inline ssize_t read_socket(int sockfd, size_t len) {
  if (len == 0 || sockfd <= 0)
    return 0;
  char buff[1024 * 8];
  return read(sockfd, buff, 1024 * 8);
}

static inline int read_method(Method *method, void *src) {
  if (memcmp(src, "GET", 3) == 0)
    *method = GET;
  else if (memcmp(src, "POST", 4) == 0)
    *method = POST;
  else if (memcmp(src, "HEAD", 4) == 0)
    *method = HEAD;
  else if (memcmp(src, "PUT", 3) == 0)
    *method = PUT;
  else if (memcmp(src, "DELETE", 6) == 0)
    *method = DELETE;
  else if (memcmp(src, "CONNECT", 7) == 0)
    *method = CONNECT;
  else if (memcmp(src, "OPTIONS", 7) == 0)
    *method = OPTIONS;
  else if (memcmp(src, "TRACE", 5) == 0)
    *method = TRACE;
  else if (memcmp(src, "PATCH", 5) == 0)
    *method = PATCH;
  else
    return -1;

  return 0;
}

static inline int sendmsg_res(Request *req, ResWriter *res) {
  conn_t *conn;
  size_t head_size, res_size;
  struct iovec *iov;

  conn = current_send;
  iov = &conn->ios[0];
  head_size = res_len(req, res);
  if (head_size == 0)
    return -1;

  conn->data_left += head_size;
  res_size = fmt_res(req, res, iov->iov_base, (head_size + 1));
  if (res_size != head_size)
    return -1;
  iov->iov_len = res_size;

  return usendmsg(conn, 0, conn->nios);
}

static inline int read_req(Request *req, char *req_buffer) {
  if (!req_buffer)
    return -1;
  /*** Method ***/
  char *sep = strchr(req_buffer, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }
  *sep = '\0';
  if (read_method(&req->method, req_buffer) < 0)
    return -1;

  /*** Path ***/
  char *fullpath = sep + 1;
  sep = strchr(fullpath, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }

  *sep = '\0';
  req->path = fullpath;
  /*** Params ***/
  char *paramStart = strchr(fullpath, '?');
  if (paramStart) {
    *paramStart++ = '\0';
    int params_count = 0;
    params_count = HK_parse_params(paramStart, req->params, MAX_URL_PARAMETERS);
    if (params_count > 0)
      req->params_count = params_count;
    else
      req->params_count = 0;
  } else {
    req->params = NULL;
    req->params_count = 0;
  }

  /*** Headers ***/
  char *headStart = strstr(sep + 1, "\r\n");
  char *headEnd = strstr(sep + 1, "\r\n\r\n");
  if (!headStart) {
    LOG("read_req: !headStart\n");
    return -1;
  };

  memset(headStart, 0, 2);
  headStart += 2;
  memset(headEnd, 0, 4);
  headEnd += 4;

  int headers_count = HK_parse_headers(headStart, req->headers, MAX_REQ_HEADERS);
  if (headers_count <= 0)
    return -1;
  req->headers_count = headers_count;

  /*** Host ***/
  int index = HK_get_header(req, "Host");
  if (index < 0)
    return -1;
  char *host = req->headers[index].value;
  req->hostname = host;

  /*** Port ***/
  char *colon = strchr(host, ':');
  if (colon) {
    *colon++ = '\0';
    req->port = atoi(colon);
  } else {
    req->port = PORT;
  }
  return 0;
}
static inline int process_req(Server *serv, conn_t *conn) {
  if (!conn || conn->fd == -1)
    return -1;

  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;
  if (read_req(&req, conn->ios[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    LOG("Err: route_index == -1\n");
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;
  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  sendmsg_res(&req, &res);

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int new_conn(int connfd) {
  if (connfd <= 0)
    return -1;

  current_recv = MP_use(KB * 2, connfd, false);
  current_send = MP_use(KB * 2, connfd, false);

  current_recv->recv_conn = current_recv;
  current_recv->send_conn = current_send;

  current_send->send_conn = current_send;
  current_send->recv_conn = current_recv;

  conn_t *conn = current_recv;
  if (ufrecvmsg(conn, 0, 1) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

static inline int resubmit_sendmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return usendmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int resubmir_recvmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    // FIXME the len should be increased
    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return urecvmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int handle_sendmsg_complete(conn_t *conn) {
  struct iovec *iov, *rec;

  MP_shed(conn, 1, conn->nios - 1);
  iov = &conn->ios[0];
  rec = &conn->rec[0];
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;

  return ufrecvmsg(conn->recv_conn, 0, 1);
}

static inline int handle_sendmsg(conn_t *conn, int res, bool zc) {
  if (!conn || conn->fd == -1)
    return -1;

  conn->data_left -= res;
  if (conn->data_left > 0)
    return resubmit_sendmsg(conn, res);

  if (zc)
    return 0;

  return handle_sendmsg_complete(conn);
}

static inline int handle_insplice(conn_t *conn) {
  conn->op = OUTSPLICE;
  return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
}
static inline int handle_outsplice(conn_t *conn, int res) {
  conn->data_left -= res;
  if (conn->data_left > 0) {
    conn->op = INSPLICE;
    return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
  }

  conn_t *recv_conn = conn->recv_conn;
  struct iovec *iov = &recv_conn->ios[0];
  memset(iov->iov_base, 0, iov->iov_len);
  if (urecv(recv_conn, iov->iov_base, iov->iov_len, MSG_PEEK) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

/*
static inline int handle_recv(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  void *bptr = conn->ios[0].iov_base;
  void *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  void *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  return process_req(serv, conn);
}
*/
static inline int find_route(Server *serv, char *bptr) {
  Request req = {0};
  if (read_method(&req.method, bptr) < 0) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  };
  char *space = strchr(bptr, ' ');
  req.path = (space + 1);
  space = strchr(req.path, ' ');
  *space = '\0';
  int route_index = match_route(serv, &req);
  *space = ' ';
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }
  return route_index;
}

static inline int run_handler(Server *serv, conn_t *conn, bool uses_body) {
  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;

  if (read_req(&req, conn->rec[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  if (uses_body) {
    int h_index = HK_get_header(&req, "Content-Length");
    long body_size = atol(req.headers[h_index].value);
    if (body_size >= 0) {
      req.body.ptr = conn->rec[1].iov_base;
      req.body.size = body_size;
    } else {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    }
  }

  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  if (sendmsg_res(&req, &res) < 0)
    return -1;

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int handle_frecvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  char *bptr = (char *)conn->ios[0].iov_base;
  char *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  char *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  size_t head_size = (headEnd + 4) - bptr;
  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  int route_index = find_route(serv, bptr);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  bool uses_body = serv->routes[route_index].uses_body;
  long body_size = get_content_length(headstart + 2, headEnd + 4);
  if (body_size == -1) {
    if (uses_body) {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    } else {
      body_size = 0;
    }
  }

  conn->head_size = head_size;
  if (!uses_body) {
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  if (res == (int)(head_size + body_size)) {
    size_t iov_index = MP_expand(conn, round_to_blocks(body_size), false);
    memcpy(conn->rec[iov_index].iov_base, headEnd + 4, body_size);
    conn->ios[iov_index].iov_len = body_size;
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  conn->data_left = body_size - (res - head_size);
  bool once = ((size_t)body_size > (size_t)((pool.nblocks * MP_BLOCK) / 10));
  size_t iov_index = MP_expand(conn, round_to_blocks(body_size), once);
  memcpy(conn->rec[iov_index].iov_base, headEnd + 4, (res - head_size));
  conn->ios[iov_index].iov_base += (res - head_size);

  return urecvmsg(conn, iov_index, 1);
}

static inline int handle_recvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  if (conn->data_left > 0) {
    conn->data_left -= res;
    if (conn->data_left == 0) {
      conn->flags &= CF_HANDLER_READY;
      return run_handler(serv, conn, true);
    }

    conn->flags &= ~CF_HANDLER_READY;
    conn->ios[1].iov_base += res;
    return urecvmsg(conn, 1, 1);
  }

  conn->flags &= CF_HANDLER_READY;
  return run_handler(serv, conn, true);
}

static inline int serv_init(Server *serv) {
#if DEBUG
  logfd = log_init("log.txt");
  if (!logfd) {
    printf("log_init failed");
    return -1;
  }
#endif
  serv->_nroutes = get_nroutes(serv->routes);

  int pipefd[2];
  if (pipe(pipefd) < 0)
    return -1;
  pipe_in = pipefd[0];
  pipe_out = pipefd[1];
  nullfd = open("/dev/null", O_WRONLY);
  pipe_sz = fcntl(pipefd[0], F_GETPIPE_SZ);
  if (pipe_sz < 0)
    return -1;

  pool.rtimeout = serv->rtimeout;
  pool.wtimeout = serv->wtimeout;
  if (MP_init(MAX_CONNS * 8) < 0)
    return -1;
  LOG("pool initialized\n");

  if (io_uring_queue_init(MAX_CONNS, &ring, 0) < 0)
    return -1;
  LOG("uring initialized\n");

  int listenfd;
  if ((listenfd = tcp_listen(serv->port)) < 0)
    return -1;
  LOG("socket initialized\n");

  return umaccept(listenfd);
}

static inline int serv_listen(Server *serv) {
  // uint64_t last_check = get_time();
  while (true) {
    // uint64_t now = get_time();
    // if ((now - last_check) >= 200) {
    //   last_check = now;
    //   LOG("CM: CM_check ran\n");
    //   MP_timeout();
    // }

    LOG("SQ ready: %u, CQ ready: %u\n", io_uring_sq_ready(&ring), io_uring_cq_ready(&ring));
    struct io_uring_cqe *cqe;
    if (io_uring_wait_cqe(&ring, &cqe) < 0)
      continue;

    int res = cqe->res;
    LOG("res = %d\n", res);
    conn_t *conn = NULL;
    if (cqe->user_data > 100) {
      conn = (conn_t *)cqe->user_data;
      current_recv = (conn_t *)conn->recv_conn;
      current_send = (conn_t *)conn->send_conn;
    }

    if (res > 0) {
      if (cqe->user_data == ACCEPT) {
        LOG("new conn created\n");
        new_conn(res);
      } else if (conn && conn->fd != -1) {
        LOG("conn[%d]: conn.fd = %d; conn.op = %d\n", conn->cindex, conn->fd, conn->op);
        switch (conn->op) {
        case FRECVMSG:
          if (handle_frecvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case RECVMSG:
          if (handle_recvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case SENDMSG:
        case SENDMSGZC:
          // conn->last_write = get_time();
          bool zc = (conn->op == SENDMSGZC);
          if (handle_sendmsg(conn, res, zc) < 0)
            MP_clear(conn);
          break;
        case INSPLICE:
          if (handle_insplice(conn) < 0)
            MP_clear(conn);
          break;
        case OUTSPLICE:
          if (handle_outsplice(conn, res) < 0)
            MP_clear(conn);
          break;
        }
      }
    } else if (res == 0) {
      if (conn && conn->fd != -1) {
        switch (conn->op) {
        case SENDMSGZC:
          conn->zc_notifs--;
          if (conn->zc_notifs == 0 && handle_sendmsg_complete(conn) < 0)
            MP_clear(conn);
          break;
        case RECV:
          MP_clear(conn);
          break;
        }
      }
    } else {
      if (conn && conn->fd != -1) {
        if (res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR) {
          LOG("conn && conn->fd != -1 && res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR\n");
          MP_clear(conn);
        } else {
          LOG("res == -EAGAIN || res == -EWOULDBLOCK || res == -EINTR\n");
          conn = conn->recv_conn;
          struct iovec *iov = &conn->ios[0];
          memset(iov->iov_base, 0, iov->iov_len);
          if (urecv(conn, iov->iov_base, iov->iov_len, 0) < 0)
            MP_clear(conn);
        }
      }
    }

    LOG("uring operation seen\n");
    io_uring_cqe_seen(&ring, cqe);
  }

  io_uring_queue_exit(&ring);
  MP_exit(&pool);
  return 0;
}

/*** Helper ***/
static inline int _HK_write(void *data, size_t size) {
  size_t nblocks;
  int iov_index;
  conn_t *conn;
  struct iovec *iov;
  bool once;

  conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  nblocks = round_to_blocks(size);
  iov_index = MP_expand(conn, nblocks, once);
  iov = &conn->ios[iov_index];

  memcpy(iov->iov_base, data, size);
  iov->iov_len = size;
  conn->data_left += size;

  return 0;
}
static inline int _HK_write_body(Request *req, size_t offset, size_t size) {
  if (size > req->body.size || offset > req->body.size)
    return -1;

  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  int iov_index = MP_expand(conn, 0, false);
  struct iovec *iov = &conn->ios[iov_index];
  struct iovec *rec = &conn->rec[iov_index];
  rec->iov_base = req->body.ptr + offset;
  rec->iov_len = size;
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;
  conn->data_left += rec->iov_len;
  return 0;
}
/*
static inline int _HK_mem(size_t size, HKMem *mem) {
  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  bool once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  size_t nblocks = round_to_blocks(size);
  int iov_index = MP_expand(conn, nblocks, once);
  struct iovec *iov = &conn->ios[iov_index];
  mem->ptr = iov->iov_base;
  mem->size = iov->iov_len;
  mem->_iov_index = iov_index;
  mem->_flags = (IN_POOL(iov->iov_base)) ? CF_IN_POOL : CF_IN_HEAP;
  return 0;
}

static inline void _HK_send(HKMem *mem, size_t size) {
  conn_t *conn = current_send;
  struct iovec *iov = &conn->ios[mem->_iov_index];
  iov->iov_len = size;
  conn->data_left += size;
}
  */
#endif#define _GNU_SOURCE
#ifndef UTILS_H
#define UTILS_H

#include "hunk.h"
#include <arpa/inet.h>
#include <fcntl.h>
#include <liburing.h>
#include <netdb.h>
#include <signal.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/poll.h>
#include <sys/prctl.h>
#include <sys/socket.h>
#include <sys/sysinfo.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

#define MP_BLOCK  4
#define MAX_CONNS 4096
#define KB        1024
#define NIOS      32

#define IN_POOL(ptr)                 ((void *)ptr >= pool.bpool && (void *)ptr <= (pool.bpool + (pool.npages * pool.pagesize)))
#define ALIGN_TO_PAGESIZE(buff_size) (((buff_size) + (pool.pagesize - 1)) & ~(pool.pagesize - 1))
#define BYTES_TO_BLOCKS(buff_size)   (((buff_size) + (MP_BLOCK - 1)) / MP_BLOCK)
#define CEIL_BLOCKS(nblocks)         ((nblocks + 63) & ~63)
#define CEIL_PAGES(size)             (((size) + ((pool.pagesize) - 1)) & ~((pool.pagesize) - 1))

#define BIT_IS_FREE(word, bit)   (((word) >> (bit)) & 1)
#define MARK_BIT_USED(word, bit) ((word) &= ~(1ULL << (bit)))
#define MARK_BIT_FREE(word, bit) ((word) |= (1ULL << (bit)))
#define FIND_FREE_BIT(word)      ((uint64_t)(word) & -(uint64_t)(word))
#define STRLEN(s)                (sizeof(s) - 1)

#define IOVEC_NBLOCKS (BYTES_TO_BLOCKS(NIOS * sizeof(struct iovec)))
#define MSG_NBLOCKS   (BYTES_TO_BLOCKS(sizeof(struct msghdr)))
#define ZC_RES        KB *KB

#define DEBUG 0
#if DEBUG
#define LOG(...) fprintf(logfd, __VA_ARGS__)
#else
#define LOG(...) ((void)0)
#endif

typedef enum UOP {
  WRITEV = IORING_OP_WRITEV,
  SENDMSG = IORING_OP_SENDMSG,
  RECVMSG = IORING_OP_RECVMSG,
  ACCEPT = IORING_OP_ACCEPT,
  SEND = IORING_OP_SEND,
  RECV = IORING_OP_RECV,
  SENDZC = IORING_OP_SEND_ZC,
  SENDMSGZC = IORING_OP_SENDMSG_ZC,
  PEEK = 50,
  FRECVMSG,
  INSPLICE,
  OUTSPLICE
} UOP;

typedef enum CFS {
  CF_IN_POOL = (1 << 0),       // Connection is in the pool
  CF_IN_HEAP = (1 << 1),       // Connection is in the heap
  CF_SKIP_SOCK = (1 << 2),     // Don't close the socket
  CF_USE_ONCE = (1 << 3),      // Destroy after using
  CF_HANDLER_READY = (1 << 4), // Ready to call the handler
} CFS;

typedef struct conn_t {
  // Socket file descriptor
  int fd;

  // Amount of data left in the current operation
  uint64_t data_left;

  // The index of the connection struct
  uint32_t cindex;

  // The last time the connection was readable
  uint64_t last_read;

  // The last time the connection was writeable
  uint64_t last_write;

  // The operation currently being processed
  uint8_t op;

  // Connection flags
  int flags;

  // Splice fd_in
  int in_fd;

  // Splice fd_out
  int out_fd;

  void *recv_conn;
  void *send_conn;

  struct iovec *ios;
  struct iovec *rec;
  uint16_t nios;

  struct msghdr *msg;
  uint16_t zc_notifs;

  uint16_t head_size;
} conn_t;

typedef struct MPool {
  // The allocated pool of blocks
  void *bpool;

  // The allocated pool of connections
  conn_t *cpool;

  // The size of the pool in pages
  uint32_t npages;

  // The size of the pool in blocks
  uint32_t nblocks;

  // The locations of each page in the pool
  void **blocks;

  // The availability of each block
  uint64_t *freebs;

  // The locations of each conn in the pool
  conn_t **conns;

  // The availability of each conn
  uint64_t *freecs;

  // Clean up callback function
  void (*callback)(conn_t *conn);

  // The page size used
  uint32_t pagesize;

  // Socket read timeout
  uint32_t rtimeout;

  // Socket write timeout
  uint32_t wtimeout;
} MPool;

extern int pipe_sz;
extern int pipe_in, pipe_out, nullfd;
extern FILE *logfd;
extern struct io_uring ring;
extern MPool pool;
extern conn_t *current_recv;
extern conn_t *current_send;

/*
 * Prepare and submit a recv uring op
 */
static inline int urecv(conn_t *conn, void *buffer, size_t buff_size, int flags) {
  if (!conn || conn->fd == -1)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (flags == MSG_PEEK) ? PEEK : RECV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;

  io_uring_prep_recv(sqe, conn->fd, buffer, buff_size, flags);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a multi-shot accept uring op
 */
static inline int umaccept(int listenfd) {
  if (listenfd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = ACCEPT;
  io_uring_prep_multishot_accept(sqe, listenfd, NULL, NULL, SOCK_NONBLOCK);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a splice uring op
 */
static inline int usplice(conn_t *conn, int fd_in, int64_t off_in, int fd_out, int64_t off_out, size_t len) {
  if (!len || !conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = (__u64)conn;
  io_uring_prep_splice(sqe, fd_in, off_in, fd_out, off_out, len, 0);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a writev uring op
 */
static inline int uwritev(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = WRITEV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  io_uring_prep_writev(sqe, conn->fd, &conn->ios[iov_index], nios, -1);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a send uring op
 */
static inline int usend(conn_t *conn, char *res_buff, size_t buff_size, bool zc) {
  if (!conn || conn->fd <= 0 || buff_size == 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (zc) ? SENDZC : SEND;
  conn->data_left = buff_size;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  if (zc)
    io_uring_prep_send_zc(sqe, conn->fd, res_buff, buff_size, 0, 0);
  else
    io_uring_prep_send(sqe, conn->fd, res_buff, buff_size, 0);
  return io_uring_submit(&ring);
}

static inline int ufrecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = FRECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;

  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, rec->iov_len);
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int urecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = RECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int usendmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  bool zc = (conn->data_left > ZC_RES) ? true : false;
  conn->op = (zc) ? SENDMSGZC : SENDMSG;

  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  if (zc) {
    io_uring_prep_sendmsg_zc(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
    conn->zc_notifs++;
  } else {
    io_uring_prep_sendmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  }
  return io_uring_submit(&ring);
}

/*
 * Create and initialize a server socket
 */
static inline int tcp_listen(uint16_t port) {
  int enable;
  int listenfd;
  if ((listenfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    return -1;

  int flags = fcntl(listenfd, F_GETFL, 0);
  fcntl(listenfd, F_SETFL, flags | O_NONBLOCK);
  struct sockaddr_in servaddr;
  memset(&servaddr, 0, sizeof(servaddr));
  servaddr.sin_family = AF_INET;
  servaddr.sin_addr.s_addr = INADDR_ANY;
  servaddr.sin_port = htons(port);

  enable = 1;
  if (setsockopt(listenfd, SOL_SOCKET, SO_REUSEPORT, &enable, sizeof(enable)) < 0)
    return -1;

  if (bind(listenfd, (struct sockaddr *)&servaddr, sizeof(servaddr)) < 0)
    return -1;

  if (listen(listenfd, SOMAXCONN) < 0)
    return -1;

  return listenfd;
}

/*
 * Calculate the difference between two pointers
 */
static inline uintptr_t ptr_diff(uintptr_t p1, uintptr_t p2) { return (uintptr_t)(p1 > p2) ? (p1 - p2) : (p2 - p1); }

static inline size_t get_nroutes(Route *routes) {
  Route *route;
  for (size_t i = 0;; i++) {
    route = &routes[i];
    if (!route->path && !route->handler && !route->method)
      return i;
  }
}

static inline long get_content_length(char *src, char *end) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return -1;
    key = line;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, "Content-Length") != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;

    *line_end = '\0';
    long res = atol(value);
    *line_end = '\r';

    return res;
  }
  return -1;
}

static inline bool have_header(char *src, char *end, const char *header_key, const char *header_value) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    key = line;
    while (*key == ' ')
      key++;
    while (*header_key == ' ')
      header_key++;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return false;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, header_key) != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;
    while (*header_value == ' ')
      header_value++;

    *line_end = '\0';
    bool res = (strcasecmp(value, header_value) == 0);
    *line_end = '\r';

    return res;
  }

  return false;
}

static inline const char *method_str(Method method) {
  switch (method) {
  case GET:
    return "GET";
    break;
  case HEAD:
    return "HEAD";
    break;
  case POST:
    return "POST";
    break;
  case PUT:
    return "PUT";
    break;
  case DELETE:
    return "DELETE";
    break;
  case CONNECT:
    return "CONNECT";
    break;
  case OPTIONS:
    return "OPTIONS";
    break;
  case TRACE:
    return "TRACE";
    break;
  case PATCH:
    return "PATCH";
    break;
  default:
    return NULL;
  }
}

static inline uint8_t method_len(Method method) {
  switch (method) {
  case GET:
    return 3;
    break;
  case HEAD:
    return 4;
    break;
  case POST:
    return 4;
    break;
  case PUT:
    return 3;
    break;
  case DELETE:
    return 6;
    break;
  case CONNECT:
    return 7;
    break;
  case OPTIONS:
    return 7;
    break;
  case TRACE:
    return 5;
    break;
  case PATCH:
    return 5;
    break;
  default:
    return 0;
  }
}

static inline size_t round_to_blocks(size_t size) {
  size_t nblocks = BYTES_TO_BLOCKS(size);
  nblocks = CEIL_BLOCKS(nblocks);
  return nblocks;
}

/*
 * Count the digits in unsigned 64-bit int
 */
static inline int countd(uint64_t num) {
  if (num < 10ULL)
    return 1;
  if (num < 100ULL)
    return 2;
  if (num < 1000ULL)
    return 3;
  if (num < 10000ULL)
    return 4;
  if (num < 100000ULL)
    return 5;
  if (num < 1000000ULL)
    return 6;
  if (num < 10000000ULL)
    return 7;
  if (num < 100000000ULL)
    return 8;
  if (num < 1000000000ULL)
    return 9;
  if (num < 10000000000ULL)
    return 10;
  if (num < 100000000000ULL)
    return 11;
  if (num < 1000000000000ULL)
    return 12;
  if (num < 10000000000000ULL)
    return 13;
  if (num < 100000000000000ULL)
    return 14;
  if (num < 1000000000000000ULL)
    return 15;
  if (num < 10000000000000000ULL)
    return 16;
  if (num < 100000000000000000ULL)
    return 17;
  if (num < 1000000000000000000ULL)
    return 18;
  if (num < 10000000000000000000ULL)
    return 19;
  return 20;
}

/*
 * Get the time elabsed in ms
 */
static inline uint64_t get_time() {
  struct timespec ts;
  clock_gettime(CLOCK_MONOTONIC, &ts);
  return (uint64_t)(ts.tv_sec) * 1000 + (ts.tv_nsec / 1000000);
}

static inline FILE *log_init(const char *path) {
  FILE *res = fopen(path, "a+");
  setvbuf(res, NULL, _IONBF, 0);
  return res;
}

static inline int16_t pollevs(int connfd) {
  struct pollfd pfd;
  pfd.fd = connfd;
  pfd.events = POLLIN | POLLOUT | POLLERR;
  int res = poll(&pfd, 1, 0);
  if (res < 0)
    return POLLERR;
  return pfd.revents;
}

// FIXME This needs to be updated
static inline conn_t *MP_use_once(size_t nblocks, int fd) {

  void *mem = malloc(sizeof(conn_t) + 8 + (IOVEC_NBLOCKS * MP_BLOCK));
  struct conn_t *conn = (conn_t *)mem;
  memset(conn, 0, sizeof(conn_t));
  conn->ios = mem + sizeof(conn_t) + 8;

  if (nblocks > 0) {
    struct iovec *iov = &conn->ios[conn->nios++];
    mem = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (mem == MAP_FAILED)
      return NULL;
    iov->iov_base = mem;
    iov->iov_len = ALIGN_TO_PAGESIZE(nblocks * MP_BLOCK);
  }

  conn->flags |= CF_IN_HEAP;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;

  return conn;
}

static inline int find_freec() {
  uint64_t *word;
  size_t map_size = (sizeof(uint64_t) * 8);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    word = &pool.freecs[i / map_size];

    if (*word == 0) { // All used
      i += (map_size - 1);
      continue;
    }

    i += __builtin_ctzll(*word);
    MARK_BIT_USED(*word, i);
    return i;
  }

  return -1;
}

static inline int MP_init(size_t npages) {
  if (!npages)
    return -1;

  /*** Setup ***/
  pool.npages = npages;
  pool.pagesize = sysconf(_SC_PAGESIZE);

  /*** Pool ***/
  pool.bpool = mmap(NULL, pool.npages * pool.pagesize, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  if (pool.bpool == MAP_FAILED)
    return -1;
  pool.nblocks = (pool.npages * pool.pagesize) / MP_BLOCK;

  /*** Blocks ***/
  pool.blocks = malloc(sizeof(void *) * pool.nblocks);
  if (!pool.blocks)
    return -1;
  for (size_t i = 0; i < pool.nblocks; i++)
    pool.blocks[i] = pool.bpool + (i * MP_BLOCK);

  /*** Freebs ***/
  // if (posix_memalign((void **)&pool.freebs, 64, bitmap_size * sizeof(uint64_t)) < 0)
  size_t bitmap_size = (pool.nblocks + 63) / 64;
  pool.freebs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freebs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freebs[i] = UINT64_MAX;

  /*** Cpool ***/
  pool.cpool = (conn_t *)malloc(sizeof(conn_t) * MAX_CONNS);
  if (!pool.cpool)
    return -1;

  /*** Conns ***/
  pool.conns = (conn_t **)malloc(sizeof(conn_t *) * MAX_CONNS);
  if (!pool.conns)
    return -1;
  size_t conn_size = sizeof(conn_t);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    pool.conns[i] = (conn_t *)((char *)pool.cpool + (i * conn_size));
    pool.conns[i]->fd = -1;
    pool.conns[i]->in_fd = -1;
    pool.conns[i]->out_fd = -1;
  }

  /*** Freecs ***/
  bitmap_size = (MAX_CONNS + 63) / 64;
  pool.freecs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freecs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freecs[i] = UINT64_MAX;

  return 0;
}

static inline int MP_use_blks(size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t max_start = pool.nblocks - nblocks;
  size_t full_chunks = (nblocks / 64) * 64;

  for (size_t i = 0, c = 0; i <= max_start; i++, c++) {
    bool free = true;

    for (size_t j = 0; j < full_chunks; j += 64) {
      size_t word_index = (i + j) / 64;
      if (pool.freebs[word_index] != UINT64_MAX) {
        free = false;
        i += 63;
        break;
      }
    }

    for (size_t j = full_chunks; j < nblocks; j++) {
      size_t bit_index = i + j;
      size_t word_index = bit_index / 64;
      size_t bit_in_word = bit_index % 64;

      if (!BIT_IS_FREE(pool.freebs[word_index], bit_in_word)) {
        free = false;
        i += j;
        break;
      }
    }

    if (free) {
      for (size_t j = 0; j < full_chunks; j += 64) {
        size_t word_index = (i + j) / 64;
        pool.freebs[word_index] = 0;
      }

      for (size_t j = full_chunks; j < nblocks; j++) {
        size_t bit_index = i + j;
        size_t word_index = bit_index / 64;
        size_t bit_in_word = bit_index % 64;

        MARK_BIT_USED(pool.freebs[word_index], bit_in_word);
      }

      return i;
    }
  }

  return -1;
}

static inline int MP_free_blks(size_t bindex, size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t full_chunks = (nblocks / 64) * 64;
  for (size_t i = 0; i < full_chunks; i += 64) {
    size_t word_index = (bindex + i) / 64;
    pool.freebs[word_index] = UINT64_MAX;
  }

  for (size_t i = full_chunks; i < nblocks; i++) {
    size_t bit_index = bindex + i;
    size_t word_index = bit_index / 64;
    size_t bit_in_word = bit_index % 64;

    MARK_BIT_FREE(pool.freebs[word_index], bit_in_word);
  }

  memset(pool.blocks[bindex], 0, nblocks * MP_BLOCK);
  return 0;
}

static inline conn_t *MP_use(size_t nblocks, int fd, bool once) {
  if (fd <= 0)
    return NULL;
  if (once)
    return MP_use_once(nblocks, fd);

  int cindex = find_freec();
  if (cindex < 0) {
    LOG("Err: cindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  conn_t *conn = pool.conns[cindex];

  int ios_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (ios_bindex < 0) {
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }

  struct iovec *ios = pool.blocks[ios_bindex];
  conn->ios = ios;

  int rec_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (rec_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct iovec *rec = pool.blocks[rec_bindex];
  conn->rec = rec;

  int msg_bindex = MP_use_blks(MSG_NBLOCKS);
  if (msg_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct msghdr *msg = pool.blocks[msg_bindex];
  conn->msg = msg;

  if (nblocks > 0) {
    int bindex = MP_use_blks(nblocks);
    if (bindex < 0) {
      MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
      MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
      MP_free_blks(msg_bindex, IOVEC_NBLOCKS);
      MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
      LOG("Err: bindex < 0; will use MP_use_once\n");
      return MP_use_once(nblocks, fd);
    }

    size_t iov_index = conn->nios++;
    struct iovec *iov = &conn->ios[iov_index];
    struct iovec *rec = &conn->rec[iov_index];
    iov->iov_base = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
  }

  conn->msg->msg_iov = conn->ios;
  conn->msg->msg_iovlen = conn->nios;
  conn->cindex = cindex;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;
  return conn;
}

static inline void MP_shed(conn_t *conn, size_t iov_index, size_t nios) {
  struct iovec *iov, *rec;
  size_t bindex, nblocks, index;

  for (size_t i = 0; i < nios; i++) {
    index = iov_index + i;
    iov = &conn->ios[index];
    rec = &conn->rec[index];
    if (!rec || !rec->iov_base)
      continue;
    if (!IN_POOL(rec->iov_base)) {
      munmap(rec->iov_base, rec->iov_len / pool.pagesize);
    } else {
      bindex = ptr_diff((uintptr_t)rec->iov_base, (uintptr_t)pool.bpool) / MP_BLOCK;
      nblocks = rec->iov_len / MP_BLOCK;
      MP_free_blks(bindex, nblocks);
    }
    memset(iov, 0, sizeof(struct iovec));
    memset(rec, 0, sizeof(struct iovec));
    conn->nios--;
  }
}

static inline int MP_expand(conn_t *conn, size_t nblocks, bool once) {
  void *bptr;
  int iov_index, bindex;
  struct iovec *iov, *rec;

  iov_index = conn->nios++;
  iov = &conn->ios[iov_index];
  rec = &conn->rec[iov_index];

  if (nblocks == 0)
    return iov_index;

  if (once) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_base = bptr;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
    return iov_index;
  }

  bindex = MP_use_blks(nblocks);
  if (bindex < 0) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_len = iov->iov_len;
  } else {
    bptr = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_len = iov->iov_len;
  }

  iov->iov_base = bptr;
  rec->iov_base = iov->iov_base;
  return iov_index;
}

static inline int MP_free(conn_t *conn) {
  if (!conn)
    return -1;
  size_t bindex, nblocks;
  uint64_t *word;

  MP_shed(conn, 0, conn->nios);
  if (conn->flags & CF_IN_HEAP) {
    if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
      close(conn->fd);
    free(conn);
    return 0;
  }

  word = &pool.freecs[conn->cindex / 64];
  if (conn->cindex > MAX_CONNS)
    return -1;
  else if (BIT_IS_FREE(*word, conn->cindex))
    return 0;

  bindex = ptr_diff((uintptr_t)conn->ios, (uintptr_t)pool.bpool) / MP_BLOCK;
  nblocks = IOVEC_NBLOCKS;
  MP_free_blks(bindex, nblocks);

  bindex = ptr_diff((uintptr_t)conn->rec, (uintptr_t)pool.bpool) / MP_BLOCK;
  MP_free_blks(bindex, nblocks);

  if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
    close(conn->fd);

  MARK_BIT_FREE(*word, conn->cindex);
  memset(conn, 0, sizeof(conn_t));
  conn->fd = -1;
  conn->in_fd = -1;
  conn->out_fd = -1;
  return 0;
}

static inline void MP_clear(conn_t *conn) {
  conn_t *recv_conn = conn->recv_conn;
  conn_t *send_conn = conn->send_conn;
  if (recv_conn)
    MP_free(recv_conn);
  if (send_conn)
    MP_free(send_conn);
}

static inline void MP_exit(MPool *pool) {
  munmap(pool->bpool, pool->npages);
  free(pool->cpool);
  free(pool->blocks);
  free(pool->conns);
  free(pool->freebs);
  free(pool->freecs);
}

static inline void MP_timeout() {
  conn_t *conn;
  int16_t res;
  uint64_t now;
  size_t windex = 0;
  uint64_t *word = &pool.freecs[0];
  for (size_t i = 0; i < MAX_CONNS; i++) {
    if ((i / 64) < windex)
      word = &pool.freecs[++windex];

    if (*word == UINTMAX_MAX) {
      i = (i / 64) * 64 + 64;
      continue;
    }

    conn = pool.conns[i];
    if (!conn || conn->fd == -1)
      continue;

    res = pollevs(conn->fd);

    now = get_time();
    if (res & POLLERR) {
      MP_clear(conn);
      continue;
    }
    if (res & POLLIN) {
      if (pool.rtimeout > 0 && (now - conn->last_read) >= pool.rtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (res & POLLOUT) {
      if (pool.wtimeout > 0 && (now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (!(res & POLLIN || res & POLLOUT)) {
      if ((pool.rtimeout > 0 && now - conn->last_read) >= pool.rtimeout
          || (pool.wtimeout > 0 && now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
  }
}

/*
 * Calculate the length of a status string
 */
static inline size_t status_len(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return 8;
  case STATUSSWITCHINGPROTOCOLS:
    return 19;
  case STATUSPROCESSING:
    return 10;
  case STATUSEARLYHINTS:
    return 11;
  case STATUSOK:
    return 2;
  case STATUSCREATED:
    return 7;
  case STATUSACCEPTED:
    return 8;
  case STATUSNONAUTHORITATIVE:
    return 29;
  case STATUSNOCONTENT:
    return 10;
  case STATUSRESETCONTENT:
    return 13;
  case STATUSPARTIALCONTENT:
    return 15;
  case STATUSMULTISTATUS:
    return 12;
  case STATUSALREADYREPORTED:
    return 16;
  case STATUSIMUSED:
    return 7;
  case STATUSMULTIPLECHOICES:
    return 16;
  case STATUSMOVEDPERMANENTLY:
    return 17;
  case STATUSFOUND:
    return 5;
  case STATUSSEEOTHER:
    return 9;
  case STATUSNOTMODIFIED:
    return 12;
  case STATUSUSEPROXY:
    return 9;
  case STATUSTEMPORARYREDIRECT:
    return 18;
  case STATUSPERMANENTREDIRECT:
    return 18;
  case STATUSBADREQUEST:
    return 11;
  case STATUSUNAUTHORIZED:
    return 12;
  case STATUSPAYMENTREQUIRED:
    return 16;
  case STATUSFORBIDDEN:
    return 9;
  case STATUSNOTFOUND:
    return 9;
  case STATUSMETHODNOTALLOWED:
    return 18;
  case STATUSNOTACCEPTABLE:
    return 14;
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return 29;
  case STATUSREQUESTTIMEOUT:
    return 15;
  case STATUSCONFLICT:
    return 8;
  case STATUSGONE:
    return 4;
  case STATUSLENGTHREQUIRED:
    return 15;
  case STATUSPRECONDITIONFAILED:
    return 19;
  case CONTENTTOOLARGE:
    return 17;
  case STATUSURITOOLONG:
    return 12;
  case STATUSUNSUPPORTEDMEDIATYPE:
    return 22;
  case STATUSRANGENOTSATISFIABLE:
    return 21;
  case STATUSEXPECTATIONFAILED:
    return 18;
  case STATUSMISDIRECTEDREQUEST:
    return 19;
  case STATUSUNPROCESSABLECONTENT:
    return 21;
  case STATUSLOCKED:
    return 6;
  case STATUSFAILEDDEPENDENCY:
    return 17;
  case STATUSTOOEARLY:
    return 9;
  case STATUSUPGRADEREQUIRED:
    return 16;
  case STATUSPRECONDITIONREQUIRED:
    return 21;
  case STATUSTOOMANYREQUESTS:
    return 17;
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return 31;
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return 29;
  case STATUSInternalServerError:
    return 21;
  case STATUSNOTIMPLEMENTED:
    return 15;
  case STATUSBADGATEWAY:
    return 11;
  case STATUSSERVICEUNAVAILABLE:
    return 19;
  case STATUSGATEWAYTIMEOUT:
    return 15;
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return 26;
  case STATUSVARIANTALSONEGOTIATES:
    return 23;
  case STATUSINSUFFICIENTSTORAGE:
    return 20;
  case STATUSLOOPDETECTED:
    return 13;
  case STATUSNOTEXTENDED:
    return 12;
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return 31;
  default:
    return 0;
  }
}

/*
 * Return the status code string as string literal
 */
static inline char *status_str(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return "Continue";
  case STATUSSWITCHINGPROTOCOLS:
    return "Switching Protocols";
  case STATUSPROCESSING:
    return "Processing";
  case STATUSEARLYHINTS:
    return "Early Hints";
  case STATUSOK:
    return "OK";
  case STATUSCREATED:
    return "Created";
  case STATUSACCEPTED:
    return "Accepted";
  case STATUSNONAUTHORITATIVE:
    return "Non-Authoritative Information";
  case STATUSNOCONTENT:
    return "No Content";
  case STATUSRESETCONTENT:
    return "Reset Content";
  case STATUSPARTIALCONTENT:
    return "Partial Content";
  case STATUSMULTISTATUS:
    return "Multi-Status";
  case STATUSALREADYREPORTED:
    return "Already Reported";
  case STATUSIMUSED:
    return "Im Used";
  case STATUSMULTIPLECHOICES:
    return "Multiple Choices";
  case STATUSMOVEDPERMANENTLY:
    return "Moved Permanently";
  case STATUSFOUND:
    return "Found";
  case STATUSSEEOTHER:
    return "See Other";
  case STATUSNOTMODIFIED:
    return "Not Modified";
  case STATUSUSEPROXY:
    return "Use Proxy";
  case STATUSTEMPORARYREDIRECT:
    return "Temporary Redirect";
  case STATUSPERMANENTREDIRECT:
    return "Permanent Redirect";
  case STATUSBADREQUEST:
    return "Bad Request";
  case STATUSUNAUTHORIZED:
    return "Unauthorized";
  case STATUSPAYMENTREQUIRED:
    return "Payment Required";
  case STATUSFORBIDDEN:
    return "Forbidden";
  case STATUSNOTFOUND:
    return "Not Found";
  case STATUSMETHODNOTALLOWED:
    return "Method Not Allowed";
  case STATUSNOTACCEPTABLE:
    return "Not Acceptable";
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return "Proxy Authentication Required";
  case STATUSREQUESTTIMEOUT:
    return "Request Timeout";
  case STATUSCONFLICT:
    return "Conflict";
  case STATUSGONE:
    return "Gone";
  case STATUSLENGTHREQUIRED:
    return "Length Required";
  case STATUSPRECONDITIONFAILED:
    return "Precondition Failed";
  case CONTENTTOOLARGE:
    return "Content Too Large";
  case STATUSURITOOLONG:
    return "URI Too Long";
  case STATUSUNSUPPORTEDMEDIATYPE:
    return "Unsupported Media Type";
  case STATUSRANGENOTSATISFIABLE:
    return "Range Not Satisfiable";
  case STATUSEXPECTATIONFAILED:
    return "Expectation Failed";
  case STATUSMISDIRECTEDREQUEST:
    return "Misdirected Request";
  case STATUSUNPROCESSABLECONTENT:
    return "Unprocessable Content";
  case STATUSLOCKED:
    return "Locked";
  case STATUSFAILEDDEPENDENCY:
    return "Failed Dependency";
  case STATUSTOOEARLY:
    return "Too Early";
  case STATUSUPGRADEREQUIRED:
    return "Upgrade Required";
  case STATUSPRECONDITIONREQUIRED:
    return "Precondition Required";
  case STATUSTOOMANYREQUESTS:
    return "Too Many Requests";
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return "Request Header Fields Too Large";
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return "Unavailable For Legal Reasons";
  case STATUSInternalServerError:
    return "Internal Server Error";
  case STATUSNOTIMPLEMENTED:
    return "Not Implemented";
  case STATUSBADGATEWAY:
    return "Bad Gateway";
  case STATUSSERVICEUNAVAILABLE:
    return "Service Unavailable";
  case STATUSGATEWAYTIMEOUT:
    return "Gateway Timeout";
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return "HTTP Version Not Supported";
  case STATUSVARIANTALSONEGOTIATES:
    return "Variant Also Negotiates";
  case STATUSINSUFFICIENTSTORAGE:
    return "Insufficient Storage";
  case STATUSLOOPDETECTED:
    return "Loop Detected";
  case STATUSNOTEXTENDED:
    return "Not Extended";
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return "Network Authentication Required";
  default:
    return 0;
  }
}

/*
 * Return true if routes match
 */
static inline bool route_equ(Route *route, Request *req) {
  return route->method == req->method && strncmp(route->path, req->path, strlen(route->path)) == 0;
}

/*
 * Return the matching route index on success. -1 on failure
 */
static inline int match_route(Server *serv, Request *req) {
  for (size_t i = 0; i < serv->_nroutes; i++) {
    Route route = serv->routes[i];
    if (!req->path || !route.path)
      continue;
    if (route_equ(&route, req))
      return i;
    else if (req->method == HEAD && route.method == GET && strcmp(route.path, req->path) == 0)
      return i;
  }
  return -1;
}

/*
 * Return true if the response should contain the Content-Length header
 */
static inline bool should_have_content_length(Request *req, ResWriter *res) {
  return (req->method != CONNECT              // CONNECT request
          && res->status != STATUSNOCONTENT   // 204 response
          && res->status != STATUSNOTMODIFIED // 304 response
          && res->status >= 200);             // 1xx response
}

/*
 * Format http response from the ResWriter.
 * Return response size on success, 0 on failure.
 */
static inline size_t fmt_res(Request *req, ResWriter *res, char *buffer, size_t buffer_size) {
  if (!res || !buffer || buffer_size == 0)
    return 0;

  size_t res_len, total = 0;
  char *dst = buffer;
  size_t maxlen = buffer_size;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t body_length = res->len;

  res_len = snprintf(dst, maxlen, "HTTP/1.1 %d %s", (int)res->status, status_str(res->status));
  total += res_len;
  dst += res_len;
  maxlen -= res_len;

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    res_len = snprintf(dst, maxlen, "\r\n%s: %s", header->key, header->value);
    total += res_len;
    dst += res_len;
    maxlen -= res_len;
  }

  if (have_content_length) {
    res_len = snprintf(dst, maxlen, "\r\nContent-Length: %lu", body_length);
    total += res_len, dst += res_len, maxlen -= res_len;
  }

  memcpy(dst, "\r\n\r\n", 4);
  total += 4, dst += 4, maxlen -= 4;

  return total;
}

static inline size_t res_len(Request *req, ResWriter *res) {
  if (!req || !res)
    return 0;

  if (!res->status)
    res->status = STATUSOK;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t result = 0;
  result += STRLEN("HTTP/1.1 ");     // HTTP version
  result += 4;                       // Status code + space
  result += status_len(res->status); // Status name

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    result += 2;                       // "\r\n"
    result += strlen(header->key) + 2; // Header key + ':' + space
    result += strlen(header->value);   // header value
  }

  if (have_content_length) {
    result += 2;                          // "\r\n"
    result += STRLEN("Content-Length: "); // Header key
    result += countd(res->len);           // Header value
  }

  result += 4; // "\r\n\r\n"

  return result;
}

static inline int send_empty_res(Status status) {
  size_t res_len = STRLEN("HTTP/1.1 ")        // HTTP version
                   + countd((uint64_t)status) // status code
                   + 1                        // space
                   + (int)status_len(status)  // status string
                   + 4;                       // \r\n\r\n

  conn_t *conn = current_send;
  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, res_len);
  if (snprintf((char *)rec->iov_base, res_len + 1, "HTTP/1.1 %d %s\r\n\r\n", (int)status, status_str(status))
      != (int)res_len)
    return -1;

  return usendmsg(conn, 0, 1);
}

static inline ssize_t read_socket(int sockfd, size_t len) {
  if (len == 0 || sockfd <= 0)
    return 0;
  char buff[1024 * 8];
  return read(sockfd, buff, 1024 * 8);
}

static inline int read_method(Method *method, void *src) {
  if (memcmp(src, "GET", 3) == 0)
    *method = GET;
  else if (memcmp(src, "POST", 4) == 0)
    *method = POST;
  else if (memcmp(src, "HEAD", 4) == 0)
    *method = HEAD;
  else if (memcmp(src, "PUT", 3) == 0)
    *method = PUT;
  else if (memcmp(src, "DELETE", 6) == 0)
    *method = DELETE;
  else if (memcmp(src, "CONNECT", 7) == 0)
    *method = CONNECT;
  else if (memcmp(src, "OPTIONS", 7) == 0)
    *method = OPTIONS;
  else if (memcmp(src, "TRACE", 5) == 0)
    *method = TRACE;
  else if (memcmp(src, "PATCH", 5) == 0)
    *method = PATCH;
  else
    return -1;

  return 0;
}

static inline int sendmsg_res(Request *req, ResWriter *res) {
  conn_t *conn;
  size_t head_size, res_size;
  struct iovec *iov;

  conn = current_send;
  iov = &conn->ios[0];
  head_size = res_len(req, res);
  if (head_size == 0)
    return -1;

  conn->data_left += head_size;
  res_size = fmt_res(req, res, iov->iov_base, (head_size + 1));
  if (res_size != head_size)
    return -1;
  iov->iov_len = res_size;

  return usendmsg(conn, 0, conn->nios);
}

static inline int read_req(Request *req, char *req_buffer) {
  if (!req_buffer)
    return -1;
  /*** Method ***/
  char *sep = strchr(req_buffer, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }
  *sep = '\0';
  if (read_method(&req->method, req_buffer) < 0)
    return -1;

  /*** Path ***/
  char *fullpath = sep + 1;
  sep = strchr(fullpath, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }

  *sep = '\0';
  req->path = fullpath;
  /*** Params ***/
  char *paramStart = strchr(fullpath, '?');
  if (paramStart) {
    *paramStart++ = '\0';
    int params_count = 0;
    params_count = HK_parse_params(paramStart, req->params, MAX_URL_PARAMETERS);
    if (params_count > 0)
      req->params_count = params_count;
    else
      req->params_count = 0;
  } else {
    req->params = NULL;
    req->params_count = 0;
  }

  /*** Headers ***/
  char *headStart = strstr(sep + 1, "\r\n");
  char *headEnd = strstr(sep + 1, "\r\n\r\n");
  if (!headStart) {
    LOG("read_req: !headStart\n");
    return -1;
  };

  memset(headStart, 0, 2);
  headStart += 2;
  memset(headEnd, 0, 4);
  headEnd += 4;

  int headers_count = HK_parse_headers(headStart, req->headers, MAX_REQ_HEADERS);
  if (headers_count <= 0)
    return -1;
  req->headers_count = headers_count;

  /*** Host ***/
  int index = HK_get_header(req, "Host");
  if (index < 0)
    return -1;
  char *host = req->headers[index].value;
  req->hostname = host;

  /*** Port ***/
  char *colon = strchr(host, ':');
  if (colon) {
    *colon++ = '\0';
    req->port = atoi(colon);
  } else {
    req->port = PORT;
  }
  return 0;
}
static inline int process_req(Server *serv, conn_t *conn) {
  if (!conn || conn->fd == -1)
    return -1;

  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;
  if (read_req(&req, conn->ios[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    LOG("Err: route_index == -1\n");
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;
  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  sendmsg_res(&req, &res);

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int new_conn(int connfd) {
  if (connfd <= 0)
    return -1;

  current_recv = MP_use(KB * 2, connfd, false);
  current_send = MP_use(KB * 2, connfd, false);

  current_recv->recv_conn = current_recv;
  current_recv->send_conn = current_send;

  current_send->send_conn = current_send;
  current_send->recv_conn = current_recv;

  conn_t *conn = current_recv;
  if (ufrecvmsg(conn, 0, 1) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

static inline int resubmit_sendmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return usendmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int resubmir_recvmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    // FIXME the len should be increased
    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return urecvmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int handle_sendmsg_complete(conn_t *conn) {
  struct iovec *iov, *rec;

  MP_shed(conn, 1, conn->nios - 1);
  iov = &conn->ios[0];
  rec = &conn->rec[0];
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;

  return ufrecvmsg(conn->recv_conn, 0, 1);
}

static inline int handle_sendmsg(conn_t *conn, int res, bool zc) {
  if (!conn || conn->fd == -1)
    return -1;

  conn->data_left -= res;
  if (conn->data_left > 0)
    return resubmit_sendmsg(conn, res);

  if (zc)
    return 0;

  return handle_sendmsg_complete(conn);
}

static inline int handle_insplice(conn_t *conn) {
  conn->op = OUTSPLICE;
  return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
}
static inline int handle_outsplice(conn_t *conn, int res) {
  conn->data_left -= res;
  if (conn->data_left > 0) {
    conn->op = INSPLICE;
    return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
  }

  conn_t *recv_conn = conn->recv_conn;
  struct iovec *iov = &recv_conn->ios[0];
  memset(iov->iov_base, 0, iov->iov_len);
  if (urecv(recv_conn, iov->iov_base, iov->iov_len, MSG_PEEK) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

/*
static inline int handle_recv(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  void *bptr = conn->ios[0].iov_base;
  void *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  void *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  return process_req(serv, conn);
}
*/
static inline int find_route(Server *serv, char *bptr) {
  Request req = {0};
  if (read_method(&req.method, bptr) < 0) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  };
  char *space = strchr(bptr, ' ');
  req.path = (space + 1);
  space = strchr(req.path, ' ');
  *space = '\0';
  int route_index = match_route(serv, &req);
  *space = ' ';
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }
  return route_index;
}

static inline int run_handler(Server *serv, conn_t *conn, bool uses_body) {
  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;

  if (read_req(&req, conn->rec[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  if (uses_body) {
    int h_index = HK_get_header(&req, "Content-Length");
    long body_size = atol(req.headers[h_index].value);
    if (body_size >= 0) {
      req.body.ptr = conn->rec[1].iov_base;
      req.body.size = body_size;
    } else {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    }
  }

  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  if (sendmsg_res(&req, &res) < 0)
    return -1;

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int handle_frecvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  char *bptr = (char *)conn->ios[0].iov_base;
  char *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  char *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  size_t head_size = (headEnd + 4) - bptr;
  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  int route_index = find_route(serv, bptr);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  bool uses_body = serv->routes[route_index].uses_body;
  long body_size = get_content_length(headstart + 2, headEnd + 4);
  if (body_size == -1) {
    if (uses_body) {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    } else {
      body_size = 0;
    }
  }

  conn->head_size = head_size;
  if (!uses_body) {
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  if (res == (int)(head_size + body_size)) {
    size_t iov_index = MP_expand(conn, round_to_blocks(body_size), false);
    memcpy(conn->rec[iov_index].iov_base, headEnd + 4, body_size);
    conn->ios[iov_index].iov_len = body_size;
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  conn->data_left = body_size - (res - head_size);
  bool once = ((size_t)body_size > (size_t)((pool.nblocks * MP_BLOCK) / 10));
  size_t iov_index = MP_expand(conn, round_to_blocks(body_size), once);
  memcpy(conn->rec[iov_index].iov_base, headEnd + 4, (res - head_size));
  conn->ios[iov_index].iov_base += (res - head_size);

  return urecvmsg(conn, iov_index, 1);
}

static inline int handle_recvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  if (conn->data_left > 0) {
    conn->data_left -= res;
    if (conn->data_left == 0) {
      conn->flags &= CF_HANDLER_READY;
      return run_handler(serv, conn, true);
    }

    conn->flags &= ~CF_HANDLER_READY;
    conn->ios[1].iov_base += res;
    return urecvmsg(conn, 1, 1);
  }

  conn->flags &= CF_HANDLER_READY;
  return run_handler(serv, conn, true);
}

static inline int serv_init(Server *serv) {
#if DEBUG
  logfd = log_init("log.txt");
  if (!logfd) {
    printf("log_init failed");
    return -1;
  }
#endif
  serv->_nroutes = get_nroutes(serv->routes);

  int pipefd[2];
  if (pipe(pipefd) < 0)
    return -1;
  pipe_in = pipefd[0];
  pipe_out = pipefd[1];
  nullfd = open("/dev/null", O_WRONLY);
  pipe_sz = fcntl(pipefd[0], F_GETPIPE_SZ);
  if (pipe_sz < 0)
    return -1;

  pool.rtimeout = serv->rtimeout;
  pool.wtimeout = serv->wtimeout;
  if (MP_init(MAX_CONNS * 8) < 0)
    return -1;
  LOG("pool initialized\n");

  if (io_uring_queue_init(MAX_CONNS, &ring, 0) < 0)
    return -1;
  LOG("uring initialized\n");

  int listenfd;
  if ((listenfd = tcp_listen(serv->port)) < 0)
    return -1;
  LOG("socket initialized\n");

  return umaccept(listenfd);
}

static inline int serv_listen(Server *serv) {
  // uint64_t last_check = get_time();
  while (true) {
    // uint64_t now = get_time();
    // if ((now - last_check) >= 200) {
    //   last_check = now;
    //   LOG("CM: CM_check ran\n");
    //   MP_timeout();
    // }

    LOG("SQ ready: %u, CQ ready: %u\n", io_uring_sq_ready(&ring), io_uring_cq_ready(&ring));
    struct io_uring_cqe *cqe;
    if (io_uring_wait_cqe(&ring, &cqe) < 0)
      continue;

    int res = cqe->res;
    LOG("res = %d\n", res);
    conn_t *conn = NULL;
    if (cqe->user_data > 100) {
      conn = (conn_t *)cqe->user_data;
      current_recv = (conn_t *)conn->recv_conn;
      current_send = (conn_t *)conn->send_conn;
    }

    if (res > 0) {
      if (cqe->user_data == ACCEPT) {
        LOG("new conn created\n");
        new_conn(res);
      } else if (conn && conn->fd != -1) {
        LOG("conn[%d]: conn.fd = %d; conn.op = %d\n", conn->cindex, conn->fd, conn->op);
        switch (conn->op) {
        case FRECVMSG:
          if (handle_frecvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case RECVMSG:
          if (handle_recvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case SENDMSG:
        case SENDMSGZC:
          // conn->last_write = get_time();
          bool zc = (conn->op == SENDMSGZC);
          if (handle_sendmsg(conn, res, zc) < 0)
            MP_clear(conn);
          break;
        case INSPLICE:
          if (handle_insplice(conn) < 0)
            MP_clear(conn);
          break;
        case OUTSPLICE:
          if (handle_outsplice(conn, res) < 0)
            MP_clear(conn);
          break;
        }
      }
    } else if (res == 0) {
      if (conn && conn->fd != -1) {
        switch (conn->op) {
        case SENDMSGZC:
          conn->zc_notifs--;
          if (conn->zc_notifs == 0 && handle_sendmsg_complete(conn) < 0)
            MP_clear(conn);
          break;
        case RECV:
          MP_clear(conn);
          break;
        }
      }
    } else {
      if (conn && conn->fd != -1) {
        if (res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR) {
          LOG("conn && conn->fd != -1 && res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR\n");
          MP_clear(conn);
        } else {
          LOG("res == -EAGAIN || res == -EWOULDBLOCK || res == -EINTR\n");
          conn = conn->recv_conn;
          struct iovec *iov = &conn->ios[0];
          memset(iov->iov_base, 0, iov->iov_len);
          if (urecv(conn, iov->iov_base, iov->iov_len, 0) < 0)
            MP_clear(conn);
        }
      }
    }

    LOG("uring operation seen\n");
    io_uring_cqe_seen(&ring, cqe);
  }

  io_uring_queue_exit(&ring);
  MP_exit(&pool);
  return 0;
}

/*** Helper ***/
static inline int _HK_write(void *data, size_t size) {
  size_t nblocks;
  int iov_index;
  conn_t *conn;
  struct iovec *iov;
  bool once;

  conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  nblocks = round_to_blocks(size);
  iov_index = MP_expand(conn, nblocks, once);
  iov = &conn->ios[iov_index];

  memcpy(iov->iov_base, data, size);
  iov->iov_len = size;
  conn->data_left += size;

  return 0;
}
static inline int _HK_write_body(Request *req, size_t offset, size_t size) {
  if (size > req->body.size || offset > req->body.size)
    return -1;

  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  int iov_index = MP_expand(conn, 0, false);
  struct iovec *iov = &conn->ios[iov_index];
  struct iovec *rec = &conn->rec[iov_index];
  rec->iov_base = req->body.ptr + offset;
  rec->iov_len = size;
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;
  conn->data_left += rec->iov_len;
  return 0;
}
/*
static inline int _HK_mem(size_t size, HKMem *mem) {
  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  bool once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  size_t nblocks = round_to_blocks(size);
  int iov_index = MP_expand(conn, nblocks, once);
  struct iovec *iov = &conn->ios[iov_index];
  mem->ptr = iov->iov_base;
  mem->size = iov->iov_len;
  mem->_iov_index = iov_index;
  mem->_flags = (IN_POOL(iov->iov_base)) ? CF_IN_POOL : CF_IN_HEAP;
  return 0;
}

static inline void _HK_send(HKMem *mem, size_t size) {
  conn_t *conn = current_send;
  struct iovec *iov = &conn->ios[mem->_iov_index];
  iov->iov_len = size;
  conn->data_left += size;
}
  */
#endif#define _GNU_SOURCE
#ifndef UTILS_H
#define UTILS_H

#include "hunk.h"
#include <arpa/inet.h>
#include <fcntl.h>
#include <liburing.h>
#include <netdb.h>
#include <signal.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/poll.h>
#include <sys/prctl.h>
#include <sys/socket.h>
#include <sys/sysinfo.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

#define MP_BLOCK  4
#define MAX_CONNS 4096
#define KB        1024
#define NIOS      32

#define IN_POOL(ptr)                 ((void *)ptr >= pool.bpool && (void *)ptr <= (pool.bpool + (pool.npages * pool.pagesize)))
#define ALIGN_TO_PAGESIZE(buff_size) (((buff_size) + (pool.pagesize - 1)) & ~(pool.pagesize - 1))
#define BYTES_TO_BLOCKS(buff_size)   (((buff_size) + (MP_BLOCK - 1)) / MP_BLOCK)
#define CEIL_BLOCKS(nblocks)         ((nblocks + 63) & ~63)
#define CEIL_PAGES(size)             (((size) + ((pool.pagesize) - 1)) & ~((pool.pagesize) - 1))

#define BIT_IS_FREE(word, bit)   (((word) >> (bit)) & 1)
#define MARK_BIT_USED(word, bit) ((word) &= ~(1ULL << (bit)))
#define MARK_BIT_FREE(word, bit) ((word) |= (1ULL << (bit)))
#define FIND_FREE_BIT(word)      ((uint64_t)(word) & -(uint64_t)(word))
#define STRLEN(s)                (sizeof(s) - 1)

#define IOVEC_NBLOCKS (BYTES_TO_BLOCKS(NIOS * sizeof(struct iovec)))
#define MSG_NBLOCKS   (BYTES_TO_BLOCKS(sizeof(struct msghdr)))
#define ZC_RES        KB *KB

#define DEBUG 0
#if DEBUG
#define LOG(...) fprintf(logfd, __VA_ARGS__)
#else
#define LOG(...) ((void)0)
#endif

typedef enum UOP {
  WRITEV = IORING_OP_WRITEV,
  SENDMSG = IORING_OP_SENDMSG,
  RECVMSG = IORING_OP_RECVMSG,
  ACCEPT = IORING_OP_ACCEPT,
  SEND = IORING_OP_SEND,
  RECV = IORING_OP_RECV,
  SENDZC = IORING_OP_SEND_ZC,
  SENDMSGZC = IORING_OP_SENDMSG_ZC,
  PEEK = 50,
  FRECVMSG,
  INSPLICE,
  OUTSPLICE
} UOP;

typedef enum CFS {
  CF_IN_POOL = (1 << 0),       // Connection is in the pool
  CF_IN_HEAP = (1 << 1),       // Connection is in the heap
  CF_SKIP_SOCK = (1 << 2),     // Don't close the socket
  CF_USE_ONCE = (1 << 3),      // Destroy after using
  CF_HANDLER_READY = (1 << 4), // Ready to call the handler
} CFS;

typedef struct conn_t {
  // Socket file descriptor
  int fd;

  // Amount of data left in the current operation
  uint64_t data_left;

  // The index of the connection struct
  uint32_t cindex;

  // The last time the connection was readable
  uint64_t last_read;

  // The last time the connection was writeable
  uint64_t last_write;

  // The operation currently being processed
  uint8_t op;

  // Connection flags
  int flags;

  // Splice fd_in
  int in_fd;

  // Splice fd_out
  int out_fd;

  void *recv_conn;
  void *send_conn;

  struct iovec *ios;
  struct iovec *rec;
  uint16_t nios;

  struct msghdr *msg;
  uint16_t zc_notifs;

  uint16_t head_size;
} conn_t;

typedef struct MPool {
  // The allocated pool of blocks
  void *bpool;

  // The allocated pool of connections
  conn_t *cpool;

  // The size of the pool in pages
  uint32_t npages;

  // The size of the pool in blocks
  uint32_t nblocks;

  // The locations of each page in the pool
  void **blocks;

  // The availability of each block
  uint64_t *freebs;

  // The locations of each conn in the pool
  conn_t **conns;

  // The availability of each conn
  uint64_t *freecs;

  // Clean up callback function
  void (*callback)(conn_t *conn);

  // The page size used
  uint32_t pagesize;

  // Socket read timeout
  uint32_t rtimeout;

  // Socket write timeout
  uint32_t wtimeout;
} MPool;

extern int pipe_sz;
extern int pipe_in, pipe_out, nullfd;
extern FILE *logfd;
extern struct io_uring ring;
extern MPool pool;
extern conn_t *current_recv;
extern conn_t *current_send;

/*
 * Prepare and submit a recv uring op
 */
static inline int urecv(conn_t *conn, void *buffer, size_t buff_size, int flags) {
  if (!conn || conn->fd == -1)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (flags == MSG_PEEK) ? PEEK : RECV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;

  io_uring_prep_recv(sqe, conn->fd, buffer, buff_size, flags);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a multi-shot accept uring op
 */
static inline int umaccept(int listenfd) {
  if (listenfd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = ACCEPT;
  io_uring_prep_multishot_accept(sqe, listenfd, NULL, NULL, SOCK_NONBLOCK);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a splice uring op
 */
static inline int usplice(conn_t *conn, int fd_in, int64_t off_in, int fd_out, int64_t off_out, size_t len) {
  if (!len || !conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = (__u64)conn;
  io_uring_prep_splice(sqe, fd_in, off_in, fd_out, off_out, len, 0);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a writev uring op
 */
static inline int uwritev(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = WRITEV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  io_uring_prep_writev(sqe, conn->fd, &conn->ios[iov_index], nios, -1);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a send uring op
 */
static inline int usend(conn_t *conn, char *res_buff, size_t buff_size, bool zc) {
  if (!conn || conn->fd <= 0 || buff_size == 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (zc) ? SENDZC : SEND;
  conn->data_left = buff_size;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  if (zc)
    io_uring_prep_send_zc(sqe, conn->fd, res_buff, buff_size, 0, 0);
  else
    io_uring_prep_send(sqe, conn->fd, res_buff, buff_size, 0);
  return io_uring_submit(&ring);
}

static inline int ufrecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = FRECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;

  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, rec->iov_len);
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int urecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = RECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int usendmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  bool zc = (conn->data_left > ZC_RES) ? true : false;
  conn->op = (zc) ? SENDMSGZC : SENDMSG;

  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  if (zc) {
    io_uring_prep_sendmsg_zc(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
    conn->zc_notifs++;
  } else {
    io_uring_prep_sendmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  }
  return io_uring_submit(&ring);
}

/*
 * Create and initialize a server socket
 */
static inline int tcp_listen(uint16_t port) {
  int enable;
  int listenfd;
  if ((listenfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    return -1;

  int flags = fcntl(listenfd, F_GETFL, 0);
  fcntl(listenfd, F_SETFL, flags | O_NONBLOCK);
  struct sockaddr_in servaddr;
  memset(&servaddr, 0, sizeof(servaddr));
  servaddr.sin_family = AF_INET;
  servaddr.sin_addr.s_addr = INADDR_ANY;
  servaddr.sin_port = htons(port);

  enable = 1;
  if (setsockopt(listenfd, SOL_SOCKET, SO_REUSEPORT, &enable, sizeof(enable)) < 0)
    return -1;

  if (bind(listenfd, (struct sockaddr *)&servaddr, sizeof(servaddr)) < 0)
    return -1;

  if (listen(listenfd, SOMAXCONN) < 0)
    return -1;

  return listenfd;
}

/*
 * Calculate the difference between two pointers
 */
static inline uintptr_t ptr_diff(uintptr_t p1, uintptr_t p2) { return (uintptr_t)(p1 > p2) ? (p1 - p2) : (p2 - p1); }

static inline size_t get_nroutes(Route *routes) {
  Route *route;
  for (size_t i = 0;; i++) {
    route = &routes[i];
    if (!route->path && !route->handler && !route->method)
      return i;
  }
}

static inline long get_content_length(char *src, char *end) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return -1;
    key = line;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, "Content-Length") != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;

    *line_end = '\0';
    long res = atol(value);
    *line_end = '\r';

    return res;
  }
  return -1;
}

static inline bool have_header(char *src, char *end, const char *header_key, const char *header_value) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    key = line;
    while (*key == ' ')
      key++;
    while (*header_key == ' ')
      header_key++;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return false;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, header_key) != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;
    while (*header_value == ' ')
      header_value++;

    *line_end = '\0';
    bool res = (strcasecmp(value, header_value) == 0);
    *line_end = '\r';

    return res;
  }

  return false;
}

static inline const char *method_str(Method method) {
  switch (method) {
  case GET:
    return "GET";
    break;
  case HEAD:
    return "HEAD";
    break;
  case POST:
    return "POST";
    break;
  case PUT:
    return "PUT";
    break;
  case DELETE:
    return "DELETE";
    break;
  case CONNECT:
    return "CONNECT";
    break;
  case OPTIONS:
    return "OPTIONS";
    break;
  case TRACE:
    return "TRACE";
    break;
  case PATCH:
    return "PATCH";
    break;
  default:
    return NULL;
  }
}

static inline uint8_t method_len(Method method) {
  switch (method) {
  case GET:
    return 3;
    break;
  case HEAD:
    return 4;
    break;
  case POST:
    return 4;
    break;
  case PUT:
    return 3;
    break;
  case DELETE:
    return 6;
    break;
  case CONNECT:
    return 7;
    break;
  case OPTIONS:
    return 7;
    break;
  case TRACE:
    return 5;
    break;
  case PATCH:
    return 5;
    break;
  default:
    return 0;
  }
}

static inline size_t round_to_blocks(size_t size) {
  size_t nblocks = BYTES_TO_BLOCKS(size);
  nblocks = CEIL_BLOCKS(nblocks);
  return nblocks;
}

/*
 * Count the digits in unsigned 64-bit int
 */
static inline int countd(uint64_t num) {
  if (num < 10ULL)
    return 1;
  if (num < 100ULL)
    return 2;
  if (num < 1000ULL)
    return 3;
  if (num < 10000ULL)
    return 4;
  if (num < 100000ULL)
    return 5;
  if (num < 1000000ULL)
    return 6;
  if (num < 10000000ULL)
    return 7;
  if (num < 100000000ULL)
    return 8;
  if (num < 1000000000ULL)
    return 9;
  if (num < 10000000000ULL)
    return 10;
  if (num < 100000000000ULL)
    return 11;
  if (num < 1000000000000ULL)
    return 12;
  if (num < 10000000000000ULL)
    return 13;
  if (num < 100000000000000ULL)
    return 14;
  if (num < 1000000000000000ULL)
    return 15;
  if (num < 10000000000000000ULL)
    return 16;
  if (num < 100000000000000000ULL)
    return 17;
  if (num < 1000000000000000000ULL)
    return 18;
  if (num < 10000000000000000000ULL)
    return 19;
  return 20;
}

/*
 * Get the time elabsed in ms
 */
static inline uint64_t get_time() {
  struct timespec ts;
  clock_gettime(CLOCK_MONOTONIC, &ts);
  return (uint64_t)(ts.tv_sec) * 1000 + (ts.tv_nsec / 1000000);
}

static inline FILE *log_init(const char *path) {
  FILE *res = fopen(path, "a+");
  setvbuf(res, NULL, _IONBF, 0);
  return res;
}

static inline int16_t pollevs(int connfd) {
  struct pollfd pfd;
  pfd.fd = connfd;
  pfd.events = POLLIN | POLLOUT | POLLERR;
  int res = poll(&pfd, 1, 0);
  if (res < 0)
    return POLLERR;
  return pfd.revents;
}

// FIXME This needs to be updated
static inline conn_t *MP_use_once(size_t nblocks, int fd) {

  void *mem = malloc(sizeof(conn_t) + 8 + (IOVEC_NBLOCKS * MP_BLOCK));
  struct conn_t *conn = (conn_t *)mem;
  memset(conn, 0, sizeof(conn_t));
  conn->ios = mem + sizeof(conn_t) + 8;

  if (nblocks > 0) {
    struct iovec *iov = &conn->ios[conn->nios++];
    mem = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (mem == MAP_FAILED)
      return NULL;
    iov->iov_base = mem;
    iov->iov_len = ALIGN_TO_PAGESIZE(nblocks * MP_BLOCK);
  }

  conn->flags |= CF_IN_HEAP;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;

  return conn;
}

static inline int find_freec() {
  uint64_t *word;
  size_t map_size = (sizeof(uint64_t) * 8);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    word = &pool.freecs[i / map_size];

    if (*word == 0) { // All used
      i += (map_size - 1);
      continue;
    }

    i += __builtin_ctzll(*word);
    MARK_BIT_USED(*word, i);
    return i;
  }

  return -1;
}

static inline int MP_init(size_t npages) {
  if (!npages)
    return -1;

  /*** Setup ***/
  pool.npages = npages;
  pool.pagesize = sysconf(_SC_PAGESIZE);

  /*** Pool ***/
  pool.bpool = mmap(NULL, pool.npages * pool.pagesize, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  if (pool.bpool == MAP_FAILED)
    return -1;
  pool.nblocks = (pool.npages * pool.pagesize) / MP_BLOCK;

  /*** Blocks ***/
  pool.blocks = malloc(sizeof(void *) * pool.nblocks);
  if (!pool.blocks)
    return -1;
  for (size_t i = 0; i < pool.nblocks; i++)
    pool.blocks[i] = pool.bpool + (i * MP_BLOCK);

  /*** Freebs ***/
  // if (posix_memalign((void **)&pool.freebs, 64, bitmap_size * sizeof(uint64_t)) < 0)
  size_t bitmap_size = (pool.nblocks + 63) / 64;
  pool.freebs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freebs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freebs[i] = UINT64_MAX;

  /*** Cpool ***/
  pool.cpool = (conn_t *)malloc(sizeof(conn_t) * MAX_CONNS);
  if (!pool.cpool)
    return -1;

  /*** Conns ***/
  pool.conns = (conn_t **)malloc(sizeof(conn_t *) * MAX_CONNS);
  if (!pool.conns)
    return -1;
  size_t conn_size = sizeof(conn_t);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    pool.conns[i] = (conn_t *)((char *)pool.cpool + (i * conn_size));
    pool.conns[i]->fd = -1;
    pool.conns[i]->in_fd = -1;
    pool.conns[i]->out_fd = -1;
  }

  /*** Freecs ***/
  bitmap_size = (MAX_CONNS + 63) / 64;
  pool.freecs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freecs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freecs[i] = UINT64_MAX;

  return 0;
}

static inline int MP_use_blks(size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t max_start = pool.nblocks - nblocks;
  size_t full_chunks = (nblocks / 64) * 64;

  for (size_t i = 0, c = 0; i <= max_start; i++, c++) {
    bool free = true;

    for (size_t j = 0; j < full_chunks; j += 64) {
      size_t word_index = (i + j) / 64;
      if (pool.freebs[word_index] != UINT64_MAX) {
        free = false;
        i += 63;
        break;
      }
    }

    for (size_t j = full_chunks; j < nblocks; j++) {
      size_t bit_index = i + j;
      size_t word_index = bit_index / 64;
      size_t bit_in_word = bit_index % 64;

      if (!BIT_IS_FREE(pool.freebs[word_index], bit_in_word)) {
        free = false;
        i += j;
        break;
      }
    }

    if (free) {
      for (size_t j = 0; j < full_chunks; j += 64) {
        size_t word_index = (i + j) / 64;
        pool.freebs[word_index] = 0;
      }

      for (size_t j = full_chunks; j < nblocks; j++) {
        size_t bit_index = i + j;
        size_t word_index = bit_index / 64;
        size_t bit_in_word = bit_index % 64;

        MARK_BIT_USED(pool.freebs[word_index], bit_in_word);
      }

      return i;
    }
  }

  return -1;
}

static inline int MP_free_blks(size_t bindex, size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t full_chunks = (nblocks / 64) * 64;
  for (size_t i = 0; i < full_chunks; i += 64) {
    size_t word_index = (bindex + i) / 64;
    pool.freebs[word_index] = UINT64_MAX;
  }

  for (size_t i = full_chunks; i < nblocks; i++) {
    size_t bit_index = bindex + i;
    size_t word_index = bit_index / 64;
    size_t bit_in_word = bit_index % 64;

    MARK_BIT_FREE(pool.freebs[word_index], bit_in_word);
  }

  memset(pool.blocks[bindex], 0, nblocks * MP_BLOCK);
  return 0;
}

static inline conn_t *MP_use(size_t nblocks, int fd, bool once) {
  if (fd <= 0)
    return NULL;
  if (once)
    return MP_use_once(nblocks, fd);

  int cindex = find_freec();
  if (cindex < 0) {
    LOG("Err: cindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  conn_t *conn = pool.conns[cindex];

  int ios_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (ios_bindex < 0) {
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }

  struct iovec *ios = pool.blocks[ios_bindex];
  conn->ios = ios;

  int rec_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (rec_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct iovec *rec = pool.blocks[rec_bindex];
  conn->rec = rec;

  int msg_bindex = MP_use_blks(MSG_NBLOCKS);
  if (msg_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct msghdr *msg = pool.blocks[msg_bindex];
  conn->msg = msg;

  if (nblocks > 0) {
    int bindex = MP_use_blks(nblocks);
    if (bindex < 0) {
      MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
      MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
      MP_free_blks(msg_bindex, IOVEC_NBLOCKS);
      MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
      LOG("Err: bindex < 0; will use MP_use_once\n");
      return MP_use_once(nblocks, fd);
    }

    size_t iov_index = conn->nios++;
    struct iovec *iov = &conn->ios[iov_index];
    struct iovec *rec = &conn->rec[iov_index];
    iov->iov_base = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
  }

  conn->msg->msg_iov = conn->ios;
  conn->msg->msg_iovlen = conn->nios;
  conn->cindex = cindex;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;
  return conn;
}

static inline void MP_shed(conn_t *conn, size_t iov_index, size_t nios) {
  struct iovec *iov, *rec;
  size_t bindex, nblocks, index;

  for (size_t i = 0; i < nios; i++) {
    index = iov_index + i;
    iov = &conn->ios[index];
    rec = &conn->rec[index];
    if (!rec || !rec->iov_base)
      continue;
    if (!IN_POOL(rec->iov_base)) {
      munmap(rec->iov_base, rec->iov_len / pool.pagesize);
    } else {
      bindex = ptr_diff((uintptr_t)rec->iov_base, (uintptr_t)pool.bpool) / MP_BLOCK;
      nblocks = rec->iov_len / MP_BLOCK;
      MP_free_blks(bindex, nblocks);
    }
    memset(iov, 0, sizeof(struct iovec));
    memset(rec, 0, sizeof(struct iovec));
    conn->nios--;
  }
}

static inline int MP_expand(conn_t *conn, size_t nblocks, bool once) {
  void *bptr;
  int iov_index, bindex;
  struct iovec *iov, *rec;

  iov_index = conn->nios++;
  iov = &conn->ios[iov_index];
  rec = &conn->rec[iov_index];

  if (nblocks == 0)
    return iov_index;

  if (once) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_base = bptr;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
    return iov_index;
  }

  bindex = MP_use_blks(nblocks);
  if (bindex < 0) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_len = iov->iov_len;
  } else {
    bptr = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_len = iov->iov_len;
  }

  iov->iov_base = bptr;
  rec->iov_base = iov->iov_base;
  return iov_index;
}

static inline int MP_free(conn_t *conn) {
  if (!conn)
    return -1;
  size_t bindex, nblocks;
  uint64_t *word;

  MP_shed(conn, 0, conn->nios);
  if (conn->flags & CF_IN_HEAP) {
    if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
      close(conn->fd);
    free(conn);
    return 0;
  }

  word = &pool.freecs[conn->cindex / 64];
  if (conn->cindex > MAX_CONNS)
    return -1;
  else if (BIT_IS_FREE(*word, conn->cindex))
    return 0;

  bindex = ptr_diff((uintptr_t)conn->ios, (uintptr_t)pool.bpool) / MP_BLOCK;
  nblocks = IOVEC_NBLOCKS;
  MP_free_blks(bindex, nblocks);

  bindex = ptr_diff((uintptr_t)conn->rec, (uintptr_t)pool.bpool) / MP_BLOCK;
  MP_free_blks(bindex, nblocks);

  if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
    close(conn->fd);

  MARK_BIT_FREE(*word, conn->cindex);
  memset(conn, 0, sizeof(conn_t));
  conn->fd = -1;
  conn->in_fd = -1;
  conn->out_fd = -1;
  return 0;
}

static inline void MP_clear(conn_t *conn) {
  conn_t *recv_conn = conn->recv_conn;
  conn_t *send_conn = conn->send_conn;
  if (recv_conn)
    MP_free(recv_conn);
  if (send_conn)
    MP_free(send_conn);
}

static inline void MP_exit(MPool *pool) {
  munmap(pool->bpool, pool->npages);
  free(pool->cpool);
  free(pool->blocks);
  free(pool->conns);
  free(pool->freebs);
  free(pool->freecs);
}

static inline void MP_timeout() {
  conn_t *conn;
  int16_t res;
  uint64_t now;
  size_t windex = 0;
  uint64_t *word = &pool.freecs[0];
  for (size_t i = 0; i < MAX_CONNS; i++) {
    if ((i / 64) < windex)
      word = &pool.freecs[++windex];

    if (*word == UINTMAX_MAX) {
      i = (i / 64) * 64 + 64;
      continue;
    }

    conn = pool.conns[i];
    if (!conn || conn->fd == -1)
      continue;

    res = pollevs(conn->fd);

    now = get_time();
    if (res & POLLERR) {
      MP_clear(conn);
      continue;
    }
    if (res & POLLIN) {
      if (pool.rtimeout > 0 && (now - conn->last_read) >= pool.rtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (res & POLLOUT) {
      if (pool.wtimeout > 0 && (now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (!(res & POLLIN || res & POLLOUT)) {
      if ((pool.rtimeout > 0 && now - conn->last_read) >= pool.rtimeout
          || (pool.wtimeout > 0 && now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
  }
}

/*
 * Calculate the length of a status string
 */
static inline size_t status_len(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return 8;
  case STATUSSWITCHINGPROTOCOLS:
    return 19;
  case STATUSPROCESSING:
    return 10;
  case STATUSEARLYHINTS:
    return 11;
  case STATUSOK:
    return 2;
  case STATUSCREATED:
    return 7;
  case STATUSACCEPTED:
    return 8;
  case STATUSNONAUTHORITATIVE:
    return 29;
  case STATUSNOCONTENT:
    return 10;
  case STATUSRESETCONTENT:
    return 13;
  case STATUSPARTIALCONTENT:
    return 15;
  case STATUSMULTISTATUS:
    return 12;
  case STATUSALREADYREPORTED:
    return 16;
  case STATUSIMUSED:
    return 7;
  case STATUSMULTIPLECHOICES:
    return 16;
  case STATUSMOVEDPERMANENTLY:
    return 17;
  case STATUSFOUND:
    return 5;
  case STATUSSEEOTHER:
    return 9;
  case STATUSNOTMODIFIED:
    return 12;
  case STATUSUSEPROXY:
    return 9;
  case STATUSTEMPORARYREDIRECT:
    return 18;
  case STATUSPERMANENTREDIRECT:
    return 18;
  case STATUSBADREQUEST:
    return 11;
  case STATUSUNAUTHORIZED:
    return 12;
  case STATUSPAYMENTREQUIRED:
    return 16;
  case STATUSFORBIDDEN:
    return 9;
  case STATUSNOTFOUND:
    return 9;
  case STATUSMETHODNOTALLOWED:
    return 18;
  case STATUSNOTACCEPTABLE:
    return 14;
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return 29;
  case STATUSREQUESTTIMEOUT:
    return 15;
  case STATUSCONFLICT:
    return 8;
  case STATUSGONE:
    return 4;
  case STATUSLENGTHREQUIRED:
    return 15;
  case STATUSPRECONDITIONFAILED:
    return 19;
  case CONTENTTOOLARGE:
    return 17;
  case STATUSURITOOLONG:
    return 12;
  case STATUSUNSUPPORTEDMEDIATYPE:
    return 22;
  case STATUSRANGENOTSATISFIABLE:
    return 21;
  case STATUSEXPECTATIONFAILED:
    return 18;
  case STATUSMISDIRECTEDREQUEST:
    return 19;
  case STATUSUNPROCESSABLECONTENT:
    return 21;
  case STATUSLOCKED:
    return 6;
  case STATUSFAILEDDEPENDENCY:
    return 17;
  case STATUSTOOEARLY:
    return 9;
  case STATUSUPGRADEREQUIRED:
    return 16;
  case STATUSPRECONDITIONREQUIRED:
    return 21;
  case STATUSTOOMANYREQUESTS:
    return 17;
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return 31;
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return 29;
  case STATUSInternalServerError:
    return 21;
  case STATUSNOTIMPLEMENTED:
    return 15;
  case STATUSBADGATEWAY:
    return 11;
  case STATUSSERVICEUNAVAILABLE:
    return 19;
  case STATUSGATEWAYTIMEOUT:
    return 15;
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return 26;
  case STATUSVARIANTALSONEGOTIATES:
    return 23;
  case STATUSINSUFFICIENTSTORAGE:
    return 20;
  case STATUSLOOPDETECTED:
    return 13;
  case STATUSNOTEXTENDED:
    return 12;
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return 31;
  default:
    return 0;
  }
}

/*
 * Return the status code string as string literal
 */
static inline char *status_str(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return "Continue";
  case STATUSSWITCHINGPROTOCOLS:
    return "Switching Protocols";
  case STATUSPROCESSING:
    return "Processing";
  case STATUSEARLYHINTS:
    return "Early Hints";
  case STATUSOK:
    return "OK";
  case STATUSCREATED:
    return "Created";
  case STATUSACCEPTED:
    return "Accepted";
  case STATUSNONAUTHORITATIVE:
    return "Non-Authoritative Information";
  case STATUSNOCONTENT:
    return "No Content";
  case STATUSRESETCONTENT:
    return "Reset Content";
  case STATUSPARTIALCONTENT:
    return "Partial Content";
  case STATUSMULTISTATUS:
    return "Multi-Status";
  case STATUSALREADYREPORTED:
    return "Already Reported";
  case STATUSIMUSED:
    return "Im Used";
  case STATUSMULTIPLECHOICES:
    return "Multiple Choices";
  case STATUSMOVEDPERMANENTLY:
    return "Moved Permanently";
  case STATUSFOUND:
    return "Found";
  case STATUSSEEOTHER:
    return "See Other";
  case STATUSNOTMODIFIED:
    return "Not Modified";
  case STATUSUSEPROXY:
    return "Use Proxy";
  case STATUSTEMPORARYREDIRECT:
    return "Temporary Redirect";
  case STATUSPERMANENTREDIRECT:
    return "Permanent Redirect";
  case STATUSBADREQUEST:
    return "Bad Request";
  case STATUSUNAUTHORIZED:
    return "Unauthorized";
  case STATUSPAYMENTREQUIRED:
    return "Payment Required";
  case STATUSFORBIDDEN:
    return "Forbidden";
  case STATUSNOTFOUND:
    return "Not Found";
  case STATUSMETHODNOTALLOWED:
    return "Method Not Allowed";
  case STATUSNOTACCEPTABLE:
    return "Not Acceptable";
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return "Proxy Authentication Required";
  case STATUSREQUESTTIMEOUT:
    return "Request Timeout";
  case STATUSCONFLICT:
    return "Conflict";
  case STATUSGONE:
    return "Gone";
  case STATUSLENGTHREQUIRED:
    return "Length Required";
  case STATUSPRECONDITIONFAILED:
    return "Precondition Failed";
  case CONTENTTOOLARGE:
    return "Content Too Large";
  case STATUSURITOOLONG:
    return "URI Too Long";
  case STATUSUNSUPPORTEDMEDIATYPE:
    return "Unsupported Media Type";
  case STATUSRANGENOTSATISFIABLE:
    return "Range Not Satisfiable";
  case STATUSEXPECTATIONFAILED:
    return "Expectation Failed";
  case STATUSMISDIRECTEDREQUEST:
    return "Misdirected Request";
  case STATUSUNPROCESSABLECONTENT:
    return "Unprocessable Content";
  case STATUSLOCKED:
    return "Locked";
  case STATUSFAILEDDEPENDENCY:
    return "Failed Dependency";
  case STATUSTOOEARLY:
    return "Too Early";
  case STATUSUPGRADEREQUIRED:
    return "Upgrade Required";
  case STATUSPRECONDITIONREQUIRED:
    return "Precondition Required";
  case STATUSTOOMANYREQUESTS:
    return "Too Many Requests";
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return "Request Header Fields Too Large";
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return "Unavailable For Legal Reasons";
  case STATUSInternalServerError:
    return "Internal Server Error";
  case STATUSNOTIMPLEMENTED:
    return "Not Implemented";
  case STATUSBADGATEWAY:
    return "Bad Gateway";
  case STATUSSERVICEUNAVAILABLE:
    return "Service Unavailable";
  case STATUSGATEWAYTIMEOUT:
    return "Gateway Timeout";
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return "HTTP Version Not Supported";
  case STATUSVARIANTALSONEGOTIATES:
    return "Variant Also Negotiates";
  case STATUSINSUFFICIENTSTORAGE:
    return "Insufficient Storage";
  case STATUSLOOPDETECTED:
    return "Loop Detected";
  case STATUSNOTEXTENDED:
    return "Not Extended";
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return "Network Authentication Required";
  default:
    return 0;
  }
}

/*
 * Return true if routes match
 */
static inline bool route_equ(Route *route, Request *req) {
  return route->method == req->method && strncmp(route->path, req->path, strlen(route->path)) == 0;
}

/*
 * Return the matching route index on success. -1 on failure
 */
static inline int match_route(Server *serv, Request *req) {
  for (size_t i = 0; i < serv->_nroutes; i++) {
    Route route = serv->routes[i];
    if (!req->path || !route.path)
      continue;
    if (route_equ(&route, req))
      return i;
    else if (req->method == HEAD && route.method == GET && strcmp(route.path, req->path) == 0)
      return i;
  }
  return -1;
}

/*
 * Return true if the response should contain the Content-Length header
 */
static inline bool should_have_content_length(Request *req, ResWriter *res) {
  return (req->method != CONNECT              // CONNECT request
          && res->status != STATUSNOCONTENT   // 204 response
          && res->status != STATUSNOTMODIFIED // 304 response
          && res->status >= 200);             // 1xx response
}

/*
 * Format http response from the ResWriter.
 * Return response size on success, 0 on failure.
 */
static inline size_t fmt_res(Request *req, ResWriter *res, char *buffer, size_t buffer_size) {
  if (!res || !buffer || buffer_size == 0)
    return 0;

  size_t res_len, total = 0;
  char *dst = buffer;
  size_t maxlen = buffer_size;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t body_length = res->len;

  res_len = snprintf(dst, maxlen, "HTTP/1.1 %d %s", (int)res->status, status_str(res->status));
  total += res_len;
  dst += res_len;
  maxlen -= res_len;

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    res_len = snprintf(dst, maxlen, "\r\n%s: %s", header->key, header->value);
    total += res_len;
    dst += res_len;
    maxlen -= res_len;
  }

  if (have_content_length) {
    res_len = snprintf(dst, maxlen, "\r\nContent-Length: %lu", body_length);
    total += res_len, dst += res_len, maxlen -= res_len;
  }

  memcpy(dst, "\r\n\r\n", 4);
  total += 4, dst += 4, maxlen -= 4;

  return total;
}

static inline size_t res_len(Request *req, ResWriter *res) {
  if (!req || !res)
    return 0;

  if (!res->status)
    res->status = STATUSOK;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t result = 0;
  result += STRLEN("HTTP/1.1 ");     // HTTP version
  result += 4;                       // Status code + space
  result += status_len(res->status); // Status name

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    result += 2;                       // "\r\n"
    result += strlen(header->key) + 2; // Header key + ':' + space
    result += strlen(header->value);   // header value
  }

  if (have_content_length) {
    result += 2;                          // "\r\n"
    result += STRLEN("Content-Length: "); // Header key
    result += countd(res->len);           // Header value
  }

  result += 4; // "\r\n\r\n"

  return result;
}

static inline int send_empty_res(Status status) {
  size_t res_len = STRLEN("HTTP/1.1 ")        // HTTP version
                   + countd((uint64_t)status) // status code
                   + 1                        // space
                   + (int)status_len(status)  // status string
                   + 4;                       // \r\n\r\n

  conn_t *conn = current_send;
  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, res_len);
  if (snprintf((char *)rec->iov_base, res_len + 1, "HTTP/1.1 %d %s\r\n\r\n", (int)status, status_str(status))
      != (int)res_len)
    return -1;

  return usendmsg(conn, 0, 1);
}

static inline ssize_t read_socket(int sockfd, size_t len) {
  if (len == 0 || sockfd <= 0)
    return 0;
  char buff[1024 * 8];
  return read(sockfd, buff, 1024 * 8);
}

static inline int read_method(Method *method, void *src) {
  if (memcmp(src, "GET", 3) == 0)
    *method = GET;
  else if (memcmp(src, "POST", 4) == 0)
    *method = POST;
  else if (memcmp(src, "HEAD", 4) == 0)
    *method = HEAD;
  else if (memcmp(src, "PUT", 3) == 0)
    *method = PUT;
  else if (memcmp(src, "DELETE", 6) == 0)
    *method = DELETE;
  else if (memcmp(src, "CONNECT", 7) == 0)
    *method = CONNECT;
  else if (memcmp(src, "OPTIONS", 7) == 0)
    *method = OPTIONS;
  else if (memcmp(src, "TRACE", 5) == 0)
    *method = TRACE;
  else if (memcmp(src, "PATCH", 5) == 0)
    *method = PATCH;
  else
    return -1;

  return 0;
}

static inline int sendmsg_res(Request *req, ResWriter *res) {
  conn_t *conn;
  size_t head_size, res_size;
  struct iovec *iov;

  conn = current_send;
  iov = &conn->ios[0];
  head_size = res_len(req, res);
  if (head_size == 0)
    return -1;

  conn->data_left += head_size;
  res_size = fmt_res(req, res, iov->iov_base, (head_size + 1));
  if (res_size != head_size)
    return -1;
  iov->iov_len = res_size;

  return usendmsg(conn, 0, conn->nios);
}

static inline int read_req(Request *req, char *req_buffer) {
  if (!req_buffer)
    return -1;
  /*** Method ***/
  char *sep = strchr(req_buffer, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }
  *sep = '\0';
  if (read_method(&req->method, req_buffer) < 0)
    return -1;

  /*** Path ***/
  char *fullpath = sep + 1;
  sep = strchr(fullpath, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }

  *sep = '\0';
  req->path = fullpath;
  /*** Params ***/
  char *paramStart = strchr(fullpath, '?');
  if (paramStart) {
    *paramStart++ = '\0';
    int params_count = 0;
    params_count = HK_parse_params(paramStart, req->params, MAX_URL_PARAMETERS);
    if (params_count > 0)
      req->params_count = params_count;
    else
      req->params_count = 0;
  } else {
    req->params = NULL;
    req->params_count = 0;
  }

  /*** Headers ***/
  char *headStart = strstr(sep + 1, "\r\n");
  char *headEnd = strstr(sep + 1, "\r\n\r\n");
  if (!headStart) {
    LOG("read_req: !headStart\n");
    return -1;
  };

  memset(headStart, 0, 2);
  headStart += 2;
  memset(headEnd, 0, 4);
  headEnd += 4;

  int headers_count = HK_parse_headers(headStart, req->headers, MAX_REQ_HEADERS);
  if (headers_count <= 0)
    return -1;
  req->headers_count = headers_count;

  /*** Host ***/
  int index = HK_get_header(req, "Host");
  if (index < 0)
    return -1;
  char *host = req->headers[index].value;
  req->hostname = host;

  /*** Port ***/
  char *colon = strchr(host, ':');
  if (colon) {
    *colon++ = '\0';
    req->port = atoi(colon);
  } else {
    req->port = PORT;
  }
  return 0;
}
static inline int process_req(Server *serv, conn_t *conn) {
  if (!conn || conn->fd == -1)
    return -1;

  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;
  if (read_req(&req, conn->ios[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    LOG("Err: route_index == -1\n");
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;
  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  sendmsg_res(&req, &res);

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int new_conn(int connfd) {
  if (connfd <= 0)
    return -1;

  current_recv = MP_use(KB * 2, connfd, false);
  current_send = MP_use(KB * 2, connfd, false);

  current_recv->recv_conn = current_recv;
  current_recv->send_conn = current_send;

  current_send->send_conn = current_send;
  current_send->recv_conn = current_recv;

  conn_t *conn = current_recv;
  if (ufrecvmsg(conn, 0, 1) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

static inline int resubmit_sendmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return usendmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int resubmir_recvmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    // FIXME the len should be increased
    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return urecvmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int handle_sendmsg_complete(conn_t *conn) {
  struct iovec *iov, *rec;

  MP_shed(conn, 1, conn->nios - 1);
  iov = &conn->ios[0];
  rec = &conn->rec[0];
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;

  return ufrecvmsg(conn->recv_conn, 0, 1);
}

static inline int handle_sendmsg(conn_t *conn, int res, bool zc) {
  if (!conn || conn->fd == -1)
    return -1;

  conn->data_left -= res;
  if (conn->data_left > 0)
    return resubmit_sendmsg(conn, res);

  if (zc)
    return 0;

  return handle_sendmsg_complete(conn);
}

static inline int handle_insplice(conn_t *conn) {
  conn->op = OUTSPLICE;
  return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
}
static inline int handle_outsplice(conn_t *conn, int res) {
  conn->data_left -= res;
  if (conn->data_left > 0) {
    conn->op = INSPLICE;
    return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
  }

  conn_t *recv_conn = conn->recv_conn;
  struct iovec *iov = &recv_conn->ios[0];
  memset(iov->iov_base, 0, iov->iov_len);
  if (urecv(recv_conn, iov->iov_base, iov->iov_len, MSG_PEEK) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

/*
static inline int handle_recv(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  void *bptr = conn->ios[0].iov_base;
  void *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  void *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  return process_req(serv, conn);
}
*/
static inline int find_route(Server *serv, char *bptr) {
  Request req = {0};
  if (read_method(&req.method, bptr) < 0) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  };
  char *space = strchr(bptr, ' ');
  req.path = (space + 1);
  space = strchr(req.path, ' ');
  *space = '\0';
  int route_index = match_route(serv, &req);
  *space = ' ';
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }
  return route_index;
}

static inline int run_handler(Server *serv, conn_t *conn, bool uses_body) {
  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;

  if (read_req(&req, conn->rec[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  if (uses_body) {
    int h_index = HK_get_header(&req, "Content-Length");
    long body_size = atol(req.headers[h_index].value);
    if (body_size >= 0) {
      req.body.ptr = conn->rec[1].iov_base;
      req.body.size = body_size;
    } else {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    }
  }

  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  if (sendmsg_res(&req, &res) < 0)
    return -1;

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int handle_frecvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  char *bptr = (char *)conn->ios[0].iov_base;
  char *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  char *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  size_t head_size = (headEnd + 4) - bptr;
  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  int route_index = find_route(serv, bptr);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  bool uses_body = serv->routes[route_index].uses_body;
  long body_size = get_content_length(headstart + 2, headEnd + 4);
  if (body_size == -1) {
    if (uses_body) {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    } else {
      body_size = 0;
    }
  }

  conn->head_size = head_size;
  if (!uses_body) {
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  if (res == (int)(head_size + body_size)) {
    size_t iov_index = MP_expand(conn, round_to_blocks(body_size), false);
    memcpy(conn->rec[iov_index].iov_base, headEnd + 4, body_size);
    conn->ios[iov_index].iov_len = body_size;
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  conn->data_left = body_size - (res - head_size);
  bool once = ((size_t)body_size > (size_t)((pool.nblocks * MP_BLOCK) / 10));
  size_t iov_index = MP_expand(conn, round_to_blocks(body_size), once);
  memcpy(conn->rec[iov_index].iov_base, headEnd + 4, (res - head_size));
  conn->ios[iov_index].iov_base += (res - head_size);

  return urecvmsg(conn, iov_index, 1);
}

static inline int handle_recvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  if (conn->data_left > 0) {
    conn->data_left -= res;
    if (conn->data_left == 0) {
      conn->flags &= CF_HANDLER_READY;
      return run_handler(serv, conn, true);
    }

    conn->flags &= ~CF_HANDLER_READY;
    conn->ios[1].iov_base += res;
    return urecvmsg(conn, 1, 1);
  }

  conn->flags &= CF_HANDLER_READY;
  return run_handler(serv, conn, true);
}

static inline int serv_init(Server *serv) {
#if DEBUG
  logfd = log_init("log.txt");
  if (!logfd) {
    printf("log_init failed");
    return -1;
  }
#endif
  serv->_nroutes = get_nroutes(serv->routes);

  int pipefd[2];
  if (pipe(pipefd) < 0)
    return -1;
  pipe_in = pipefd[0];
  pipe_out = pipefd[1];
  nullfd = open("/dev/null", O_WRONLY);
  pipe_sz = fcntl(pipefd[0], F_GETPIPE_SZ);
  if (pipe_sz < 0)
    return -1;

  pool.rtimeout = serv->rtimeout;
  pool.wtimeout = serv->wtimeout;
  if (MP_init(MAX_CONNS * 8) < 0)
    return -1;
  LOG("pool initialized\n");

  if (io_uring_queue_init(MAX_CONNS, &ring, 0) < 0)
    return -1;
  LOG("uring initialized\n");

  int listenfd;
  if ((listenfd = tcp_listen(serv->port)) < 0)
    return -1;
  LOG("socket initialized\n");

  return umaccept(listenfd);
}

static inline int serv_listen(Server *serv) {
  // uint64_t last_check = get_time();
  while (true) {
    // uint64_t now = get_time();
    // if ((now - last_check) >= 200) {
    //   last_check = now;
    //   LOG("CM: CM_check ran\n");
    //   MP_timeout();
    // }

    LOG("SQ ready: %u, CQ ready: %u\n", io_uring_sq_ready(&ring), io_uring_cq_ready(&ring));
    struct io_uring_cqe *cqe;
    if (io_uring_wait_cqe(&ring, &cqe) < 0)
      continue;

    int res = cqe->res;
    LOG("res = %d\n", res);
    conn_t *conn = NULL;
    if (cqe->user_data > 100) {
      conn = (conn_t *)cqe->user_data;
      current_recv = (conn_t *)conn->recv_conn;
      current_send = (conn_t *)conn->send_conn;
    }

    if (res > 0) {
      if (cqe->user_data == ACCEPT) {
        LOG("new conn created\n");
        new_conn(res);
      } else if (conn && conn->fd != -1) {
        LOG("conn[%d]: conn.fd = %d; conn.op = %d\n", conn->cindex, conn->fd, conn->op);
        switch (conn->op) {
        case FRECVMSG:
          if (handle_frecvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case RECVMSG:
          if (handle_recvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case SENDMSG:
        case SENDMSGZC:
          // conn->last_write = get_time();
          bool zc = (conn->op == SENDMSGZC);
          if (handle_sendmsg(conn, res, zc) < 0)
            MP_clear(conn);
          break;
        case INSPLICE:
          if (handle_insplice(conn) < 0)
            MP_clear(conn);
          break;
        case OUTSPLICE:
          if (handle_outsplice(conn, res) < 0)
            MP_clear(conn);
          break;
        }
      }
    } else if (res == 0) {
      if (conn && conn->fd != -1) {
        switch (conn->op) {
        case SENDMSGZC:
          conn->zc_notifs--;
          if (conn->zc_notifs == 0 && handle_sendmsg_complete(conn) < 0)
            MP_clear(conn);
          break;
        case RECV:
          MP_clear(conn);
          break;
        }
      }
    } else {
      if (conn && conn->fd != -1) {
        if (res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR) {
          LOG("conn && conn->fd != -1 && res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR\n");
          MP_clear(conn);
        } else {
          LOG("res == -EAGAIN || res == -EWOULDBLOCK || res == -EINTR\n");
          conn = conn->recv_conn;
          struct iovec *iov = &conn->ios[0];
          memset(iov->iov_base, 0, iov->iov_len);
          if (urecv(conn, iov->iov_base, iov->iov_len, 0) < 0)
            MP_clear(conn);
        }
      }
    }

    LOG("uring operation seen\n");
    io_uring_cqe_seen(&ring, cqe);
  }

  io_uring_queue_exit(&ring);
  MP_exit(&pool);
  return 0;
}

/*** Helper ***/
static inline int _HK_write(void *data, size_t size) {
  size_t nblocks;
  int iov_index;
  conn_t *conn;
  struct iovec *iov;
  bool once;

  conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  nblocks = round_to_blocks(size);
  iov_index = MP_expand(conn, nblocks, once);
  iov = &conn->ios[iov_index];

  memcpy(iov->iov_base, data, size);
  iov->iov_len = size;
  conn->data_left += size;

  return 0;
}
static inline int _HK_write_body(Request *req, size_t offset, size_t size) {
  if (size > req->body.size || offset > req->body.size)
    return -1;

  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  int iov_index = MP_expand(conn, 0, false);
  struct iovec *iov = &conn->ios[iov_index];
  struct iovec *rec = &conn->rec[iov_index];
  rec->iov_base = req->body.ptr + offset;
  rec->iov_len = size;
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;
  conn->data_left += rec->iov_len;
  return 0;
}
/*
static inline int _HK_mem(size_t size, HKMem *mem) {
  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  bool once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  size_t nblocks = round_to_blocks(size);
  int iov_index = MP_expand(conn, nblocks, once);
  struct iovec *iov = &conn->ios[iov_index];
  mem->ptr = iov->iov_base;
  mem->size = iov->iov_len;
  mem->_iov_index = iov_index;
  mem->_flags = (IN_POOL(iov->iov_base)) ? CF_IN_POOL : CF_IN_HEAP;
  return 0;
}

static inline void _HK_send(HKMem *mem, size_t size) {
  conn_t *conn = current_send;
  struct iovec *iov = &conn->ios[mem->_iov_index];
  iov->iov_len = size;
  conn->data_left += size;
}
  */
#endif#define _GNU_SOURCE
#ifndef UTILS_H
#define UTILS_H

#include "hunk.h"
#include <arpa/inet.h>
#include <fcntl.h>
#include <liburing.h>
#include <netdb.h>
#include <signal.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/poll.h>
#include <sys/prctl.h>
#include <sys/socket.h>
#include <sys/sysinfo.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

#define MP_BLOCK  4
#define MAX_CONNS 4096
#define KB        1024
#define NIOS      32

#define IN_POOL(ptr)                 ((void *)ptr >= pool.bpool && (void *)ptr <= (pool.bpool + (pool.npages * pool.pagesize)))
#define ALIGN_TO_PAGESIZE(buff_size) (((buff_size) + (pool.pagesize - 1)) & ~(pool.pagesize - 1))
#define BYTES_TO_BLOCKS(buff_size)   (((buff_size) + (MP_BLOCK - 1)) / MP_BLOCK)
#define CEIL_BLOCKS(nblocks)         ((nblocks + 63) & ~63)
#define CEIL_PAGES(size)             (((size) + ((pool.pagesize) - 1)) & ~((pool.pagesize) - 1))

#define BIT_IS_FREE(word, bit)   (((word) >> (bit)) & 1)
#define MARK_BIT_USED(word, bit) ((word) &= ~(1ULL << (bit)))
#define MARK_BIT_FREE(word, bit) ((word) |= (1ULL << (bit)))
#define FIND_FREE_BIT(word)      ((uint64_t)(word) & -(uint64_t)(word))
#define STRLEN(s)                (sizeof(s) - 1)

#define IOVEC_NBLOCKS (BYTES_TO_BLOCKS(NIOS * sizeof(struct iovec)))
#define MSG_NBLOCKS   (BYTES_TO_BLOCKS(sizeof(struct msghdr)))
#define ZC_RES        KB *KB

#define DEBUG 0
#if DEBUG
#define LOG(...) fprintf(logfd, __VA_ARGS__)
#else
#define LOG(...) ((void)0)
#endif

typedef enum UOP {
  WRITEV = IORING_OP_WRITEV,
  SENDMSG = IORING_OP_SENDMSG,
  RECVMSG = IORING_OP_RECVMSG,
  ACCEPT = IORING_OP_ACCEPT,
  SEND = IORING_OP_SEND,
  RECV = IORING_OP_RECV,
  SENDZC = IORING_OP_SEND_ZC,
  SENDMSGZC = IORING_OP_SENDMSG_ZC,
  PEEK = 50,
  FRECVMSG,
  INSPLICE,
  OUTSPLICE
} UOP;

typedef enum CFS {
  CF_IN_POOL = (1 << 0),       // Connection is in the pool
  CF_IN_HEAP = (1 << 1),       // Connection is in the heap
  CF_SKIP_SOCK = (1 << 2),     // Don't close the socket
  CF_USE_ONCE = (1 << 3),      // Destroy after using
  CF_HANDLER_READY = (1 << 4), // Ready to call the handler
} CFS;

typedef struct conn_t {
  // Socket file descriptor
  int fd;

  // Amount of data left in the current operation
  uint64_t data_left;

  // The index of the connection struct
  uint32_t cindex;

  // The last time the connection was readable
  uint64_t last_read;

  // The last time the connection was writeable
  uint64_t last_write;

  // The operation currently being processed
  uint8_t op;

  // Connection flags
  int flags;

  // Splice fd_in
  int in_fd;

  // Splice fd_out
  int out_fd;

  void *recv_conn;
  void *send_conn;

  struct iovec *ios;
  struct iovec *rec;
  uint16_t nios;

  struct msghdr *msg;
  uint16_t zc_notifs;

  uint16_t head_size;
} conn_t;

typedef struct MPool {
  // The allocated pool of blocks
  void *bpool;

  // The allocated pool of connections
  conn_t *cpool;

  // The size of the pool in pages
  uint32_t npages;

  // The size of the pool in blocks
  uint32_t nblocks;

  // The locations of each page in the pool
  void **blocks;

  // The availability of each block
  uint64_t *freebs;

  // The locations of each conn in the pool
  conn_t **conns;

  // The availability of each conn
  uint64_t *freecs;

  // Clean up callback function
  void (*callback)(conn_t *conn);

  // The page size used
  uint32_t pagesize;

  // Socket read timeout
  uint32_t rtimeout;

  // Socket write timeout
  uint32_t wtimeout;
} MPool;

extern int pipe_sz;
extern int pipe_in, pipe_out, nullfd;
extern FILE *logfd;
extern struct io_uring ring;
extern MPool pool;
extern conn_t *current_recv;
extern conn_t *current_send;

/*
 * Prepare and submit a recv uring op
 */
static inline int urecv(conn_t *conn, void *buffer, size_t buff_size, int flags) {
  if (!conn || conn->fd == -1)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (flags == MSG_PEEK) ? PEEK : RECV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;

  io_uring_prep_recv(sqe, conn->fd, buffer, buff_size, flags);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a multi-shot accept uring op
 */
static inline int umaccept(int listenfd) {
  if (listenfd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = ACCEPT;
  io_uring_prep_multishot_accept(sqe, listenfd, NULL, NULL, SOCK_NONBLOCK);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a splice uring op
 */
static inline int usplice(conn_t *conn, int fd_in, int64_t off_in, int fd_out, int64_t off_out, size_t len) {
  if (!len || !conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = (__u64)conn;
  io_uring_prep_splice(sqe, fd_in, off_in, fd_out, off_out, len, 0);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a writev uring op
 */
static inline int uwritev(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = WRITEV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  io_uring_prep_writev(sqe, conn->fd, &conn->ios[iov_index], nios, -1);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a send uring op
 */
static inline int usend(conn_t *conn, char *res_buff, size_t buff_size, bool zc) {
  if (!conn || conn->fd <= 0 || buff_size == 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (zc) ? SENDZC : SEND;
  conn->data_left = buff_size;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  if (zc)
    io_uring_prep_send_zc(sqe, conn->fd, res_buff, buff_size, 0, 0);
  else
    io_uring_prep_send(sqe, conn->fd, res_buff, buff_size, 0);
  return io_uring_submit(&ring);
}

static inline int ufrecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = FRECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;

  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, rec->iov_len);
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int urecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = RECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int usendmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  bool zc = (conn->data_left > ZC_RES) ? true : false;
  conn->op = (zc) ? SENDMSGZC : SENDMSG;

  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  if (zc) {
    io_uring_prep_sendmsg_zc(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
    conn->zc_notifs++;
  } else {
    io_uring_prep_sendmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  }
  return io_uring_submit(&ring);
}

/*
 * Create and initialize a server socket
 */
static inline int tcp_listen(uint16_t port) {
  int enable;
  int listenfd;
  if ((listenfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    return -1;

  int flags = fcntl(listenfd, F_GETFL, 0);
  fcntl(listenfd, F_SETFL, flags | O_NONBLOCK);
  struct sockaddr_in servaddr;
  memset(&servaddr, 0, sizeof(servaddr));
  servaddr.sin_family = AF_INET;
  servaddr.sin_addr.s_addr = INADDR_ANY;
  servaddr.sin_port = htons(port);

  enable = 1;
  if (setsockopt(listenfd, SOL_SOCKET, SO_REUSEPORT, &enable, sizeof(enable)) < 0)
    return -1;

  if (bind(listenfd, (struct sockaddr *)&servaddr, sizeof(servaddr)) < 0)
    return -1;

  if (listen(listenfd, SOMAXCONN) < 0)
    return -1;

  return listenfd;
}

/*
 * Calculate the difference between two pointers
 */
static inline uintptr_t ptr_diff(uintptr_t p1, uintptr_t p2) { return (uintptr_t)(p1 > p2) ? (p1 - p2) : (p2 - p1); }

static inline size_t get_nroutes(Route *routes) {
  Route *route;
  for (size_t i = 0;; i++) {
    route = &routes[i];
    if (!route->path && !route->handler && !route->method)
      return i;
  }
}

static inline long get_content_length(char *src, char *end) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return -1;
    key = line;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, "Content-Length") != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;

    *line_end = '\0';
    long res = atol(value);
    *line_end = '\r';

    return res;
  }
  return -1;
}

static inline bool have_header(char *src, char *end, const char *header_key, const char *header_value) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    key = line;
    while (*key == ' ')
      key++;
    while (*header_key == ' ')
      header_key++;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return false;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, header_key) != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;
    while (*header_value == ' ')
      header_value++;

    *line_end = '\0';
    bool res = (strcasecmp(value, header_value) == 0);
    *line_end = '\r';

    return res;
  }

  return false;
}

static inline const char *method_str(Method method) {
  switch (method) {
  case GET:
    return "GET";
    break;
  case HEAD:
    return "HEAD";
    break;
  case POST:
    return "POST";
    break;
  case PUT:
    return "PUT";
    break;
  case DELETE:
    return "DELETE";
    break;
  case CONNECT:
    return "CONNECT";
    break;
  case OPTIONS:
    return "OPTIONS";
    break;
  case TRACE:
    return "TRACE";
    break;
  case PATCH:
    return "PATCH";
    break;
  default:
    return NULL;
  }
}

static inline uint8_t method_len(Method method) {
  switch (method) {
  case GET:
    return 3;
    break;
  case HEAD:
    return 4;
    break;
  case POST:
    return 4;
    break;
  case PUT:
    return 3;
    break;
  case DELETE:
    return 6;
    break;
  case CONNECT:
    return 7;
    break;
  case OPTIONS:
    return 7;
    break;
  case TRACE:
    return 5;
    break;
  case PATCH:
    return 5;
    break;
  default:
    return 0;
  }
}

static inline size_t round_to_blocks(size_t size) {
  size_t nblocks = BYTES_TO_BLOCKS(size);
  nblocks = CEIL_BLOCKS(nblocks);
  return nblocks;
}

/*
 * Count the digits in unsigned 64-bit int
 */
static inline int countd(uint64_t num) {
  if (num < 10ULL)
    return 1;
  if (num < 100ULL)
    return 2;
  if (num < 1000ULL)
    return 3;
  if (num < 10000ULL)
    return 4;
  if (num < 100000ULL)
    return 5;
  if (num < 1000000ULL)
    return 6;
  if (num < 10000000ULL)
    return 7;
  if (num < 100000000ULL)
    return 8;
  if (num < 1000000000ULL)
    return 9;
  if (num < 10000000000ULL)
    return 10;
  if (num < 100000000000ULL)
    return 11;
  if (num < 1000000000000ULL)
    return 12;
  if (num < 10000000000000ULL)
    return 13;
  if (num < 100000000000000ULL)
    return 14;
  if (num < 1000000000000000ULL)
    return 15;
  if (num < 10000000000000000ULL)
    return 16;
  if (num < 100000000000000000ULL)
    return 17;
  if (num < 1000000000000000000ULL)
    return 18;
  if (num < 10000000000000000000ULL)
    return 19;
  return 20;
}

/*
 * Get the time elabsed in ms
 */
static inline uint64_t get_time() {
  struct timespec ts;
  clock_gettime(CLOCK_MONOTONIC, &ts);
  return (uint64_t)(ts.tv_sec) * 1000 + (ts.tv_nsec / 1000000);
}

static inline FILE *log_init(const char *path) {
  FILE *res = fopen(path, "a+");
  setvbuf(res, NULL, _IONBF, 0);
  return res;
}

static inline int16_t pollevs(int connfd) {
  struct pollfd pfd;
  pfd.fd = connfd;
  pfd.events = POLLIN | POLLOUT | POLLERR;
  int res = poll(&pfd, 1, 0);
  if (res < 0)
    return POLLERR;
  return pfd.revents;
}

// FIXME This needs to be updated
static inline conn_t *MP_use_once(size_t nblocks, int fd) {

  void *mem = malloc(sizeof(conn_t) + 8 + (IOVEC_NBLOCKS * MP_BLOCK));
  struct conn_t *conn = (conn_t *)mem;
  memset(conn, 0, sizeof(conn_t));
  conn->ios = mem + sizeof(conn_t) + 8;

  if (nblocks > 0) {
    struct iovec *iov = &conn->ios[conn->nios++];
    mem = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (mem == MAP_FAILED)
      return NULL;
    iov->iov_base = mem;
    iov->iov_len = ALIGN_TO_PAGESIZE(nblocks * MP_BLOCK);
  }

  conn->flags |= CF_IN_HEAP;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;

  return conn;
}

static inline int find_freec() {
  uint64_t *word;
  size_t map_size = (sizeof(uint64_t) * 8);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    word = &pool.freecs[i / map_size];

    if (*word == 0) { // All used
      i += (map_size - 1);
      continue;
    }

    i += __builtin_ctzll(*word);
    MARK_BIT_USED(*word, i);
    return i;
  }

  return -1;
}

static inline int MP_init(size_t npages) {
  if (!npages)
    return -1;

  /*** Setup ***/
  pool.npages = npages;
  pool.pagesize = sysconf(_SC_PAGESIZE);

  /*** Pool ***/
  pool.bpool = mmap(NULL, pool.npages * pool.pagesize, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  if (pool.bpool == MAP_FAILED)
    return -1;
  pool.nblocks = (pool.npages * pool.pagesize) / MP_BLOCK;

  /*** Blocks ***/
  pool.blocks = malloc(sizeof(void *) * pool.nblocks);
  if (!pool.blocks)
    return -1;
  for (size_t i = 0; i < pool.nblocks; i++)
    pool.blocks[i] = pool.bpool + (i * MP_BLOCK);

  /*** Freebs ***/
  // if (posix_memalign((void **)&pool.freebs, 64, bitmap_size * sizeof(uint64_t)) < 0)
  size_t bitmap_size = (pool.nblocks + 63) / 64;
  pool.freebs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freebs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freebs[i] = UINT64_MAX;

  /*** Cpool ***/
  pool.cpool = (conn_t *)malloc(sizeof(conn_t) * MAX_CONNS);
  if (!pool.cpool)
    return -1;

  /*** Conns ***/
  pool.conns = (conn_t **)malloc(sizeof(conn_t *) * MAX_CONNS);
  if (!pool.conns)
    return -1;
  size_t conn_size = sizeof(conn_t);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    pool.conns[i] = (conn_t *)((char *)pool.cpool + (i * conn_size));
    pool.conns[i]->fd = -1;
    pool.conns[i]->in_fd = -1;
    pool.conns[i]->out_fd = -1;
  }

  /*** Freecs ***/
  bitmap_size = (MAX_CONNS + 63) / 64;
  pool.freecs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freecs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freecs[i] = UINT64_MAX;

  return 0;
}

static inline int MP_use_blks(size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t max_start = pool.nblocks - nblocks;
  size_t full_chunks = (nblocks / 64) * 64;

  for (size_t i = 0, c = 0; i <= max_start; i++, c++) {
    bool free = true;

    for (size_t j = 0; j < full_chunks; j += 64) {
      size_t word_index = (i + j) / 64;
      if (pool.freebs[word_index] != UINT64_MAX) {
        free = false;
        i += 63;
        break;
      }
    }

    for (size_t j = full_chunks; j < nblocks; j++) {
      size_t bit_index = i + j;
      size_t word_index = bit_index / 64;
      size_t bit_in_word = bit_index % 64;

      if (!BIT_IS_FREE(pool.freebs[word_index], bit_in_word)) {
        free = false;
        i += j;
        break;
      }
    }

    if (free) {
      for (size_t j = 0; j < full_chunks; j += 64) {
        size_t word_index = (i + j) / 64;
        pool.freebs[word_index] = 0;
      }

      for (size_t j = full_chunks; j < nblocks; j++) {
        size_t bit_index = i + j;
        size_t word_index = bit_index / 64;
        size_t bit_in_word = bit_index % 64;

        MARK_BIT_USED(pool.freebs[word_index], bit_in_word);
      }

      return i;
    }
  }

  return -1;
}

static inline int MP_free_blks(size_t bindex, size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t full_chunks = (nblocks / 64) * 64;
  for (size_t i = 0; i < full_chunks; i += 64) {
    size_t word_index = (bindex + i) / 64;
    pool.freebs[word_index] = UINT64_MAX;
  }

  for (size_t i = full_chunks; i < nblocks; i++) {
    size_t bit_index = bindex + i;
    size_t word_index = bit_index / 64;
    size_t bit_in_word = bit_index % 64;

    MARK_BIT_FREE(pool.freebs[word_index], bit_in_word);
  }

  memset(pool.blocks[bindex], 0, nblocks * MP_BLOCK);
  return 0;
}

static inline conn_t *MP_use(size_t nblocks, int fd, bool once) {
  if (fd <= 0)
    return NULL;
  if (once)
    return MP_use_once(nblocks, fd);

  int cindex = find_freec();
  if (cindex < 0) {
    LOG("Err: cindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  conn_t *conn = pool.conns[cindex];

  int ios_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (ios_bindex < 0) {
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }

  struct iovec *ios = pool.blocks[ios_bindex];
  conn->ios = ios;

  int rec_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (rec_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct iovec *rec = pool.blocks[rec_bindex];
  conn->rec = rec;

  int msg_bindex = MP_use_blks(MSG_NBLOCKS);
  if (msg_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct msghdr *msg = pool.blocks[msg_bindex];
  conn->msg = msg;

  if (nblocks > 0) {
    int bindex = MP_use_blks(nblocks);
    if (bindex < 0) {
      MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
      MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
      MP_free_blks(msg_bindex, IOVEC_NBLOCKS);
      MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
      LOG("Err: bindex < 0; will use MP_use_once\n");
      return MP_use_once(nblocks, fd);
    }

    size_t iov_index = conn->nios++;
    struct iovec *iov = &conn->ios[iov_index];
    struct iovec *rec = &conn->rec[iov_index];
    iov->iov_base = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
  }

  conn->msg->msg_iov = conn->ios;
  conn->msg->msg_iovlen = conn->nios;
  conn->cindex = cindex;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;
  return conn;
}

static inline void MP_shed(conn_t *conn, size_t iov_index, size_t nios) {
  struct iovec *iov, *rec;
  size_t bindex, nblocks, index;

  for (size_t i = 0; i < nios; i++) {
    index = iov_index + i;
    iov = &conn->ios[index];
    rec = &conn->rec[index];
    if (!rec || !rec->iov_base)
      continue;
    if (!IN_POOL(rec->iov_base)) {
      munmap(rec->iov_base, rec->iov_len / pool.pagesize);
    } else {
      bindex = ptr_diff((uintptr_t)rec->iov_base, (uintptr_t)pool.bpool) / MP_BLOCK;
      nblocks = rec->iov_len / MP_BLOCK;
      MP_free_blks(bindex, nblocks);
    }
    memset(iov, 0, sizeof(struct iovec));
    memset(rec, 0, sizeof(struct iovec));
    conn->nios--;
  }
}

static inline int MP_expand(conn_t *conn, size_t nblocks, bool once) {
  void *bptr;
  int iov_index, bindex;
  struct iovec *iov, *rec;

  iov_index = conn->nios++;
  iov = &conn->ios[iov_index];
  rec = &conn->rec[iov_index];

  if (nblocks == 0)
    return iov_index;

  if (once) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_base = bptr;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
    return iov_index;
  }

  bindex = MP_use_blks(nblocks);
  if (bindex < 0) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_len = iov->iov_len;
  } else {
    bptr = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_len = iov->iov_len;
  }

  iov->iov_base = bptr;
  rec->iov_base = iov->iov_base;
  return iov_index;
}

static inline int MP_free(conn_t *conn) {
  if (!conn)
    return -1;
  size_t bindex, nblocks;
  uint64_t *word;

  MP_shed(conn, 0, conn->nios);
  if (conn->flags & CF_IN_HEAP) {
    if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
      close(conn->fd);
    free(conn);
    return 0;
  }

  word = &pool.freecs[conn->cindex / 64];
  if (conn->cindex > MAX_CONNS)
    return -1;
  else if (BIT_IS_FREE(*word, conn->cindex))
    return 0;

  bindex = ptr_diff((uintptr_t)conn->ios, (uintptr_t)pool.bpool) / MP_BLOCK;
  nblocks = IOVEC_NBLOCKS;
  MP_free_blks(bindex, nblocks);

  bindex = ptr_diff((uintptr_t)conn->rec, (uintptr_t)pool.bpool) / MP_BLOCK;
  MP_free_blks(bindex, nblocks);

  if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
    close(conn->fd);

  MARK_BIT_FREE(*word, conn->cindex);
  memset(conn, 0, sizeof(conn_t));
  conn->fd = -1;
  conn->in_fd = -1;
  conn->out_fd = -1;
  return 0;
}

static inline void MP_clear(conn_t *conn) {
  conn_t *recv_conn = conn->recv_conn;
  conn_t *send_conn = conn->send_conn;
  if (recv_conn)
    MP_free(recv_conn);
  if (send_conn)
    MP_free(send_conn);
}

static inline void MP_exit(MPool *pool) {
  munmap(pool->bpool, pool->npages);
  free(pool->cpool);
  free(pool->blocks);
  free(pool->conns);
  free(pool->freebs);
  free(pool->freecs);
}

static inline void MP_timeout() {
  conn_t *conn;
  int16_t res;
  uint64_t now;
  size_t windex = 0;
  uint64_t *word = &pool.freecs[0];
  for (size_t i = 0; i < MAX_CONNS; i++) {
    if ((i / 64) < windex)
      word = &pool.freecs[++windex];

    if (*word == UINTMAX_MAX) {
      i = (i / 64) * 64 + 64;
      continue;
    }

    conn = pool.conns[i];
    if (!conn || conn->fd == -1)
      continue;

    res = pollevs(conn->fd);

    now = get_time();
    if (res & POLLERR) {
      MP_clear(conn);
      continue;
    }
    if (res & POLLIN) {
      if (pool.rtimeout > 0 && (now - conn->last_read) >= pool.rtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (res & POLLOUT) {
      if (pool.wtimeout > 0 && (now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (!(res & POLLIN || res & POLLOUT)) {
      if ((pool.rtimeout > 0 && now - conn->last_read) >= pool.rtimeout
          || (pool.wtimeout > 0 && now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
  }
}

/*
 * Calculate the length of a status string
 */
static inline size_t status_len(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return 8;
  case STATUSSWITCHINGPROTOCOLS:
    return 19;
  case STATUSPROCESSING:
    return 10;
  case STATUSEARLYHINTS:
    return 11;
  case STATUSOK:
    return 2;
  case STATUSCREATED:
    return 7;
  case STATUSACCEPTED:
    return 8;
  case STATUSNONAUTHORITATIVE:
    return 29;
  case STATUSNOCONTENT:
    return 10;
  case STATUSRESETCONTENT:
    return 13;
  case STATUSPARTIALCONTENT:
    return 15;
  case STATUSMULTISTATUS:
    return 12;
  case STATUSALREADYREPORTED:
    return 16;
  case STATUSIMUSED:
    return 7;
  case STATUSMULTIPLECHOICES:
    return 16;
  case STATUSMOVEDPERMANENTLY:
    return 17;
  case STATUSFOUND:
    return 5;
  case STATUSSEEOTHER:
    return 9;
  case STATUSNOTMODIFIED:
    return 12;
  case STATUSUSEPROXY:
    return 9;
  case STATUSTEMPORARYREDIRECT:
    return 18;
  case STATUSPERMANENTREDIRECT:
    return 18;
  case STATUSBADREQUEST:
    return 11;
  case STATUSUNAUTHORIZED:
    return 12;
  case STATUSPAYMENTREQUIRED:
    return 16;
  case STATUSFORBIDDEN:
    return 9;
  case STATUSNOTFOUND:
    return 9;
  case STATUSMETHODNOTALLOWED:
    return 18;
  case STATUSNOTACCEPTABLE:
    return 14;
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return 29;
  case STATUSREQUESTTIMEOUT:
    return 15;
  case STATUSCONFLICT:
    return 8;
  case STATUSGONE:
    return 4;
  case STATUSLENGTHREQUIRED:
    return 15;
  case STATUSPRECONDITIONFAILED:
    return 19;
  case CONTENTTOOLARGE:
    return 17;
  case STATUSURITOOLONG:
    return 12;
  case STATUSUNSUPPORTEDMEDIATYPE:
    return 22;
  case STATUSRANGENOTSATISFIABLE:
    return 21;
  case STATUSEXPECTATIONFAILED:
    return 18;
  case STATUSMISDIRECTEDREQUEST:
    return 19;
  case STATUSUNPROCESSABLECONTENT:
    return 21;
  case STATUSLOCKED:
    return 6;
  case STATUSFAILEDDEPENDENCY:
    return 17;
  case STATUSTOOEARLY:
    return 9;
  case STATUSUPGRADEREQUIRED:
    return 16;
  case STATUSPRECONDITIONREQUIRED:
    return 21;
  case STATUSTOOMANYREQUESTS:
    return 17;
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return 31;
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return 29;
  case STATUSInternalServerError:
    return 21;
  case STATUSNOTIMPLEMENTED:
    return 15;
  case STATUSBADGATEWAY:
    return 11;
  case STATUSSERVICEUNAVAILABLE:
    return 19;
  case STATUSGATEWAYTIMEOUT:
    return 15;
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return 26;
  case STATUSVARIANTALSONEGOTIATES:
    return 23;
  case STATUSINSUFFICIENTSTORAGE:
    return 20;
  case STATUSLOOPDETECTED:
    return 13;
  case STATUSNOTEXTENDED:
    return 12;
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return 31;
  default:
    return 0;
  }
}

/*
 * Return the status code string as string literal
 */
static inline char *status_str(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return "Continue";
  case STATUSSWITCHINGPROTOCOLS:
    return "Switching Protocols";
  case STATUSPROCESSING:
    return "Processing";
  case STATUSEARLYHINTS:
    return "Early Hints";
  case STATUSOK:
    return "OK";
  case STATUSCREATED:
    return "Created";
  case STATUSACCEPTED:
    return "Accepted";
  case STATUSNONAUTHORITATIVE:
    return "Non-Authoritative Information";
  case STATUSNOCONTENT:
    return "No Content";
  case STATUSRESETCONTENT:
    return "Reset Content";
  case STATUSPARTIALCONTENT:
    return "Partial Content";
  case STATUSMULTISTATUS:
    return "Multi-Status";
  case STATUSALREADYREPORTED:
    return "Already Reported";
  case STATUSIMUSED:
    return "Im Used";
  case STATUSMULTIPLECHOICES:
    return "Multiple Choices";
  case STATUSMOVEDPERMANENTLY:
    return "Moved Permanently";
  case STATUSFOUND:
    return "Found";
  case STATUSSEEOTHER:
    return "See Other";
  case STATUSNOTMODIFIED:
    return "Not Modified";
  case STATUSUSEPROXY:
    return "Use Proxy";
  case STATUSTEMPORARYREDIRECT:
    return "Temporary Redirect";
  case STATUSPERMANENTREDIRECT:
    return "Permanent Redirect";
  case STATUSBADREQUEST:
    return "Bad Request";
  case STATUSUNAUTHORIZED:
    return "Unauthorized";
  case STATUSPAYMENTREQUIRED:
    return "Payment Required";
  case STATUSFORBIDDEN:
    return "Forbidden";
  case STATUSNOTFOUND:
    return "Not Found";
  case STATUSMETHODNOTALLOWED:
    return "Method Not Allowed";
  case STATUSNOTACCEPTABLE:
    return "Not Acceptable";
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return "Proxy Authentication Required";
  case STATUSREQUESTTIMEOUT:
    return "Request Timeout";
  case STATUSCONFLICT:
    return "Conflict";
  case STATUSGONE:
    return "Gone";
  case STATUSLENGTHREQUIRED:
    return "Length Required";
  case STATUSPRECONDITIONFAILED:
    return "Precondition Failed";
  case CONTENTTOOLARGE:
    return "Content Too Large";
  case STATUSURITOOLONG:
    return "URI Too Long";
  case STATUSUNSUPPORTEDMEDIATYPE:
    return "Unsupported Media Type";
  case STATUSRANGENOTSATISFIABLE:
    return "Range Not Satisfiable";
  case STATUSEXPECTATIONFAILED:
    return "Expectation Failed";
  case STATUSMISDIRECTEDREQUEST:
    return "Misdirected Request";
  case STATUSUNPROCESSABLECONTENT:
    return "Unprocessable Content";
  case STATUSLOCKED:
    return "Locked";
  case STATUSFAILEDDEPENDENCY:
    return "Failed Dependency";
  case STATUSTOOEARLY:
    return "Too Early";
  case STATUSUPGRADEREQUIRED:
    return "Upgrade Required";
  case STATUSPRECONDITIONREQUIRED:
    return "Precondition Required";
  case STATUSTOOMANYREQUESTS:
    return "Too Many Requests";
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return "Request Header Fields Too Large";
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return "Unavailable For Legal Reasons";
  case STATUSInternalServerError:
    return "Internal Server Error";
  case STATUSNOTIMPLEMENTED:
    return "Not Implemented";
  case STATUSBADGATEWAY:
    return "Bad Gateway";
  case STATUSSERVICEUNAVAILABLE:
    return "Service Unavailable";
  case STATUSGATEWAYTIMEOUT:
    return "Gateway Timeout";
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return "HTTP Version Not Supported";
  case STATUSVARIANTALSONEGOTIATES:
    return "Variant Also Negotiates";
  case STATUSINSUFFICIENTSTORAGE:
    return "Insufficient Storage";
  case STATUSLOOPDETECTED:
    return "Loop Detected";
  case STATUSNOTEXTENDED:
    return "Not Extended";
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return "Network Authentication Required";
  default:
    return 0;
  }
}

/*
 * Return true if routes match
 */
static inline bool route_equ(Route *route, Request *req) {
  return route->method == req->method && strncmp(route->path, req->path, strlen(route->path)) == 0;
}

/*
 * Return the matching route index on success. -1 on failure
 */
static inline int match_route(Server *serv, Request *req) {
  for (size_t i = 0; i < serv->_nroutes; i++) {
    Route route = serv->routes[i];
    if (!req->path || !route.path)
      continue;
    if (route_equ(&route, req))
      return i;
    else if (req->method == HEAD && route.method == GET && strcmp(route.path, req->path) == 0)
      return i;
  }
  return -1;
}

/*
 * Return true if the response should contain the Content-Length header
 */
static inline bool should_have_content_length(Request *req, ResWriter *res) {
  return (req->method != CONNECT              // CONNECT request
          && res->status != STATUSNOCONTENT   // 204 response
          && res->status != STATUSNOTMODIFIED // 304 response
          && res->status >= 200);             // 1xx response
}

/*
 * Format http response from the ResWriter.
 * Return response size on success, 0 on failure.
 */
static inline size_t fmt_res(Request *req, ResWriter *res, char *buffer, size_t buffer_size) {
  if (!res || !buffer || buffer_size == 0)
    return 0;

  size_t res_len, total = 0;
  char *dst = buffer;
  size_t maxlen = buffer_size;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t body_length = res->len;

  res_len = snprintf(dst, maxlen, "HTTP/1.1 %d %s", (int)res->status, status_str(res->status));
  total += res_len;
  dst += res_len;
  maxlen -= res_len;

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    res_len = snprintf(dst, maxlen, "\r\n%s: %s", header->key, header->value);
    total += res_len;
    dst += res_len;
    maxlen -= res_len;
  }

  if (have_content_length) {
    res_len = snprintf(dst, maxlen, "\r\nContent-Length: %lu", body_length);
    total += res_len, dst += res_len, maxlen -= res_len;
  }

  memcpy(dst, "\r\n\r\n", 4);
  total += 4, dst += 4, maxlen -= 4;

  return total;
}

static inline size_t res_len(Request *req, ResWriter *res) {
  if (!req || !res)
    return 0;

  if (!res->status)
    res->status = STATUSOK;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t result = 0;
  result += STRLEN("HTTP/1.1 ");     // HTTP version
  result += 4;                       // Status code + space
  result += status_len(res->status); // Status name

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    result += 2;                       // "\r\n"
    result += strlen(header->key) + 2; // Header key + ':' + space
    result += strlen(header->value);   // header value
  }

  if (have_content_length) {
    result += 2;                          // "\r\n"
    result += STRLEN("Content-Length: "); // Header key
    result += countd(res->len);           // Header value
  }

  result += 4; // "\r\n\r\n"

  return result;
}

static inline int send_empty_res(Status status) {
  size_t res_len = STRLEN("HTTP/1.1 ")        // HTTP version
                   + countd((uint64_t)status) // status code
                   + 1                        // space
                   + (int)status_len(status)  // status string
                   + 4;                       // \r\n\r\n

  conn_t *conn = current_send;
  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, res_len);
  if (snprintf((char *)rec->iov_base, res_len + 1, "HTTP/1.1 %d %s\r\n\r\n", (int)status, status_str(status))
      != (int)res_len)
    return -1;

  return usendmsg(conn, 0, 1);
}

static inline ssize_t read_socket(int sockfd, size_t len) {
  if (len == 0 || sockfd <= 0)
    return 0;
  char buff[1024 * 8];
  return read(sockfd, buff, 1024 * 8);
}

static inline int read_method(Method *method, void *src) {
  if (memcmp(src, "GET", 3) == 0)
    *method = GET;
  else if (memcmp(src, "POST", 4) == 0)
    *method = POST;
  else if (memcmp(src, "HEAD", 4) == 0)
    *method = HEAD;
  else if (memcmp(src, "PUT", 3) == 0)
    *method = PUT;
  else if (memcmp(src, "DELETE", 6) == 0)
    *method = DELETE;
  else if (memcmp(src, "CONNECT", 7) == 0)
    *method = CONNECT;
  else if (memcmp(src, "OPTIONS", 7) == 0)
    *method = OPTIONS;
  else if (memcmp(src, "TRACE", 5) == 0)
    *method = TRACE;
  else if (memcmp(src, "PATCH", 5) == 0)
    *method = PATCH;
  else
    return -1;

  return 0;
}

static inline int sendmsg_res(Request *req, ResWriter *res) {
  conn_t *conn;
  size_t head_size, res_size;
  struct iovec *iov;

  conn = current_send;
  iov = &conn->ios[0];
  head_size = res_len(req, res);
  if (head_size == 0)
    return -1;

  conn->data_left += head_size;
  res_size = fmt_res(req, res, iov->iov_base, (head_size + 1));
  if (res_size != head_size)
    return -1;
  iov->iov_len = res_size;

  return usendmsg(conn, 0, conn->nios);
}

static inline int read_req(Request *req, char *req_buffer) {
  if (!req_buffer)
    return -1;
  /*** Method ***/
  char *sep = strchr(req_buffer, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }
  *sep = '\0';
  if (read_method(&req->method, req_buffer) < 0)
    return -1;

  /*** Path ***/
  char *fullpath = sep + 1;
  sep = strchr(fullpath, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }

  *sep = '\0';
  req->path = fullpath;
  /*** Params ***/
  char *paramStart = strchr(fullpath, '?');
  if (paramStart) {
    *paramStart++ = '\0';
    int params_count = 0;
    params_count = HK_parse_params(paramStart, req->params, MAX_URL_PARAMETERS);
    if (params_count > 0)
      req->params_count = params_count;
    else
      req->params_count = 0;
  } else {
    req->params = NULL;
    req->params_count = 0;
  }

  /*** Headers ***/
  char *headStart = strstr(sep + 1, "\r\n");
  char *headEnd = strstr(sep + 1, "\r\n\r\n");
  if (!headStart) {
    LOG("read_req: !headStart\n");
    return -1;
  };

  memset(headStart, 0, 2);
  headStart += 2;
  memset(headEnd, 0, 4);
  headEnd += 4;

  int headers_count = HK_parse_headers(headStart, req->headers, MAX_REQ_HEADERS);
  if (headers_count <= 0)
    return -1;
  req->headers_count = headers_count;

  /*** Host ***/
  int index = HK_get_header(req, "Host");
  if (index < 0)
    return -1;
  char *host = req->headers[index].value;
  req->hostname = host;

  /*** Port ***/
  char *colon = strchr(host, ':');
  if (colon) {
    *colon++ = '\0';
    req->port = atoi(colon);
  } else {
    req->port = PORT;
  }
  return 0;
}
static inline int process_req(Server *serv, conn_t *conn) {
  if (!conn || conn->fd == -1)
    return -1;

  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;
  if (read_req(&req, conn->ios[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    LOG("Err: route_index == -1\n");
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;
  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  sendmsg_res(&req, &res);

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int new_conn(int connfd) {
  if (connfd <= 0)
    return -1;

  current_recv = MP_use(KB * 2, connfd, false);
  current_send = MP_use(KB * 2, connfd, false);

  current_recv->recv_conn = current_recv;
  current_recv->send_conn = current_send;

  current_send->send_conn = current_send;
  current_send->recv_conn = current_recv;

  conn_t *conn = current_recv;
  if (ufrecvmsg(conn, 0, 1) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

static inline int resubmit_sendmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return usendmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int resubmir_recvmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    // FIXME the len should be increased
    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return urecvmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int handle_sendmsg_complete(conn_t *conn) {
  struct iovec *iov, *rec;

  MP_shed(conn, 1, conn->nios - 1);
  iov = &conn->ios[0];
  rec = &conn->rec[0];
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;

  return ufrecvmsg(conn->recv_conn, 0, 1);
}

static inline int handle_sendmsg(conn_t *conn, int res, bool zc) {
  if (!conn || conn->fd == -1)
    return -1;

  conn->data_left -= res;
  if (conn->data_left > 0)
    return resubmit_sendmsg(conn, res);

  if (zc)
    return 0;

  return handle_sendmsg_complete(conn);
}

static inline int handle_insplice(conn_t *conn) {
  conn->op = OUTSPLICE;
  return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
}
static inline int handle_outsplice(conn_t *conn, int res) {
  conn->data_left -= res;
  if (conn->data_left > 0) {
    conn->op = INSPLICE;
    return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
  }

  conn_t *recv_conn = conn->recv_conn;
  struct iovec *iov = &recv_conn->ios[0];
  memset(iov->iov_base, 0, iov->iov_len);
  if (urecv(recv_conn, iov->iov_base, iov->iov_len, MSG_PEEK) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

/*
static inline int handle_recv(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  void *bptr = conn->ios[0].iov_base;
  void *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  void *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  return process_req(serv, conn);
}
*/
static inline int find_route(Server *serv, char *bptr) {
  Request req = {0};
  if (read_method(&req.method, bptr) < 0) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  };
  char *space = strchr(bptr, ' ');
  req.path = (space + 1);
  space = strchr(req.path, ' ');
  *space = '\0';
  int route_index = match_route(serv, &req);
  *space = ' ';
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }
  return route_index;
}

static inline int run_handler(Server *serv, conn_t *conn, bool uses_body) {
  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;

  if (read_req(&req, conn->rec[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  if (uses_body) {
    int h_index = HK_get_header(&req, "Content-Length");
    long body_size = atol(req.headers[h_index].value);
    if (body_size >= 0) {
      req.body.ptr = conn->rec[1].iov_base;
      req.body.size = body_size;
    } else {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    }
  }

  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  if (sendmsg_res(&req, &res) < 0)
    return -1;

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int handle_frecvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  char *bptr = (char *)conn->ios[0].iov_base;
  char *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  char *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  size_t head_size = (headEnd + 4) - bptr;
  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  int route_index = find_route(serv, bptr);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  bool uses_body = serv->routes[route_index].uses_body;
  long body_size = get_content_length(headstart + 2, headEnd + 4);
  if (body_size == -1) {
    if (uses_body) {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    } else {
      body_size = 0;
    }
  }

  conn->head_size = head_size;
  if (!uses_body) {
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  if (res == (int)(head_size + body_size)) {
    size_t iov_index = MP_expand(conn, round_to_blocks(body_size), false);
    memcpy(conn->rec[iov_index].iov_base, headEnd + 4, body_size);
    conn->ios[iov_index].iov_len = body_size;
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  conn->data_left = body_size - (res - head_size);
  bool once = ((size_t)body_size > (size_t)((pool.nblocks * MP_BLOCK) / 10));
  size_t iov_index = MP_expand(conn, round_to_blocks(body_size), once);
  memcpy(conn->rec[iov_index].iov_base, headEnd + 4, (res - head_size));
  conn->ios[iov_index].iov_base += (res - head_size);

  return urecvmsg(conn, iov_index, 1);
}

static inline int handle_recvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  if (conn->data_left > 0) {
    conn->data_left -= res;
    if (conn->data_left == 0) {
      conn->flags &= CF_HANDLER_READY;
      return run_handler(serv, conn, true);
    }

    conn->flags &= ~CF_HANDLER_READY;
    conn->ios[1].iov_base += res;
    return urecvmsg(conn, 1, 1);
  }

  conn->flags &= CF_HANDLER_READY;
  return run_handler(serv, conn, true);
}

static inline int serv_init(Server *serv) {
#if DEBUG
  logfd = log_init("log.txt");
  if (!logfd) {
    printf("log_init failed");
    return -1;
  }
#endif
  serv->_nroutes = get_nroutes(serv->routes);

  int pipefd[2];
  if (pipe(pipefd) < 0)
    return -1;
  pipe_in = pipefd[0];
  pipe_out = pipefd[1];
  nullfd = open("/dev/null", O_WRONLY);
  pipe_sz = fcntl(pipefd[0], F_GETPIPE_SZ);
  if (pipe_sz < 0)
    return -1;

  pool.rtimeout = serv->rtimeout;
  pool.wtimeout = serv->wtimeout;
  if (MP_init(MAX_CONNS * 8) < 0)
    return -1;
  LOG("pool initialized\n");

  if (io_uring_queue_init(MAX_CONNS, &ring, 0) < 0)
    return -1;
  LOG("uring initialized\n");

  int listenfd;
  if ((listenfd = tcp_listen(serv->port)) < 0)
    return -1;
  LOG("socket initialized\n");

  return umaccept(listenfd);
}

static inline int serv_listen(Server *serv) {
  // uint64_t last_check = get_time();
  while (true) {
    // uint64_t now = get_time();
    // if ((now - last_check) >= 200) {
    //   last_check = now;
    //   LOG("CM: CM_check ran\n");
    //   MP_timeout();
    // }

    LOG("SQ ready: %u, CQ ready: %u\n", io_uring_sq_ready(&ring), io_uring_cq_ready(&ring));
    struct io_uring_cqe *cqe;
    if (io_uring_wait_cqe(&ring, &cqe) < 0)
      continue;

    int res = cqe->res;
    LOG("res = %d\n", res);
    conn_t *conn = NULL;
    if (cqe->user_data > 100) {
      conn = (conn_t *)cqe->user_data;
      current_recv = (conn_t *)conn->recv_conn;
      current_send = (conn_t *)conn->send_conn;
    }

    if (res > 0) {
      if (cqe->user_data == ACCEPT) {
        LOG("new conn created\n");
        new_conn(res);
      } else if (conn && conn->fd != -1) {
        LOG("conn[%d]: conn.fd = %d; conn.op = %d\n", conn->cindex, conn->fd, conn->op);
        switch (conn->op) {
        case FRECVMSG:
          if (handle_frecvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case RECVMSG:
          if (handle_recvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case SENDMSG:
        case SENDMSGZC:
          // conn->last_write = get_time();
          bool zc = (conn->op == SENDMSGZC);
          if (handle_sendmsg(conn, res, zc) < 0)
            MP_clear(conn);
          break;
        case INSPLICE:
          if (handle_insplice(conn) < 0)
            MP_clear(conn);
          break;
        case OUTSPLICE:
          if (handle_outsplice(conn, res) < 0)
            MP_clear(conn);
          break;
        }
      }
    } else if (res == 0) {
      if (conn && conn->fd != -1) {
        switch (conn->op) {
        case SENDMSGZC:
          conn->zc_notifs--;
          if (conn->zc_notifs == 0 && handle_sendmsg_complete(conn) < 0)
            MP_clear(conn);
          break;
        case RECV:
          MP_clear(conn);
          break;
        }
      }
    } else {
      if (conn && conn->fd != -1) {
        if (res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR) {
          LOG("conn && conn->fd != -1 && res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR\n");
          MP_clear(conn);
        } else {
          LOG("res == -EAGAIN || res == -EWOULDBLOCK || res == -EINTR\n");
          conn = conn->recv_conn;
          struct iovec *iov = &conn->ios[0];
          memset(iov->iov_base, 0, iov->iov_len);
          if (urecv(conn, iov->iov_base, iov->iov_len, 0) < 0)
            MP_clear(conn);
        }
      }
    }

    LOG("uring operation seen\n");
    io_uring_cqe_seen(&ring, cqe);
  }

  io_uring_queue_exit(&ring);
  MP_exit(&pool);
  return 0;
}

/*** Helper ***/
static inline int _HK_write(void *data, size_t size) {
  size_t nblocks;
  int iov_index;
  conn_t *conn;
  struct iovec *iov;
  bool once;

  conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  nblocks = round_to_blocks(size);
  iov_index = MP_expand(conn, nblocks, once);
  iov = &conn->ios[iov_index];

  memcpy(iov->iov_base, data, size);
  iov->iov_len = size;
  conn->data_left += size;

  return 0;
}
static inline int _HK_write_body(Request *req, size_t offset, size_t size) {
  if (size > req->body.size || offset > req->body.size)
    return -1;

  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  int iov_index = MP_expand(conn, 0, false);
  struct iovec *iov = &conn->ios[iov_index];
  struct iovec *rec = &conn->rec[iov_index];
  rec->iov_base = req->body.ptr + offset;
  rec->iov_len = size;
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;
  conn->data_left += rec->iov_len;
  return 0;
}
/*
static inline int _HK_mem(size_t size, HKMem *mem) {
  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  bool once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  size_t nblocks = round_to_blocks(size);
  int iov_index = MP_expand(conn, nblocks, once);
  struct iovec *iov = &conn->ios[iov_index];
  mem->ptr = iov->iov_base;
  mem->size = iov->iov_len;
  mem->_iov_index = iov_index;
  mem->_flags = (IN_POOL(iov->iov_base)) ? CF_IN_POOL : CF_IN_HEAP;
  return 0;
}

static inline void _HK_send(HKMem *mem, size_t size) {
  conn_t *conn = current_send;
  struct iovec *iov = &conn->ios[mem->_iov_index];
  iov->iov_len = size;
  conn->data_left += size;
}
  */
#endif#define _GNU_SOURCE
#ifndef UTILS_H
#define UTILS_H

#include "hunk.h"
#include <arpa/inet.h>
#include <fcntl.h>
#include <liburing.h>
#include <netdb.h>
#include <signal.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/poll.h>
#include <sys/prctl.h>
#include <sys/socket.h>
#include <sys/sysinfo.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

#define MP_BLOCK  4
#define MAX_CONNS 4096
#define KB        1024
#define NIOS      32

#define IN_POOL(ptr)                 ((void *)ptr >= pool.bpool && (void *)ptr <= (pool.bpool + (pool.npages * pool.pagesize)))
#define ALIGN_TO_PAGESIZE(buff_size) (((buff_size) + (pool.pagesize - 1)) & ~(pool.pagesize - 1))
#define BYTES_TO_BLOCKS(buff_size)   (((buff_size) + (MP_BLOCK - 1)) / MP_BLOCK)
#define CEIL_BLOCKS(nblocks)         ((nblocks + 63) & ~63)
#define CEIL_PAGES(size)             (((size) + ((pool.pagesize) - 1)) & ~((pool.pagesize) - 1))

#define BIT_IS_FREE(word, bit)   (((word) >> (bit)) & 1)
#define MARK_BIT_USED(word, bit) ((word) &= ~(1ULL << (bit)))
#define MARK_BIT_FREE(word, bit) ((word) |= (1ULL << (bit)))
#define FIND_FREE_BIT(word)      ((uint64_t)(word) & -(uint64_t)(word))
#define STRLEN(s)                (sizeof(s) - 1)

#define IOVEC_NBLOCKS (BYTES_TO_BLOCKS(NIOS * sizeof(struct iovec)))
#define MSG_NBLOCKS   (BYTES_TO_BLOCKS(sizeof(struct msghdr)))
#define ZC_RES        KB *KB

#define DEBUG 0
#if DEBUG
#define LOG(...) fprintf(logfd, __VA_ARGS__)
#else
#define LOG(...) ((void)0)
#endif

typedef enum UOP {
  WRITEV = IORING_OP_WRITEV,
  SENDMSG = IORING_OP_SENDMSG,
  RECVMSG = IORING_OP_RECVMSG,
  ACCEPT = IORING_OP_ACCEPT,
  SEND = IORING_OP_SEND,
  RECV = IORING_OP_RECV,
  SENDZC = IORING_OP_SEND_ZC,
  SENDMSGZC = IORING_OP_SENDMSG_ZC,
  PEEK = 50,
  FRECVMSG,
  INSPLICE,
  OUTSPLICE
} UOP;

typedef enum CFS {
  CF_IN_POOL = (1 << 0),       // Connection is in the pool
  CF_IN_HEAP = (1 << 1),       // Connection is in the heap
  CF_SKIP_SOCK = (1 << 2),     // Don't close the socket
  CF_USE_ONCE = (1 << 3),      // Destroy after using
  CF_HANDLER_READY = (1 << 4), // Ready to call the handler
} CFS;

typedef struct conn_t {
  // Socket file descriptor
  int fd;

  // Amount of data left in the current operation
  uint64_t data_left;

  // The index of the connection struct
  uint32_t cindex;

  // The last time the connection was readable
  uint64_t last_read;

  // The last time the connection was writeable
  uint64_t last_write;

  // The operation currently being processed
  uint8_t op;

  // Connection flags
  int flags;

  // Splice fd_in
  int in_fd;

  // Splice fd_out
  int out_fd;

  void *recv_conn;
  void *send_conn;

  struct iovec *ios;
  struct iovec *rec;
  uint16_t nios;

  struct msghdr *msg;
  uint16_t zc_notifs;

  uint16_t head_size;
} conn_t;

typedef struct MPool {
  // The allocated pool of blocks
  void *bpool;

  // The allocated pool of connections
  conn_t *cpool;

  // The size of the pool in pages
  uint32_t npages;

  // The size of the pool in blocks
  uint32_t nblocks;

  // The locations of each page in the pool
  void **blocks;

  // The availability of each block
  uint64_t *freebs;

  // The locations of each conn in the pool
  conn_t **conns;

  // The availability of each conn
  uint64_t *freecs;

  // Clean up callback function
  void (*callback)(conn_t *conn);

  // The page size used
  uint32_t pagesize;

  // Socket read timeout
  uint32_t rtimeout;

  // Socket write timeout
  uint32_t wtimeout;
} MPool;

extern int pipe_sz;
extern int pipe_in, pipe_out, nullfd;
extern FILE *logfd;
extern struct io_uring ring;
extern MPool pool;
extern conn_t *current_recv;
extern conn_t *current_send;

/*
 * Prepare and submit a recv uring op
 */
static inline int urecv(conn_t *conn, void *buffer, size_t buff_size, int flags) {
  if (!conn || conn->fd == -1)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (flags == MSG_PEEK) ? PEEK : RECV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;

  io_uring_prep_recv(sqe, conn->fd, buffer, buff_size, flags);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a multi-shot accept uring op
 */
static inline int umaccept(int listenfd) {
  if (listenfd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = ACCEPT;
  io_uring_prep_multishot_accept(sqe, listenfd, NULL, NULL, SOCK_NONBLOCK);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a splice uring op
 */
static inline int usplice(conn_t *conn, int fd_in, int64_t off_in, int fd_out, int64_t off_out, size_t len) {
  if (!len || !conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = (__u64)conn;
  io_uring_prep_splice(sqe, fd_in, off_in, fd_out, off_out, len, 0);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a writev uring op
 */
static inline int uwritev(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = WRITEV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  io_uring_prep_writev(sqe, conn->fd, &conn->ios[iov_index], nios, -1);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a send uring op
 */
static inline int usend(conn_t *conn, char *res_buff, size_t buff_size, bool zc) {
  if (!conn || conn->fd <= 0 || buff_size == 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (zc) ? SENDZC : SEND;
  conn->data_left = buff_size;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  if (zc)
    io_uring_prep_send_zc(sqe, conn->fd, res_buff, buff_size, 0, 0);
  else
    io_uring_prep_send(sqe, conn->fd, res_buff, buff_size, 0);
  return io_uring_submit(&ring);
}

static inline int ufrecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = FRECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;

  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, rec->iov_len);
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int urecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = RECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int usendmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  bool zc = (conn->data_left > ZC_RES) ? true : false;
  conn->op = (zc) ? SENDMSGZC : SENDMSG;

  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  if (zc) {
    io_uring_prep_sendmsg_zc(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
    conn->zc_notifs++;
  } else {
    io_uring_prep_sendmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  }
  return io_uring_submit(&ring);
}

/*
 * Create and initialize a server socket
 */
static inline int tcp_listen(uint16_t port) {
  int enable;
  int listenfd;
  if ((listenfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    return -1;

  int flags = fcntl(listenfd, F_GETFL, 0);
  fcntl(listenfd, F_SETFL, flags | O_NONBLOCK);
  struct sockaddr_in servaddr;
  memset(&servaddr, 0, sizeof(servaddr));
  servaddr.sin_family = AF_INET;
  servaddr.sin_addr.s_addr = INADDR_ANY;
  servaddr.sin_port = htons(port);

  enable = 1;
  if (setsockopt(listenfd, SOL_SOCKET, SO_REUSEPORT, &enable, sizeof(enable)) < 0)
    return -1;

  if (bind(listenfd, (struct sockaddr *)&servaddr, sizeof(servaddr)) < 0)
    return -1;

  if (listen(listenfd, SOMAXCONN) < 0)
    return -1;

  return listenfd;
}

/*
 * Calculate the difference between two pointers
 */
static inline uintptr_t ptr_diff(uintptr_t p1, uintptr_t p2) { return (uintptr_t)(p1 > p2) ? (p1 - p2) : (p2 - p1); }

static inline size_t get_nroutes(Route *routes) {
  Route *route;
  for (size_t i = 0;; i++) {
    route = &routes[i];
    if (!route->path && !route->handler && !route->method)
      return i;
  }
}

static inline long get_content_length(char *src, char *end) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return -1;
    key = line;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, "Content-Length") != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;

    *line_end = '\0';
    long res = atol(value);
    *line_end = '\r';

    return res;
  }
  return -1;
}

static inline bool have_header(char *src, char *end, const char *header_key, const char *header_value) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    key = line;
    while (*key == ' ')
      key++;
    while (*header_key == ' ')
      header_key++;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return false;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, header_key) != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;
    while (*header_value == ' ')
      header_value++;

    *line_end = '\0';
    bool res = (strcasecmp(value, header_value) == 0);
    *line_end = '\r';

    return res;
  }

  return false;
}

static inline const char *method_str(Method method) {
  switch (method) {
  case GET:
    return "GET";
    break;
  case HEAD:
    return "HEAD";
    break;
  case POST:
    return "POST";
    break;
  case PUT:
    return "PUT";
    break;
  case DELETE:
    return "DELETE";
    break;
  case CONNECT:
    return "CONNECT";
    break;
  case OPTIONS:
    return "OPTIONS";
    break;
  case TRACE:
    return "TRACE";
    break;
  case PATCH:
    return "PATCH";
    break;
  default:
    return NULL;
  }
}

static inline uint8_t method_len(Method method) {
  switch (method) {
  case GET:
    return 3;
    break;
  case HEAD:
    return 4;
    break;
  case POST:
    return 4;
    break;
  case PUT:
    return 3;
    break;
  case DELETE:
    return 6;
    break;
  case CONNECT:
    return 7;
    break;
  case OPTIONS:
    return 7;
    break;
  case TRACE:
    return 5;
    break;
  case PATCH:
    return 5;
    break;
  default:
    return 0;
  }
}

static inline size_t round_to_blocks(size_t size) {
  size_t nblocks = BYTES_TO_BLOCKS(size);
  nblocks = CEIL_BLOCKS(nblocks);
  return nblocks;
}

/*
 * Count the digits in unsigned 64-bit int
 */
static inline int countd(uint64_t num) {
  if (num < 10ULL)
    return 1;
  if (num < 100ULL)
    return 2;
  if (num < 1000ULL)
    return 3;
  if (num < 10000ULL)
    return 4;
  if (num < 100000ULL)
    return 5;
  if (num < 1000000ULL)
    return 6;
  if (num < 10000000ULL)
    return 7;
  if (num < 100000000ULL)
    return 8;
  if (num < 1000000000ULL)
    return 9;
  if (num < 10000000000ULL)
    return 10;
  if (num < 100000000000ULL)
    return 11;
  if (num < 1000000000000ULL)
    return 12;
  if (num < 10000000000000ULL)
    return 13;
  if (num < 100000000000000ULL)
    return 14;
  if (num < 1000000000000000ULL)
    return 15;
  if (num < 10000000000000000ULL)
    return 16;
  if (num < 100000000000000000ULL)
    return 17;
  if (num < 1000000000000000000ULL)
    return 18;
  if (num < 10000000000000000000ULL)
    return 19;
  return 20;
}

/*
 * Get the time elabsed in ms
 */
static inline uint64_t get_time() {
  struct timespec ts;
  clock_gettime(CLOCK_MONOTONIC, &ts);
  return (uint64_t)(ts.tv_sec) * 1000 + (ts.tv_nsec / 1000000);
}

static inline FILE *log_init(const char *path) {
  FILE *res = fopen(path, "a+");
  setvbuf(res, NULL, _IONBF, 0);
  return res;
}

static inline int16_t pollevs(int connfd) {
  struct pollfd pfd;
  pfd.fd = connfd;
  pfd.events = POLLIN | POLLOUT | POLLERR;
  int res = poll(&pfd, 1, 0);
  if (res < 0)
    return POLLERR;
  return pfd.revents;
}

// FIXME This needs to be updated
static inline conn_t *MP_use_once(size_t nblocks, int fd) {

  void *mem = malloc(sizeof(conn_t) + 8 + (IOVEC_NBLOCKS * MP_BLOCK));
  struct conn_t *conn = (conn_t *)mem;
  memset(conn, 0, sizeof(conn_t));
  conn->ios = mem + sizeof(conn_t) + 8;

  if (nblocks > 0) {
    struct iovec *iov = &conn->ios[conn->nios++];
    mem = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (mem == MAP_FAILED)
      return NULL;
    iov->iov_base = mem;
    iov->iov_len = ALIGN_TO_PAGESIZE(nblocks * MP_BLOCK);
  }

  conn->flags |= CF_IN_HEAP;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;

  return conn;
}

static inline int find_freec() {
  uint64_t *word;
  size_t map_size = (sizeof(uint64_t) * 8);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    word = &pool.freecs[i / map_size];

    if (*word == 0) { // All used
      i += (map_size - 1);
      continue;
    }

    i += __builtin_ctzll(*word);
    MARK_BIT_USED(*word, i);
    return i;
  }

  return -1;
}

static inline int MP_init(size_t npages) {
  if (!npages)
    return -1;

  /*** Setup ***/
  pool.npages = npages;
  pool.pagesize = sysconf(_SC_PAGESIZE);

  /*** Pool ***/
  pool.bpool = mmap(NULL, pool.npages * pool.pagesize, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  if (pool.bpool == MAP_FAILED)
    return -1;
  pool.nblocks = (pool.npages * pool.pagesize) / MP_BLOCK;

  /*** Blocks ***/
  pool.blocks = malloc(sizeof(void *) * pool.nblocks);
  if (!pool.blocks)
    return -1;
  for (size_t i = 0; i < pool.nblocks; i++)
    pool.blocks[i] = pool.bpool + (i * MP_BLOCK);

  /*** Freebs ***/
  // if (posix_memalign((void **)&pool.freebs, 64, bitmap_size * sizeof(uint64_t)) < 0)
  size_t bitmap_size = (pool.nblocks + 63) / 64;
  pool.freebs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freebs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freebs[i] = UINT64_MAX;

  /*** Cpool ***/
  pool.cpool = (conn_t *)malloc(sizeof(conn_t) * MAX_CONNS);
  if (!pool.cpool)
    return -1;

  /*** Conns ***/
  pool.conns = (conn_t **)malloc(sizeof(conn_t *) * MAX_CONNS);
  if (!pool.conns)
    return -1;
  size_t conn_size = sizeof(conn_t);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    pool.conns[i] = (conn_t *)((char *)pool.cpool + (i * conn_size));
    pool.conns[i]->fd = -1;
    pool.conns[i]->in_fd = -1;
    pool.conns[i]->out_fd = -1;
  }

  /*** Freecs ***/
  bitmap_size = (MAX_CONNS + 63) / 64;
  pool.freecs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freecs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freecs[i] = UINT64_MAX;

  return 0;
}

static inline int MP_use_blks(size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t max_start = pool.nblocks - nblocks;
  size_t full_chunks = (nblocks / 64) * 64;

  for (size_t i = 0, c = 0; i <= max_start; i++, c++) {
    bool free = true;

    for (size_t j = 0; j < full_chunks; j += 64) {
      size_t word_index = (i + j) / 64;
      if (pool.freebs[word_index] != UINT64_MAX) {
        free = false;
        i += 63;
        break;
      }
    }

    for (size_t j = full_chunks; j < nblocks; j++) {
      size_t bit_index = i + j;
      size_t word_index = bit_index / 64;
      size_t bit_in_word = bit_index % 64;

      if (!BIT_IS_FREE(pool.freebs[word_index], bit_in_word)) {
        free = false;
        i += j;
        break;
      }
    }

    if (free) {
      for (size_t j = 0; j < full_chunks; j += 64) {
        size_t word_index = (i + j) / 64;
        pool.freebs[word_index] = 0;
      }

      for (size_t j = full_chunks; j < nblocks; j++) {
        size_t bit_index = i + j;
        size_t word_index = bit_index / 64;
        size_t bit_in_word = bit_index % 64;

        MARK_BIT_USED(pool.freebs[word_index], bit_in_word);
      }

      return i;
    }
  }

  return -1;
}

static inline int MP_free_blks(size_t bindex, size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t full_chunks = (nblocks / 64) * 64;
  for (size_t i = 0; i < full_chunks; i += 64) {
    size_t word_index = (bindex + i) / 64;
    pool.freebs[word_index] = UINT64_MAX;
  }

  for (size_t i = full_chunks; i < nblocks; i++) {
    size_t bit_index = bindex + i;
    size_t word_index = bit_index / 64;
    size_t bit_in_word = bit_index % 64;

    MARK_BIT_FREE(pool.freebs[word_index], bit_in_word);
  }

  memset(pool.blocks[bindex], 0, nblocks * MP_BLOCK);
  return 0;
}

static inline conn_t *MP_use(size_t nblocks, int fd, bool once) {
  if (fd <= 0)
    return NULL;
  if (once)
    return MP_use_once(nblocks, fd);

  int cindex = find_freec();
  if (cindex < 0) {
    LOG("Err: cindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  conn_t *conn = pool.conns[cindex];

  int ios_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (ios_bindex < 0) {
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }

  struct iovec *ios = pool.blocks[ios_bindex];
  conn->ios = ios;

  int rec_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (rec_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct iovec *rec = pool.blocks[rec_bindex];
  conn->rec = rec;

  int msg_bindex = MP_use_blks(MSG_NBLOCKS);
  if (msg_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct msghdr *msg = pool.blocks[msg_bindex];
  conn->msg = msg;

  if (nblocks > 0) {
    int bindex = MP_use_blks(nblocks);
    if (bindex < 0) {
      MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
      MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
      MP_free_blks(msg_bindex, IOVEC_NBLOCKS);
      MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
      LOG("Err: bindex < 0; will use MP_use_once\n");
      return MP_use_once(nblocks, fd);
    }

    size_t iov_index = conn->nios++;
    struct iovec *iov = &conn->ios[iov_index];
    struct iovec *rec = &conn->rec[iov_index];
    iov->iov_base = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
  }

  conn->msg->msg_iov = conn->ios;
  conn->msg->msg_iovlen = conn->nios;
  conn->cindex = cindex;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;
  return conn;
}

static inline void MP_shed(conn_t *conn, size_t iov_index, size_t nios) {
  struct iovec *iov, *rec;
  size_t bindex, nblocks, index;

  for (size_t i = 0; i < nios; i++) {
    index = iov_index + i;
    iov = &conn->ios[index];
    rec = &conn->rec[index];
    if (!rec || !rec->iov_base)
      continue;
    if (!IN_POOL(rec->iov_base)) {
      munmap(rec->iov_base, rec->iov_len / pool.pagesize);
    } else {
      bindex = ptr_diff((uintptr_t)rec->iov_base, (uintptr_t)pool.bpool) / MP_BLOCK;
      nblocks = rec->iov_len / MP_BLOCK;
      MP_free_blks(bindex, nblocks);
    }
    memset(iov, 0, sizeof(struct iovec));
    memset(rec, 0, sizeof(struct iovec));
    conn->nios--;
  }
}

static inline int MP_expand(conn_t *conn, size_t nblocks, bool once) {
  void *bptr;
  int iov_index, bindex;
  struct iovec *iov, *rec;

  iov_index = conn->nios++;
  iov = &conn->ios[iov_index];
  rec = &conn->rec[iov_index];

  if (nblocks == 0)
    return iov_index;

  if (once) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_base = bptr;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
    return iov_index;
  }

  bindex = MP_use_blks(nblocks);
  if (bindex < 0) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_len = iov->iov_len;
  } else {
    bptr = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_len = iov->iov_len;
  }

  iov->iov_base = bptr;
  rec->iov_base = iov->iov_base;
  return iov_index;
}

static inline int MP_free(conn_t *conn) {
  if (!conn)
    return -1;
  size_t bindex, nblocks;
  uint64_t *word;

  MP_shed(conn, 0, conn->nios);
  if (conn->flags & CF_IN_HEAP) {
    if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
      close(conn->fd);
    free(conn);
    return 0;
  }

  word = &pool.freecs[conn->cindex / 64];
  if (conn->cindex > MAX_CONNS)
    return -1;
  else if (BIT_IS_FREE(*word, conn->cindex))
    return 0;

  bindex = ptr_diff((uintptr_t)conn->ios, (uintptr_t)pool.bpool) / MP_BLOCK;
  nblocks = IOVEC_NBLOCKS;
  MP_free_blks(bindex, nblocks);

  bindex = ptr_diff((uintptr_t)conn->rec, (uintptr_t)pool.bpool) / MP_BLOCK;
  MP_free_blks(bindex, nblocks);

  if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
    close(conn->fd);

  MARK_BIT_FREE(*word, conn->cindex);
  memset(conn, 0, sizeof(conn_t));
  conn->fd = -1;
  conn->in_fd = -1;
  conn->out_fd = -1;
  return 0;
}

static inline void MP_clear(conn_t *conn) {
  conn_t *recv_conn = conn->recv_conn;
  conn_t *send_conn = conn->send_conn;
  if (recv_conn)
    MP_free(recv_conn);
  if (send_conn)
    MP_free(send_conn);
}

static inline void MP_exit(MPool *pool) {
  munmap(pool->bpool, pool->npages);
  free(pool->cpool);
  free(pool->blocks);
  free(pool->conns);
  free(pool->freebs);
  free(pool->freecs);
}

static inline void MP_timeout() {
  conn_t *conn;
  int16_t res;
  uint64_t now;
  size_t windex = 0;
  uint64_t *word = &pool.freecs[0];
  for (size_t i = 0; i < MAX_CONNS; i++) {
    if ((i / 64) < windex)
      word = &pool.freecs[++windex];

    if (*word == UINTMAX_MAX) {
      i = (i / 64) * 64 + 64;
      continue;
    }

    conn = pool.conns[i];
    if (!conn || conn->fd == -1)
      continue;

    res = pollevs(conn->fd);

    now = get_time();
    if (res & POLLERR) {
      MP_clear(conn);
      continue;
    }
    if (res & POLLIN) {
      if (pool.rtimeout > 0 && (now - conn->last_read) >= pool.rtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (res & POLLOUT) {
      if (pool.wtimeout > 0 && (now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (!(res & POLLIN || res & POLLOUT)) {
      if ((pool.rtimeout > 0 && now - conn->last_read) >= pool.rtimeout
          || (pool.wtimeout > 0 && now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
  }
}

/*
 * Calculate the length of a status string
 */
static inline size_t status_len(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return 8;
  case STATUSSWITCHINGPROTOCOLS:
    return 19;
  case STATUSPROCESSING:
    return 10;
  case STATUSEARLYHINTS:
    return 11;
  case STATUSOK:
    return 2;
  case STATUSCREATED:
    return 7;
  case STATUSACCEPTED:
    return 8;
  case STATUSNONAUTHORITATIVE:
    return 29;
  case STATUSNOCONTENT:
    return 10;
  case STATUSRESETCONTENT:
    return 13;
  case STATUSPARTIALCONTENT:
    return 15;
  case STATUSMULTISTATUS:
    return 12;
  case STATUSALREADYREPORTED:
    return 16;
  case STATUSIMUSED:
    return 7;
  case STATUSMULTIPLECHOICES:
    return 16;
  case STATUSMOVEDPERMANENTLY:
    return 17;
  case STATUSFOUND:
    return 5;
  case STATUSSEEOTHER:
    return 9;
  case STATUSNOTMODIFIED:
    return 12;
  case STATUSUSEPROXY:
    return 9;
  case STATUSTEMPORARYREDIRECT:
    return 18;
  case STATUSPERMANENTREDIRECT:
    return 18;
  case STATUSBADREQUEST:
    return 11;
  case STATUSUNAUTHORIZED:
    return 12;
  case STATUSPAYMENTREQUIRED:
    return 16;
  case STATUSFORBIDDEN:
    return 9;
  case STATUSNOTFOUND:
    return 9;
  case STATUSMETHODNOTALLOWED:
    return 18;
  case STATUSNOTACCEPTABLE:
    return 14;
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return 29;
  case STATUSREQUESTTIMEOUT:
    return 15;
  case STATUSCONFLICT:
    return 8;
  case STATUSGONE:
    return 4;
  case STATUSLENGTHREQUIRED:
    return 15;
  case STATUSPRECONDITIONFAILED:
    return 19;
  case CONTENTTOOLARGE:
    return 17;
  case STATUSURITOOLONG:
    return 12;
  case STATUSUNSUPPORTEDMEDIATYPE:
    return 22;
  case STATUSRANGENOTSATISFIABLE:
    return 21;
  case STATUSEXPECTATIONFAILED:
    return 18;
  case STATUSMISDIRECTEDREQUEST:
    return 19;
  case STATUSUNPROCESSABLECONTENT:
    return 21;
  case STATUSLOCKED:
    return 6;
  case STATUSFAILEDDEPENDENCY:
    return 17;
  case STATUSTOOEARLY:
    return 9;
  case STATUSUPGRADEREQUIRED:
    return 16;
  case STATUSPRECONDITIONREQUIRED:
    return 21;
  case STATUSTOOMANYREQUESTS:
    return 17;
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return 31;
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return 29;
  case STATUSInternalServerError:
    return 21;
  case STATUSNOTIMPLEMENTED:
    return 15;
  case STATUSBADGATEWAY:
    return 11;
  case STATUSSERVICEUNAVAILABLE:
    return 19;
  case STATUSGATEWAYTIMEOUT:
    return 15;
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return 26;
  case STATUSVARIANTALSONEGOTIATES:
    return 23;
  case STATUSINSUFFICIENTSTORAGE:
    return 20;
  case STATUSLOOPDETECTED:
    return 13;
  case STATUSNOTEXTENDED:
    return 12;
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return 31;
  default:
    return 0;
  }
}

/*
 * Return the status code string as string literal
 */
static inline char *status_str(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return "Continue";
  case STATUSSWITCHINGPROTOCOLS:
    return "Switching Protocols";
  case STATUSPROCESSING:
    return "Processing";
  case STATUSEARLYHINTS:
    return "Early Hints";
  case STATUSOK:
    return "OK";
  case STATUSCREATED:
    return "Created";
  case STATUSACCEPTED:
    return "Accepted";
  case STATUSNONAUTHORITATIVE:
    return "Non-Authoritative Information";
  case STATUSNOCONTENT:
    return "No Content";
  case STATUSRESETCONTENT:
    return "Reset Content";
  case STATUSPARTIALCONTENT:
    return "Partial Content";
  case STATUSMULTISTATUS:
    return "Multi-Status";
  case STATUSALREADYREPORTED:
    return "Already Reported";
  case STATUSIMUSED:
    return "Im Used";
  case STATUSMULTIPLECHOICES:
    return "Multiple Choices";
  case STATUSMOVEDPERMANENTLY:
    return "Moved Permanently";
  case STATUSFOUND:
    return "Found";
  case STATUSSEEOTHER:
    return "See Other";
  case STATUSNOTMODIFIED:
    return "Not Modified";
  case STATUSUSEPROXY:
    return "Use Proxy";
  case STATUSTEMPORARYREDIRECT:
    return "Temporary Redirect";
  case STATUSPERMANENTREDIRECT:
    return "Permanent Redirect";
  case STATUSBADREQUEST:
    return "Bad Request";
  case STATUSUNAUTHORIZED:
    return "Unauthorized";
  case STATUSPAYMENTREQUIRED:
    return "Payment Required";
  case STATUSFORBIDDEN:
    return "Forbidden";
  case STATUSNOTFOUND:
    return "Not Found";
  case STATUSMETHODNOTALLOWED:
    return "Method Not Allowed";
  case STATUSNOTACCEPTABLE:
    return "Not Acceptable";
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return "Proxy Authentication Required";
  case STATUSREQUESTTIMEOUT:
    return "Request Timeout";
  case STATUSCONFLICT:
    return "Conflict";
  case STATUSGONE:
    return "Gone";
  case STATUSLENGTHREQUIRED:
    return "Length Required";
  case STATUSPRECONDITIONFAILED:
    return "Precondition Failed";
  case CONTENTTOOLARGE:
    return "Content Too Large";
  case STATUSURITOOLONG:
    return "URI Too Long";
  case STATUSUNSUPPORTEDMEDIATYPE:
    return "Unsupported Media Type";
  case STATUSRANGENOTSATISFIABLE:
    return "Range Not Satisfiable";
  case STATUSEXPECTATIONFAILED:
    return "Expectation Failed";
  case STATUSMISDIRECTEDREQUEST:
    return "Misdirected Request";
  case STATUSUNPROCESSABLECONTENT:
    return "Unprocessable Content";
  case STATUSLOCKED:
    return "Locked";
  case STATUSFAILEDDEPENDENCY:
    return "Failed Dependency";
  case STATUSTOOEARLY:
    return "Too Early";
  case STATUSUPGRADEREQUIRED:
    return "Upgrade Required";
  case STATUSPRECONDITIONREQUIRED:
    return "Precondition Required";
  case STATUSTOOMANYREQUESTS:
    return "Too Many Requests";
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return "Request Header Fields Too Large";
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return "Unavailable For Legal Reasons";
  case STATUSInternalServerError:
    return "Internal Server Error";
  case STATUSNOTIMPLEMENTED:
    return "Not Implemented";
  case STATUSBADGATEWAY:
    return "Bad Gateway";
  case STATUSSERVICEUNAVAILABLE:
    return "Service Unavailable";
  case STATUSGATEWAYTIMEOUT:
    return "Gateway Timeout";
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return "HTTP Version Not Supported";
  case STATUSVARIANTALSONEGOTIATES:
    return "Variant Also Negotiates";
  case STATUSINSUFFICIENTSTORAGE:
    return "Insufficient Storage";
  case STATUSLOOPDETECTED:
    return "Loop Detected";
  case STATUSNOTEXTENDED:
    return "Not Extended";
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return "Network Authentication Required";
  default:
    return 0;
  }
}

/*
 * Return true if routes match
 */
static inline bool route_equ(Route *route, Request *req) {
  return route->method == req->method && strncmp(route->path, req->path, strlen(route->path)) == 0;
}

/*
 * Return the matching route index on success. -1 on failure
 */
static inline int match_route(Server *serv, Request *req) {
  for (size_t i = 0; i < serv->_nroutes; i++) {
    Route route = serv->routes[i];
    if (!req->path || !route.path)
      continue;
    if (route_equ(&route, req))
      return i;
    else if (req->method == HEAD && route.method == GET && strcmp(route.path, req->path) == 0)
      return i;
  }
  return -1;
}

/*
 * Return true if the response should contain the Content-Length header
 */
static inline bool should_have_content_length(Request *req, ResWriter *res) {
  return (req->method != CONNECT              // CONNECT request
          && res->status != STATUSNOCONTENT   // 204 response
          && res->status != STATUSNOTMODIFIED // 304 response
          && res->status >= 200);             // 1xx response
}

/*
 * Format http response from the ResWriter.
 * Return response size on success, 0 on failure.
 */
static inline size_t fmt_res(Request *req, ResWriter *res, char *buffer, size_t buffer_size) {
  if (!res || !buffer || buffer_size == 0)
    return 0;

  size_t res_len, total = 0;
  char *dst = buffer;
  size_t maxlen = buffer_size;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t body_length = res->len;

  res_len = snprintf(dst, maxlen, "HTTP/1.1 %d %s", (int)res->status, status_str(res->status));
  total += res_len;
  dst += res_len;
  maxlen -= res_len;

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    res_len = snprintf(dst, maxlen, "\r\n%s: %s", header->key, header->value);
    total += res_len;
    dst += res_len;
    maxlen -= res_len;
  }

  if (have_content_length) {
    res_len = snprintf(dst, maxlen, "\r\nContent-Length: %lu", body_length);
    total += res_len, dst += res_len, maxlen -= res_len;
  }

  memcpy(dst, "\r\n\r\n", 4);
  total += 4, dst += 4, maxlen -= 4;

  return total;
}

static inline size_t res_len(Request *req, ResWriter *res) {
  if (!req || !res)
    return 0;

  if (!res->status)
    res->status = STATUSOK;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t result = 0;
  result += STRLEN("HTTP/1.1 ");     // HTTP version
  result += 4;                       // Status code + space
  result += status_len(res->status); // Status name

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    result += 2;                       // "\r\n"
    result += strlen(header->key) + 2; // Header key + ':' + space
    result += strlen(header->value);   // header value
  }

  if (have_content_length) {
    result += 2;                          // "\r\n"
    result += STRLEN("Content-Length: "); // Header key
    result += countd(res->len);           // Header value
  }

  result += 4; // "\r\n\r\n"

  return result;
}

static inline int send_empty_res(Status status) {
  size_t res_len = STRLEN("HTTP/1.1 ")        // HTTP version
                   + countd((uint64_t)status) // status code
                   + 1                        // space
                   + (int)status_len(status)  // status string
                   + 4;                       // \r\n\r\n

  conn_t *conn = current_send;
  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, res_len);
  if (snprintf((char *)rec->iov_base, res_len + 1, "HTTP/1.1 %d %s\r\n\r\n", (int)status, status_str(status))
      != (int)res_len)
    return -1;

  return usendmsg(conn, 0, 1);
}

static inline ssize_t read_socket(int sockfd, size_t len) {
  if (len == 0 || sockfd <= 0)
    return 0;
  char buff[1024 * 8];
  return read(sockfd, buff, 1024 * 8);
}

static inline int read_method(Method *method, void *src) {
  if (memcmp(src, "GET", 3) == 0)
    *method = GET;
  else if (memcmp(src, "POST", 4) == 0)
    *method = POST;
  else if (memcmp(src, "HEAD", 4) == 0)
    *method = HEAD;
  else if (memcmp(src, "PUT", 3) == 0)
    *method = PUT;
  else if (memcmp(src, "DELETE", 6) == 0)
    *method = DELETE;
  else if (memcmp(src, "CONNECT", 7) == 0)
    *method = CONNECT;
  else if (memcmp(src, "OPTIONS", 7) == 0)
    *method = OPTIONS;
  else if (memcmp(src, "TRACE", 5) == 0)
    *method = TRACE;
  else if (memcmp(src, "PATCH", 5) == 0)
    *method = PATCH;
  else
    return -1;

  return 0;
}

static inline int sendmsg_res(Request *req, ResWriter *res) {
  conn_t *conn;
  size_t head_size, res_size;
  struct iovec *iov;

  conn = current_send;
  iov = &conn->ios[0];
  head_size = res_len(req, res);
  if (head_size == 0)
    return -1;

  conn->data_left += head_size;
  res_size = fmt_res(req, res, iov->iov_base, (head_size + 1));
  if (res_size != head_size)
    return -1;
  iov->iov_len = res_size;

  return usendmsg(conn, 0, conn->nios);
}

static inline int read_req(Request *req, char *req_buffer) {
  if (!req_buffer)
    return -1;
  /*** Method ***/
  char *sep = strchr(req_buffer, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }
  *sep = '\0';
  if (read_method(&req->method, req_buffer) < 0)
    return -1;

  /*** Path ***/
  char *fullpath = sep + 1;
  sep = strchr(fullpath, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }

  *sep = '\0';
  req->path = fullpath;
  /*** Params ***/
  char *paramStart = strchr(fullpath, '?');
  if (paramStart) {
    *paramStart++ = '\0';
    int params_count = 0;
    params_count = HK_parse_params(paramStart, req->params, MAX_URL_PARAMETERS);
    if (params_count > 0)
      req->params_count = params_count;
    else
      req->params_count = 0;
  } else {
    req->params = NULL;
    req->params_count = 0;
  }

  /*** Headers ***/
  char *headStart = strstr(sep + 1, "\r\n");
  char *headEnd = strstr(sep + 1, "\r\n\r\n");
  if (!headStart) {
    LOG("read_req: !headStart\n");
    return -1;
  };

  memset(headStart, 0, 2);
  headStart += 2;
  memset(headEnd, 0, 4);
  headEnd += 4;

  int headers_count = HK_parse_headers(headStart, req->headers, MAX_REQ_HEADERS);
  if (headers_count <= 0)
    return -1;
  req->headers_count = headers_count;

  /*** Host ***/
  int index = HK_get_header(req, "Host");
  if (index < 0)
    return -1;
  char *host = req->headers[index].value;
  req->hostname = host;

  /*** Port ***/
  char *colon = strchr(host, ':');
  if (colon) {
    *colon++ = '\0';
    req->port = atoi(colon);
  } else {
    req->port = PORT;
  }
  return 0;
}
static inline int process_req(Server *serv, conn_t *conn) {
  if (!conn || conn->fd == -1)
    return -1;

  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;
  if (read_req(&req, conn->ios[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    LOG("Err: route_index == -1\n");
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;
  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  sendmsg_res(&req, &res);

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int new_conn(int connfd) {
  if (connfd <= 0)
    return -1;

  current_recv = MP_use(KB * 2, connfd, false);
  current_send = MP_use(KB * 2, connfd, false);

  current_recv->recv_conn = current_recv;
  current_recv->send_conn = current_send;

  current_send->send_conn = current_send;
  current_send->recv_conn = current_recv;

  conn_t *conn = current_recv;
  if (ufrecvmsg(conn, 0, 1) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

static inline int resubmit_sendmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return usendmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int resubmir_recvmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    // FIXME the len should be increased
    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return urecvmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int handle_sendmsg_complete(conn_t *conn) {
  struct iovec *iov, *rec;

  MP_shed(conn, 1, conn->nios - 1);
  iov = &conn->ios[0];
  rec = &conn->rec[0];
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;

  return ufrecvmsg(conn->recv_conn, 0, 1);
}

static inline int handle_sendmsg(conn_t *conn, int res, bool zc) {
  if (!conn || conn->fd == -1)
    return -1;

  conn->data_left -= res;
  if (conn->data_left > 0)
    return resubmit_sendmsg(conn, res);

  if (zc)
    return 0;

  return handle_sendmsg_complete(conn);
}

static inline int handle_insplice(conn_t *conn) {
  conn->op = OUTSPLICE;
  return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
}
static inline int handle_outsplice(conn_t *conn, int res) {
  conn->data_left -= res;
  if (conn->data_left > 0) {
    conn->op = INSPLICE;
    return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
  }

  conn_t *recv_conn = conn->recv_conn;
  struct iovec *iov = &recv_conn->ios[0];
  memset(iov->iov_base, 0, iov->iov_len);
  if (urecv(recv_conn, iov->iov_base, iov->iov_len, MSG_PEEK) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

/*
static inline int handle_recv(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  void *bptr = conn->ios[0].iov_base;
  void *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  void *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  return process_req(serv, conn);
}
*/
static inline int find_route(Server *serv, char *bptr) {
  Request req = {0};
  if (read_method(&req.method, bptr) < 0) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  };
  char *space = strchr(bptr, ' ');
  req.path = (space + 1);
  space = strchr(req.path, ' ');
  *space = '\0';
  int route_index = match_route(serv, &req);
  *space = ' ';
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }
  return route_index;
}

static inline int run_handler(Server *serv, conn_t *conn, bool uses_body) {
  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;

  if (read_req(&req, conn->rec[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  if (uses_body) {
    int h_index = HK_get_header(&req, "Content-Length");
    long body_size = atol(req.headers[h_index].value);
    if (body_size >= 0) {
      req.body.ptr = conn->rec[1].iov_base;
      req.body.size = body_size;
    } else {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    }
  }

  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  if (sendmsg_res(&req, &res) < 0)
    return -1;

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int handle_frecvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  char *bptr = (char *)conn->ios[0].iov_base;
  char *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  char *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  size_t head_size = (headEnd + 4) - bptr;
  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  int route_index = find_route(serv, bptr);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  bool uses_body = serv->routes[route_index].uses_body;
  long body_size = get_content_length(headstart + 2, headEnd + 4);
  if (body_size == -1) {
    if (uses_body) {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    } else {
      body_size = 0;
    }
  }

  conn->head_size = head_size;
  if (!uses_body) {
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  if (res == (int)(head_size + body_size)) {
    size_t iov_index = MP_expand(conn, round_to_blocks(body_size), false);
    memcpy(conn->rec[iov_index].iov_base, headEnd + 4, body_size);
    conn->ios[iov_index].iov_len = body_size;
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  conn->data_left = body_size - (res - head_size);
  bool once = ((size_t)body_size > (size_t)((pool.nblocks * MP_BLOCK) / 10));
  size_t iov_index = MP_expand(conn, round_to_blocks(body_size), once);
  memcpy(conn->rec[iov_index].iov_base, headEnd + 4, (res - head_size));
  conn->ios[iov_index].iov_base += (res - head_size);

  return urecvmsg(conn, iov_index, 1);
}

static inline int handle_recvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  if (conn->data_left > 0) {
    conn->data_left -= res;
    if (conn->data_left == 0) {
      conn->flags &= CF_HANDLER_READY;
      return run_handler(serv, conn, true);
    }

    conn->flags &= ~CF_HANDLER_READY;
    conn->ios[1].iov_base += res;
    return urecvmsg(conn, 1, 1);
  }

  conn->flags &= CF_HANDLER_READY;
  return run_handler(serv, conn, true);
}

static inline int serv_init(Server *serv) {
#if DEBUG
  logfd = log_init("log.txt");
  if (!logfd) {
    printf("log_init failed");
    return -1;
  }
#endif
  serv->_nroutes = get_nroutes(serv->routes);

  int pipefd[2];
  if (pipe(pipefd) < 0)
    return -1;
  pipe_in = pipefd[0];
  pipe_out = pipefd[1];
  nullfd = open("/dev/null", O_WRONLY);
  pipe_sz = fcntl(pipefd[0], F_GETPIPE_SZ);
  if (pipe_sz < 0)
    return -1;

  pool.rtimeout = serv->rtimeout;
  pool.wtimeout = serv->wtimeout;
  if (MP_init(MAX_CONNS * 8) < 0)
    return -1;
  LOG("pool initialized\n");

  if (io_uring_queue_init(MAX_CONNS, &ring, 0) < 0)
    return -1;
  LOG("uring initialized\n");

  int listenfd;
  if ((listenfd = tcp_listen(serv->port)) < 0)
    return -1;
  LOG("socket initialized\n");

  return umaccept(listenfd);
}

static inline int serv_listen(Server *serv) {
  // uint64_t last_check = get_time();
  while (true) {
    // uint64_t now = get_time();
    // if ((now - last_check) >= 200) {
    //   last_check = now;
    //   LOG("CM: CM_check ran\n");
    //   MP_timeout();
    // }

    LOG("SQ ready: %u, CQ ready: %u\n", io_uring_sq_ready(&ring), io_uring_cq_ready(&ring));
    struct io_uring_cqe *cqe;
    if (io_uring_wait_cqe(&ring, &cqe) < 0)
      continue;

    int res = cqe->res;
    LOG("res = %d\n", res);
    conn_t *conn = NULL;
    if (cqe->user_data > 100) {
      conn = (conn_t *)cqe->user_data;
      current_recv = (conn_t *)conn->recv_conn;
      current_send = (conn_t *)conn->send_conn;
    }

    if (res > 0) {
      if (cqe->user_data == ACCEPT) {
        LOG("new conn created\n");
        new_conn(res);
      } else if (conn && conn->fd != -1) {
        LOG("conn[%d]: conn.fd = %d; conn.op = %d\n", conn->cindex, conn->fd, conn->op);
        switch (conn->op) {
        case FRECVMSG:
          if (handle_frecvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case RECVMSG:
          if (handle_recvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case SENDMSG:
        case SENDMSGZC:
          // conn->last_write = get_time();
          bool zc = (conn->op == SENDMSGZC);
          if (handle_sendmsg(conn, res, zc) < 0)
            MP_clear(conn);
          break;
        case INSPLICE:
          if (handle_insplice(conn) < 0)
            MP_clear(conn);
          break;
        case OUTSPLICE:
          if (handle_outsplice(conn, res) < 0)
            MP_clear(conn);
          break;
        }
      }
    } else if (res == 0) {
      if (conn && conn->fd != -1) {
        switch (conn->op) {
        case SENDMSGZC:
          conn->zc_notifs--;
          if (conn->zc_notifs == 0 && handle_sendmsg_complete(conn) < 0)
            MP_clear(conn);
          break;
        case RECV:
          MP_clear(conn);
          break;
        }
      }
    } else {
      if (conn && conn->fd != -1) {
        if (res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR) {
          LOG("conn && conn->fd != -1 && res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR\n");
          MP_clear(conn);
        } else {
          LOG("res == -EAGAIN || res == -EWOULDBLOCK || res == -EINTR\n");
          conn = conn->recv_conn;
          struct iovec *iov = &conn->ios[0];
          memset(iov->iov_base, 0, iov->iov_len);
          if (urecv(conn, iov->iov_base, iov->iov_len, 0) < 0)
            MP_clear(conn);
        }
      }
    }

    LOG("uring operation seen\n");
    io_uring_cqe_seen(&ring, cqe);
  }

  io_uring_queue_exit(&ring);
  MP_exit(&pool);
  return 0;
}

/*** Helper ***/
static inline int _HK_write(void *data, size_t size) {
  size_t nblocks;
  int iov_index;
  conn_t *conn;
  struct iovec *iov;
  bool once;

  conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  nblocks = round_to_blocks(size);
  iov_index = MP_expand(conn, nblocks, once);
  iov = &conn->ios[iov_index];

  memcpy(iov->iov_base, data, size);
  iov->iov_len = size;
  conn->data_left += size;

  return 0;
}
static inline int _HK_write_body(Request *req, size_t offset, size_t size) {
  if (size > req->body.size || offset > req->body.size)
    return -1;

  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  int iov_index = MP_expand(conn, 0, false);
  struct iovec *iov = &conn->ios[iov_index];
  struct iovec *rec = &conn->rec[iov_index];
  rec->iov_base = req->body.ptr + offset;
  rec->iov_len = size;
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;
  conn->data_left += rec->iov_len;
  return 0;
}
/*
static inline int _HK_mem(size_t size, HKMem *mem) {
  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  bool once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  size_t nblocks = round_to_blocks(size);
  int iov_index = MP_expand(conn, nblocks, once);
  struct iovec *iov = &conn->ios[iov_index];
  mem->ptr = iov->iov_base;
  mem->size = iov->iov_len;
  mem->_iov_index = iov_index;
  mem->_flags = (IN_POOL(iov->iov_base)) ? CF_IN_POOL : CF_IN_HEAP;
  return 0;
}

static inline void _HK_send(HKMem *mem, size_t size) {
  conn_t *conn = current_send;
  struct iovec *iov = &conn->ios[mem->_iov_index];
  iov->iov_len = size;
  conn->data_left += size;
}
  */
#endif#define _GNU_SOURCE
#ifndef UTILS_H
#define UTILS_H

#include "hunk.h"
#include <arpa/inet.h>
#include <fcntl.h>
#include <liburing.h>
#include <netdb.h>
#include <signal.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/poll.h>
#include <sys/prctl.h>
#include <sys/socket.h>
#include <sys/sysinfo.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

#define MP_BLOCK  4
#define MAX_CONNS 4096
#define KB        1024
#define NIOS      32

#define IN_POOL(ptr)                 ((void *)ptr >= pool.bpool && (void *)ptr <= (pool.bpool + (pool.npages * pool.pagesize)))
#define ALIGN_TO_PAGESIZE(buff_size) (((buff_size) + (pool.pagesize - 1)) & ~(pool.pagesize - 1))
#define BYTES_TO_BLOCKS(buff_size)   (((buff_size) + (MP_BLOCK - 1)) / MP_BLOCK)
#define CEIL_BLOCKS(nblocks)         ((nblocks + 63) & ~63)
#define CEIL_PAGES(size)             (((size) + ((pool.pagesize) - 1)) & ~((pool.pagesize) - 1))

#define BIT_IS_FREE(word, bit)   (((word) >> (bit)) & 1)
#define MARK_BIT_USED(word, bit) ((word) &= ~(1ULL << (bit)))
#define MARK_BIT_FREE(word, bit) ((word) |= (1ULL << (bit)))
#define FIND_FREE_BIT(word)      ((uint64_t)(word) & -(uint64_t)(word))
#define STRLEN(s)                (sizeof(s) - 1)

#define IOVEC_NBLOCKS (BYTES_TO_BLOCKS(NIOS * sizeof(struct iovec)))
#define MSG_NBLOCKS   (BYTES_TO_BLOCKS(sizeof(struct msghdr)))
#define ZC_RES        KB *KB

#define DEBUG 0
#if DEBUG
#define LOG(...) fprintf(logfd, __VA_ARGS__)
#else
#define LOG(...) ((void)0)
#endif

typedef enum UOP {
  WRITEV = IORING_OP_WRITEV,
  SENDMSG = IORING_OP_SENDMSG,
  RECVMSG = IORING_OP_RECVMSG,
  ACCEPT = IORING_OP_ACCEPT,
  SEND = IORING_OP_SEND,
  RECV = IORING_OP_RECV,
  SENDZC = IORING_OP_SEND_ZC,
  SENDMSGZC = IORING_OP_SENDMSG_ZC,
  PEEK = 50,
  FRECVMSG,
  INSPLICE,
  OUTSPLICE
} UOP;

typedef enum CFS {
  CF_IN_POOL = (1 << 0),       // Connection is in the pool
  CF_IN_HEAP = (1 << 1),       // Connection is in the heap
  CF_SKIP_SOCK = (1 << 2),     // Don't close the socket
  CF_USE_ONCE = (1 << 3),      // Destroy after using
  CF_HANDLER_READY = (1 << 4), // Ready to call the handler
} CFS;

typedef struct conn_t {
  // Socket file descriptor
  int fd;

  // Amount of data left in the current operation
  uint64_t data_left;

  // The index of the connection struct
  uint32_t cindex;

  // The last time the connection was readable
  uint64_t last_read;

  // The last time the connection was writeable
  uint64_t last_write;

  // The operation currently being processed
  uint8_t op;

  // Connection flags
  int flags;

  // Splice fd_in
  int in_fd;

  // Splice fd_out
  int out_fd;

  void *recv_conn;
  void *send_conn;

  struct iovec *ios;
  struct iovec *rec;
  uint16_t nios;

  struct msghdr *msg;
  uint16_t zc_notifs;

  uint16_t head_size;
} conn_t;

typedef struct MPool {
  // The allocated pool of blocks
  void *bpool;

  // The allocated pool of connections
  conn_t *cpool;

  // The size of the pool in pages
  uint32_t npages;

  // The size of the pool in blocks
  uint32_t nblocks;

  // The locations of each page in the pool
  void **blocks;

  // The availability of each block
  uint64_t *freebs;

  // The locations of each conn in the pool
  conn_t **conns;

  // The availability of each conn
  uint64_t *freecs;

  // Clean up callback function
  void (*callback)(conn_t *conn);

  // The page size used
  uint32_t pagesize;

  // Socket read timeout
  uint32_t rtimeout;

  // Socket write timeout
  uint32_t wtimeout;
} MPool;

extern int pipe_sz;
extern int pipe_in, pipe_out, nullfd;
extern FILE *logfd;
extern struct io_uring ring;
extern MPool pool;
extern conn_t *current_recv;
extern conn_t *current_send;

/*
 * Prepare and submit a recv uring op
 */
static inline int urecv(conn_t *conn, void *buffer, size_t buff_size, int flags) {
  if (!conn || conn->fd == -1)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (flags == MSG_PEEK) ? PEEK : RECV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;

  io_uring_prep_recv(sqe, conn->fd, buffer, buff_size, flags);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a multi-shot accept uring op
 */
static inline int umaccept(int listenfd) {
  if (listenfd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = ACCEPT;
  io_uring_prep_multishot_accept(sqe, listenfd, NULL, NULL, SOCK_NONBLOCK);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a splice uring op
 */
static inline int usplice(conn_t *conn, int fd_in, int64_t off_in, int fd_out, int64_t off_out, size_t len) {
  if (!len || !conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = (__u64)conn;
  io_uring_prep_splice(sqe, fd_in, off_in, fd_out, off_out, len, 0);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a writev uring op
 */
static inline int uwritev(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = WRITEV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  io_uring_prep_writev(sqe, conn->fd, &conn->ios[iov_index], nios, -1);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a send uring op
 */
static inline int usend(conn_t *conn, char *res_buff, size_t buff_size, bool zc) {
  if (!conn || conn->fd <= 0 || buff_size == 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (zc) ? SENDZC : SEND;
  conn->data_left = buff_size;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  if (zc)
    io_uring_prep_send_zc(sqe, conn->fd, res_buff, buff_size, 0, 0);
  else
    io_uring_prep_send(sqe, conn->fd, res_buff, buff_size, 0);
  return io_uring_submit(&ring);
}

static inline int ufrecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = FRECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;

  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, rec->iov_len);
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int urecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = RECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int usendmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  bool zc = (conn->data_left > ZC_RES) ? true : false;
  conn->op = (zc) ? SENDMSGZC : SENDMSG;

  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  if (zc) {
    io_uring_prep_sendmsg_zc(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
    conn->zc_notifs++;
  } else {
    io_uring_prep_sendmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  }
  return io_uring_submit(&ring);
}

/*
 * Create and initialize a server socket
 */
static inline int tcp_listen(uint16_t port) {
  int enable;
  int listenfd;
  if ((listenfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    return -1;

  int flags = fcntl(listenfd, F_GETFL, 0);
  fcntl(listenfd, F_SETFL, flags | O_NONBLOCK);
  struct sockaddr_in servaddr;
  memset(&servaddr, 0, sizeof(servaddr));
  servaddr.sin_family = AF_INET;
  servaddr.sin_addr.s_addr = INADDR_ANY;
  servaddr.sin_port = htons(port);

  enable = 1;
  if (setsockopt(listenfd, SOL_SOCKET, SO_REUSEPORT, &enable, sizeof(enable)) < 0)
    return -1;

  if (bind(listenfd, (struct sockaddr *)&servaddr, sizeof(servaddr)) < 0)
    return -1;

  if (listen(listenfd, SOMAXCONN) < 0)
    return -1;

  return listenfd;
}

/*
 * Calculate the difference between two pointers
 */
static inline uintptr_t ptr_diff(uintptr_t p1, uintptr_t p2) { return (uintptr_t)(p1 > p2) ? (p1 - p2) : (p2 - p1); }

static inline size_t get_nroutes(Route *routes) {
  Route *route;
  for (size_t i = 0;; i++) {
    route = &routes[i];
    if (!route->path && !route->handler && !route->method)
      return i;
  }
}

static inline long get_content_length(char *src, char *end) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return -1;
    key = line;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, "Content-Length") != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;

    *line_end = '\0';
    long res = atol(value);
    *line_end = '\r';

    return res;
  }
  return -1;
}

static inline bool have_header(char *src, char *end, const char *header_key, const char *header_value) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    key = line;
    while (*key == ' ')
      key++;
    while (*header_key == ' ')
      header_key++;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return false;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, header_key) != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;
    while (*header_value == ' ')
      header_value++;

    *line_end = '\0';
    bool res = (strcasecmp(value, header_value) == 0);
    *line_end = '\r';

    return res;
  }

  return false;
}

static inline const char *method_str(Method method) {
  switch (method) {
  case GET:
    return "GET";
    break;
  case HEAD:
    return "HEAD";
    break;
  case POST:
    return "POST";
    break;
  case PUT:
    return "PUT";
    break;
  case DELETE:
    return "DELETE";
    break;
  case CONNECT:
    return "CONNECT";
    break;
  case OPTIONS:
    return "OPTIONS";
    break;
  case TRACE:
    return "TRACE";
    break;
  case PATCH:
    return "PATCH";
    break;
  default:
    return NULL;
  }
}

static inline uint8_t method_len(Method method) {
  switch (method) {
  case GET:
    return 3;
    break;
  case HEAD:
    return 4;
    break;
  case POST:
    return 4;
    break;
  case PUT:
    return 3;
    break;
  case DELETE:
    return 6;
    break;
  case CONNECT:
    return 7;
    break;
  case OPTIONS:
    return 7;
    break;
  case TRACE:
    return 5;
    break;
  case PATCH:
    return 5;
    break;
  default:
    return 0;
  }
}

static inline size_t round_to_blocks(size_t size) {
  size_t nblocks = BYTES_TO_BLOCKS(size);
  nblocks = CEIL_BLOCKS(nblocks);
  return nblocks;
}

/*
 * Count the digits in unsigned 64-bit int
 */
static inline int countd(uint64_t num) {
  if (num < 10ULL)
    return 1;
  if (num < 100ULL)
    return 2;
  if (num < 1000ULL)
    return 3;
  if (num < 10000ULL)
    return 4;
  if (num < 100000ULL)
    return 5;
  if (num < 1000000ULL)
    return 6;
  if (num < 10000000ULL)
    return 7;
  if (num < 100000000ULL)
    return 8;
  if (num < 1000000000ULL)
    return 9;
  if (num < 10000000000ULL)
    return 10;
  if (num < 100000000000ULL)
    return 11;
  if (num < 1000000000000ULL)
    return 12;
  if (num < 10000000000000ULL)
    return 13;
  if (num < 100000000000000ULL)
    return 14;
  if (num < 1000000000000000ULL)
    return 15;
  if (num < 10000000000000000ULL)
    return 16;
  if (num < 100000000000000000ULL)
    return 17;
  if (num < 1000000000000000000ULL)
    return 18;
  if (num < 10000000000000000000ULL)
    return 19;
  return 20;
}

/*
 * Get the time elabsed in ms
 */
static inline uint64_t get_time() {
  struct timespec ts;
  clock_gettime(CLOCK_MONOTONIC, &ts);
  return (uint64_t)(ts.tv_sec) * 1000 + (ts.tv_nsec / 1000000);
}

static inline FILE *log_init(const char *path) {
  FILE *res = fopen(path, "a+");
  setvbuf(res, NULL, _IONBF, 0);
  return res;
}

static inline int16_t pollevs(int connfd) {
  struct pollfd pfd;
  pfd.fd = connfd;
  pfd.events = POLLIN | POLLOUT | POLLERR;
  int res = poll(&pfd, 1, 0);
  if (res < 0)
    return POLLERR;
  return pfd.revents;
}

// FIXME This needs to be updated
static inline conn_t *MP_use_once(size_t nblocks, int fd) {

  void *mem = malloc(sizeof(conn_t) + 8 + (IOVEC_NBLOCKS * MP_BLOCK));
  struct conn_t *conn = (conn_t *)mem;
  memset(conn, 0, sizeof(conn_t));
  conn->ios = mem + sizeof(conn_t) + 8;

  if (nblocks > 0) {
    struct iovec *iov = &conn->ios[conn->nios++];
    mem = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (mem == MAP_FAILED)
      return NULL;
    iov->iov_base = mem;
    iov->iov_len = ALIGN_TO_PAGESIZE(nblocks * MP_BLOCK);
  }

  conn->flags |= CF_IN_HEAP;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;

  return conn;
}

static inline int find_freec() {
  uint64_t *word;
  size_t map_size = (sizeof(uint64_t) * 8);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    word = &pool.freecs[i / map_size];

    if (*word == 0) { // All used
      i += (map_size - 1);
      continue;
    }

    i += __builtin_ctzll(*word);
    MARK_BIT_USED(*word, i);
    return i;
  }

  return -1;
}

static inline int MP_init(size_t npages) {
  if (!npages)
    return -1;

  /*** Setup ***/
  pool.npages = npages;
  pool.pagesize = sysconf(_SC_PAGESIZE);

  /*** Pool ***/
  pool.bpool = mmap(NULL, pool.npages * pool.pagesize, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  if (pool.bpool == MAP_FAILED)
    return -1;
  pool.nblocks = (pool.npages * pool.pagesize) / MP_BLOCK;

  /*** Blocks ***/
  pool.blocks = malloc(sizeof(void *) * pool.nblocks);
  if (!pool.blocks)
    return -1;
  for (size_t i = 0; i < pool.nblocks; i++)
    pool.blocks[i] = pool.bpool + (i * MP_BLOCK);

  /*** Freebs ***/
  // if (posix_memalign((void **)&pool.freebs, 64, bitmap_size * sizeof(uint64_t)) < 0)
  size_t bitmap_size = (pool.nblocks + 63) / 64;
  pool.freebs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freebs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freebs[i] = UINT64_MAX;

  /*** Cpool ***/
  pool.cpool = (conn_t *)malloc(sizeof(conn_t) * MAX_CONNS);
  if (!pool.cpool)
    return -1;

  /*** Conns ***/
  pool.conns = (conn_t **)malloc(sizeof(conn_t *) * MAX_CONNS);
  if (!pool.conns)
    return -1;
  size_t conn_size = sizeof(conn_t);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    pool.conns[i] = (conn_t *)((char *)pool.cpool + (i * conn_size));
    pool.conns[i]->fd = -1;
    pool.conns[i]->in_fd = -1;
    pool.conns[i]->out_fd = -1;
  }

  /*** Freecs ***/
  bitmap_size = (MAX_CONNS + 63) / 64;
  pool.freecs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freecs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freecs[i] = UINT64_MAX;

  return 0;
}

static inline int MP_use_blks(size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t max_start = pool.nblocks - nblocks;
  size_t full_chunks = (nblocks / 64) * 64;

  for (size_t i = 0, c = 0; i <= max_start; i++, c++) {
    bool free = true;

    for (size_t j = 0; j < full_chunks; j += 64) {
      size_t word_index = (i + j) / 64;
      if (pool.freebs[word_index] != UINT64_MAX) {
        free = false;
        i += 63;
        break;
      }
    }

    for (size_t j = full_chunks; j < nblocks; j++) {
      size_t bit_index = i + j;
      size_t word_index = bit_index / 64;
      size_t bit_in_word = bit_index % 64;

      if (!BIT_IS_FREE(pool.freebs[word_index], bit_in_word)) {
        free = false;
        i += j;
        break;
      }
    }

    if (free) {
      for (size_t j = 0; j < full_chunks; j += 64) {
        size_t word_index = (i + j) / 64;
        pool.freebs[word_index] = 0;
      }

      for (size_t j = full_chunks; j < nblocks; j++) {
        size_t bit_index = i + j;
        size_t word_index = bit_index / 64;
        size_t bit_in_word = bit_index % 64;

        MARK_BIT_USED(pool.freebs[word_index], bit_in_word);
      }

      return i;
    }
  }

  return -1;
}

static inline int MP_free_blks(size_t bindex, size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t full_chunks = (nblocks / 64) * 64;
  for (size_t i = 0; i < full_chunks; i += 64) {
    size_t word_index = (bindex + i) / 64;
    pool.freebs[word_index] = UINT64_MAX;
  }

  for (size_t i = full_chunks; i < nblocks; i++) {
    size_t bit_index = bindex + i;
    size_t word_index = bit_index / 64;
    size_t bit_in_word = bit_index % 64;

    MARK_BIT_FREE(pool.freebs[word_index], bit_in_word);
  }

  memset(pool.blocks[bindex], 0, nblocks * MP_BLOCK);
  return 0;
}

static inline conn_t *MP_use(size_t nblocks, int fd, bool once) {
  if (fd <= 0)
    return NULL;
  if (once)
    return MP_use_once(nblocks, fd);

  int cindex = find_freec();
  if (cindex < 0) {
    LOG("Err: cindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  conn_t *conn = pool.conns[cindex];

  int ios_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (ios_bindex < 0) {
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }

  struct iovec *ios = pool.blocks[ios_bindex];
  conn->ios = ios;

  int rec_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (rec_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct iovec *rec = pool.blocks[rec_bindex];
  conn->rec = rec;

  int msg_bindex = MP_use_blks(MSG_NBLOCKS);
  if (msg_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct msghdr *msg = pool.blocks[msg_bindex];
  conn->msg = msg;

  if (nblocks > 0) {
    int bindex = MP_use_blks(nblocks);
    if (bindex < 0) {
      MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
      MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
      MP_free_blks(msg_bindex, IOVEC_NBLOCKS);
      MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
      LOG("Err: bindex < 0; will use MP_use_once\n");
      return MP_use_once(nblocks, fd);
    }

    size_t iov_index = conn->nios++;
    struct iovec *iov = &conn->ios[iov_index];
    struct iovec *rec = &conn->rec[iov_index];
    iov->iov_base = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
  }

  conn->msg->msg_iov = conn->ios;
  conn->msg->msg_iovlen = conn->nios;
  conn->cindex = cindex;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;
  return conn;
}

static inline void MP_shed(conn_t *conn, size_t iov_index, size_t nios) {
  struct iovec *iov, *rec;
  size_t bindex, nblocks, index;

  for (size_t i = 0; i < nios; i++) {
    index = iov_index + i;
    iov = &conn->ios[index];
    rec = &conn->rec[index];
    if (!rec || !rec->iov_base)
      continue;
    if (!IN_POOL(rec->iov_base)) {
      munmap(rec->iov_base, rec->iov_len / pool.pagesize);
    } else {
      bindex = ptr_diff((uintptr_t)rec->iov_base, (uintptr_t)pool.bpool) / MP_BLOCK;
      nblocks = rec->iov_len / MP_BLOCK;
      MP_free_blks(bindex, nblocks);
    }
    memset(iov, 0, sizeof(struct iovec));
    memset(rec, 0, sizeof(struct iovec));
    conn->nios--;
  }
}

static inline int MP_expand(conn_t *conn, size_t nblocks, bool once) {
  void *bptr;
  int iov_index, bindex;
  struct iovec *iov, *rec;

  iov_index = conn->nios++;
  iov = &conn->ios[iov_index];
  rec = &conn->rec[iov_index];

  if (nblocks == 0)
    return iov_index;

  if (once) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_base = bptr;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
    return iov_index;
  }

  bindex = MP_use_blks(nblocks);
  if (bindex < 0) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_len = iov->iov_len;
  } else {
    bptr = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_len = iov->iov_len;
  }

  iov->iov_base = bptr;
  rec->iov_base = iov->iov_base;
  return iov_index;
}

static inline int MP_free(conn_t *conn) {
  if (!conn)
    return -1;
  size_t bindex, nblocks;
  uint64_t *word;

  MP_shed(conn, 0, conn->nios);
  if (conn->flags & CF_IN_HEAP) {
    if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
      close(conn->fd);
    free(conn);
    return 0;
  }

  word = &pool.freecs[conn->cindex / 64];
  if (conn->cindex > MAX_CONNS)
    return -1;
  else if (BIT_IS_FREE(*word, conn->cindex))
    return 0;

  bindex = ptr_diff((uintptr_t)conn->ios, (uintptr_t)pool.bpool) / MP_BLOCK;
  nblocks = IOVEC_NBLOCKS;
  MP_free_blks(bindex, nblocks);

  bindex = ptr_diff((uintptr_t)conn->rec, (uintptr_t)pool.bpool) / MP_BLOCK;
  MP_free_blks(bindex, nblocks);

  if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
    close(conn->fd);

  MARK_BIT_FREE(*word, conn->cindex);
  memset(conn, 0, sizeof(conn_t));
  conn->fd = -1;
  conn->in_fd = -1;
  conn->out_fd = -1;
  return 0;
}

static inline void MP_clear(conn_t *conn) {
  conn_t *recv_conn = conn->recv_conn;
  conn_t *send_conn = conn->send_conn;
  if (recv_conn)
    MP_free(recv_conn);
  if (send_conn)
    MP_free(send_conn);
}

static inline void MP_exit(MPool *pool) {
  munmap(pool->bpool, pool->npages);
  free(pool->cpool);
  free(pool->blocks);
  free(pool->conns);
  free(pool->freebs);
  free(pool->freecs);
}

static inline void MP_timeout() {
  conn_t *conn;
  int16_t res;
  uint64_t now;
  size_t windex = 0;
  uint64_t *word = &pool.freecs[0];
  for (size_t i = 0; i < MAX_CONNS; i++) {
    if ((i / 64) < windex)
      word = &pool.freecs[++windex];

    if (*word == UINTMAX_MAX) {
      i = (i / 64) * 64 + 64;
      continue;
    }

    conn = pool.conns[i];
    if (!conn || conn->fd == -1)
      continue;

    res = pollevs(conn->fd);

    now = get_time();
    if (res & POLLERR) {
      MP_clear(conn);
      continue;
    }
    if (res & POLLIN) {
      if (pool.rtimeout > 0 && (now - conn->last_read) >= pool.rtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (res & POLLOUT) {
      if (pool.wtimeout > 0 && (now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (!(res & POLLIN || res & POLLOUT)) {
      if ((pool.rtimeout > 0 && now - conn->last_read) >= pool.rtimeout
          || (pool.wtimeout > 0 && now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
  }
}

/*
 * Calculate the length of a status string
 */
static inline size_t status_len(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return 8;
  case STATUSSWITCHINGPROTOCOLS:
    return 19;
  case STATUSPROCESSING:
    return 10;
  case STATUSEARLYHINTS:
    return 11;
  case STATUSOK:
    return 2;
  case STATUSCREATED:
    return 7;
  case STATUSACCEPTED:
    return 8;
  case STATUSNONAUTHORITATIVE:
    return 29;
  case STATUSNOCONTENT:
    return 10;
  case STATUSRESETCONTENT:
    return 13;
  case STATUSPARTIALCONTENT:
    return 15;
  case STATUSMULTISTATUS:
    return 12;
  case STATUSALREADYREPORTED:
    return 16;
  case STATUSIMUSED:
    return 7;
  case STATUSMULTIPLECHOICES:
    return 16;
  case STATUSMOVEDPERMANENTLY:
    return 17;
  case STATUSFOUND:
    return 5;
  case STATUSSEEOTHER:
    return 9;
  case STATUSNOTMODIFIED:
    return 12;
  case STATUSUSEPROXY:
    return 9;
  case STATUSTEMPORARYREDIRECT:
    return 18;
  case STATUSPERMANENTREDIRECT:
    return 18;
  case STATUSBADREQUEST:
    return 11;
  case STATUSUNAUTHORIZED:
    return 12;
  case STATUSPAYMENTREQUIRED:
    return 16;
  case STATUSFORBIDDEN:
    return 9;
  case STATUSNOTFOUND:
    return 9;
  case STATUSMETHODNOTALLOWED:
    return 18;
  case STATUSNOTACCEPTABLE:
    return 14;
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return 29;
  case STATUSREQUESTTIMEOUT:
    return 15;
  case STATUSCONFLICT:
    return 8;
  case STATUSGONE:
    return 4;
  case STATUSLENGTHREQUIRED:
    return 15;
  case STATUSPRECONDITIONFAILED:
    return 19;
  case CONTENTTOOLARGE:
    return 17;
  case STATUSURITOOLONG:
    return 12;
  case STATUSUNSUPPORTEDMEDIATYPE:
    return 22;
  case STATUSRANGENOTSATISFIABLE:
    return 21;
  case STATUSEXPECTATIONFAILED:
    return 18;
  case STATUSMISDIRECTEDREQUEST:
    return 19;
  case STATUSUNPROCESSABLECONTENT:
    return 21;
  case STATUSLOCKED:
    return 6;
  case STATUSFAILEDDEPENDENCY:
    return 17;
  case STATUSTOOEARLY:
    return 9;
  case STATUSUPGRADEREQUIRED:
    return 16;
  case STATUSPRECONDITIONREQUIRED:
    return 21;
  case STATUSTOOMANYREQUESTS:
    return 17;
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return 31;
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return 29;
  case STATUSInternalServerError:
    return 21;
  case STATUSNOTIMPLEMENTED:
    return 15;
  case STATUSBADGATEWAY:
    return 11;
  case STATUSSERVICEUNAVAILABLE:
    return 19;
  case STATUSGATEWAYTIMEOUT:
    return 15;
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return 26;
  case STATUSVARIANTALSONEGOTIATES:
    return 23;
  case STATUSINSUFFICIENTSTORAGE:
    return 20;
  case STATUSLOOPDETECTED:
    return 13;
  case STATUSNOTEXTENDED:
    return 12;
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return 31;
  default:
    return 0;
  }
}

/*
 * Return the status code string as string literal
 */
static inline char *status_str(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return "Continue";
  case STATUSSWITCHINGPROTOCOLS:
    return "Switching Protocols";
  case STATUSPROCESSING:
    return "Processing";
  case STATUSEARLYHINTS:
    return "Early Hints";
  case STATUSOK:
    return "OK";
  case STATUSCREATED:
    return "Created";
  case STATUSACCEPTED:
    return "Accepted";
  case STATUSNONAUTHORITATIVE:
    return "Non-Authoritative Information";
  case STATUSNOCONTENT:
    return "No Content";
  case STATUSRESETCONTENT:
    return "Reset Content";
  case STATUSPARTIALCONTENT:
    return "Partial Content";
  case STATUSMULTISTATUS:
    return "Multi-Status";
  case STATUSALREADYREPORTED:
    return "Already Reported";
  case STATUSIMUSED:
    return "Im Used";
  case STATUSMULTIPLECHOICES:
    return "Multiple Choices";
  case STATUSMOVEDPERMANENTLY:
    return "Moved Permanently";
  case STATUSFOUND:
    return "Found";
  case STATUSSEEOTHER:
    return "See Other";
  case STATUSNOTMODIFIED:
    return "Not Modified";
  case STATUSUSEPROXY:
    return "Use Proxy";
  case STATUSTEMPORARYREDIRECT:
    return "Temporary Redirect";
  case STATUSPERMANENTREDIRECT:
    return "Permanent Redirect";
  case STATUSBADREQUEST:
    return "Bad Request";
  case STATUSUNAUTHORIZED:
    return "Unauthorized";
  case STATUSPAYMENTREQUIRED:
    return "Payment Required";
  case STATUSFORBIDDEN:
    return "Forbidden";
  case STATUSNOTFOUND:
    return "Not Found";
  case STATUSMETHODNOTALLOWED:
    return "Method Not Allowed";
  case STATUSNOTACCEPTABLE:
    return "Not Acceptable";
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return "Proxy Authentication Required";
  case STATUSREQUESTTIMEOUT:
    return "Request Timeout";
  case STATUSCONFLICT:
    return "Conflict";
  case STATUSGONE:
    return "Gone";
  case STATUSLENGTHREQUIRED:
    return "Length Required";
  case STATUSPRECONDITIONFAILED:
    return "Precondition Failed";
  case CONTENTTOOLARGE:
    return "Content Too Large";
  case STATUSURITOOLONG:
    return "URI Too Long";
  case STATUSUNSUPPORTEDMEDIATYPE:
    return "Unsupported Media Type";
  case STATUSRANGENOTSATISFIABLE:
    return "Range Not Satisfiable";
  case STATUSEXPECTATIONFAILED:
    return "Expectation Failed";
  case STATUSMISDIRECTEDREQUEST:
    return "Misdirected Request";
  case STATUSUNPROCESSABLECONTENT:
    return "Unprocessable Content";
  case STATUSLOCKED:
    return "Locked";
  case STATUSFAILEDDEPENDENCY:
    return "Failed Dependency";
  case STATUSTOOEARLY:
    return "Too Early";
  case STATUSUPGRADEREQUIRED:
    return "Upgrade Required";
  case STATUSPRECONDITIONREQUIRED:
    return "Precondition Required";
  case STATUSTOOMANYREQUESTS:
    return "Too Many Requests";
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return "Request Header Fields Too Large";
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return "Unavailable For Legal Reasons";
  case STATUSInternalServerError:
    return "Internal Server Error";
  case STATUSNOTIMPLEMENTED:
    return "Not Implemented";
  case STATUSBADGATEWAY:
    return "Bad Gateway";
  case STATUSSERVICEUNAVAILABLE:
    return "Service Unavailable";
  case STATUSGATEWAYTIMEOUT:
    return "Gateway Timeout";
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return "HTTP Version Not Supported";
  case STATUSVARIANTALSONEGOTIATES:
    return "Variant Also Negotiates";
  case STATUSINSUFFICIENTSTORAGE:
    return "Insufficient Storage";
  case STATUSLOOPDETECTED:
    return "Loop Detected";
  case STATUSNOTEXTENDED:
    return "Not Extended";
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return "Network Authentication Required";
  default:
    return 0;
  }
}

/*
 * Return true if routes match
 */
static inline bool route_equ(Route *route, Request *req) {
  return route->method == req->method && strncmp(route->path, req->path, strlen(route->path)) == 0;
}

/*
 * Return the matching route index on success. -1 on failure
 */
static inline int match_route(Server *serv, Request *req) {
  for (size_t i = 0; i < serv->_nroutes; i++) {
    Route route = serv->routes[i];
    if (!req->path || !route.path)
      continue;
    if (route_equ(&route, req))
      return i;
    else if (req->method == HEAD && route.method == GET && strcmp(route.path, req->path) == 0)
      return i;
  }
  return -1;
}

/*
 * Return true if the response should contain the Content-Length header
 */
static inline bool should_have_content_length(Request *req, ResWriter *res) {
  return (req->method != CONNECT              // CONNECT request
          && res->status != STATUSNOCONTENT   // 204 response
          && res->status != STATUSNOTMODIFIED // 304 response
          && res->status >= 200);             // 1xx response
}

/*
 * Format http response from the ResWriter.
 * Return response size on success, 0 on failure.
 */
static inline size_t fmt_res(Request *req, ResWriter *res, char *buffer, size_t buffer_size) {
  if (!res || !buffer || buffer_size == 0)
    return 0;

  size_t res_len, total = 0;
  char *dst = buffer;
  size_t maxlen = buffer_size;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t body_length = res->len;

  res_len = snprintf(dst, maxlen, "HTTP/1.1 %d %s", (int)res->status, status_str(res->status));
  total += res_len;
  dst += res_len;
  maxlen -= res_len;

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    res_len = snprintf(dst, maxlen, "\r\n%s: %s", header->key, header->value);
    total += res_len;
    dst += res_len;
    maxlen -= res_len;
  }

  if (have_content_length) {
    res_len = snprintf(dst, maxlen, "\r\nContent-Length: %lu", body_length);
    total += res_len, dst += res_len, maxlen -= res_len;
  }

  memcpy(dst, "\r\n\r\n", 4);
  total += 4, dst += 4, maxlen -= 4;

  return total;
}

static inline size_t res_len(Request *req, ResWriter *res) {
  if (!req || !res)
    return 0;

  if (!res->status)
    res->status = STATUSOK;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t result = 0;
  result += STRLEN("HTTP/1.1 ");     // HTTP version
  result += 4;                       // Status code + space
  result += status_len(res->status); // Status name

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    result += 2;                       // "\r\n"
    result += strlen(header->key) + 2; // Header key + ':' + space
    result += strlen(header->value);   // header value
  }

  if (have_content_length) {
    result += 2;                          // "\r\n"
    result += STRLEN("Content-Length: "); // Header key
    result += countd(res->len);           // Header value
  }

  result += 4; // "\r\n\r\n"

  return result;
}

static inline int send_empty_res(Status status) {
  size_t res_len = STRLEN("HTTP/1.1 ")        // HTTP version
                   + countd((uint64_t)status) // status code
                   + 1                        // space
                   + (int)status_len(status)  // status string
                   + 4;                       // \r\n\r\n

  conn_t *conn = current_send;
  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, res_len);
  if (snprintf((char *)rec->iov_base, res_len + 1, "HTTP/1.1 %d %s\r\n\r\n", (int)status, status_str(status))
      != (int)res_len)
    return -1;

  return usendmsg(conn, 0, 1);
}

static inline ssize_t read_socket(int sockfd, size_t len) {
  if (len == 0 || sockfd <= 0)
    return 0;
  char buff[1024 * 8];
  return read(sockfd, buff, 1024 * 8);
}

static inline int read_method(Method *method, void *src) {
  if (memcmp(src, "GET", 3) == 0)
    *method = GET;
  else if (memcmp(src, "POST", 4) == 0)
    *method = POST;
  else if (memcmp(src, "HEAD", 4) == 0)
    *method = HEAD;
  else if (memcmp(src, "PUT", 3) == 0)
    *method = PUT;
  else if (memcmp(src, "DELETE", 6) == 0)
    *method = DELETE;
  else if (memcmp(src, "CONNECT", 7) == 0)
    *method = CONNECT;
  else if (memcmp(src, "OPTIONS", 7) == 0)
    *method = OPTIONS;
  else if (memcmp(src, "TRACE", 5) == 0)
    *method = TRACE;
  else if (memcmp(src, "PATCH", 5) == 0)
    *method = PATCH;
  else
    return -1;

  return 0;
}

static inline int sendmsg_res(Request *req, ResWriter *res) {
  conn_t *conn;
  size_t head_size, res_size;
  struct iovec *iov;

  conn = current_send;
  iov = &conn->ios[0];
  head_size = res_len(req, res);
  if (head_size == 0)
    return -1;

  conn->data_left += head_size;
  res_size = fmt_res(req, res, iov->iov_base, (head_size + 1));
  if (res_size != head_size)
    return -1;
  iov->iov_len = res_size;

  return usendmsg(conn, 0, conn->nios);
}

static inline int read_req(Request *req, char *req_buffer) {
  if (!req_buffer)
    return -1;
  /*** Method ***/
  char *sep = strchr(req_buffer, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }
  *sep = '\0';
  if (read_method(&req->method, req_buffer) < 0)
    return -1;

  /*** Path ***/
  char *fullpath = sep + 1;
  sep = strchr(fullpath, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }

  *sep = '\0';
  req->path = fullpath;
  /*** Params ***/
  char *paramStart = strchr(fullpath, '?');
  if (paramStart) {
    *paramStart++ = '\0';
    int params_count = 0;
    params_count = HK_parse_params(paramStart, req->params, MAX_URL_PARAMETERS);
    if (params_count > 0)
      req->params_count = params_count;
    else
      req->params_count = 0;
  } else {
    req->params = NULL;
    req->params_count = 0;
  }

  /*** Headers ***/
  char *headStart = strstr(sep + 1, "\r\n");
  char *headEnd = strstr(sep + 1, "\r\n\r\n");
  if (!headStart) {
    LOG("read_req: !headStart\n");
    return -1;
  };

  memset(headStart, 0, 2);
  headStart += 2;
  memset(headEnd, 0, 4);
  headEnd += 4;

  int headers_count = HK_parse_headers(headStart, req->headers, MAX_REQ_HEADERS);
  if (headers_count <= 0)
    return -1;
  req->headers_count = headers_count;

  /*** Host ***/
  int index = HK_get_header(req, "Host");
  if (index < 0)
    return -1;
  char *host = req->headers[index].value;
  req->hostname = host;

  /*** Port ***/
  char *colon = strchr(host, ':');
  if (colon) {
    *colon++ = '\0';
    req->port = atoi(colon);
  } else {
    req->port = PORT;
  }
  return 0;
}
static inline int process_req(Server *serv, conn_t *conn) {
  if (!conn || conn->fd == -1)
    return -1;

  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;
  if (read_req(&req, conn->ios[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    LOG("Err: route_index == -1\n");
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;
  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  sendmsg_res(&req, &res);

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int new_conn(int connfd) {
  if (connfd <= 0)
    return -1;

  current_recv = MP_use(KB * 2, connfd, false);
  current_send = MP_use(KB * 2, connfd, false);

  current_recv->recv_conn = current_recv;
  current_recv->send_conn = current_send;

  current_send->send_conn = current_send;
  current_send->recv_conn = current_recv;

  conn_t *conn = current_recv;
  if (ufrecvmsg(conn, 0, 1) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

static inline int resubmit_sendmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return usendmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int resubmir_recvmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    // FIXME the len should be increased
    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return urecvmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int handle_sendmsg_complete(conn_t *conn) {
  struct iovec *iov, *rec;

  MP_shed(conn, 1, conn->nios - 1);
  iov = &conn->ios[0];
  rec = &conn->rec[0];
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;

  return ufrecvmsg(conn->recv_conn, 0, 1);
}

static inline int handle_sendmsg(conn_t *conn, int res, bool zc) {
  if (!conn || conn->fd == -1)
    return -1;

  conn->data_left -= res;
  if (conn->data_left > 0)
    return resubmit_sendmsg(conn, res);

  if (zc)
    return 0;

  return handle_sendmsg_complete(conn);
}

static inline int handle_insplice(conn_t *conn) {
  conn->op = OUTSPLICE;
  return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
}
static inline int handle_outsplice(conn_t *conn, int res) {
  conn->data_left -= res;
  if (conn->data_left > 0) {
    conn->op = INSPLICE;
    return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
  }

  conn_t *recv_conn = conn->recv_conn;
  struct iovec *iov = &recv_conn->ios[0];
  memset(iov->iov_base, 0, iov->iov_len);
  if (urecv(recv_conn, iov->iov_base, iov->iov_len, MSG_PEEK) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

/*
static inline int handle_recv(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  void *bptr = conn->ios[0].iov_base;
  void *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  void *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  return process_req(serv, conn);
}
*/
static inline int find_route(Server *serv, char *bptr) {
  Request req = {0};
  if (read_method(&req.method, bptr) < 0) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  };
  char *space = strchr(bptr, ' ');
  req.path = (space + 1);
  space = strchr(req.path, ' ');
  *space = '\0';
  int route_index = match_route(serv, &req);
  *space = ' ';
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }
  return route_index;
}

static inline int run_handler(Server *serv, conn_t *conn, bool uses_body) {
  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;

  if (read_req(&req, conn->rec[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  if (uses_body) {
    int h_index = HK_get_header(&req, "Content-Length");
    long body_size = atol(req.headers[h_index].value);
    if (body_size >= 0) {
      req.body.ptr = conn->rec[1].iov_base;
      req.body.size = body_size;
    } else {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    }
  }

  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  if (sendmsg_res(&req, &res) < 0)
    return -1;

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int handle_frecvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  char *bptr = (char *)conn->ios[0].iov_base;
  char *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  char *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  size_t head_size = (headEnd + 4) - bptr;
  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  int route_index = find_route(serv, bptr);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  bool uses_body = serv->routes[route_index].uses_body;
  long body_size = get_content_length(headstart + 2, headEnd + 4);
  if (body_size == -1) {
    if (uses_body) {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    } else {
      body_size = 0;
    }
  }

  conn->head_size = head_size;
  if (!uses_body) {
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  if (res == (int)(head_size + body_size)) {
    size_t iov_index = MP_expand(conn, round_to_blocks(body_size), false);
    memcpy(conn->rec[iov_index].iov_base, headEnd + 4, body_size);
    conn->ios[iov_index].iov_len = body_size;
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  conn->data_left = body_size - (res - head_size);
  bool once = ((size_t)body_size > (size_t)((pool.nblocks * MP_BLOCK) / 10));
  size_t iov_index = MP_expand(conn, round_to_blocks(body_size), once);
  memcpy(conn->rec[iov_index].iov_base, headEnd + 4, (res - head_size));
  conn->ios[iov_index].iov_base += (res - head_size);

  return urecvmsg(conn, iov_index, 1);
}

static inline int handle_recvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  if (conn->data_left > 0) {
    conn->data_left -= res;
    if (conn->data_left == 0) {
      conn->flags &= CF_HANDLER_READY;
      return run_handler(serv, conn, true);
    }

    conn->flags &= ~CF_HANDLER_READY;
    conn->ios[1].iov_base += res;
    return urecvmsg(conn, 1, 1);
  }

  conn->flags &= CF_HANDLER_READY;
  return run_handler(serv, conn, true);
}

static inline int serv_init(Server *serv) {
#if DEBUG
  logfd = log_init("log.txt");
  if (!logfd) {
    printf("log_init failed");
    return -1;
  }
#endif
  serv->_nroutes = get_nroutes(serv->routes);

  int pipefd[2];
  if (pipe(pipefd) < 0)
    return -1;
  pipe_in = pipefd[0];
  pipe_out = pipefd[1];
  nullfd = open("/dev/null", O_WRONLY);
  pipe_sz = fcntl(pipefd[0], F_GETPIPE_SZ);
  if (pipe_sz < 0)
    return -1;

  pool.rtimeout = serv->rtimeout;
  pool.wtimeout = serv->wtimeout;
  if (MP_init(MAX_CONNS * 8) < 0)
    return -1;
  LOG("pool initialized\n");

  if (io_uring_queue_init(MAX_CONNS, &ring, 0) < 0)
    return -1;
  LOG("uring initialized\n");

  int listenfd;
  if ((listenfd = tcp_listen(serv->port)) < 0)
    return -1;
  LOG("socket initialized\n");

  return umaccept(listenfd);
}

static inline int serv_listen(Server *serv) {
  // uint64_t last_check = get_time();
  while (true) {
    // uint64_t now = get_time();
    // if ((now - last_check) >= 200) {
    //   last_check = now;
    //   LOG("CM: CM_check ran\n");
    //   MP_timeout();
    // }

    LOG("SQ ready: %u, CQ ready: %u\n", io_uring_sq_ready(&ring), io_uring_cq_ready(&ring));
    struct io_uring_cqe *cqe;
    if (io_uring_wait_cqe(&ring, &cqe) < 0)
      continue;

    int res = cqe->res;
    LOG("res = %d\n", res);
    conn_t *conn = NULL;
    if (cqe->user_data > 100) {
      conn = (conn_t *)cqe->user_data;
      current_recv = (conn_t *)conn->recv_conn;
      current_send = (conn_t *)conn->send_conn;
    }

    if (res > 0) {
      if (cqe->user_data == ACCEPT) {
        LOG("new conn created\n");
        new_conn(res);
      } else if (conn && conn->fd != -1) {
        LOG("conn[%d]: conn.fd = %d; conn.op = %d\n", conn->cindex, conn->fd, conn->op);
        switch (conn->op) {
        case FRECVMSG:
          if (handle_frecvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case RECVMSG:
          if (handle_recvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case SENDMSG:
        case SENDMSGZC:
          // conn->last_write = get_time();
          bool zc = (conn->op == SENDMSGZC);
          if (handle_sendmsg(conn, res, zc) < 0)
            MP_clear(conn);
          break;
        case INSPLICE:
          if (handle_insplice(conn) < 0)
            MP_clear(conn);
          break;
        case OUTSPLICE:
          if (handle_outsplice(conn, res) < 0)
            MP_clear(conn);
          break;
        }
      }
    } else if (res == 0) {
      if (conn && conn->fd != -1) {
        switch (conn->op) {
        case SENDMSGZC:
          conn->zc_notifs--;
          if (conn->zc_notifs == 0 && handle_sendmsg_complete(conn) < 0)
            MP_clear(conn);
          break;
        case RECV:
          MP_clear(conn);
          break;
        }
      }
    } else {
      if (conn && conn->fd != -1) {
        if (res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR) {
          LOG("conn && conn->fd != -1 && res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR\n");
          MP_clear(conn);
        } else {
          LOG("res == -EAGAIN || res == -EWOULDBLOCK || res == -EINTR\n");
          conn = conn->recv_conn;
          struct iovec *iov = &conn->ios[0];
          memset(iov->iov_base, 0, iov->iov_len);
          if (urecv(conn, iov->iov_base, iov->iov_len, 0) < 0)
            MP_clear(conn);
        }
      }
    }

    LOG("uring operation seen\n");
    io_uring_cqe_seen(&ring, cqe);
  }

  io_uring_queue_exit(&ring);
  MP_exit(&pool);
  return 0;
}

/*** Helper ***/
static inline int _HK_write(void *data, size_t size) {
  size_t nblocks;
  int iov_index;
  conn_t *conn;
  struct iovec *iov;
  bool once;

  conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  nblocks = round_to_blocks(size);
  iov_index = MP_expand(conn, nblocks, once);
  iov = &conn->ios[iov_index];

  memcpy(iov->iov_base, data, size);
  iov->iov_len = size;
  conn->data_left += size;

  return 0;
}
static inline int _HK_write_body(Request *req, size_t offset, size_t size) {
  if (size > req->body.size || offset > req->body.size)
    return -1;

  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  int iov_index = MP_expand(conn, 0, false);
  struct iovec *iov = &conn->ios[iov_index];
  struct iovec *rec = &conn->rec[iov_index];
  rec->iov_base = req->body.ptr + offset;
  rec->iov_len = size;
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;
  conn->data_left += rec->iov_len;
  return 0;
}
/*
static inline int _HK_mem(size_t size, HKMem *mem) {
  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  bool once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  size_t nblocks = round_to_blocks(size);
  int iov_index = MP_expand(conn, nblocks, once);
  struct iovec *iov = &conn->ios[iov_index];
  mem->ptr = iov->iov_base;
  mem->size = iov->iov_len;
  mem->_iov_index = iov_index;
  mem->_flags = (IN_POOL(iov->iov_base)) ? CF_IN_POOL : CF_IN_HEAP;
  return 0;
}

static inline void _HK_send(HKMem *mem, size_t size) {
  conn_t *conn = current_send;
  struct iovec *iov = &conn->ios[mem->_iov_index];
  iov->iov_len = size;
  conn->data_left += size;
}
  */
#endif#define _GNU_SOURCE
#ifndef UTILS_H
#define UTILS_H

#include "hunk.h"
#include <arpa/inet.h>
#include <fcntl.h>
#include <liburing.h>
#include <netdb.h>
#include <signal.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/poll.h>
#include <sys/prctl.h>
#include <sys/socket.h>
#include <sys/sysinfo.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

#define MP_BLOCK  4
#define MAX_CONNS 4096
#define KB        1024
#define NIOS      32

#define IN_POOL(ptr)                 ((void *)ptr >= pool.bpool && (void *)ptr <= (pool.bpool + (pool.npages * pool.pagesize)))
#define ALIGN_TO_PAGESIZE(buff_size) (((buff_size) + (pool.pagesize - 1)) & ~(pool.pagesize - 1))
#define BYTES_TO_BLOCKS(buff_size)   (((buff_size) + (MP_BLOCK - 1)) / MP_BLOCK)
#define CEIL_BLOCKS(nblocks)         ((nblocks + 63) & ~63)
#define CEIL_PAGES(size)             (((size) + ((pool.pagesize) - 1)) & ~((pool.pagesize) - 1))

#define BIT_IS_FREE(word, bit)   (((word) >> (bit)) & 1)
#define MARK_BIT_USED(word, bit) ((word) &= ~(1ULL << (bit)))
#define MARK_BIT_FREE(word, bit) ((word) |= (1ULL << (bit)))
#define FIND_FREE_BIT(word)      ((uint64_t)(word) & -(uint64_t)(word))
#define STRLEN(s)                (sizeof(s) - 1)

#define IOVEC_NBLOCKS (BYTES_TO_BLOCKS(NIOS * sizeof(struct iovec)))
#define MSG_NBLOCKS   (BYTES_TO_BLOCKS(sizeof(struct msghdr)))
#define ZC_RES        KB *KB

#define DEBUG 0
#if DEBUG
#define LOG(...) fprintf(logfd, __VA_ARGS__)
#else
#define LOG(...) ((void)0)
#endif

typedef enum UOP {
  WRITEV = IORING_OP_WRITEV,
  SENDMSG = IORING_OP_SENDMSG,
  RECVMSG = IORING_OP_RECVMSG,
  ACCEPT = IORING_OP_ACCEPT,
  SEND = IORING_OP_SEND,
  RECV = IORING_OP_RECV,
  SENDZC = IORING_OP_SEND_ZC,
  SENDMSGZC = IORING_OP_SENDMSG_ZC,
  PEEK = 50,
  FRECVMSG,
  INSPLICE,
  OUTSPLICE
} UOP;

typedef enum CFS {
  CF_IN_POOL = (1 << 0),       // Connection is in the pool
  CF_IN_HEAP = (1 << 1),       // Connection is in the heap
  CF_SKIP_SOCK = (1 << 2),     // Don't close the socket
  CF_USE_ONCE = (1 << 3),      // Destroy after using
  CF_HANDLER_READY = (1 << 4), // Ready to call the handler
} CFS;

typedef struct conn_t {
  // Socket file descriptor
  int fd;

  // Amount of data left in the current operation
  uint64_t data_left;

  // The index of the connection struct
  uint32_t cindex;

  // The last time the connection was readable
  uint64_t last_read;

  // The last time the connection was writeable
  uint64_t last_write;

  // The operation currently being processed
  uint8_t op;

  // Connection flags
  int flags;

  // Splice fd_in
  int in_fd;

  // Splice fd_out
  int out_fd;

  void *recv_conn;
  void *send_conn;

  struct iovec *ios;
  struct iovec *rec;
  uint16_t nios;

  struct msghdr *msg;
  uint16_t zc_notifs;

  uint16_t head_size;
} conn_t;

typedef struct MPool {
  // The allocated pool of blocks
  void *bpool;

  // The allocated pool of connections
  conn_t *cpool;

  // The size of the pool in pages
  uint32_t npages;

  // The size of the pool in blocks
  uint32_t nblocks;

  // The locations of each page in the pool
  void **blocks;

  // The availability of each block
  uint64_t *freebs;

  // The locations of each conn in the pool
  conn_t **conns;

  // The availability of each conn
  uint64_t *freecs;

  // Clean up callback function
  void (*callback)(conn_t *conn);

  // The page size used
  uint32_t pagesize;

  // Socket read timeout
  uint32_t rtimeout;

  // Socket write timeout
  uint32_t wtimeout;
} MPool;

extern int pipe_sz;
extern int pipe_in, pipe_out, nullfd;
extern FILE *logfd;
extern struct io_uring ring;
extern MPool pool;
extern conn_t *current_recv;
extern conn_t *current_send;

/*
 * Prepare and submit a recv uring op
 */
static inline int urecv(conn_t *conn, void *buffer, size_t buff_size, int flags) {
  if (!conn || conn->fd == -1)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (flags == MSG_PEEK) ? PEEK : RECV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;

  io_uring_prep_recv(sqe, conn->fd, buffer, buff_size, flags);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a multi-shot accept uring op
 */
static inline int umaccept(int listenfd) {
  if (listenfd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = ACCEPT;
  io_uring_prep_multishot_accept(sqe, listenfd, NULL, NULL, SOCK_NONBLOCK);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a splice uring op
 */
static inline int usplice(conn_t *conn, int fd_in, int64_t off_in, int fd_out, int64_t off_out, size_t len) {
  if (!len || !conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = (__u64)conn;
  io_uring_prep_splice(sqe, fd_in, off_in, fd_out, off_out, len, 0);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a writev uring op
 */
static inline int uwritev(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = WRITEV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  io_uring_prep_writev(sqe, conn->fd, &conn->ios[iov_index], nios, -1);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a send uring op
 */
static inline int usend(conn_t *conn, char *res_buff, size_t buff_size, bool zc) {
  if (!conn || conn->fd <= 0 || buff_size == 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (zc) ? SENDZC : SEND;
  conn->data_left = buff_size;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  if (zc)
    io_uring_prep_send_zc(sqe, conn->fd, res_buff, buff_size, 0, 0);
  else
    io_uring_prep_send(sqe, conn->fd, res_buff, buff_size, 0);
  return io_uring_submit(&ring);
}

static inline int ufrecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = FRECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;

  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, rec->iov_len);
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int urecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = RECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int usendmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  bool zc = (conn->data_left > ZC_RES) ? true : false;
  conn->op = (zc) ? SENDMSGZC : SENDMSG;

  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  if (zc) {
    io_uring_prep_sendmsg_zc(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
    conn->zc_notifs++;
  } else {
    io_uring_prep_sendmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  }
  return io_uring_submit(&ring);
}

/*
 * Create and initialize a server socket
 */
static inline int tcp_listen(uint16_t port) {
  int enable;
  int listenfd;
  if ((listenfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    return -1;

  int flags = fcntl(listenfd, F_GETFL, 0);
  fcntl(listenfd, F_SETFL, flags | O_NONBLOCK);
  struct sockaddr_in servaddr;
  memset(&servaddr, 0, sizeof(servaddr));
  servaddr.sin_family = AF_INET;
  servaddr.sin_addr.s_addr = INADDR_ANY;
  servaddr.sin_port = htons(port);

  enable = 1;
  if (setsockopt(listenfd, SOL_SOCKET, SO_REUSEPORT, &enable, sizeof(enable)) < 0)
    return -1;

  if (bind(listenfd, (struct sockaddr *)&servaddr, sizeof(servaddr)) < 0)
    return -1;

  if (listen(listenfd, SOMAXCONN) < 0)
    return -1;

  return listenfd;
}

/*
 * Calculate the difference between two pointers
 */
static inline uintptr_t ptr_diff(uintptr_t p1, uintptr_t p2) { return (uintptr_t)(p1 > p2) ? (p1 - p2) : (p2 - p1); }

static inline size_t get_nroutes(Route *routes) {
  Route *route;
  for (size_t i = 0;; i++) {
    route = &routes[i];
    if (!route->path && !route->handler && !route->method)
      return i;
  }
}

static inline long get_content_length(char *src, char *end) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return -1;
    key = line;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, "Content-Length") != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;

    *line_end = '\0';
    long res = atol(value);
    *line_end = '\r';

    return res;
  }
  return -1;
}

static inline bool have_header(char *src, char *end, const char *header_key, const char *header_value) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    key = line;
    while (*key == ' ')
      key++;
    while (*header_key == ' ')
      header_key++;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return false;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, header_key) != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;
    while (*header_value == ' ')
      header_value++;

    *line_end = '\0';
    bool res = (strcasecmp(value, header_value) == 0);
    *line_end = '\r';

    return res;
  }

  return false;
}

static inline const char *method_str(Method method) {
  switch (method) {
  case GET:
    return "GET";
    break;
  case HEAD:
    return "HEAD";
    break;
  case POST:
    return "POST";
    break;
  case PUT:
    return "PUT";
    break;
  case DELETE:
    return "DELETE";
    break;
  case CONNECT:
    return "CONNECT";
    break;
  case OPTIONS:
    return "OPTIONS";
    break;
  case TRACE:
    return "TRACE";
    break;
  case PATCH:
    return "PATCH";
    break;
  default:
    return NULL;
  }
}

static inline uint8_t method_len(Method method) {
  switch (method) {
  case GET:
    return 3;
    break;
  case HEAD:
    return 4;
    break;
  case POST:
    return 4;
    break;
  case PUT:
    return 3;
    break;
  case DELETE:
    return 6;
    break;
  case CONNECT:
    return 7;
    break;
  case OPTIONS:
    return 7;
    break;
  case TRACE:
    return 5;
    break;
  case PATCH:
    return 5;
    break;
  default:
    return 0;
  }
}

static inline size_t round_to_blocks(size_t size) {
  size_t nblocks = BYTES_TO_BLOCKS(size);
  nblocks = CEIL_BLOCKS(nblocks);
  return nblocks;
}

/*
 * Count the digits in unsigned 64-bit int
 */
static inline int countd(uint64_t num) {
  if (num < 10ULL)
    return 1;
  if (num < 100ULL)
    return 2;
  if (num < 1000ULL)
    return 3;
  if (num < 10000ULL)
    return 4;
  if (num < 100000ULL)
    return 5;
  if (num < 1000000ULL)
    return 6;
  if (num < 10000000ULL)
    return 7;
  if (num < 100000000ULL)
    return 8;
  if (num < 1000000000ULL)
    return 9;
  if (num < 10000000000ULL)
    return 10;
  if (num < 100000000000ULL)
    return 11;
  if (num < 1000000000000ULL)
    return 12;
  if (num < 10000000000000ULL)
    return 13;
  if (num < 100000000000000ULL)
    return 14;
  if (num < 1000000000000000ULL)
    return 15;
  if (num < 10000000000000000ULL)
    return 16;
  if (num < 100000000000000000ULL)
    return 17;
  if (num < 1000000000000000000ULL)
    return 18;
  if (num < 10000000000000000000ULL)
    return 19;
  return 20;
}

/*
 * Get the time elabsed in ms
 */
static inline uint64_t get_time() {
  struct timespec ts;
  clock_gettime(CLOCK_MONOTONIC, &ts);
  return (uint64_t)(ts.tv_sec) * 1000 + (ts.tv_nsec / 1000000);
}

static inline FILE *log_init(const char *path) {
  FILE *res = fopen(path, "a+");
  setvbuf(res, NULL, _IONBF, 0);
  return res;
}

static inline int16_t pollevs(int connfd) {
  struct pollfd pfd;
  pfd.fd = connfd;
  pfd.events = POLLIN | POLLOUT | POLLERR;
  int res = poll(&pfd, 1, 0);
  if (res < 0)
    return POLLERR;
  return pfd.revents;
}

// FIXME This needs to be updated
static inline conn_t *MP_use_once(size_t nblocks, int fd) {

  void *mem = malloc(sizeof(conn_t) + 8 + (IOVEC_NBLOCKS * MP_BLOCK));
  struct conn_t *conn = (conn_t *)mem;
  memset(conn, 0, sizeof(conn_t));
  conn->ios = mem + sizeof(conn_t) + 8;

  if (nblocks > 0) {
    struct iovec *iov = &conn->ios[conn->nios++];
    mem = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (mem == MAP_FAILED)
      return NULL;
    iov->iov_base = mem;
    iov->iov_len = ALIGN_TO_PAGESIZE(nblocks * MP_BLOCK);
  }

  conn->flags |= CF_IN_HEAP;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;

  return conn;
}

static inline int find_freec() {
  uint64_t *word;
  size_t map_size = (sizeof(uint64_t) * 8);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    word = &pool.freecs[i / map_size];

    if (*word == 0) { // All used
      i += (map_size - 1);
      continue;
    }

    i += __builtin_ctzll(*word);
    MARK_BIT_USED(*word, i);
    return i;
  }

  return -1;
}

static inline int MP_init(size_t npages) {
  if (!npages)
    return -1;

  /*** Setup ***/
  pool.npages = npages;
  pool.pagesize = sysconf(_SC_PAGESIZE);

  /*** Pool ***/
  pool.bpool = mmap(NULL, pool.npages * pool.pagesize, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  if (pool.bpool == MAP_FAILED)
    return -1;
  pool.nblocks = (pool.npages * pool.pagesize) / MP_BLOCK;

  /*** Blocks ***/
  pool.blocks = malloc(sizeof(void *) * pool.nblocks);
  if (!pool.blocks)
    return -1;
  for (size_t i = 0; i < pool.nblocks; i++)
    pool.blocks[i] = pool.bpool + (i * MP_BLOCK);

  /*** Freebs ***/
  // if (posix_memalign((void **)&pool.freebs, 64, bitmap_size * sizeof(uint64_t)) < 0)
  size_t bitmap_size = (pool.nblocks + 63) / 64;
  pool.freebs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freebs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freebs[i] = UINT64_MAX;

  /*** Cpool ***/
  pool.cpool = (conn_t *)malloc(sizeof(conn_t) * MAX_CONNS);
  if (!pool.cpool)
    return -1;

  /*** Conns ***/
  pool.conns = (conn_t **)malloc(sizeof(conn_t *) * MAX_CONNS);
  if (!pool.conns)
    return -1;
  size_t conn_size = sizeof(conn_t);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    pool.conns[i] = (conn_t *)((char *)pool.cpool + (i * conn_size));
    pool.conns[i]->fd = -1;
    pool.conns[i]->in_fd = -1;
    pool.conns[i]->out_fd = -1;
  }

  /*** Freecs ***/
  bitmap_size = (MAX_CONNS + 63) / 64;
  pool.freecs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freecs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freecs[i] = UINT64_MAX;

  return 0;
}

static inline int MP_use_blks(size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t max_start = pool.nblocks - nblocks;
  size_t full_chunks = (nblocks / 64) * 64;

  for (size_t i = 0, c = 0; i <= max_start; i++, c++) {
    bool free = true;

    for (size_t j = 0; j < full_chunks; j += 64) {
      size_t word_index = (i + j) / 64;
      if (pool.freebs[word_index] != UINT64_MAX) {
        free = false;
        i += 63;
        break;
      }
    }

    for (size_t j = full_chunks; j < nblocks; j++) {
      size_t bit_index = i + j;
      size_t word_index = bit_index / 64;
      size_t bit_in_word = bit_index % 64;

      if (!BIT_IS_FREE(pool.freebs[word_index], bit_in_word)) {
        free = false;
        i += j;
        break;
      }
    }

    if (free) {
      for (size_t j = 0; j < full_chunks; j += 64) {
        size_t word_index = (i + j) / 64;
        pool.freebs[word_index] = 0;
      }

      for (size_t j = full_chunks; j < nblocks; j++) {
        size_t bit_index = i + j;
        size_t word_index = bit_index / 64;
        size_t bit_in_word = bit_index % 64;

        MARK_BIT_USED(pool.freebs[word_index], bit_in_word);
      }

      return i;
    }
  }

  return -1;
}

static inline int MP_free_blks(size_t bindex, size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t full_chunks = (nblocks / 64) * 64;
  for (size_t i = 0; i < full_chunks; i += 64) {
    size_t word_index = (bindex + i) / 64;
    pool.freebs[word_index] = UINT64_MAX;
  }

  for (size_t i = full_chunks; i < nblocks; i++) {
    size_t bit_index = bindex + i;
    size_t word_index = bit_index / 64;
    size_t bit_in_word = bit_index % 64;

    MARK_BIT_FREE(pool.freebs[word_index], bit_in_word);
  }

  memset(pool.blocks[bindex], 0, nblocks * MP_BLOCK);
  return 0;
}

static inline conn_t *MP_use(size_t nblocks, int fd, bool once) {
  if (fd <= 0)
    return NULL;
  if (once)
    return MP_use_once(nblocks, fd);

  int cindex = find_freec();
  if (cindex < 0) {
    LOG("Err: cindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  conn_t *conn = pool.conns[cindex];

  int ios_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (ios_bindex < 0) {
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }

  struct iovec *ios = pool.blocks[ios_bindex];
  conn->ios = ios;

  int rec_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (rec_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct iovec *rec = pool.blocks[rec_bindex];
  conn->rec = rec;

  int msg_bindex = MP_use_blks(MSG_NBLOCKS);
  if (msg_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct msghdr *msg = pool.blocks[msg_bindex];
  conn->msg = msg;

  if (nblocks > 0) {
    int bindex = MP_use_blks(nblocks);
    if (bindex < 0) {
      MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
      MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
      MP_free_blks(msg_bindex, IOVEC_NBLOCKS);
      MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
      LOG("Err: bindex < 0; will use MP_use_once\n");
      return MP_use_once(nblocks, fd);
    }

    size_t iov_index = conn->nios++;
    struct iovec *iov = &conn->ios[iov_index];
    struct iovec *rec = &conn->rec[iov_index];
    iov->iov_base = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
  }

  conn->msg->msg_iov = conn->ios;
  conn->msg->msg_iovlen = conn->nios;
  conn->cindex = cindex;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;
  return conn;
}

static inline void MP_shed(conn_t *conn, size_t iov_index, size_t nios) {
  struct iovec *iov, *rec;
  size_t bindex, nblocks, index;

  for (size_t i = 0; i < nios; i++) {
    index = iov_index + i;
    iov = &conn->ios[index];
    rec = &conn->rec[index];
    if (!rec || !rec->iov_base)
      continue;
    if (!IN_POOL(rec->iov_base)) {
      munmap(rec->iov_base, rec->iov_len / pool.pagesize);
    } else {
      bindex = ptr_diff((uintptr_t)rec->iov_base, (uintptr_t)pool.bpool) / MP_BLOCK;
      nblocks = rec->iov_len / MP_BLOCK;
      MP_free_blks(bindex, nblocks);
    }
    memset(iov, 0, sizeof(struct iovec));
    memset(rec, 0, sizeof(struct iovec));
    conn->nios--;
  }
}

static inline int MP_expand(conn_t *conn, size_t nblocks, bool once) {
  void *bptr;
  int iov_index, bindex;
  struct iovec *iov, *rec;

  iov_index = conn->nios++;
  iov = &conn->ios[iov_index];
  rec = &conn->rec[iov_index];

  if (nblocks == 0)
    return iov_index;

  if (once) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_base = bptr;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
    return iov_index;
  }

  bindex = MP_use_blks(nblocks);
  if (bindex < 0) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_len = iov->iov_len;
  } else {
    bptr = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_len = iov->iov_len;
  }

  iov->iov_base = bptr;
  rec->iov_base = iov->iov_base;
  return iov_index;
}

static inline int MP_free(conn_t *conn) {
  if (!conn)
    return -1;
  size_t bindex, nblocks;
  uint64_t *word;

  MP_shed(conn, 0, conn->nios);
  if (conn->flags & CF_IN_HEAP) {
    if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
      close(conn->fd);
    free(conn);
    return 0;
  }

  word = &pool.freecs[conn->cindex / 64];
  if (conn->cindex > MAX_CONNS)
    return -1;
  else if (BIT_IS_FREE(*word, conn->cindex))
    return 0;

  bindex = ptr_diff((uintptr_t)conn->ios, (uintptr_t)pool.bpool) / MP_BLOCK;
  nblocks = IOVEC_NBLOCKS;
  MP_free_blks(bindex, nblocks);

  bindex = ptr_diff((uintptr_t)conn->rec, (uintptr_t)pool.bpool) / MP_BLOCK;
  MP_free_blks(bindex, nblocks);

  if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
    close(conn->fd);

  MARK_BIT_FREE(*word, conn->cindex);
  memset(conn, 0, sizeof(conn_t));
  conn->fd = -1;
  conn->in_fd = -1;
  conn->out_fd = -1;
  return 0;
}

static inline void MP_clear(conn_t *conn) {
  conn_t *recv_conn = conn->recv_conn;
  conn_t *send_conn = conn->send_conn;
  if (recv_conn)
    MP_free(recv_conn);
  if (send_conn)
    MP_free(send_conn);
}

static inline void MP_exit(MPool *pool) {
  munmap(pool->bpool, pool->npages);
  free(pool->cpool);
  free(pool->blocks);
  free(pool->conns);
  free(pool->freebs);
  free(pool->freecs);
}

static inline void MP_timeout() {
  conn_t *conn;
  int16_t res;
  uint64_t now;
  size_t windex = 0;
  uint64_t *word = &pool.freecs[0];
  for (size_t i = 0; i < MAX_CONNS; i++) {
    if ((i / 64) < windex)
      word = &pool.freecs[++windex];

    if (*word == UINTMAX_MAX) {
      i = (i / 64) * 64 + 64;
      continue;
    }

    conn = pool.conns[i];
    if (!conn || conn->fd == -1)
      continue;

    res = pollevs(conn->fd);

    now = get_time();
    if (res & POLLERR) {
      MP_clear(conn);
      continue;
    }
    if (res & POLLIN) {
      if (pool.rtimeout > 0 && (now - conn->last_read) >= pool.rtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (res & POLLOUT) {
      if (pool.wtimeout > 0 && (now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (!(res & POLLIN || res & POLLOUT)) {
      if ((pool.rtimeout > 0 && now - conn->last_read) >= pool.rtimeout
          || (pool.wtimeout > 0 && now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
  }
}

/*
 * Calculate the length of a status string
 */
static inline size_t status_len(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return 8;
  case STATUSSWITCHINGPROTOCOLS:
    return 19;
  case STATUSPROCESSING:
    return 10;
  case STATUSEARLYHINTS:
    return 11;
  case STATUSOK:
    return 2;
  case STATUSCREATED:
    return 7;
  case STATUSACCEPTED:
    return 8;
  case STATUSNONAUTHORITATIVE:
    return 29;
  case STATUSNOCONTENT:
    return 10;
  case STATUSRESETCONTENT:
    return 13;
  case STATUSPARTIALCONTENT:
    return 15;
  case STATUSMULTISTATUS:
    return 12;
  case STATUSALREADYREPORTED:
    return 16;
  case STATUSIMUSED:
    return 7;
  case STATUSMULTIPLECHOICES:
    return 16;
  case STATUSMOVEDPERMANENTLY:
    return 17;
  case STATUSFOUND:
    return 5;
  case STATUSSEEOTHER:
    return 9;
  case STATUSNOTMODIFIED:
    return 12;
  case STATUSUSEPROXY:
    return 9;
  case STATUSTEMPORARYREDIRECT:
    return 18;
  case STATUSPERMANENTREDIRECT:
    return 18;
  case STATUSBADREQUEST:
    return 11;
  case STATUSUNAUTHORIZED:
    return 12;
  case STATUSPAYMENTREQUIRED:
    return 16;
  case STATUSFORBIDDEN:
    return 9;
  case STATUSNOTFOUND:
    return 9;
  case STATUSMETHODNOTALLOWED:
    return 18;
  case STATUSNOTACCEPTABLE:
    return 14;
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return 29;
  case STATUSREQUESTTIMEOUT:
    return 15;
  case STATUSCONFLICT:
    return 8;
  case STATUSGONE:
    return 4;
  case STATUSLENGTHREQUIRED:
    return 15;
  case STATUSPRECONDITIONFAILED:
    return 19;
  case CONTENTTOOLARGE:
    return 17;
  case STATUSURITOOLONG:
    return 12;
  case STATUSUNSUPPORTEDMEDIATYPE:
    return 22;
  case STATUSRANGENOTSATISFIABLE:
    return 21;
  case STATUSEXPECTATIONFAILED:
    return 18;
  case STATUSMISDIRECTEDREQUEST:
    return 19;
  case STATUSUNPROCESSABLECONTENT:
    return 21;
  case STATUSLOCKED:
    return 6;
  case STATUSFAILEDDEPENDENCY:
    return 17;
  case STATUSTOOEARLY:
    return 9;
  case STATUSUPGRADEREQUIRED:
    return 16;
  case STATUSPRECONDITIONREQUIRED:
    return 21;
  case STATUSTOOMANYREQUESTS:
    return 17;
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return 31;
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return 29;
  case STATUSInternalServerError:
    return 21;
  case STATUSNOTIMPLEMENTED:
    return 15;
  case STATUSBADGATEWAY:
    return 11;
  case STATUSSERVICEUNAVAILABLE:
    return 19;
  case STATUSGATEWAYTIMEOUT:
    return 15;
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return 26;
  case STATUSVARIANTALSONEGOTIATES:
    return 23;
  case STATUSINSUFFICIENTSTORAGE:
    return 20;
  case STATUSLOOPDETECTED:
    return 13;
  case STATUSNOTEXTENDED:
    return 12;
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return 31;
  default:
    return 0;
  }
}

/*
 * Return the status code string as string literal
 */
static inline char *status_str(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return "Continue";
  case STATUSSWITCHINGPROTOCOLS:
    return "Switching Protocols";
  case STATUSPROCESSING:
    return "Processing";
  case STATUSEARLYHINTS:
    return "Early Hints";
  case STATUSOK:
    return "OK";
  case STATUSCREATED:
    return "Created";
  case STATUSACCEPTED:
    return "Accepted";
  case STATUSNONAUTHORITATIVE:
    return "Non-Authoritative Information";
  case STATUSNOCONTENT:
    return "No Content";
  case STATUSRESETCONTENT:
    return "Reset Content";
  case STATUSPARTIALCONTENT:
    return "Partial Content";
  case STATUSMULTISTATUS:
    return "Multi-Status";
  case STATUSALREADYREPORTED:
    return "Already Reported";
  case STATUSIMUSED:
    return "Im Used";
  case STATUSMULTIPLECHOICES:
    return "Multiple Choices";
  case STATUSMOVEDPERMANENTLY:
    return "Moved Permanently";
  case STATUSFOUND:
    return "Found";
  case STATUSSEEOTHER:
    return "See Other";
  case STATUSNOTMODIFIED:
    return "Not Modified";
  case STATUSUSEPROXY:
    return "Use Proxy";
  case STATUSTEMPORARYREDIRECT:
    return "Temporary Redirect";
  case STATUSPERMANENTREDIRECT:
    return "Permanent Redirect";
  case STATUSBADREQUEST:
    return "Bad Request";
  case STATUSUNAUTHORIZED:
    return "Unauthorized";
  case STATUSPAYMENTREQUIRED:
    return "Payment Required";
  case STATUSFORBIDDEN:
    return "Forbidden";
  case STATUSNOTFOUND:
    return "Not Found";
  case STATUSMETHODNOTALLOWED:
    return "Method Not Allowed";
  case STATUSNOTACCEPTABLE:
    return "Not Acceptable";
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return "Proxy Authentication Required";
  case STATUSREQUESTTIMEOUT:
    return "Request Timeout";
  case STATUSCONFLICT:
    return "Conflict";
  case STATUSGONE:
    return "Gone";
  case STATUSLENGTHREQUIRED:
    return "Length Required";
  case STATUSPRECONDITIONFAILED:
    return "Precondition Failed";
  case CONTENTTOOLARGE:
    return "Content Too Large";
  case STATUSURITOOLONG:
    return "URI Too Long";
  case STATUSUNSUPPORTEDMEDIATYPE:
    return "Unsupported Media Type";
  case STATUSRANGENOTSATISFIABLE:
    return "Range Not Satisfiable";
  case STATUSEXPECTATIONFAILED:
    return "Expectation Failed";
  case STATUSMISDIRECTEDREQUEST:
    return "Misdirected Request";
  case STATUSUNPROCESSABLECONTENT:
    return "Unprocessable Content";
  case STATUSLOCKED:
    return "Locked";
  case STATUSFAILEDDEPENDENCY:
    return "Failed Dependency";
  case STATUSTOOEARLY:
    return "Too Early";
  case STATUSUPGRADEREQUIRED:
    return "Upgrade Required";
  case STATUSPRECONDITIONREQUIRED:
    return "Precondition Required";
  case STATUSTOOMANYREQUESTS:
    return "Too Many Requests";
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return "Request Header Fields Too Large";
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return "Unavailable For Legal Reasons";
  case STATUSInternalServerError:
    return "Internal Server Error";
  case STATUSNOTIMPLEMENTED:
    return "Not Implemented";
  case STATUSBADGATEWAY:
    return "Bad Gateway";
  case STATUSSERVICEUNAVAILABLE:
    return "Service Unavailable";
  case STATUSGATEWAYTIMEOUT:
    return "Gateway Timeout";
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return "HTTP Version Not Supported";
  case STATUSVARIANTALSONEGOTIATES:
    return "Variant Also Negotiates";
  case STATUSINSUFFICIENTSTORAGE:
    return "Insufficient Storage";
  case STATUSLOOPDETECTED:
    return "Loop Detected";
  case STATUSNOTEXTENDED:
    return "Not Extended";
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return "Network Authentication Required";
  default:
    return 0;
  }
}

/*
 * Return true if routes match
 */
static inline bool route_equ(Route *route, Request *req) {
  return route->method == req->method && strncmp(route->path, req->path, strlen(route->path)) == 0;
}

/*
 * Return the matching route index on success. -1 on failure
 */
static inline int match_route(Server *serv, Request *req) {
  for (size_t i = 0; i < serv->_nroutes; i++) {
    Route route = serv->routes[i];
    if (!req->path || !route.path)
      continue;
    if (route_equ(&route, req))
      return i;
    else if (req->method == HEAD && route.method == GET && strcmp(route.path, req->path) == 0)
      return i;
  }
  return -1;
}

/*
 * Return true if the response should contain the Content-Length header
 */
static inline bool should_have_content_length(Request *req, ResWriter *res) {
  return (req->method != CONNECT              // CONNECT request
          && res->status != STATUSNOCONTENT   // 204 response
          && res->status != STATUSNOTMODIFIED // 304 response
          && res->status >= 200);             // 1xx response
}

/*
 * Format http response from the ResWriter.
 * Return response size on success, 0 on failure.
 */
static inline size_t fmt_res(Request *req, ResWriter *res, char *buffer, size_t buffer_size) {
  if (!res || !buffer || buffer_size == 0)
    return 0;

  size_t res_len, total = 0;
  char *dst = buffer;
  size_t maxlen = buffer_size;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t body_length = res->len;

  res_len = snprintf(dst, maxlen, "HTTP/1.1 %d %s", (int)res->status, status_str(res->status));
  total += res_len;
  dst += res_len;
  maxlen -= res_len;

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    res_len = snprintf(dst, maxlen, "\r\n%s: %s", header->key, header->value);
    total += res_len;
    dst += res_len;
    maxlen -= res_len;
  }

  if (have_content_length) {
    res_len = snprintf(dst, maxlen, "\r\nContent-Length: %lu", body_length);
    total += res_len, dst += res_len, maxlen -= res_len;
  }

  memcpy(dst, "\r\n\r\n", 4);
  total += 4, dst += 4, maxlen -= 4;

  return total;
}

static inline size_t res_len(Request *req, ResWriter *res) {
  if (!req || !res)
    return 0;

  if (!res->status)
    res->status = STATUSOK;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t result = 0;
  result += STRLEN("HTTP/1.1 ");     // HTTP version
  result += 4;                       // Status code + space
  result += status_len(res->status); // Status name

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    result += 2;                       // "\r\n"
    result += strlen(header->key) + 2; // Header key + ':' + space
    result += strlen(header->value);   // header value
  }

  if (have_content_length) {
    result += 2;                          // "\r\n"
    result += STRLEN("Content-Length: "); // Header key
    result += countd(res->len);           // Header value
  }

  result += 4; // "\r\n\r\n"

  return result;
}

static inline int send_empty_res(Status status) {
  size_t res_len = STRLEN("HTTP/1.1 ")        // HTTP version
                   + countd((uint64_t)status) // status code
                   + 1                        // space
                   + (int)status_len(status)  // status string
                   + 4;                       // \r\n\r\n

  conn_t *conn = current_send;
  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, res_len);
  if (snprintf((char *)rec->iov_base, res_len + 1, "HTTP/1.1 %d %s\r\n\r\n", (int)status, status_str(status))
      != (int)res_len)
    return -1;

  return usendmsg(conn, 0, 1);
}

static inline ssize_t read_socket(int sockfd, size_t len) {
  if (len == 0 || sockfd <= 0)
    return 0;
  char buff[1024 * 8];
  return read(sockfd, buff, 1024 * 8);
}

static inline int read_method(Method *method, void *src) {
  if (memcmp(src, "GET", 3) == 0)
    *method = GET;
  else if (memcmp(src, "POST", 4) == 0)
    *method = POST;
  else if (memcmp(src, "HEAD", 4) == 0)
    *method = HEAD;
  else if (memcmp(src, "PUT", 3) == 0)
    *method = PUT;
  else if (memcmp(src, "DELETE", 6) == 0)
    *method = DELETE;
  else if (memcmp(src, "CONNECT", 7) == 0)
    *method = CONNECT;
  else if (memcmp(src, "OPTIONS", 7) == 0)
    *method = OPTIONS;
  else if (memcmp(src, "TRACE", 5) == 0)
    *method = TRACE;
  else if (memcmp(src, "PATCH", 5) == 0)
    *method = PATCH;
  else
    return -1;

  return 0;
}

static inline int sendmsg_res(Request *req, ResWriter *res) {
  conn_t *conn;
  size_t head_size, res_size;
  struct iovec *iov;

  conn = current_send;
  iov = &conn->ios[0];
  head_size = res_len(req, res);
  if (head_size == 0)
    return -1;

  conn->data_left += head_size;
  res_size = fmt_res(req, res, iov->iov_base, (head_size + 1));
  if (res_size != head_size)
    return -1;
  iov->iov_len = res_size;

  return usendmsg(conn, 0, conn->nios);
}

static inline int read_req(Request *req, char *req_buffer) {
  if (!req_buffer)
    return -1;
  /*** Method ***/
  char *sep = strchr(req_buffer, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }
  *sep = '\0';
  if (read_method(&req->method, req_buffer) < 0)
    return -1;

  /*** Path ***/
  char *fullpath = sep + 1;
  sep = strchr(fullpath, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }

  *sep = '\0';
  req->path = fullpath;
  /*** Params ***/
  char *paramStart = strchr(fullpath, '?');
  if (paramStart) {
    *paramStart++ = '\0';
    int params_count = 0;
    params_count = HK_parse_params(paramStart, req->params, MAX_URL_PARAMETERS);
    if (params_count > 0)
      req->params_count = params_count;
    else
      req->params_count = 0;
  } else {
    req->params = NULL;
    req->params_count = 0;
  }

  /*** Headers ***/
  char *headStart = strstr(sep + 1, "\r\n");
  char *headEnd = strstr(sep + 1, "\r\n\r\n");
  if (!headStart) {
    LOG("read_req: !headStart\n");
    return -1;
  };

  memset(headStart, 0, 2);
  headStart += 2;
  memset(headEnd, 0, 4);
  headEnd += 4;

  int headers_count = HK_parse_headers(headStart, req->headers, MAX_REQ_HEADERS);
  if (headers_count <= 0)
    return -1;
  req->headers_count = headers_count;

  /*** Host ***/
  int index = HK_get_header(req, "Host");
  if (index < 0)
    return -1;
  char *host = req->headers[index].value;
  req->hostname = host;

  /*** Port ***/
  char *colon = strchr(host, ':');
  if (colon) {
    *colon++ = '\0';
    req->port = atoi(colon);
  } else {
    req->port = PORT;
  }
  return 0;
}
static inline int process_req(Server *serv, conn_t *conn) {
  if (!conn || conn->fd == -1)
    return -1;

  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;
  if (read_req(&req, conn->ios[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    LOG("Err: route_index == -1\n");
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;
  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  sendmsg_res(&req, &res);

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int new_conn(int connfd) {
  if (connfd <= 0)
    return -1;

  current_recv = MP_use(KB * 2, connfd, false);
  current_send = MP_use(KB * 2, connfd, false);

  current_recv->recv_conn = current_recv;
  current_recv->send_conn = current_send;

  current_send->send_conn = current_send;
  current_send->recv_conn = current_recv;

  conn_t *conn = current_recv;
  if (ufrecvmsg(conn, 0, 1) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

static inline int resubmit_sendmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return usendmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int resubmir_recvmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    // FIXME the len should be increased
    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return urecvmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int handle_sendmsg_complete(conn_t *conn) {
  struct iovec *iov, *rec;

  MP_shed(conn, 1, conn->nios - 1);
  iov = &conn->ios[0];
  rec = &conn->rec[0];
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;

  return ufrecvmsg(conn->recv_conn, 0, 1);
}

static inline int handle_sendmsg(conn_t *conn, int res, bool zc) {
  if (!conn || conn->fd == -1)
    return -1;

  conn->data_left -= res;
  if (conn->data_left > 0)
    return resubmit_sendmsg(conn, res);

  if (zc)
    return 0;

  return handle_sendmsg_complete(conn);
}

static inline int handle_insplice(conn_t *conn) {
  conn->op = OUTSPLICE;
  return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
}
static inline int handle_outsplice(conn_t *conn, int res) {
  conn->data_left -= res;
  if (conn->data_left > 0) {
    conn->op = INSPLICE;
    return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
  }

  conn_t *recv_conn = conn->recv_conn;
  struct iovec *iov = &recv_conn->ios[0];
  memset(iov->iov_base, 0, iov->iov_len);
  if (urecv(recv_conn, iov->iov_base, iov->iov_len, MSG_PEEK) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

/*
static inline int handle_recv(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  void *bptr = conn->ios[0].iov_base;
  void *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  void *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  return process_req(serv, conn);
}
*/
static inline int find_route(Server *serv, char *bptr) {
  Request req = {0};
  if (read_method(&req.method, bptr) < 0) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  };
  char *space = strchr(bptr, ' ');
  req.path = (space + 1);
  space = strchr(req.path, ' ');
  *space = '\0';
  int route_index = match_route(serv, &req);
  *space = ' ';
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }
  return route_index;
}

static inline int run_handler(Server *serv, conn_t *conn, bool uses_body) {
  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;

  if (read_req(&req, conn->rec[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  if (uses_body) {
    int h_index = HK_get_header(&req, "Content-Length");
    long body_size = atol(req.headers[h_index].value);
    if (body_size >= 0) {
      req.body.ptr = conn->rec[1].iov_base;
      req.body.size = body_size;
    } else {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    }
  }

  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  if (sendmsg_res(&req, &res) < 0)
    return -1;

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int handle_frecvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  char *bptr = (char *)conn->ios[0].iov_base;
  char *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  char *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  size_t head_size = (headEnd + 4) - bptr;
  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  int route_index = find_route(serv, bptr);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  bool uses_body = serv->routes[route_index].uses_body;
  long body_size = get_content_length(headstart + 2, headEnd + 4);
  if (body_size == -1) {
    if (uses_body) {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    } else {
      body_size = 0;
    }
  }

  conn->head_size = head_size;
  if (!uses_body) {
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  if (res == (int)(head_size + body_size)) {
    size_t iov_index = MP_expand(conn, round_to_blocks(body_size), false);
    memcpy(conn->rec[iov_index].iov_base, headEnd + 4, body_size);
    conn->ios[iov_index].iov_len = body_size;
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  conn->data_left = body_size - (res - head_size);
  bool once = ((size_t)body_size > (size_t)((pool.nblocks * MP_BLOCK) / 10));
  size_t iov_index = MP_expand(conn, round_to_blocks(body_size), once);
  memcpy(conn->rec[iov_index].iov_base, headEnd + 4, (res - head_size));
  conn->ios[iov_index].iov_base += (res - head_size);

  return urecvmsg(conn, iov_index, 1);
}

static inline int handle_recvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  if (conn->data_left > 0) {
    conn->data_left -= res;
    if (conn->data_left == 0) {
      conn->flags &= CF_HANDLER_READY;
      return run_handler(serv, conn, true);
    }

    conn->flags &= ~CF_HANDLER_READY;
    conn->ios[1].iov_base += res;
    return urecvmsg(conn, 1, 1);
  }

  conn->flags &= CF_HANDLER_READY;
  return run_handler(serv, conn, true);
}

static inline int serv_init(Server *serv) {
#if DEBUG
  logfd = log_init("log.txt");
  if (!logfd) {
    printf("log_init failed");
    return -1;
  }
#endif
  serv->_nroutes = get_nroutes(serv->routes);

  int pipefd[2];
  if (pipe(pipefd) < 0)
    return -1;
  pipe_in = pipefd[0];
  pipe_out = pipefd[1];
  nullfd = open("/dev/null", O_WRONLY);
  pipe_sz = fcntl(pipefd[0], F_GETPIPE_SZ);
  if (pipe_sz < 0)
    return -1;

  pool.rtimeout = serv->rtimeout;
  pool.wtimeout = serv->wtimeout;
  if (MP_init(MAX_CONNS * 8) < 0)
    return -1;
  LOG("pool initialized\n");

  if (io_uring_queue_init(MAX_CONNS, &ring, 0) < 0)
    return -1;
  LOG("uring initialized\n");

  int listenfd;
  if ((listenfd = tcp_listen(serv->port)) < 0)
    return -1;
  LOG("socket initialized\n");

  return umaccept(listenfd);
}

static inline int serv_listen(Server *serv) {
  // uint64_t last_check = get_time();
  while (true) {
    // uint64_t now = get_time();
    // if ((now - last_check) >= 200) {
    //   last_check = now;
    //   LOG("CM: CM_check ran\n");
    //   MP_timeout();
    // }

    LOG("SQ ready: %u, CQ ready: %u\n", io_uring_sq_ready(&ring), io_uring_cq_ready(&ring));
    struct io_uring_cqe *cqe;
    if (io_uring_wait_cqe(&ring, &cqe) < 0)
      continue;

    int res = cqe->res;
    LOG("res = %d\n", res);
    conn_t *conn = NULL;
    if (cqe->user_data > 100) {
      conn = (conn_t *)cqe->user_data;
      current_recv = (conn_t *)conn->recv_conn;
      current_send = (conn_t *)conn->send_conn;
    }

    if (res > 0) {
      if (cqe->user_data == ACCEPT) {
        LOG("new conn created\n");
        new_conn(res);
      } else if (conn && conn->fd != -1) {
        LOG("conn[%d]: conn.fd = %d; conn.op = %d\n", conn->cindex, conn->fd, conn->op);
        switch (conn->op) {
        case FRECVMSG:
          if (handle_frecvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case RECVMSG:
          if (handle_recvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case SENDMSG:
        case SENDMSGZC:
          // conn->last_write = get_time();
          bool zc = (conn->op == SENDMSGZC);
          if (handle_sendmsg(conn, res, zc) < 0)
            MP_clear(conn);
          break;
        case INSPLICE:
          if (handle_insplice(conn) < 0)
            MP_clear(conn);
          break;
        case OUTSPLICE:
          if (handle_outsplice(conn, res) < 0)
            MP_clear(conn);
          break;
        }
      }
    } else if (res == 0) {
      if (conn && conn->fd != -1) {
        switch (conn->op) {
        case SENDMSGZC:
          conn->zc_notifs--;
          if (conn->zc_notifs == 0 && handle_sendmsg_complete(conn) < 0)
            MP_clear(conn);
          break;
        case RECV:
          MP_clear(conn);
          break;
        }
      }
    } else {
      if (conn && conn->fd != -1) {
        if (res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR) {
          LOG("conn && conn->fd != -1 && res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR\n");
          MP_clear(conn);
        } else {
          LOG("res == -EAGAIN || res == -EWOULDBLOCK || res == -EINTR\n");
          conn = conn->recv_conn;
          struct iovec *iov = &conn->ios[0];
          memset(iov->iov_base, 0, iov->iov_len);
          if (urecv(conn, iov->iov_base, iov->iov_len, 0) < 0)
            MP_clear(conn);
        }
      }
    }

    LOG("uring operation seen\n");
    io_uring_cqe_seen(&ring, cqe);
  }

  io_uring_queue_exit(&ring);
  MP_exit(&pool);
  return 0;
}

/*** Helper ***/
static inline int _HK_write(void *data, size_t size) {
  size_t nblocks;
  int iov_index;
  conn_t *conn;
  struct iovec *iov;
  bool once;

  conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  nblocks = round_to_blocks(size);
  iov_index = MP_expand(conn, nblocks, once);
  iov = &conn->ios[iov_index];

  memcpy(iov->iov_base, data, size);
  iov->iov_len = size;
  conn->data_left += size;

  return 0;
}
static inline int _HK_write_body(Request *req, size_t offset, size_t size) {
  if (size > req->body.size || offset > req->body.size)
    return -1;

  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  int iov_index = MP_expand(conn, 0, false);
  struct iovec *iov = &conn->ios[iov_index];
  struct iovec *rec = &conn->rec[iov_index];
  rec->iov_base = req->body.ptr + offset;
  rec->iov_len = size;
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;
  conn->data_left += rec->iov_len;
  return 0;
}
/*
static inline int _HK_mem(size_t size, HKMem *mem) {
  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  bool once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  size_t nblocks = round_to_blocks(size);
  int iov_index = MP_expand(conn, nblocks, once);
  struct iovec *iov = &conn->ios[iov_index];
  mem->ptr = iov->iov_base;
  mem->size = iov->iov_len;
  mem->_iov_index = iov_index;
  mem->_flags = (IN_POOL(iov->iov_base)) ? CF_IN_POOL : CF_IN_HEAP;
  return 0;
}

static inline void _HK_send(HKMem *mem, size_t size) {
  conn_t *conn = current_send;
  struct iovec *iov = &conn->ios[mem->_iov_index];
  iov->iov_len = size;
  conn->data_left += size;
}
  */
#endif
#define _GNU_SOURCE
#ifndef UTILS_H
#define UTILS_H

#include "hunk.h"
#include <arpa/inet.h>
#include <fcntl.h>
#include <liburing.h>
#include <netdb.h>
#include <signal.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/poll.h>
#include <sys/prctl.h>
#include <sys/socket.h>
#include <sys/sysinfo.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

#define MP_BLOCK  4
#define MAX_CONNS 4096
#define KB        1024
#define NIOS      32

#define IN_POOL(ptr)                 ((void *)ptr >= pool.bpool && (void *)ptr <= (pool.bpool + (pool.npages * pool.pagesize)))
#define ALIGN_TO_PAGESIZE(buff_size) (((buff_size) + (pool.pagesize - 1)) & ~(pool.pagesize - 1))
#define BYTES_TO_BLOCKS(buff_size)   (((buff_size) + (MP_BLOCK - 1)) / MP_BLOCK)
#define CEIL_BLOCKS(nblocks)         ((nblocks + 63) & ~63)
#define CEIL_PAGES(size)             (((size) + ((pool.pagesize) - 1)) & ~((pool.pagesize) - 1))

#define BIT_IS_FREE(word, bit)   (((word) >> (bit)) & 1)
#define MARK_BIT_USED(word, bit) ((word) &= ~(1ULL << (bit)))
#define MARK_BIT_FREE(word, bit) ((word) |= (1ULL << (bit)))
#define FIND_FREE_BIT(word)      ((uint64_t)(word) & -(uint64_t)(word))
#define STRLEN(s)                (sizeof(s) - 1)

#define IOVEC_NBLOCKS (BYTES_TO_BLOCKS(NIOS * sizeof(struct iovec)))
#define MSG_NBLOCKS   (BYTES_TO_BLOCKS(sizeof(struct msghdr)))
#define ZC_RES        KB *KB

#define DEBUG 0
#if DEBUG
#define LOG(...) fprintf(logfd, __VA_ARGS__)
#else
#define LOG(...) ((void)0)
#endif

typedef enum UOP {
  WRITEV = IORING_OP_WRITEV,
  SENDMSG = IORING_OP_SENDMSG,
  RECVMSG = IORING_OP_RECVMSG,
  ACCEPT = IORING_OP_ACCEPT,
  SEND = IORING_OP_SEND,
  RECV = IORING_OP_RECV,
  SENDZC = IORING_OP_SEND_ZC,
  SENDMSGZC = IORING_OP_SENDMSG_ZC,
  PEEK = 50,
  FRECVMSG,
  INSPLICE,
  OUTSPLICE
} UOP;

typedef enum CFS {
  CF_IN_POOL = (1 << 0),       // Connection is in the pool
  CF_IN_HEAP = (1 << 1),       // Connection is in the heap
  CF_SKIP_SOCK = (1 << 2),     // Don't close the socket
  CF_USE_ONCE = (1 << 3),      // Destroy after using
  CF_HANDLER_READY = (1 << 4), // Ready to call the handler
} CFS;

typedef struct conn_t {
  // Socket file descriptor
  int fd;

  // Amount of data left in the current operation
  uint64_t data_left;

  // The index of the connection struct
  uint32_t cindex;

  // The last time the connection was readable
  uint64_t last_read;

  // The last time the connection was writeable
  uint64_t last_write;

  // The operation currently being processed
  uint8_t op;

  // Connection flags
  int flags;

  // Splice fd_in
  int in_fd;

  // Splice fd_out
  int out_fd;

  void *recv_conn;
  void *send_conn;

  struct iovec *ios;
  struct iovec *rec;
  uint16_t nios;

  struct msghdr *msg;
  uint16_t zc_notifs;

  uint16_t head_size;
} conn_t;

typedef struct MPool {
  // The allocated pool of blocks
  void *bpool;

  // The allocated pool of connections
  conn_t *cpool;

  // The size of the pool in pages
  uint32_t npages;

  // The size of the pool in blocks
  uint32_t nblocks;

  // The locations of each page in the pool
  void **blocks;

  // The availability of each block
  uint64_t *freebs;

  // The locations of each conn in the pool
  conn_t **conns;

  // The availability of each conn
  uint64_t *freecs;

  // Clean up callback function
  void (*callback)(conn_t *conn);

  // The page size used
  uint32_t pagesize;

  // Socket read timeout
  uint32_t rtimeout;

  // Socket write timeout
  uint32_t wtimeout;
} MPool;

extern int pipe_sz;
extern int pipe_in, pipe_out, nullfd;
extern FILE *logfd;
extern struct io_uring ring;
extern MPool pool;
extern conn_t *current_recv;
extern conn_t *current_send;

/*
 * Prepare and submit a recv uring op
 */
static inline int urecv(conn_t *conn, void *buffer, size_t buff_size, int flags) {
  if (!conn || conn->fd == -1)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (flags == MSG_PEEK) ? PEEK : RECV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;

  io_uring_prep_recv(sqe, conn->fd, buffer, buff_size, flags);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a multi-shot accept uring op
 */
static inline int umaccept(int listenfd) {
  if (listenfd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = ACCEPT;
  io_uring_prep_multishot_accept(sqe, listenfd, NULL, NULL, SOCK_NONBLOCK);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a splice uring op
 */
static inline int usplice(conn_t *conn, int fd_in, int64_t off_in, int fd_out, int64_t off_out, size_t len) {
  if (!len || !conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = (__u64)conn;
  io_uring_prep_splice(sqe, fd_in, off_in, fd_out, off_out, len, 0);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a writev uring op
 */
static inline int uwritev(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = WRITEV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  io_uring_prep_writev(sqe, conn->fd, &conn->ios[iov_index], nios, -1);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a send uring op
 */
static inline int usend(conn_t *conn, char *res_buff, size_t buff_size, bool zc) {
  if (!conn || conn->fd <= 0 || buff_size == 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (zc) ? SENDZC : SEND;
  conn->data_left = buff_size;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  if (zc)
    io_uring_prep_send_zc(sqe, conn->fd, res_buff, buff_size, 0, 0);
  else
    io_uring_prep_send(sqe, conn->fd, res_buff, buff_size, 0);
  return io_uring_submit(&ring);
}

static inline int ufrecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = FRECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;

  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, rec->iov_len);
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int urecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = RECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int usendmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  bool zc = (conn->data_left > ZC_RES) ? true : false;
  conn->op = (zc) ? SENDMSGZC : SENDMSG;

  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  if (zc) {
    io_uring_prep_sendmsg_zc(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
    conn->zc_notifs++;
  } else {
    io_uring_prep_sendmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  }
  return io_uring_submit(&ring);
}

/*
 * Create and initialize a server socket
 */
static inline int tcp_listen(uint16_t port) {
  int enable;
  int listenfd;
  if ((listenfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    return -1;

  int flags = fcntl(listenfd, F_GETFL, 0);
  fcntl(listenfd, F_SETFL, flags | O_NONBLOCK);
  struct sockaddr_in servaddr;
  memset(&servaddr, 0, sizeof(servaddr));
  servaddr.sin_family = AF_INET;
  servaddr.sin_addr.s_addr = INADDR_ANY;
  servaddr.sin_port = htons(port);

  enable = 1;
  if (setsockopt(listenfd, SOL_SOCKET, SO_REUSEPORT, &enable, sizeof(enable)) < 0)
    return -1;

  if (bind(listenfd, (struct sockaddr *)&servaddr, sizeof(servaddr)) < 0)
    return -1;

  if (listen(listenfd, SOMAXCONN) < 0)
    return -1;

  return listenfd;
}

/*
 * Calculate the difference between two pointers
 */
static inline uintptr_t ptr_diff(uintptr_t p1, uintptr_t p2) { return (uintptr_t)(p1 > p2) ? (p1 - p2) : (p2 - p1); }

static inline size_t get_nroutes(Route *routes) {
  Route *route;
  for (size_t i = 0;; i++) {
    route = &routes[i];
    if (!route->path && !route->handler && !route->method)
      return i;
  }
}

static inline long get_content_length(char *src, char *end) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return -1;
    key = line;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, "Content-Length") != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;

    *line_end = '\0';
    long res = atol(value);
    *line_end = '\r';

    return res;
  }
  return -1;
}

static inline bool have_header(char *src, char *end, const char *header_key, const char *header_value) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    key = line;
    while (*key == ' ')
      key++;
    while (*header_key == ' ')
      header_key++;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return false;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, header_key) != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;
    while (*header_value == ' ')
      header_value++;

    *line_end = '\0';
    bool res = (strcasecmp(value, header_value) == 0);
    *line_end = '\r';

    return res;
  }

  return false;
}

static inline const char *method_str(Method method) {
  switch (method) {
  case GET:
    return "GET";
    break;
  case HEAD:
    return "HEAD";
    break;
  case POST:
    return "POST";
    break;
  case PUT:
    return "PUT";
    break;
  case DELETE:
    return "DELETE";
    break;
  case CONNECT:
    return "CONNECT";
    break;
  case OPTIONS:
    return "OPTIONS";
    break;
  case TRACE:
    return "TRACE";
    break;
  case PATCH:
    return "PATCH";
    break;
  default:
    return NULL;
  }
}

static inline uint8_t method_len(Method method) {
  switch (method) {
  case GET:
    return 3;
    break;
  case HEAD:
    return 4;
    break;
  case POST:
    return 4;
    break;
  case PUT:
    return 3;
    break;
  case DELETE:
    return 6;
    break;
  case CONNECT:
    return 7;
    break;
  case OPTIONS:
    return 7;
    break;
  case TRACE:
    return 5;
    break;
  case PATCH:
    return 5;
    break;
  default:
    return 0;
  }
}

static inline size_t round_to_blocks(size_t size) {
  size_t nblocks = BYTES_TO_BLOCKS(size);
  nblocks = CEIL_BLOCKS(nblocks);
  return nblocks;
}

/*
 * Count the digits in unsigned 64-bit int
 */
static inline int countd(uint64_t num) {
  if (num < 10ULL)
    return 1;
  if (num < 100ULL)
    return 2;
  if (num < 1000ULL)
    return 3;
  if (num < 10000ULL)
    return 4;
  if (num < 100000ULL)
    return 5;
  if (num < 1000000ULL)
    return 6;
  if (num < 10000000ULL)
    return 7;
  if (num < 100000000ULL)
    return 8;
  if (num < 1000000000ULL)
    return 9;
  if (num < 10000000000ULL)
    return 10;
  if (num < 100000000000ULL)
    return 11;
  if (num < 1000000000000ULL)
    return 12;
  if (num < 10000000000000ULL)
    return 13;
  if (num < 100000000000000ULL)
    return 14;
  if (num < 1000000000000000ULL)
    return 15;
  if (num < 10000000000000000ULL)
    return 16;
  if (num < 100000000000000000ULL)
    return 17;
  if (num < 1000000000000000000ULL)
    return 18;
  if (num < 10000000000000000000ULL)
    return 19;
  return 20;
}

/*
 * Get the time elabsed in ms
 */
static inline uint64_t get_time() {
  struct timespec ts;
  clock_gettime(CLOCK_MONOTONIC, &ts);
  return (uint64_t)(ts.tv_sec) * 1000 + (ts.tv_nsec / 1000000);
}

static inline FILE *log_init(const char *path) {
  FILE *res = fopen(path, "a+");
  setvbuf(res, NULL, _IONBF, 0);
  return res;
}

static inline int16_t pollevs(int connfd) {
  struct pollfd pfd;
  pfd.fd = connfd;
  pfd.events = POLLIN | POLLOUT | POLLERR;
  int res = poll(&pfd, 1, 0);
  if (res < 0)
    return POLLERR;
  return pfd.revents;
}

// FIXME This needs to be updated
static inline conn_t *MP_use_once(size_t nblocks, int fd) {

  void *mem = malloc(sizeof(conn_t) + 8 + (IOVEC_NBLOCKS * MP_BLOCK));
  struct conn_t *conn = (conn_t *)mem;
  memset(conn, 0, sizeof(conn_t));
  conn->ios = mem + sizeof(conn_t) + 8;

  if (nblocks > 0) {
    struct iovec *iov = &conn->ios[conn->nios++];
    mem = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (mem == MAP_FAILED)
      return NULL;
    iov->iov_base = mem;
    iov->iov_len = ALIGN_TO_PAGESIZE(nblocks * MP_BLOCK);
  }

  conn->flags |= CF_IN_HEAP;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;

  return conn;
}

static inline int find_freec() {
  uint64_t *word;
  size_t map_size = (sizeof(uint64_t) * 8);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    word = &pool.freecs[i / map_size];

    if (*word == 0) { // All used
      i += (map_size - 1);
      continue;
    }

    i += __builtin_ctzll(*word);
    MARK_BIT_USED(*word, i);
    return i;
  }

  return -1;
}

static inline int MP_init(size_t npages) {
  if (!npages)
    return -1;

  /*** Setup ***/
  pool.npages = npages;
  pool.pagesize = sysconf(_SC_PAGESIZE);

  /*** Pool ***/
  pool.bpool = mmap(NULL, pool.npages * pool.pagesize, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  if (pool.bpool == MAP_FAILED)
    return -1;
  pool.nblocks = (pool.npages * pool.pagesize) / MP_BLOCK;

  /*** Blocks ***/
  pool.blocks = malloc(sizeof(void *) * pool.nblocks);
  if (!pool.blocks)
    return -1;
  for (size_t i = 0; i < pool.nblocks; i++)
    pool.blocks[i] = pool.bpool + (i * MP_BLOCK);

  /*** Freebs ***/
  // if (posix_memalign((void **)&pool.freebs, 64, bitmap_size * sizeof(uint64_t)) < 0)
  size_t bitmap_size = (pool.nblocks + 63) / 64;
  pool.freebs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freebs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freebs[i] = UINT64_MAX;

  /*** Cpool ***/
  pool.cpool = (conn_t *)malloc(sizeof(conn_t) * MAX_CONNS);
  if (!pool.cpool)
    return -1;

  /*** Conns ***/
  pool.conns = (conn_t **)malloc(sizeof(conn_t *) * MAX_CONNS);
  if (!pool.conns)
    return -1;
  size_t conn_size = sizeof(conn_t);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    pool.conns[i] = (conn_t *)((char *)pool.cpool + (i * conn_size));
    pool.conns[i]->fd = -1;
    pool.conns[i]->in_fd = -1;
    pool.conns[i]->out_fd = -1;
  }

  /*** Freecs ***/
  bitmap_size = (MAX_CONNS + 63) / 64;
  pool.freecs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freecs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freecs[i] = UINT64_MAX;

  return 0;
}

static inline int MP_use_blks(size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t max_start = pool.nblocks - nblocks;
  size_t full_chunks = (nblocks / 64) * 64;

  for (size_t i = 0, c = 0; i <= max_start; i++, c++) {
    bool free = true;

    for (size_t j = 0; j < full_chunks; j += 64) {
      size_t word_index = (i + j) / 64;
      if (pool.freebs[word_index] != UINT64_MAX) {
        free = false;
        i += 63;
        break;
      }
    }

    for (size_t j = full_chunks; j < nblocks; j++) {
      size_t bit_index = i + j;
      size_t word_index = bit_index / 64;
      size_t bit_in_word = bit_index % 64;

      if (!BIT_IS_FREE(pool.freebs[word_index], bit_in_word)) {
        free = false;
        i += j;
        break;
      }
    }

    if (free) {
      for (size_t j = 0; j < full_chunks; j += 64) {
        size_t word_index = (i + j) / 64;
        pool.freebs[word_index] = 0;
      }

      for (size_t j = full_chunks; j < nblocks; j++) {
        size_t bit_index = i + j;
        size_t word_index = bit_index / 64;
        size_t bit_in_word = bit_index % 64;

        MARK_BIT_USED(pool.freebs[word_index], bit_in_word);
      }

      return i;
    }
  }

  return -1;
}

static inline int MP_free_blks(size_t bindex, size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t full_chunks = (nblocks / 64) * 64;
  for (size_t i = 0; i < full_chunks; i += 64) {
    size_t word_index = (bindex + i) / 64;
    pool.freebs[word_index] = UINT64_MAX;
  }

  for (size_t i = full_chunks; i < nblocks; i++) {
    size_t bit_index = bindex + i;
    size_t word_index = bit_index / 64;
    size_t bit_in_word = bit_index % 64;

    MARK_BIT_FREE(pool.freebs[word_index], bit_in_word);
  }

  memset(pool.blocks[bindex], 0, nblocks * MP_BLOCK);
  return 0;
}

static inline conn_t *MP_use(size_t nblocks, int fd, bool once) {
  if (fd <= 0)
    return NULL;
  if (once)
    return MP_use_once(nblocks, fd);

  int cindex = find_freec();
  if (cindex < 0) {
    LOG("Err: cindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  conn_t *conn = pool.conns[cindex];

  int ios_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (ios_bindex < 0) {
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }

  struct iovec *ios = pool.blocks[ios_bindex];
  conn->ios = ios;

  int rec_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (rec_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct iovec *rec = pool.blocks[rec_bindex];
  conn->rec = rec;

  int msg_bindex = MP_use_blks(MSG_NBLOCKS);
  if (msg_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct msghdr *msg = pool.blocks[msg_bindex];
  conn->msg = msg;

  if (nblocks > 0) {
    int bindex = MP_use_blks(nblocks);
    if (bindex < 0) {
      MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
      MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
      MP_free_blks(msg_bindex, IOVEC_NBLOCKS);
      MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
      LOG("Err: bindex < 0; will use MP_use_once\n");
      return MP_use_once(nblocks, fd);
    }

    size_t iov_index = conn->nios++;
    struct iovec *iov = &conn->ios[iov_index];
    struct iovec *rec = &conn->rec[iov_index];
    iov->iov_base = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
  }

  conn->msg->msg_iov = conn->ios;
  conn->msg->msg_iovlen = conn->nios;
  conn->cindex = cindex;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;
  return conn;
}

static inline void MP_shed(conn_t *conn, size_t iov_index, size_t nios) {
  struct iovec *iov, *rec;
  size_t bindex, nblocks, index;

  for (size_t i = 0; i < nios; i++) {
    index = iov_index + i;
    iov = &conn->ios[index];
    rec = &conn->rec[index];
    if (!rec || !rec->iov_base)
      continue;
    if (!IN_POOL(rec->iov_base)) {
      munmap(rec->iov_base, rec->iov_len / pool.pagesize);
    } else {
      bindex = ptr_diff((uintptr_t)rec->iov_base, (uintptr_t)pool.bpool) / MP_BLOCK;
      nblocks = rec->iov_len / MP_BLOCK;
      MP_free_blks(bindex, nblocks);
    }
    memset(iov, 0, sizeof(struct iovec));
    memset(rec, 0, sizeof(struct iovec));
    conn->nios--;
  }
}

static inline int MP_expand(conn_t *conn, size_t nblocks, bool once) {
  void *bptr;
  int iov_index, bindex;
  struct iovec *iov, *rec;

  iov_index = conn->nios++;
  iov = &conn->ios[iov_index];
  rec = &conn->rec[iov_index];

  if (nblocks == 0)
    return iov_index;

  if (once) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_base = bptr;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
    return iov_index;
  }

  bindex = MP_use_blks(nblocks);
  if (bindex < 0) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_len = iov->iov_len;
  } else {
    bptr = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_len = iov->iov_len;
  }

  iov->iov_base = bptr;
  rec->iov_base = iov->iov_base;
  return iov_index;
}

static inline int MP_free(conn_t *conn) {
  if (!conn)
    return -1;
  size_t bindex, nblocks;
  uint64_t *word;

  MP_shed(conn, 0, conn->nios);
  if (conn->flags & CF_IN_HEAP) {
    if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
      close(conn->fd);
    free(conn);
    return 0;
  }

  word = &pool.freecs[conn->cindex / 64];
  if (conn->cindex > MAX_CONNS)
    return -1;
  else if (BIT_IS_FREE(*word, conn->cindex))
    return 0;

  bindex = ptr_diff((uintptr_t)conn->ios, (uintptr_t)pool.bpool) / MP_BLOCK;
  nblocks = IOVEC_NBLOCKS;
  MP_free_blks(bindex, nblocks);

  bindex = ptr_diff((uintptr_t)conn->rec, (uintptr_t)pool.bpool) / MP_BLOCK;
  MP_free_blks(bindex, nblocks);

  if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
    close(conn->fd);

  MARK_BIT_FREE(*word, conn->cindex);
  memset(conn, 0, sizeof(conn_t));
  conn->fd = -1;
  conn->in_fd = -1;
  conn->out_fd = -1;
  return 0;
}

static inline void MP_clear(conn_t *conn) {
  conn_t *recv_conn = conn->recv_conn;
  conn_t *send_conn = conn->send_conn;
  if (recv_conn)
    MP_free(recv_conn);
  if (send_conn)
    MP_free(send_conn);
}

static inline void MP_exit(MPool *pool) {
  munmap(pool->bpool, pool->npages);
  free(pool->cpool);
  free(pool->blocks);
  free(pool->conns);
  free(pool->freebs);
  free(pool->freecs);
}

static inline void MP_timeout() {
  conn_t *conn;
  int16_t res;
  uint64_t now;
  size_t windex = 0;
  uint64_t *word = &pool.freecs[0];
  for (size_t i = 0; i < MAX_CONNS; i++) {
    if ((i / 64) < windex)
      word = &pool.freecs[++windex];

    if (*word == UINTMAX_MAX) {
      i = (i / 64) * 64 + 64;
      continue;
    }

    conn = pool.conns[i];
    if (!conn || conn->fd == -1)
      continue;

    res = pollevs(conn->fd);

    now = get_time();
    if (res & POLLERR) {
      MP_clear(conn);
      continue;
    }
    if (res & POLLIN) {
      if (pool.rtimeout > 0 && (now - conn->last_read) >= pool.rtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (res & POLLOUT) {
      if (pool.wtimeout > 0 && (now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (!(res & POLLIN || res & POLLOUT)) {
      if ((pool.rtimeout > 0 && now - conn->last_read) >= pool.rtimeout
          || (pool.wtimeout > 0 && now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
  }
}

/*
 * Calculate the length of a status string
 */
static inline size_t status_len(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return 8;
  case STATUSSWITCHINGPROTOCOLS:
    return 19;
  case STATUSPROCESSING:
    return 10;
  case STATUSEARLYHINTS:
    return 11;
  case STATUSOK:
    return 2;
  case STATUSCREATED:
    return 7;
  case STATUSACCEPTED:
    return 8;
  case STATUSNONAUTHORITATIVE:
    return 29;
  case STATUSNOCONTENT:
    return 10;
  case STATUSRESETCONTENT:
    return 13;
  case STATUSPARTIALCONTENT:
    return 15;
  case STATUSMULTISTATUS:
    return 12;
  case STATUSALREADYREPORTED:
    return 16;
  case STATUSIMUSED:
    return 7;
  case STATUSMULTIPLECHOICES:
    return 16;
  case STATUSMOVEDPERMANENTLY:
    return 17;
  case STATUSFOUND:
    return 5;
  case STATUSSEEOTHER:
    return 9;
  case STATUSNOTMODIFIED:
    return 12;
  case STATUSUSEPROXY:
    return 9;
  case STATUSTEMPORARYREDIRECT:
    return 18;
  case STATUSPERMANENTREDIRECT:
    return 18;
  case STATUSBADREQUEST:
    return 11;
  case STATUSUNAUTHORIZED:
    return 12;
  case STATUSPAYMENTREQUIRED:
    return 16;
  case STATUSFORBIDDEN:
    return 9;
  case STATUSNOTFOUND:
    return 9;
  case STATUSMETHODNOTALLOWED:
    return 18;
  case STATUSNOTACCEPTABLE:
    return 14;
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return 29;
  case STATUSREQUESTTIMEOUT:
    return 15;
  case STATUSCONFLICT:
    return 8;
  case STATUSGONE:
    return 4;
  case STATUSLENGTHREQUIRED:
    return 15;
  case STATUSPRECONDITIONFAILED:
    return 19;
  case CONTENTTOOLARGE:
    return 17;
  case STATUSURITOOLONG:
    return 12;
  case STATUSUNSUPPORTEDMEDIATYPE:
    return 22;
  case STATUSRANGENOTSATISFIABLE:
    return 21;
  case STATUSEXPECTATIONFAILED:
    return 18;
  case STATUSMISDIRECTEDREQUEST:
    return 19;
  case STATUSUNPROCESSABLECONTENT:
    return 21;
  case STATUSLOCKED:
    return 6;
  case STATUSFAILEDDEPENDENCY:
    return 17;
  case STATUSTOOEARLY:
    return 9;
  case STATUSUPGRADEREQUIRED:
    return 16;
  case STATUSPRECONDITIONREQUIRED:
    return 21;
  case STATUSTOOMANYREQUESTS:
    return 17;
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return 31;
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return 29;
  case STATUSInternalServerError:
    return 21;
  case STATUSNOTIMPLEMENTED:
    return 15;
  case STATUSBADGATEWAY:
    return 11;
  case STATUSSERVICEUNAVAILABLE:
    return 19;
  case STATUSGATEWAYTIMEOUT:
    return 15;
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return 26;
  case STATUSVARIANTALSONEGOTIATES:
    return 23;
  case STATUSINSUFFICIENTSTORAGE:
    return 20;
  case STATUSLOOPDETECTED:
    return 13;
  case STATUSNOTEXTENDED:
    return 12;
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return 31;
  default:
    return 0;
  }
}

/*
 * Return the status code string as string literal
 */
static inline char *status_str(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return "Continue";
  case STATUSSWITCHINGPROTOCOLS:
    return "Switching Protocols";
  case STATUSPROCESSING:
    return "Processing";
  case STATUSEARLYHINTS:
    return "Early Hints";
  case STATUSOK:
    return "OK";
  case STATUSCREATED:
    return "Created";
  case STATUSACCEPTED:
    return "Accepted";
  case STATUSNONAUTHORITATIVE:
    return "Non-Authoritative Information";
  case STATUSNOCONTENT:
    return "No Content";
  case STATUSRESETCONTENT:
    return "Reset Content";
  case STATUSPARTIALCONTENT:
    return "Partial Content";
  case STATUSMULTISTATUS:
    return "Multi-Status";
  case STATUSALREADYREPORTED:
    return "Already Reported";
  case STATUSIMUSED:
    return "Im Used";
  case STATUSMULTIPLECHOICES:
    return "Multiple Choices";
  case STATUSMOVEDPERMANENTLY:
    return "Moved Permanently";
  case STATUSFOUND:
    return "Found";
  case STATUSSEEOTHER:
    return "See Other";
  case STATUSNOTMODIFIED:
    return "Not Modified";
  case STATUSUSEPROXY:
    return "Use Proxy";
  case STATUSTEMPORARYREDIRECT:
    return "Temporary Redirect";
  case STATUSPERMANENTREDIRECT:
    return "Permanent Redirect";
  case STATUSBADREQUEST:
    return "Bad Request";
  case STATUSUNAUTHORIZED:
    return "Unauthorized";
  case STATUSPAYMENTREQUIRED:
    return "Payment Required";
  case STATUSFORBIDDEN:
    return "Forbidden";
  case STATUSNOTFOUND:
    return "Not Found";
  case STATUSMETHODNOTALLOWED:
    return "Method Not Allowed";
  case STATUSNOTACCEPTABLE:
    return "Not Acceptable";
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return "Proxy Authentication Required";
  case STATUSREQUESTTIMEOUT:
    return "Request Timeout";
  case STATUSCONFLICT:
    return "Conflict";
  case STATUSGONE:
    return "Gone";
  case STATUSLENGTHREQUIRED:
    return "Length Required";
  case STATUSPRECONDITIONFAILED:
    return "Precondition Failed";
  case CONTENTTOOLARGE:
    return "Content Too Large";
  case STATUSURITOOLONG:
    return "URI Too Long";
  case STATUSUNSUPPORTEDMEDIATYPE:
    return "Unsupported Media Type";
  case STATUSRANGENOTSATISFIABLE:
    return "Range Not Satisfiable";
  case STATUSEXPECTATIONFAILED:
    return "Expectation Failed";
  case STATUSMISDIRECTEDREQUEST:
    return "Misdirected Request";
  case STATUSUNPROCESSABLECONTENT:
    return "Unprocessable Content";
  case STATUSLOCKED:
    return "Locked";
  case STATUSFAILEDDEPENDENCY:
    return "Failed Dependency";
  case STATUSTOOEARLY:
    return "Too Early";
  case STATUSUPGRADEREQUIRED:
    return "Upgrade Required";
  case STATUSPRECONDITIONREQUIRED:
    return "Precondition Required";
  case STATUSTOOMANYREQUESTS:
    return "Too Many Requests";
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return "Request Header Fields Too Large";
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return "Unavailable For Legal Reasons";
  case STATUSInternalServerError:
    return "Internal Server Error";
  case STATUSNOTIMPLEMENTED:
    return "Not Implemented";
  case STATUSBADGATEWAY:
    return "Bad Gateway";
  case STATUSSERVICEUNAVAILABLE:
    return "Service Unavailable";
  case STATUSGATEWAYTIMEOUT:
    return "Gateway Timeout";
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return "HTTP Version Not Supported";
  case STATUSVARIANTALSONEGOTIATES:
    return "Variant Also Negotiates";
  case STATUSINSUFFICIENTSTORAGE:
    return "Insufficient Storage";
  case STATUSLOOPDETECTED:
    return "Loop Detected";
  case STATUSNOTEXTENDED:
    return "Not Extended";
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return "Network Authentication Required";
  default:
    return 0;
  }
}

/*
 * Return true if routes match
 */
static inline bool route_equ(Route *route, Request *req) {
  return route->method == req->method && strncmp(route->path, req->path, strlen(route->path)) == 0;
}

/*
 * Return the matching route index on success. -1 on failure
 */
static inline int match_route(Server *serv, Request *req) {
  for (size_t i = 0; i < serv->_nroutes; i++) {
    Route route = serv->routes[i];
    if (!req->path || !route.path)
      continue;
    if (route_equ(&route, req))
      return i;
    else if (req->method == HEAD && route.method == GET && strcmp(route.path, req->path) == 0)
      return i;
  }
  return -1;
}

/*
 * Return true if the response should contain the Content-Length header
 */
static inline bool should_have_content_length(Request *req, ResWriter *res) {
  return (req->method != CONNECT              // CONNECT request
          && res->status != STATUSNOCONTENT   // 204 response
          && res->status != STATUSNOTMODIFIED // 304 response
          && res->status >= 200);             // 1xx response
}

/*
 * Format http response from the ResWriter.
 * Return response size on success, 0 on failure.
 */
static inline size_t fmt_res(Request *req, ResWriter *res, char *buffer, size_t buffer_size) {
  if (!res || !buffer || buffer_size == 0)
    return 0;

  size_t res_len, total = 0;
  char *dst = buffer;
  size_t maxlen = buffer_size;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t body_length = res->len;

  res_len = snprintf(dst, maxlen, "HTTP/1.1 %d %s", (int)res->status, status_str(res->status));
  total += res_len;
  dst += res_len;
  maxlen -= res_len;

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    res_len = snprintf(dst, maxlen, "\r\n%s: %s", header->key, header->value);
    total += res_len;
    dst += res_len;
    maxlen -= res_len;
  }

  if (have_content_length) {
    res_len = snprintf(dst, maxlen, "\r\nContent-Length: %lu", body_length);
    total += res_len, dst += res_len, maxlen -= res_len;
  }

  memcpy(dst, "\r\n\r\n", 4);
  total += 4, dst += 4, maxlen -= 4;

  return total;
}

static inline size_t res_len(Request *req, ResWriter *res) {
  if (!req || !res)
    return 0;

  if (!res->status)
    res->status = STATUSOK;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t result = 0;
  result += STRLEN("HTTP/1.1 ");     // HTTP version
  result += 4;                       // Status code + space
  result += status_len(res->status); // Status name

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    result += 2;                       // "\r\n"
    result += strlen(header->key) + 2; // Header key + ':' + space
    result += strlen(header->value);   // header value
  }

  if (have_content_length) {
    result += 2;                          // "\r\n"
    result += STRLEN("Content-Length: "); // Header key
    result += countd(res->len);           // Header value
  }

  result += 4; // "\r\n\r\n"

  return result;
}

static inline int send_empty_res(Status status) {
  size_t res_len = STRLEN("HTTP/1.1 ")        // HTTP version
                   + countd((uint64_t)status) // status code
                   + 1                        // space
                   + (int)status_len(status)  // status string
                   + 4;                       // \r\n\r\n

  conn_t *conn = current_send;
  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, res_len);
  if (snprintf((char *)rec->iov_base, res_len + 1, "HTTP/1.1 %d %s\r\n\r\n", (int)status, status_str(status))
      != (int)res_len)
    return -1;

  return usendmsg(conn, 0, 1);
}

static inline ssize_t read_socket(int sockfd, size_t len) {
  if (len == 0 || sockfd <= 0)
    return 0;
  char buff[1024 * 8];
  return read(sockfd, buff, 1024 * 8);
}

static inline int read_method(Method *method, void *src) {
  if (memcmp(src, "GET", 3) == 0)
    *method = GET;
  else if (memcmp(src, "POST", 4) == 0)
    *method = POST;
  else if (memcmp(src, "HEAD", 4) == 0)
    *method = HEAD;
  else if (memcmp(src, "PUT", 3) == 0)
    *method = PUT;
  else if (memcmp(src, "DELETE", 6) == 0)
    *method = DELETE;
  else if (memcmp(src, "CONNECT", 7) == 0)
    *method = CONNECT;
  else if (memcmp(src, "OPTIONS", 7) == 0)
    *method = OPTIONS;
  else if (memcmp(src, "TRACE", 5) == 0)
    *method = TRACE;
  else if (memcmp(src, "PATCH", 5) == 0)
    *method = PATCH;
  else
    return -1;

  return 0;
}

static inline int sendmsg_res(Request *req, ResWriter *res) {
  conn_t *conn;
  size_t head_size, res_size;
  struct iovec *iov;

  conn = current_send;
  iov = &conn->ios[0];
  head_size = res_len(req, res);
  if (head_size == 0)
    return -1;

  conn->data_left += head_size;
  res_size = fmt_res(req, res, iov->iov_base, (head_size + 1));
  if (res_size != head_size)
    return -1;
  iov->iov_len = res_size;

  return usendmsg(conn, 0, conn->nios);
}

static inline int read_req(Request *req, char *req_buffer) {
  if (!req_buffer)
    return -1;
  /*** Method ***/
  char *sep = strchr(req_buffer, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }
  *sep = '\0';
  if (read_method(&req->method, req_buffer) < 0)
    return -1;

  /*** Path ***/
  char *fullpath = sep + 1;
  sep = strchr(fullpath, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }

  *sep = '\0';
  req->path = fullpath;
  /*** Params ***/
  char *paramStart = strchr(fullpath, '?');
  if (paramStart) {
    *paramStart++ = '\0';
    int params_count = 0;
    params_count = HK_parse_params(paramStart, req->params, MAX_URL_PARAMETERS);
    if (params_count > 0)
      req->params_count = params_count;
    else
      req->params_count = 0;
  } else {
    req->params = NULL;
    req->params_count = 0;
  }

  /*** Headers ***/
  char *headStart = strstr(sep + 1, "\r\n");
  char *headEnd = strstr(sep + 1, "\r\n\r\n");
  if (!headStart) {
    LOG("read_req: !headStart\n");
    return -1;
  };

  memset(headStart, 0, 2);
  headStart += 2;
  memset(headEnd, 0, 4);
  headEnd += 4;

  int headers_count = HK_parse_headers(headStart, req->headers, MAX_REQ_HEADERS);
  if (headers_count <= 0)
    return -1;
  req->headers_count = headers_count;

  /*** Host ***/
  int index = HK_get_header(req, "Host");
  if (index < 0)
    return -1;
  char *host = req->headers[index].value;
  req->hostname = host;

  /*** Port ***/
  char *colon = strchr(host, ':');
  if (colon) {
    *colon++ = '\0';
    req->port = atoi(colon);
  } else {
    req->port = PORT;
  }
  return 0;
}
static inline int process_req(Server *serv, conn_t *conn) {
  if (!conn || conn->fd == -1)
    return -1;

  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;
  if (read_req(&req, conn->ios[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    LOG("Err: route_index == -1\n");
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;
  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  sendmsg_res(&req, &res);

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int new_conn(int connfd) {
  if (connfd <= 0)
    return -1;

  current_recv = MP_use(KB * 2, connfd, false);
  current_send = MP_use(KB * 2, connfd, false);

  current_recv->recv_conn = current_recv;
  current_recv->send_conn = current_send;

  current_send->send_conn = current_send;
  current_send->recv_conn = current_recv;

  conn_t *conn = current_recv;
  if (ufrecvmsg(conn, 0, 1) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

static inline int resubmit_sendmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return usendmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int resubmir_recvmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    // FIXME the len should be increased
    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return urecvmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int handle_sendmsg_complete(conn_t *conn) {
  struct iovec *iov, *rec;

  MP_shed(conn, 1, conn->nios - 1);
  iov = &conn->ios[0];
  rec = &conn->rec[0];
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;

  return ufrecvmsg(conn->recv_conn, 0, 1);
}

static inline int handle_sendmsg(conn_t *conn, int res, bool zc) {
  if (!conn || conn->fd == -1)
    return -1;

  conn->data_left -= res;
  if (conn->data_left > 0)
    return resubmit_sendmsg(conn, res);

  if (zc)
    return 0;

  return handle_sendmsg_complete(conn);
}

static inline int handle_insplice(conn_t *conn) {
  conn->op = OUTSPLICE;
  return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
}
static inline int handle_outsplice(conn_t *conn, int res) {
  conn->data_left -= res;
  if (conn->data_left > 0) {
    conn->op = INSPLICE;
    return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
  }

  conn_t *recv_conn = conn->recv_conn;
  struct iovec *iov = &recv_conn->ios[0];
  memset(iov->iov_base, 0, iov->iov_len);
  if (urecv(recv_conn, iov->iov_base, iov->iov_len, MSG_PEEK) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

/*
static inline int handle_recv(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  void *bptr = conn->ios[0].iov_base;
  void *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  void *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  return process_req(serv, conn);
}
*/
static inline int find_route(Server *serv, char *bptr) {
  Request req = {0};
  if (read_method(&req.method, bptr) < 0) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  };
  char *space = strchr(bptr, ' ');
  req.path = (space + 1);
  space = strchr(req.path, ' ');
  *space = '\0';
  int route_index = match_route(serv, &req);
  *space = ' ';
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }
  return route_index;
}

static inline int run_handler(Server *serv, conn_t *conn, bool uses_body) {
  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;

  if (read_req(&req, conn->rec[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  if (uses_body) {
    int h_index = HK_get_header(&req, "Content-Length");
    long body_size = atol(req.headers[h_index].value);
    if (body_size >= 0) {
      req.body.ptr = conn->rec[1].iov_base;
      req.body.size = body_size;
    } else {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    }
  }

  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  if (sendmsg_res(&req, &res) < 0)
    return -1;

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int handle_frecvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  char *bptr = (char *)conn->ios[0].iov_base;
  char *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  char *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  size_t head_size = (headEnd + 4) - bptr;
  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  int route_index = find_route(serv, bptr);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  bool uses_body = serv->routes[route_index].uses_body;
  long body_size = get_content_length(headstart + 2, headEnd + 4);
  if (body_size == -1) {
    if (uses_body) {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    } else {
      body_size = 0;
    }
  }

  conn->head_size = head_size;
  if (!uses_body) {
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  if (res == (int)(head_size + body_size)) {
    size_t iov_index = MP_expand(conn, round_to_blocks(body_size), false);
    memcpy(conn->rec[iov_index].iov_base, headEnd + 4, body_size);
    conn->ios[iov_index].iov_len = body_size;
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  conn->data_left = body_size - (res - head_size);
  bool once = ((size_t)body_size > (size_t)((pool.nblocks * MP_BLOCK) / 10));
  size_t iov_index = MP_expand(conn, round_to_blocks(body_size), once);
  memcpy(conn->rec[iov_index].iov_base, headEnd + 4, (res - head_size));
  conn->ios[iov_index].iov_base += (res - head_size);

  return urecvmsg(conn, iov_index, 1);
}

static inline int handle_recvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  if (conn->data_left > 0) {
    conn->data_left -= res;
    if (conn->data_left == 0) {
      conn->flags &= CF_HANDLER_READY;
      return run_handler(serv, conn, true);
    }

    conn->flags &= ~CF_HANDLER_READY;
    conn->ios[1].iov_base += res;
    return urecvmsg(conn, 1, 1);
  }

  conn->flags &= CF_HANDLER_READY;
  return run_handler(serv, conn, true);
}

static inline int serv_init(Server *serv) {
#if DEBUG
  logfd = log_init("log.txt");
  if (!logfd) {
    printf("log_init failed");
    return -1;
  }
#endif
  serv->_nroutes = get_nroutes(serv->routes);

  int pipefd[2];
  if (pipe(pipefd) < 0)
    return -1;
  pipe_in = pipefd[0];
  pipe_out = pipefd[1];
  nullfd = open("/dev/null", O_WRONLY);
  pipe_sz = fcntl(pipefd[0], F_GETPIPE_SZ);
  if (pipe_sz < 0)
    return -1;

  pool.rtimeout = serv->rtimeout;
  pool.wtimeout = serv->wtimeout;
  if (MP_init(MAX_CONNS * 8) < 0)
    return -1;
  LOG("pool initialized\n");

  if (io_uring_queue_init(MAX_CONNS, &ring, 0) < 0)
    return -1;
  LOG("uring initialized\n");

  int listenfd;
  if ((listenfd = tcp_listen(serv->port)) < 0)
    return -1;
  LOG("socket initialized\n");

  return umaccept(listenfd);
}

static inline int serv_listen(Server *serv) {
  // uint64_t last_check = get_time();
  while (true) {
    // uint64_t now = get_time();
    // if ((now - last_check) >= 200) {
    //   last_check = now;
    //   LOG("CM: CM_check ran\n");
    //   MP_timeout();
    // }

    LOG("SQ ready: %u, CQ ready: %u\n", io_uring_sq_ready(&ring), io_uring_cq_ready(&ring));
    struct io_uring_cqe *cqe;
    if (io_uring_wait_cqe(&ring, &cqe) < 0)
      continue;

    int res = cqe->res;
    LOG("res = %d\n", res);
    conn_t *conn = NULL;
    if (cqe->user_data > 100) {
      conn = (conn_t *)cqe->user_data;
      current_recv = (conn_t *)conn->recv_conn;
      current_send = (conn_t *)conn->send_conn;
    }

    if (res > 0) {
      if (cqe->user_data == ACCEPT) {
        LOG("new conn created\n");
        new_conn(res);
      } else if (conn && conn->fd != -1) {
        LOG("conn[%d]: conn.fd = %d; conn.op = %d\n", conn->cindex, conn->fd, conn->op);
        switch (conn->op) {
        case FRECVMSG:
          if (handle_frecvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case RECVMSG:
          if (handle_recvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case SENDMSG:
        case SENDMSGZC:
          // conn->last_write = get_time();
          bool zc = (conn->op == SENDMSGZC);
          if (handle_sendmsg(conn, res, zc) < 0)
            MP_clear(conn);
          break;
        case INSPLICE:
          if (handle_insplice(conn) < 0)
            MP_clear(conn);
          break;
        case OUTSPLICE:
          if (handle_outsplice(conn, res) < 0)
            MP_clear(conn);
          break;
        }
      }
    } else if (res == 0) {
      if (conn && conn->fd != -1) {
        switch (conn->op) {
        case SENDMSGZC:
          conn->zc_notifs--;
          if (conn->zc_notifs == 0 && handle_sendmsg_complete(conn) < 0)
            MP_clear(conn);
          break;
        case RECV:
          MP_clear(conn);
          break;
        }
      }
    } else {
      if (conn && conn->fd != -1) {
        if (res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR) {
          LOG("conn && conn->fd != -1 && res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR\n");
          MP_clear(conn);
        } else {
          LOG("res == -EAGAIN || res == -EWOULDBLOCK || res == -EINTR\n");
          conn = conn->recv_conn;
          struct iovec *iov = &conn->ios[0];
          memset(iov->iov_base, 0, iov->iov_len);
          if (urecv(conn, iov->iov_base, iov->iov_len, 0) < 0)
            MP_clear(conn);
        }
      }
    }

    LOG("uring operation seen\n");
    io_uring_cqe_seen(&ring, cqe);
  }

  io_uring_queue_exit(&ring);
  MP_exit(&pool);
  return 0;
}

/*** Helper ***/
static inline int _HK_write(void *data, size_t size) {
  size_t nblocks;
  int iov_index;
  conn_t *conn;
  struct iovec *iov;
  bool once;

  conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  nblocks = round_to_blocks(size);
  iov_index = MP_expand(conn, nblocks, once);
  iov = &conn->ios[iov_index];

  memcpy(iov->iov_base, data, size);
  iov->iov_len = size;
  conn->data_left += size;

  return 0;
}
static inline int _HK_write_body(Request *req, size_t offset, size_t size) {
  if (size > req->body.size || offset > req->body.size)
    return -1;

  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  int iov_index = MP_expand(conn, 0, false);
  struct iovec *iov = &conn->ios[iov_index];
  struct iovec *rec = &conn->rec[iov_index];
  rec->iov_base = req->body.ptr + offset;
  rec->iov_len = size;
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;
  conn->data_left += rec->iov_len;
  return 0;
}
/*
static inline int _HK_mem(size_t size, HKMem *mem) {
  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  bool once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  size_t nblocks = round_to_blocks(size);
  int iov_index = MP_expand(conn, nblocks, once);
  struct iovec *iov = &conn->ios[iov_index];
  mem->ptr = iov->iov_base;
  mem->size = iov->iov_len;
  mem->_iov_index = iov_index;
  mem->_flags = (IN_POOL(iov->iov_base)) ? CF_IN_POOL : CF_IN_HEAP;
  return 0;
}

static inline void _HK_send(HKMem *mem, size_t size) {
  conn_t *conn = current_send;
  struct iovec *iov = &conn->ios[mem->_iov_index];
  iov->iov_len = size;
  conn->data_left += size;
}
  */
#endif#define _GNU_SOURCE
#ifndef UTILS_H
#define UTILS_H

#include "hunk.h"
#include <arpa/inet.h>
#include <fcntl.h>
#include <liburing.h>
#include <netdb.h>
#include <signal.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/poll.h>
#include <sys/prctl.h>
#include <sys/socket.h>
#include <sys/sysinfo.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

#define MP_BLOCK  4
#define MAX_CONNS 4096
#define KB        1024
#define NIOS      32

#define IN_POOL(ptr)                 ((void *)ptr >= pool.bpool && (void *)ptr <= (pool.bpool + (pool.npages * pool.pagesize)))
#define ALIGN_TO_PAGESIZE(buff_size) (((buff_size) + (pool.pagesize - 1)) & ~(pool.pagesize - 1))
#define BYTES_TO_BLOCKS(buff_size)   (((buff_size) + (MP_BLOCK - 1)) / MP_BLOCK)
#define CEIL_BLOCKS(nblocks)         ((nblocks + 63) & ~63)
#define CEIL_PAGES(size)             (((size) + ((pool.pagesize) - 1)) & ~((pool.pagesize) - 1))

#define BIT_IS_FREE(word, bit)   (((word) >> (bit)) & 1)
#define MARK_BIT_USED(word, bit) ((word) &= ~(1ULL << (bit)))
#define MARK_BIT_FREE(word, bit) ((word) |= (1ULL << (bit)))
#define FIND_FREE_BIT(word)      ((uint64_t)(word) & -(uint64_t)(word))
#define STRLEN(s)                (sizeof(s) - 1)

#define IOVEC_NBLOCKS (BYTES_TO_BLOCKS(NIOS * sizeof(struct iovec)))
#define MSG_NBLOCKS   (BYTES_TO_BLOCKS(sizeof(struct msghdr)))
#define ZC_RES        KB *KB

#define DEBUG 0
#if DEBUG
#define LOG(...) fprintf(logfd, __VA_ARGS__)
#else
#define LOG(...) ((void)0)
#endif

typedef enum UOP {
  WRITEV = IORING_OP_WRITEV,
  SENDMSG = IORING_OP_SENDMSG,
  RECVMSG = IORING_OP_RECVMSG,
  ACCEPT = IORING_OP_ACCEPT,
  SEND = IORING_OP_SEND,
  RECV = IORING_OP_RECV,
  SENDZC = IORING_OP_SEND_ZC,
  SENDMSGZC = IORING_OP_SENDMSG_ZC,
  PEEK = 50,
  FRECVMSG,
  INSPLICE,
  OUTSPLICE
} UOP;

typedef enum CFS {
  CF_IN_POOL = (1 << 0),       // Connection is in the pool
  CF_IN_HEAP = (1 << 1),       // Connection is in the heap
  CF_SKIP_SOCK = (1 << 2),     // Don't close the socket
  CF_USE_ONCE = (1 << 3),      // Destroy after using
  CF_HANDLER_READY = (1 << 4), // Ready to call the handler
} CFS;

typedef struct conn_t {
  // Socket file descriptor
  int fd;

  // Amount of data left in the current operation
  uint64_t data_left;

  // The index of the connection struct
  uint32_t cindex;

  // The last time the connection was readable
  uint64_t last_read;

  // The last time the connection was writeable
  uint64_t last_write;

  // The operation currently being processed
  uint8_t op;

  // Connection flags
  int flags;

  // Splice fd_in
  int in_fd;

  // Splice fd_out
  int out_fd;

  void *recv_conn;
  void *send_conn;

  struct iovec *ios;
  struct iovec *rec;
  uint16_t nios;

  struct msghdr *msg;
  uint16_t zc_notifs;

  uint16_t head_size;
} conn_t;

typedef struct MPool {
  // The allocated pool of blocks
  void *bpool;

  // The allocated pool of connections
  conn_t *cpool;

  // The size of the pool in pages
  uint32_t npages;

  // The size of the pool in blocks
  uint32_t nblocks;

  // The locations of each page in the pool
  void **blocks;

  // The availability of each block
  uint64_t *freebs;

  // The locations of each conn in the pool
  conn_t **conns;

  // The availability of each conn
  uint64_t *freecs;

  // Clean up callback function
  void (*callback)(conn_t *conn);

  // The page size used
  uint32_t pagesize;

  // Socket read timeout
  uint32_t rtimeout;

  // Socket write timeout
  uint32_t wtimeout;
} MPool;

extern int pipe_sz;
extern int pipe_in, pipe_out, nullfd;
extern FILE *logfd;
extern struct io_uring ring;
extern MPool pool;
extern conn_t *current_recv;
extern conn_t *current_send;

/*
 * Prepare and submit a recv uring op
 */
static inline int urecv(conn_t *conn, void *buffer, size_t buff_size, int flags) {
  if (!conn || conn->fd == -1)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (flags == MSG_PEEK) ? PEEK : RECV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;

  io_uring_prep_recv(sqe, conn->fd, buffer, buff_size, flags);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a multi-shot accept uring op
 */
static inline int umaccept(int listenfd) {
  if (listenfd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = ACCEPT;
  io_uring_prep_multishot_accept(sqe, listenfd, NULL, NULL, SOCK_NONBLOCK);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a splice uring op
 */
static inline int usplice(conn_t *conn, int fd_in, int64_t off_in, int fd_out, int64_t off_out, size_t len) {
  if (!len || !conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = (__u64)conn;
  io_uring_prep_splice(sqe, fd_in, off_in, fd_out, off_out, len, 0);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a writev uring op
 */
static inline int uwritev(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = WRITEV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  io_uring_prep_writev(sqe, conn->fd, &conn->ios[iov_index], nios, -1);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a send uring op
 */
static inline int usend(conn_t *conn, char *res_buff, size_t buff_size, bool zc) {
  if (!conn || conn->fd <= 0 || buff_size == 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (zc) ? SENDZC : SEND;
  conn->data_left = buff_size;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  if (zc)
    io_uring_prep_send_zc(sqe, conn->fd, res_buff, buff_size, 0, 0);
  else
    io_uring_prep_send(sqe, conn->fd, res_buff, buff_size, 0);
  return io_uring_submit(&ring);
}

static inline int ufrecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = FRECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;

  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, rec->iov_len);
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int urecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = RECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int usendmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  bool zc = (conn->data_left > ZC_RES) ? true : false;
  conn->op = (zc) ? SENDMSGZC : SENDMSG;

  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  if (zc) {
    io_uring_prep_sendmsg_zc(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
    conn->zc_notifs++;
  } else {
    io_uring_prep_sendmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  }
  return io_uring_submit(&ring);
}

/*
 * Create and initialize a server socket
 */
static inline int tcp_listen(uint16_t port) {
  int enable;
  int listenfd;
  if ((listenfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    return -1;

  int flags = fcntl(listenfd, F_GETFL, 0);
  fcntl(listenfd, F_SETFL, flags | O_NONBLOCK);
  struct sockaddr_in servaddr;
  memset(&servaddr, 0, sizeof(servaddr));
  servaddr.sin_family = AF_INET;
  servaddr.sin_addr.s_addr = INADDR_ANY;
  servaddr.sin_port = htons(port);

  enable = 1;
  if (setsockopt(listenfd, SOL_SOCKET, SO_REUSEPORT, &enable, sizeof(enable)) < 0)
    return -1;

  if (bind(listenfd, (struct sockaddr *)&servaddr, sizeof(servaddr)) < 0)
    return -1;

  if (listen(listenfd, SOMAXCONN) < 0)
    return -1;

  return listenfd;
}

/*
 * Calculate the difference between two pointers
 */
static inline uintptr_t ptr_diff(uintptr_t p1, uintptr_t p2) { return (uintptr_t)(p1 > p2) ? (p1 - p2) : (p2 - p1); }

static inline size_t get_nroutes(Route *routes) {
  Route *route;
  for (size_t i = 0;; i++) {
    route = &routes[i];
    if (!route->path && !route->handler && !route->method)
      return i;
  }
}

static inline long get_content_length(char *src, char *end) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return -1;
    key = line;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, "Content-Length") != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;

    *line_end = '\0';
    long res = atol(value);
    *line_end = '\r';

    return res;
  }
  return -1;
}

static inline bool have_header(char *src, char *end, const char *header_key, const char *header_value) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    key = line;
    while (*key == ' ')
      key++;
    while (*header_key == ' ')
      header_key++;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return false;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, header_key) != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;
    while (*header_value == ' ')
      header_value++;

    *line_end = '\0';
    bool res = (strcasecmp(value, header_value) == 0);
    *line_end = '\r';

    return res;
  }

  return false;
}

static inline const char *method_str(Method method) {
  switch (method) {
  case GET:
    return "GET";
    break;
  case HEAD:
    return "HEAD";
    break;
  case POST:
    return "POST";
    break;
  case PUT:
    return "PUT";
    break;
  case DELETE:
    return "DELETE";
    break;
  case CONNECT:
    return "CONNECT";
    break;
  case OPTIONS:
    return "OPTIONS";
    break;
  case TRACE:
    return "TRACE";
    break;
  case PATCH:
    return "PATCH";
    break;
  default:
    return NULL;
  }
}

static inline uint8_t method_len(Method method) {
  switch (method) {
  case GET:
    return 3;
    break;
  case HEAD:
    return 4;
    break;
  case POST:
    return 4;
    break;
  case PUT:
    return 3;
    break;
  case DELETE:
    return 6;
    break;
  case CONNECT:
    return 7;
    break;
  case OPTIONS:
    return 7;
    break;
  case TRACE:
    return 5;
    break;
  case PATCH:
    return 5;
    break;
  default:
    return 0;
  }
}

static inline size_t round_to_blocks(size_t size) {
  size_t nblocks = BYTES_TO_BLOCKS(size);
  nblocks = CEIL_BLOCKS(nblocks);
  return nblocks;
}

/*
 * Count the digits in unsigned 64-bit int
 */
static inline int countd(uint64_t num) {
  if (num < 10ULL)
    return 1;
  if (num < 100ULL)
    return 2;
  if (num < 1000ULL)
    return 3;
  if (num < 10000ULL)
    return 4;
  if (num < 100000ULL)
    return 5;
  if (num < 1000000ULL)
    return 6;
  if (num < 10000000ULL)
    return 7;
  if (num < 100000000ULL)
    return 8;
  if (num < 1000000000ULL)
    return 9;
  if (num < 10000000000ULL)
    return 10;
  if (num < 100000000000ULL)
    return 11;
  if (num < 1000000000000ULL)
    return 12;
  if (num < 10000000000000ULL)
    return 13;
  if (num < 100000000000000ULL)
    return 14;
  if (num < 1000000000000000ULL)
    return 15;
  if (num < 10000000000000000ULL)
    return 16;
  if (num < 100000000000000000ULL)
    return 17;
  if (num < 1000000000000000000ULL)
    return 18;
  if (num < 10000000000000000000ULL)
    return 19;
  return 20;
}

/*
 * Get the time elabsed in ms
 */
static inline uint64_t get_time() {
  struct timespec ts;
  clock_gettime(CLOCK_MONOTONIC, &ts);
  return (uint64_t)(ts.tv_sec) * 1000 + (ts.tv_nsec / 1000000);
}

static inline FILE *log_init(const char *path) {
  FILE *res = fopen(path, "a+");
  setvbuf(res, NULL, _IONBF, 0);
  return res;
}

static inline int16_t pollevs(int connfd) {
  struct pollfd pfd;
  pfd.fd = connfd;
  pfd.events = POLLIN | POLLOUT | POLLERR;
  int res = poll(&pfd, 1, 0);
  if (res < 0)
    return POLLERR;
  return pfd.revents;
}

// FIXME This needs to be updated
static inline conn_t *MP_use_once(size_t nblocks, int fd) {

  void *mem = malloc(sizeof(conn_t) + 8 + (IOVEC_NBLOCKS * MP_BLOCK));
  struct conn_t *conn = (conn_t *)mem;
  memset(conn, 0, sizeof(conn_t));
  conn->ios = mem + sizeof(conn_t) + 8;

  if (nblocks > 0) {
    struct iovec *iov = &conn->ios[conn->nios++];
    mem = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (mem == MAP_FAILED)
      return NULL;
    iov->iov_base = mem;
    iov->iov_len = ALIGN_TO_PAGESIZE(nblocks * MP_BLOCK);
  }

  conn->flags |= CF_IN_HEAP;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;

  return conn;
}

static inline int find_freec() {
  uint64_t *word;
  size_t map_size = (sizeof(uint64_t) * 8);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    word = &pool.freecs[i / map_size];

    if (*word == 0) { // All used
      i += (map_size - 1);
      continue;
    }

    i += __builtin_ctzll(*word);
    MARK_BIT_USED(*word, i);
    return i;
  }

  return -1;
}

static inline int MP_init(size_t npages) {
  if (!npages)
    return -1;

  /*** Setup ***/
  pool.npages = npages;
  pool.pagesize = sysconf(_SC_PAGESIZE);

  /*** Pool ***/
  pool.bpool = mmap(NULL, pool.npages * pool.pagesize, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  if (pool.bpool == MAP_FAILED)
    return -1;
  pool.nblocks = (pool.npages * pool.pagesize) / MP_BLOCK;

  /*** Blocks ***/
  pool.blocks = malloc(sizeof(void *) * pool.nblocks);
  if (!pool.blocks)
    return -1;
  for (size_t i = 0; i < pool.nblocks; i++)
    pool.blocks[i] = pool.bpool + (i * MP_BLOCK);

  /*** Freebs ***/
  // if (posix_memalign((void **)&pool.freebs, 64, bitmap_size * sizeof(uint64_t)) < 0)
  size_t bitmap_size = (pool.nblocks + 63) / 64;
  pool.freebs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freebs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freebs[i] = UINT64_MAX;

  /*** Cpool ***/
  pool.cpool = (conn_t *)malloc(sizeof(conn_t) * MAX_CONNS);
  if (!pool.cpool)
    return -1;

  /*** Conns ***/
  pool.conns = (conn_t **)malloc(sizeof(conn_t *) * MAX_CONNS);
  if (!pool.conns)
    return -1;
  size_t conn_size = sizeof(conn_t);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    pool.conns[i] = (conn_t *)((char *)pool.cpool + (i * conn_size));
    pool.conns[i]->fd = -1;
    pool.conns[i]->in_fd = -1;
    pool.conns[i]->out_fd = -1;
  }

  /*** Freecs ***/
  bitmap_size = (MAX_CONNS + 63) / 64;
  pool.freecs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freecs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freecs[i] = UINT64_MAX;

  return 0;
}

static inline int MP_use_blks(size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t max_start = pool.nblocks - nblocks;
  size_t full_chunks = (nblocks / 64) * 64;

  for (size_t i = 0, c = 0; i <= max_start; i++, c++) {
    bool free = true;

    for (size_t j = 0; j < full_chunks; j += 64) {
      size_t word_index = (i + j) / 64;
      if (pool.freebs[word_index] != UINT64_MAX) {
        free = false;
        i += 63;
        break;
      }
    }

    for (size_t j = full_chunks; j < nblocks; j++) {
      size_t bit_index = i + j;
      size_t word_index = bit_index / 64;
      size_t bit_in_word = bit_index % 64;

      if (!BIT_IS_FREE(pool.freebs[word_index], bit_in_word)) {
        free = false;
        i += j;
        break;
      }
    }

    if (free) {
      for (size_t j = 0; j < full_chunks; j += 64) {
        size_t word_index = (i + j) / 64;
        pool.freebs[word_index] = 0;
      }

      for (size_t j = full_chunks; j < nblocks; j++) {
        size_t bit_index = i + j;
        size_t word_index = bit_index / 64;
        size_t bit_in_word = bit_index % 64;

        MARK_BIT_USED(pool.freebs[word_index], bit_in_word);
      }

      return i;
    }
  }

  return -1;
}

static inline int MP_free_blks(size_t bindex, size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t full_chunks = (nblocks / 64) * 64;
  for (size_t i = 0; i < full_chunks; i += 64) {
    size_t word_index = (bindex + i) / 64;
    pool.freebs[word_index] = UINT64_MAX;
  }

  for (size_t i = full_chunks; i < nblocks; i++) {
    size_t bit_index = bindex + i;
    size_t word_index = bit_index / 64;
    size_t bit_in_word = bit_index % 64;

    MARK_BIT_FREE(pool.freebs[word_index], bit_in_word);
  }

  memset(pool.blocks[bindex], 0, nblocks * MP_BLOCK);
  return 0;
}

static inline conn_t *MP_use(size_t nblocks, int fd, bool once) {
  if (fd <= 0)
    return NULL;
  if (once)
    return MP_use_once(nblocks, fd);

  int cindex = find_freec();
  if (cindex < 0) {
    LOG("Err: cindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  conn_t *conn = pool.conns[cindex];

  int ios_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (ios_bindex < 0) {
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }

  struct iovec *ios = pool.blocks[ios_bindex];
  conn->ios = ios;

  int rec_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (rec_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct iovec *rec = pool.blocks[rec_bindex];
  conn->rec = rec;

  int msg_bindex = MP_use_blks(MSG_NBLOCKS);
  if (msg_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct msghdr *msg = pool.blocks[msg_bindex];
  conn->msg = msg;

  if (nblocks > 0) {
    int bindex = MP_use_blks(nblocks);
    if (bindex < 0) {
      MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
      MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
      MP_free_blks(msg_bindex, IOVEC_NBLOCKS);
      MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
      LOG("Err: bindex < 0; will use MP_use_once\n");
      return MP_use_once(nblocks, fd);
    }

    size_t iov_index = conn->nios++;
    struct iovec *iov = &conn->ios[iov_index];
    struct iovec *rec = &conn->rec[iov_index];
    iov->iov_base = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
  }

  conn->msg->msg_iov = conn->ios;
  conn->msg->msg_iovlen = conn->nios;
  conn->cindex = cindex;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;
  return conn;
}

static inline void MP_shed(conn_t *conn, size_t iov_index, size_t nios) {
  struct iovec *iov, *rec;
  size_t bindex, nblocks, index;

  for (size_t i = 0; i < nios; i++) {
    index = iov_index + i;
    iov = &conn->ios[index];
    rec = &conn->rec[index];
    if (!rec || !rec->iov_base)
      continue;
    if (!IN_POOL(rec->iov_base)) {
      munmap(rec->iov_base, rec->iov_len / pool.pagesize);
    } else {
      bindex = ptr_diff((uintptr_t)rec->iov_base, (uintptr_t)pool.bpool) / MP_BLOCK;
      nblocks = rec->iov_len / MP_BLOCK;
      MP_free_blks(bindex, nblocks);
    }
    memset(iov, 0, sizeof(struct iovec));
    memset(rec, 0, sizeof(struct iovec));
    conn->nios--;
  }
}

static inline int MP_expand(conn_t *conn, size_t nblocks, bool once) {
  void *bptr;
  int iov_index, bindex;
  struct iovec *iov, *rec;

  iov_index = conn->nios++;
  iov = &conn->ios[iov_index];
  rec = &conn->rec[iov_index];

  if (nblocks == 0)
    return iov_index;

  if (once) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_base = bptr;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
    return iov_index;
  }

  bindex = MP_use_blks(nblocks);
  if (bindex < 0) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_len = iov->iov_len;
  } else {
    bptr = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_len = iov->iov_len;
  }

  iov->iov_base = bptr;
  rec->iov_base = iov->iov_base;
  return iov_index;
}

static inline int MP_free(conn_t *conn) {
  if (!conn)
    return -1;
  size_t bindex, nblocks;
  uint64_t *word;

  MP_shed(conn, 0, conn->nios);
  if (conn->flags & CF_IN_HEAP) {
    if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
      close(conn->fd);
    free(conn);
    return 0;
  }

  word = &pool.freecs[conn->cindex / 64];
  if (conn->cindex > MAX_CONNS)
    return -1;
  else if (BIT_IS_FREE(*word, conn->cindex))
    return 0;

  bindex = ptr_diff((uintptr_t)conn->ios, (uintptr_t)pool.bpool) / MP_BLOCK;
  nblocks = IOVEC_NBLOCKS;
  MP_free_blks(bindex, nblocks);

  bindex = ptr_diff((uintptr_t)conn->rec, (uintptr_t)pool.bpool) / MP_BLOCK;
  MP_free_blks(bindex, nblocks);

  if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
    close(conn->fd);

  MARK_BIT_FREE(*word, conn->cindex);
  memset(conn, 0, sizeof(conn_t));
  conn->fd = -1;
  conn->in_fd = -1;
  conn->out_fd = -1;
  return 0;
}

static inline void MP_clear(conn_t *conn) {
  conn_t *recv_conn = conn->recv_conn;
  conn_t *send_conn = conn->send_conn;
  if (recv_conn)
    MP_free(recv_conn);
  if (send_conn)
    MP_free(send_conn);
}

static inline void MP_exit(MPool *pool) {
  munmap(pool->bpool, pool->npages);
  free(pool->cpool);
  free(pool->blocks);
  free(pool->conns);
  free(pool->freebs);
  free(pool->freecs);
}

static inline void MP_timeout() {
  conn_t *conn;
  int16_t res;
  uint64_t now;
  size_t windex = 0;
  uint64_t *word = &pool.freecs[0];
  for (size_t i = 0; i < MAX_CONNS; i++) {
    if ((i / 64) < windex)
      word = &pool.freecs[++windex];

    if (*word == UINTMAX_MAX) {
      i = (i / 64) * 64 + 64;
      continue;
    }

    conn = pool.conns[i];
    if (!conn || conn->fd == -1)
      continue;

    res = pollevs(conn->fd);

    now = get_time();
    if (res & POLLERR) {
      MP_clear(conn);
      continue;
    }
    if (res & POLLIN) {
      if (pool.rtimeout > 0 && (now - conn->last_read) >= pool.rtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (res & POLLOUT) {
      if (pool.wtimeout > 0 && (now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (!(res & POLLIN || res & POLLOUT)) {
      if ((pool.rtimeout > 0 && now - conn->last_read) >= pool.rtimeout
          || (pool.wtimeout > 0 && now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
  }
}

/*
 * Calculate the length of a status string
 */
static inline size_t status_len(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return 8;
  case STATUSSWITCHINGPROTOCOLS:
    return 19;
  case STATUSPROCESSING:
    return 10;
  case STATUSEARLYHINTS:
    return 11;
  case STATUSOK:
    return 2;
  case STATUSCREATED:
    return 7;
  case STATUSACCEPTED:
    return 8;
  case STATUSNONAUTHORITATIVE:
    return 29;
  case STATUSNOCONTENT:
    return 10;
  case STATUSRESETCONTENT:
    return 13;
  case STATUSPARTIALCONTENT:
    return 15;
  case STATUSMULTISTATUS:
    return 12;
  case STATUSALREADYREPORTED:
    return 16;
  case STATUSIMUSED:
    return 7;
  case STATUSMULTIPLECHOICES:
    return 16;
  case STATUSMOVEDPERMANENTLY:
    return 17;
  case STATUSFOUND:
    return 5;
  case STATUSSEEOTHER:
    return 9;
  case STATUSNOTMODIFIED:
    return 12;
  case STATUSUSEPROXY:
    return 9;
  case STATUSTEMPORARYREDIRECT:
    return 18;
  case STATUSPERMANENTREDIRECT:
    return 18;
  case STATUSBADREQUEST:
    return 11;
  case STATUSUNAUTHORIZED:
    return 12;
  case STATUSPAYMENTREQUIRED:
    return 16;
  case STATUSFORBIDDEN:
    return 9;
  case STATUSNOTFOUND:
    return 9;
  case STATUSMETHODNOTALLOWED:
    return 18;
  case STATUSNOTACCEPTABLE:
    return 14;
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return 29;
  case STATUSREQUESTTIMEOUT:
    return 15;
  case STATUSCONFLICT:
    return 8;
  case STATUSGONE:
    return 4;
  case STATUSLENGTHREQUIRED:
    return 15;
  case STATUSPRECONDITIONFAILED:
    return 19;
  case CONTENTTOOLARGE:
    return 17;
  case STATUSURITOOLONG:
    return 12;
  case STATUSUNSUPPORTEDMEDIATYPE:
    return 22;
  case STATUSRANGENOTSATISFIABLE:
    return 21;
  case STATUSEXPECTATIONFAILED:
    return 18;
  case STATUSMISDIRECTEDREQUEST:
    return 19;
  case STATUSUNPROCESSABLECONTENT:
    return 21;
  case STATUSLOCKED:
    return 6;
  case STATUSFAILEDDEPENDENCY:
    return 17;
  case STATUSTOOEARLY:
    return 9;
  case STATUSUPGRADEREQUIRED:
    return 16;
  case STATUSPRECONDITIONREQUIRED:
    return 21;
  case STATUSTOOMANYREQUESTS:
    return 17;
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return 31;
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return 29;
  case STATUSInternalServerError:
    return 21;
  case STATUSNOTIMPLEMENTED:
    return 15;
  case STATUSBADGATEWAY:
    return 11;
  case STATUSSERVICEUNAVAILABLE:
    return 19;
  case STATUSGATEWAYTIMEOUT:
    return 15;
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return 26;
  case STATUSVARIANTALSONEGOTIATES:
    return 23;
  case STATUSINSUFFICIENTSTORAGE:
    return 20;
  case STATUSLOOPDETECTED:
    return 13;
  case STATUSNOTEXTENDED:
    return 12;
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return 31;
  default:
    return 0;
  }
}

/*
 * Return the status code string as string literal
 */
static inline char *status_str(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return "Continue";
  case STATUSSWITCHINGPROTOCOLS:
    return "Switching Protocols";
  case STATUSPROCESSING:
    return "Processing";
  case STATUSEARLYHINTS:
    return "Early Hints";
  case STATUSOK:
    return "OK";
  case STATUSCREATED:
    return "Created";
  case STATUSACCEPTED:
    return "Accepted";
  case STATUSNONAUTHORITATIVE:
    return "Non-Authoritative Information";
  case STATUSNOCONTENT:
    return "No Content";
  case STATUSRESETCONTENT:
    return "Reset Content";
  case STATUSPARTIALCONTENT:
    return "Partial Content";
  case STATUSMULTISTATUS:
    return "Multi-Status";
  case STATUSALREADYREPORTED:
    return "Already Reported";
  case STATUSIMUSED:
    return "Im Used";
  case STATUSMULTIPLECHOICES:
    return "Multiple Choices";
  case STATUSMOVEDPERMANENTLY:
    return "Moved Permanently";
  case STATUSFOUND:
    return "Found";
  case STATUSSEEOTHER:
    return "See Other";
  case STATUSNOTMODIFIED:
    return "Not Modified";
  case STATUSUSEPROXY:
    return "Use Proxy";
  case STATUSTEMPORARYREDIRECT:
    return "Temporary Redirect";
  case STATUSPERMANENTREDIRECT:
    return "Permanent Redirect";
  case STATUSBADREQUEST:
    return "Bad Request";
  case STATUSUNAUTHORIZED:
    return "Unauthorized";
  case STATUSPAYMENTREQUIRED:
    return "Payment Required";
  case STATUSFORBIDDEN:
    return "Forbidden";
  case STATUSNOTFOUND:
    return "Not Found";
  case STATUSMETHODNOTALLOWED:
    return "Method Not Allowed";
  case STATUSNOTACCEPTABLE:
    return "Not Acceptable";
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return "Proxy Authentication Required";
  case STATUSREQUESTTIMEOUT:
    return "Request Timeout";
  case STATUSCONFLICT:
    return "Conflict";
  case STATUSGONE:
    return "Gone";
  case STATUSLENGTHREQUIRED:
    return "Length Required";
  case STATUSPRECONDITIONFAILED:
    return "Precondition Failed";
  case CONTENTTOOLARGE:
    return "Content Too Large";
  case STATUSURITOOLONG:
    return "URI Too Long";
  case STATUSUNSUPPORTEDMEDIATYPE:
    return "Unsupported Media Type";
  case STATUSRANGENOTSATISFIABLE:
    return "Range Not Satisfiable";
  case STATUSEXPECTATIONFAILED:
    return "Expectation Failed";
  case STATUSMISDIRECTEDREQUEST:
    return "Misdirected Request";
  case STATUSUNPROCESSABLECONTENT:
    return "Unprocessable Content";
  case STATUSLOCKED:
    return "Locked";
  case STATUSFAILEDDEPENDENCY:
    return "Failed Dependency";
  case STATUSTOOEARLY:
    return "Too Early";
  case STATUSUPGRADEREQUIRED:
    return "Upgrade Required";
  case STATUSPRECONDITIONREQUIRED:
    return "Precondition Required";
  case STATUSTOOMANYREQUESTS:
    return "Too Many Requests";
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return "Request Header Fields Too Large";
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return "Unavailable For Legal Reasons";
  case STATUSInternalServerError:
    return "Internal Server Error";
  case STATUSNOTIMPLEMENTED:
    return "Not Implemented";
  case STATUSBADGATEWAY:
    return "Bad Gateway";
  case STATUSSERVICEUNAVAILABLE:
    return "Service Unavailable";
  case STATUSGATEWAYTIMEOUT:
    return "Gateway Timeout";
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return "HTTP Version Not Supported";
  case STATUSVARIANTALSONEGOTIATES:
    return "Variant Also Negotiates";
  case STATUSINSUFFICIENTSTORAGE:
    return "Insufficient Storage";
  case STATUSLOOPDETECTED:
    return "Loop Detected";
  case STATUSNOTEXTENDED:
    return "Not Extended";
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return "Network Authentication Required";
  default:
    return 0;
  }
}

/*
 * Return true if routes match
 */
static inline bool route_equ(Route *route, Request *req) {
  return route->method == req->method && strncmp(route->path, req->path, strlen(route->path)) == 0;
}

/*
 * Return the matching route index on success. -1 on failure
 */
static inline int match_route(Server *serv, Request *req) {
  for (size_t i = 0; i < serv->_nroutes; i++) {
    Route route = serv->routes[i];
    if (!req->path || !route.path)
      continue;
    if (route_equ(&route, req))
      return i;
    else if (req->method == HEAD && route.method == GET && strcmp(route.path, req->path) == 0)
      return i;
  }
  return -1;
}

/*
 * Return true if the response should contain the Content-Length header
 */
static inline bool should_have_content_length(Request *req, ResWriter *res) {
  return (req->method != CONNECT              // CONNECT request
          && res->status != STATUSNOCONTENT   // 204 response
          && res->status != STATUSNOTMODIFIED // 304 response
          && res->status >= 200);             // 1xx response
}

/*
 * Format http response from the ResWriter.
 * Return response size on success, 0 on failure.
 */
static inline size_t fmt_res(Request *req, ResWriter *res, char *buffer, size_t buffer_size) {
  if (!res || !buffer || buffer_size == 0)
    return 0;

  size_t res_len, total = 0;
  char *dst = buffer;
  size_t maxlen = buffer_size;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t body_length = res->len;

  res_len = snprintf(dst, maxlen, "HTTP/1.1 %d %s", (int)res->status, status_str(res->status));
  total += res_len;
  dst += res_len;
  maxlen -= res_len;

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    res_len = snprintf(dst, maxlen, "\r\n%s: %s", header->key, header->value);
    total += res_len;
    dst += res_len;
    maxlen -= res_len;
  }

  if (have_content_length) {
    res_len = snprintf(dst, maxlen, "\r\nContent-Length: %lu", body_length);
    total += res_len, dst += res_len, maxlen -= res_len;
  }

  memcpy(dst, "\r\n\r\n", 4);
  total += 4, dst += 4, maxlen -= 4;

  return total;
}

static inline size_t res_len(Request *req, ResWriter *res) {
  if (!req || !res)
    return 0;

  if (!res->status)
    res->status = STATUSOK;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t result = 0;
  result += STRLEN("HTTP/1.1 ");     // HTTP version
  result += 4;                       // Status code + space
  result += status_len(res->status); // Status name

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    result += 2;                       // "\r\n"
    result += strlen(header->key) + 2; // Header key + ':' + space
    result += strlen(header->value);   // header value
  }

  if (have_content_length) {
    result += 2;                          // "\r\n"
    result += STRLEN("Content-Length: "); // Header key
    result += countd(res->len);           // Header value
  }

  result += 4; // "\r\n\r\n"

  return result;
}

static inline int send_empty_res(Status status) {
  size_t res_len = STRLEN("HTTP/1.1 ")        // HTTP version
                   + countd((uint64_t)status) // status code
                   + 1                        // space
                   + (int)status_len(status)  // status string
                   + 4;                       // \r\n\r\n

  conn_t *conn = current_send;
  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, res_len);
  if (snprintf((char *)rec->iov_base, res_len + 1, "HTTP/1.1 %d %s\r\n\r\n", (int)status, status_str(status))
      != (int)res_len)
    return -1;

  return usendmsg(conn, 0, 1);
}

static inline ssize_t read_socket(int sockfd, size_t len) {
  if (len == 0 || sockfd <= 0)
    return 0;
  char buff[1024 * 8];
  return read(sockfd, buff, 1024 * 8);
}

static inline int read_method(Method *method, void *src) {
  if (memcmp(src, "GET", 3) == 0)
    *method = GET;
  else if (memcmp(src, "POST", 4) == 0)
    *method = POST;
  else if (memcmp(src, "HEAD", 4) == 0)
    *method = HEAD;
  else if (memcmp(src, "PUT", 3) == 0)
    *method = PUT;
  else if (memcmp(src, "DELETE", 6) == 0)
    *method = DELETE;
  else if (memcmp(src, "CONNECT", 7) == 0)
    *method = CONNECT;
  else if (memcmp(src, "OPTIONS", 7) == 0)
    *method = OPTIONS;
  else if (memcmp(src, "TRACE", 5) == 0)
    *method = TRACE;
  else if (memcmp(src, "PATCH", 5) == 0)
    *method = PATCH;
  else
    return -1;

  return 0;
}

static inline int sendmsg_res(Request *req, ResWriter *res) {
  conn_t *conn;
  size_t head_size, res_size;
  struct iovec *iov;

  conn = current_send;
  iov = &conn->ios[0];
  head_size = res_len(req, res);
  if (head_size == 0)
    return -1;

  conn->data_left += head_size;
  res_size = fmt_res(req, res, iov->iov_base, (head_size + 1));
  if (res_size != head_size)
    return -1;
  iov->iov_len = res_size;

  return usendmsg(conn, 0, conn->nios);
}

static inline int read_req(Request *req, char *req_buffer) {
  if (!req_buffer)
    return -1;
  /*** Method ***/
  char *sep = strchr(req_buffer, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }
  *sep = '\0';
  if (read_method(&req->method, req_buffer) < 0)
    return -1;

  /*** Path ***/
  char *fullpath = sep + 1;
  sep = strchr(fullpath, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }

  *sep = '\0';
  req->path = fullpath;
  /*** Params ***/
  char *paramStart = strchr(fullpath, '?');
  if (paramStart) {
    *paramStart++ = '\0';
    int params_count = 0;
    params_count = HK_parse_params(paramStart, req->params, MAX_URL_PARAMETERS);
    if (params_count > 0)
      req->params_count = params_count;
    else
      req->params_count = 0;
  } else {
    req->params = NULL;
    req->params_count = 0;
  }

  /*** Headers ***/
  char *headStart = strstr(sep + 1, "\r\n");
  char *headEnd = strstr(sep + 1, "\r\n\r\n");
  if (!headStart) {
    LOG("read_req: !headStart\n");
    return -1;
  };

  memset(headStart, 0, 2);
  headStart += 2;
  memset(headEnd, 0, 4);
  headEnd += 4;

  int headers_count = HK_parse_headers(headStart, req->headers, MAX_REQ_HEADERS);
  if (headers_count <= 0)
    return -1;
  req->headers_count = headers_count;

  /*** Host ***/
  int index = HK_get_header(req, "Host");
  if (index < 0)
    return -1;
  char *host = req->headers[index].value;
  req->hostname = host;

  /*** Port ***/
  char *colon = strchr(host, ':');
  if (colon) {
    *colon++ = '\0';
    req->port = atoi(colon);
  } else {
    req->port = PORT;
  }
  return 0;
}
static inline int process_req(Server *serv, conn_t *conn) {
  if (!conn || conn->fd == -1)
    return -1;

  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;
  if (read_req(&req, conn->ios[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    LOG("Err: route_index == -1\n");
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;
  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  sendmsg_res(&req, &res);

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int new_conn(int connfd) {
  if (connfd <= 0)
    return -1;

  current_recv = MP_use(KB * 2, connfd, false);
  current_send = MP_use(KB * 2, connfd, false);

  current_recv->recv_conn = current_recv;
  current_recv->send_conn = current_send;

  current_send->send_conn = current_send;
  current_send->recv_conn = current_recv;

  conn_t *conn = current_recv;
  if (ufrecvmsg(conn, 0, 1) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

static inline int resubmit_sendmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return usendmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int resubmir_recvmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    // FIXME the len should be increased
    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return urecvmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int handle_sendmsg_complete(conn_t *conn) {
  struct iovec *iov, *rec;

  MP_shed(conn, 1, conn->nios - 1);
  iov = &conn->ios[0];
  rec = &conn->rec[0];
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;

  return ufrecvmsg(conn->recv_conn, 0, 1);
}

static inline int handle_sendmsg(conn_t *conn, int res, bool zc) {
  if (!conn || conn->fd == -1)
    return -1;

  conn->data_left -= res;
  if (conn->data_left > 0)
    return resubmit_sendmsg(conn, res);

  if (zc)
    return 0;

  return handle_sendmsg_complete(conn);
}

static inline int handle_insplice(conn_t *conn) {
  conn->op = OUTSPLICE;
  return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
}
static inline int handle_outsplice(conn_t *conn, int res) {
  conn->data_left -= res;
  if (conn->data_left > 0) {
    conn->op = INSPLICE;
    return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
  }

  conn_t *recv_conn = conn->recv_conn;
  struct iovec *iov = &recv_conn->ios[0];
  memset(iov->iov_base, 0, iov->iov_len);
  if (urecv(recv_conn, iov->iov_base, iov->iov_len, MSG_PEEK) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

/*
static inline int handle_recv(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  void *bptr = conn->ios[0].iov_base;
  void *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  void *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  return process_req(serv, conn);
}
*/
static inline int find_route(Server *serv, char *bptr) {
  Request req = {0};
  if (read_method(&req.method, bptr) < 0) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  };
  char *space = strchr(bptr, ' ');
  req.path = (space + 1);
  space = strchr(req.path, ' ');
  *space = '\0';
  int route_index = match_route(serv, &req);
  *space = ' ';
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }
  return route_index;
}

static inline int run_handler(Server *serv, conn_t *conn, bool uses_body) {
  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;

  if (read_req(&req, conn->rec[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  if (uses_body) {
    int h_index = HK_get_header(&req, "Content-Length");
    long body_size = atol(req.headers[h_index].value);
    if (body_size >= 0) {
      req.body.ptr = conn->rec[1].iov_base;
      req.body.size = body_size;
    } else {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    }
  }

  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  if (sendmsg_res(&req, &res) < 0)
    return -1;

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int handle_frecvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  char *bptr = (char *)conn->ios[0].iov_base;
  char *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  char *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  size_t head_size = (headEnd + 4) - bptr;
  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  int route_index = find_route(serv, bptr);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  bool uses_body = serv->routes[route_index].uses_body;
  long body_size = get_content_length(headstart + 2, headEnd + 4);
  if (body_size == -1) {
    if (uses_body) {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    } else {
      body_size = 0;
    }
  }

  conn->head_size = head_size;
  if (!uses_body) {
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  if (res == (int)(head_size + body_size)) {
    size_t iov_index = MP_expand(conn, round_to_blocks(body_size), false);
    memcpy(conn->rec[iov_index].iov_base, headEnd + 4, body_size);
    conn->ios[iov_index].iov_len = body_size;
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  conn->data_left = body_size - (res - head_size);
  bool once = ((size_t)body_size > (size_t)((pool.nblocks * MP_BLOCK) / 10));
  size_t iov_index = MP_expand(conn, round_to_blocks(body_size), once);
  memcpy(conn->rec[iov_index].iov_base, headEnd + 4, (res - head_size));
  conn->ios[iov_index].iov_base += (res - head_size);

  return urecvmsg(conn, iov_index, 1);
}

static inline int handle_recvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  if (conn->data_left > 0) {
    conn->data_left -= res;
    if (conn->data_left == 0) {
      conn->flags &= CF_HANDLER_READY;
      return run_handler(serv, conn, true);
    }

    conn->flags &= ~CF_HANDLER_READY;
    conn->ios[1].iov_base += res;
    return urecvmsg(conn, 1, 1);
  }

  conn->flags &= CF_HANDLER_READY;
  return run_handler(serv, conn, true);
}

static inline int serv_init(Server *serv) {
#if DEBUG
  logfd = log_init("log.txt");
  if (!logfd) {
    printf("log_init failed");
    return -1;
  }
#endif
  serv->_nroutes = get_nroutes(serv->routes);

  int pipefd[2];
  if (pipe(pipefd) < 0)
    return -1;
  pipe_in = pipefd[0];
  pipe_out = pipefd[1];
  nullfd = open("/dev/null", O_WRONLY);
  pipe_sz = fcntl(pipefd[0], F_GETPIPE_SZ);
  if (pipe_sz < 0)
    return -1;

  pool.rtimeout = serv->rtimeout;
  pool.wtimeout = serv->wtimeout;
  if (MP_init(MAX_CONNS * 8) < 0)
    return -1;
  LOG("pool initialized\n");

  if (io_uring_queue_init(MAX_CONNS, &ring, 0) < 0)
    return -1;
  LOG("uring initialized\n");

  int listenfd;
  if ((listenfd = tcp_listen(serv->port)) < 0)
    return -1;
  LOG("socket initialized\n");

  return umaccept(listenfd);
}

static inline int serv_listen(Server *serv) {
  // uint64_t last_check = get_time();
  while (true) {
    // uint64_t now = get_time();
    // if ((now - last_check) >= 200) {
    //   last_check = now;
    //   LOG("CM: CM_check ran\n");
    //   MP_timeout();
    // }

    LOG("SQ ready: %u, CQ ready: %u\n", io_uring_sq_ready(&ring), io_uring_cq_ready(&ring));
    struct io_uring_cqe *cqe;
    if (io_uring_wait_cqe(&ring, &cqe) < 0)
      continue;

    int res = cqe->res;
    LOG("res = %d\n", res);
    conn_t *conn = NULL;
    if (cqe->user_data > 100) {
      conn = (conn_t *)cqe->user_data;
      current_recv = (conn_t *)conn->recv_conn;
      current_send = (conn_t *)conn->send_conn;
    }

    if (res > 0) {
      if (cqe->user_data == ACCEPT) {
        LOG("new conn created\n");
        new_conn(res);
      } else if (conn && conn->fd != -1) {
        LOG("conn[%d]: conn.fd = %d; conn.op = %d\n", conn->cindex, conn->fd, conn->op);
        switch (conn->op) {
        case FRECVMSG:
          if (handle_frecvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case RECVMSG:
          if (handle_recvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case SENDMSG:
        case SENDMSGZC:
          // conn->last_write = get_time();
          bool zc = (conn->op == SENDMSGZC);
          if (handle_sendmsg(conn, res, zc) < 0)
            MP_clear(conn);
          break;
        case INSPLICE:
          if (handle_insplice(conn) < 0)
            MP_clear(conn);
          break;
        case OUTSPLICE:
          if (handle_outsplice(conn, res) < 0)
            MP_clear(conn);
          break;
        }
      }
    } else if (res == 0) {
      if (conn && conn->fd != -1) {
        switch (conn->op) {
        case SENDMSGZC:
          conn->zc_notifs--;
          if (conn->zc_notifs == 0 && handle_sendmsg_complete(conn) < 0)
            MP_clear(conn);
          break;
        case RECV:
          MP_clear(conn);
          break;
        }
      }
    } else {
      if (conn && conn->fd != -1) {
        if (res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR) {
          LOG("conn && conn->fd != -1 && res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR\n");
          MP_clear(conn);
        } else {
          LOG("res == -EAGAIN || res == -EWOULDBLOCK || res == -EINTR\n");
          conn = conn->recv_conn;
          struct iovec *iov = &conn->ios[0];
          memset(iov->iov_base, 0, iov->iov_len);
          if (urecv(conn, iov->iov_base, iov->iov_len, 0) < 0)
            MP_clear(conn);
        }
      }
    }

    LOG("uring operation seen\n");
    io_uring_cqe_seen(&ring, cqe);
  }

  io_uring_queue_exit(&ring);
  MP_exit(&pool);
  return 0;
}

/*** Helper ***/
static inline int _HK_write(void *data, size_t size) {
  size_t nblocks;
  int iov_index;
  conn_t *conn;
  struct iovec *iov;
  bool once;

  conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  nblocks = round_to_blocks(size);
  iov_index = MP_expand(conn, nblocks, once);
  iov = &conn->ios[iov_index];

  memcpy(iov->iov_base, data, size);
  iov->iov_len = size;
  conn->data_left += size;

  return 0;
}
static inline int _HK_write_body(Request *req, size_t offset, size_t size) {
  if (size > req->body.size || offset > req->body.size)
    return -1;

  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  int iov_index = MP_expand(conn, 0, false);
  struct iovec *iov = &conn->ios[iov_index];
  struct iovec *rec = &conn->rec[iov_index];
  rec->iov_base = req->body.ptr + offset;
  rec->iov_len = size;
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;
  conn->data_left += rec->iov_len;
  return 0;
}
/*
static inline int _HK_mem(size_t size, HKMem *mem) {
  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  bool once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  size_t nblocks = round_to_blocks(size);
  int iov_index = MP_expand(conn, nblocks, once);
  struct iovec *iov = &conn->ios[iov_index];
  mem->ptr = iov->iov_base;
  mem->size = iov->iov_len;
  mem->_iov_index = iov_index;
  mem->_flags = (IN_POOL(iov->iov_base)) ? CF_IN_POOL : CF_IN_HEAP;
  return 0;
}

static inline void _HK_send(HKMem *mem, size_t size) {
  conn_t *conn = current_send;
  struct iovec *iov = &conn->ios[mem->_iov_index];
  iov->iov_len = size;
  conn->data_left += size;
}
  */
#endif#define _GNU_SOURCE
#ifndef UTILS_H
#define UTILS_H

#include "hunk.h"
#include <arpa/inet.h>
#include <fcntl.h>
#include <liburing.h>
#include <netdb.h>
#include <signal.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/poll.h>
#include <sys/prctl.h>
#include <sys/socket.h>
#include <sys/sysinfo.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

#define MP_BLOCK  4
#define MAX_CONNS 4096
#define KB        1024
#define NIOS      32

#define IN_POOL(ptr)                 ((void *)ptr >= pool.bpool && (void *)ptr <= (pool.bpool + (pool.npages * pool.pagesize)))
#define ALIGN_TO_PAGESIZE(buff_size) (((buff_size) + (pool.pagesize - 1)) & ~(pool.pagesize - 1))
#define BYTES_TO_BLOCKS(buff_size)   (((buff_size) + (MP_BLOCK - 1)) / MP_BLOCK)
#define CEIL_BLOCKS(nblocks)         ((nblocks + 63) & ~63)
#define CEIL_PAGES(size)             (((size) + ((pool.pagesize) - 1)) & ~((pool.pagesize) - 1))

#define BIT_IS_FREE(word, bit)   (((word) >> (bit)) & 1)
#define MARK_BIT_USED(word, bit) ((word) &= ~(1ULL << (bit)))
#define MARK_BIT_FREE(word, bit) ((word) |= (1ULL << (bit)))
#define FIND_FREE_BIT(word)      ((uint64_t)(word) & -(uint64_t)(word))
#define STRLEN(s)                (sizeof(s) - 1)

#define IOVEC_NBLOCKS (BYTES_TO_BLOCKS(NIOS * sizeof(struct iovec)))
#define MSG_NBLOCKS   (BYTES_TO_BLOCKS(sizeof(struct msghdr)))
#define ZC_RES        KB *KB

#define DEBUG 0
#if DEBUG
#define LOG(...) fprintf(logfd, __VA_ARGS__)
#else
#define LOG(...) ((void)0)
#endif

typedef enum UOP {
  WRITEV = IORING_OP_WRITEV,
  SENDMSG = IORING_OP_SENDMSG,
  RECVMSG = IORING_OP_RECVMSG,
  ACCEPT = IORING_OP_ACCEPT,
  SEND = IORING_OP_SEND,
  RECV = IORING_OP_RECV,
  SENDZC = IORING_OP_SEND_ZC,
  SENDMSGZC = IORING_OP_SENDMSG_ZC,
  PEEK = 50,
  FRECVMSG,
  INSPLICE,
  OUTSPLICE
} UOP;

typedef enum CFS {
  CF_IN_POOL = (1 << 0),       // Connection is in the pool
  CF_IN_HEAP = (1 << 1),       // Connection is in the heap
  CF_SKIP_SOCK = (1 << 2),     // Don't close the socket
  CF_USE_ONCE = (1 << 3),      // Destroy after using
  CF_HANDLER_READY = (1 << 4), // Ready to call the handler
} CFS;

typedef struct conn_t {
  // Socket file descriptor
  int fd;

  // Amount of data left in the current operation
  uint64_t data_left;

  // The index of the connection struct
  uint32_t cindex;

  // The last time the connection was readable
  uint64_t last_read;

  // The last time the connection was writeable
  uint64_t last_write;

  // The operation currently being processed
  uint8_t op;

  // Connection flags
  int flags;

  // Splice fd_in
  int in_fd;

  // Splice fd_out
  int out_fd;

  void *recv_conn;
  void *send_conn;

  struct iovec *ios;
  struct iovec *rec;
  uint16_t nios;

  struct msghdr *msg;
  uint16_t zc_notifs;

  uint16_t head_size;
} conn_t;

typedef struct MPool {
  // The allocated pool of blocks
  void *bpool;

  // The allocated pool of connections
  conn_t *cpool;

  // The size of the pool in pages
  uint32_t npages;

  // The size of the pool in blocks
  uint32_t nblocks;

  // The locations of each page in the pool
  void **blocks;

  // The availability of each block
  uint64_t *freebs;

  // The locations of each conn in the pool
  conn_t **conns;

  // The availability of each conn
  uint64_t *freecs;

  // Clean up callback function
  void (*callback)(conn_t *conn);

  // The page size used
  uint32_t pagesize;

  // Socket read timeout
  uint32_t rtimeout;

  // Socket write timeout
  uint32_t wtimeout;
} MPool;

extern int pipe_sz;
extern int pipe_in, pipe_out, nullfd;
extern FILE *logfd;
extern struct io_uring ring;
extern MPool pool;
extern conn_t *current_recv;
extern conn_t *current_send;

/*
 * Prepare and submit a recv uring op
 */
static inline int urecv(conn_t *conn, void *buffer, size_t buff_size, int flags) {
  if (!conn || conn->fd == -1)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (flags == MSG_PEEK) ? PEEK : RECV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;

  io_uring_prep_recv(sqe, conn->fd, buffer, buff_size, flags);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a multi-shot accept uring op
 */
static inline int umaccept(int listenfd) {
  if (listenfd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = ACCEPT;
  io_uring_prep_multishot_accept(sqe, listenfd, NULL, NULL, SOCK_NONBLOCK);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a splice uring op
 */
static inline int usplice(conn_t *conn, int fd_in, int64_t off_in, int fd_out, int64_t off_out, size_t len) {
  if (!len || !conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = (__u64)conn;
  io_uring_prep_splice(sqe, fd_in, off_in, fd_out, off_out, len, 0);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a writev uring op
 */
static inline int uwritev(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = WRITEV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  io_uring_prep_writev(sqe, conn->fd, &conn->ios[iov_index], nios, -1);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a send uring op
 */
static inline int usend(conn_t *conn, char *res_buff, size_t buff_size, bool zc) {
  if (!conn || conn->fd <= 0 || buff_size == 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (zc) ? SENDZC : SEND;
  conn->data_left = buff_size;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  if (zc)
    io_uring_prep_send_zc(sqe, conn->fd, res_buff, buff_size, 0, 0);
  else
    io_uring_prep_send(sqe, conn->fd, res_buff, buff_size, 0);
  return io_uring_submit(&ring);
}

static inline int ufrecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = FRECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;

  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, rec->iov_len);
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int urecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = RECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int usendmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  bool zc = (conn->data_left > ZC_RES) ? true : false;
  conn->op = (zc) ? SENDMSGZC : SENDMSG;

  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  if (zc) {
    io_uring_prep_sendmsg_zc(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
    conn->zc_notifs++;
  } else {
    io_uring_prep_sendmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  }
  return io_uring_submit(&ring);
}

/*
 * Create and initialize a server socket
 */
static inline int tcp_listen(uint16_t port) {
  int enable;
  int listenfd;
  if ((listenfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    return -1;

  int flags = fcntl(listenfd, F_GETFL, 0);
  fcntl(listenfd, F_SETFL, flags | O_NONBLOCK);
  struct sockaddr_in servaddr;
  memset(&servaddr, 0, sizeof(servaddr));
  servaddr.sin_family = AF_INET;
  servaddr.sin_addr.s_addr = INADDR_ANY;
  servaddr.sin_port = htons(port);

  enable = 1;
  if (setsockopt(listenfd, SOL_SOCKET, SO_REUSEPORT, &enable, sizeof(enable)) < 0)
    return -1;

  if (bind(listenfd, (struct sockaddr *)&servaddr, sizeof(servaddr)) < 0)
    return -1;

  if (listen(listenfd, SOMAXCONN) < 0)
    return -1;

  return listenfd;
}

/*
 * Calculate the difference between two pointers
 */
static inline uintptr_t ptr_diff(uintptr_t p1, uintptr_t p2) { return (uintptr_t)(p1 > p2) ? (p1 - p2) : (p2 - p1); }

static inline size_t get_nroutes(Route *routes) {
  Route *route;
  for (size_t i = 0;; i++) {
    route = &routes[i];
    if (!route->path && !route->handler && !route->method)
      return i;
  }
}

static inline long get_content_length(char *src, char *end) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return -1;
    key = line;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, "Content-Length") != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;

    *line_end = '\0';
    long res = atol(value);
    *line_end = '\r';

    return res;
  }
  return -1;
}

static inline bool have_header(char *src, char *end, const char *header_key, const char *header_value) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    key = line;
    while (*key == ' ')
      key++;
    while (*header_key == ' ')
      header_key++;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return false;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, header_key) != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;
    while (*header_value == ' ')
      header_value++;

    *line_end = '\0';
    bool res = (strcasecmp(value, header_value) == 0);
    *line_end = '\r';

    return res;
  }

  return false;
}

static inline const char *method_str(Method method) {
  switch (method) {
  case GET:
    return "GET";
    break;
  case HEAD:
    return "HEAD";
    break;
  case POST:
    return "POST";
    break;
  case PUT:
    return "PUT";
    break;
  case DELETE:
    return "DELETE";
    break;
  case CONNECT:
    return "CONNECT";
    break;
  case OPTIONS:
    return "OPTIONS";
    break;
  case TRACE:
    return "TRACE";
    break;
  case PATCH:
    return "PATCH";
    break;
  default:
    return NULL;
  }
}

static inline uint8_t method_len(Method method) {
  switch (method) {
  case GET:
    return 3;
    break;
  case HEAD:
    return 4;
    break;
  case POST:
    return 4;
    break;
  case PUT:
    return 3;
    break;
  case DELETE:
    return 6;
    break;
  case CONNECT:
    return 7;
    break;
  case OPTIONS:
    return 7;
    break;
  case TRACE:
    return 5;
    break;
  case PATCH:
    return 5;
    break;
  default:
    return 0;
  }
}

static inline size_t round_to_blocks(size_t size) {
  size_t nblocks = BYTES_TO_BLOCKS(size);
  nblocks = CEIL_BLOCKS(nblocks);
  return nblocks;
}

/*
 * Count the digits in unsigned 64-bit int
 */
static inline int countd(uint64_t num) {
  if (num < 10ULL)
    return 1;
  if (num < 100ULL)
    return 2;
  if (num < 1000ULL)
    return 3;
  if (num < 10000ULL)
    return 4;
  if (num < 100000ULL)
    return 5;
  if (num < 1000000ULL)
    return 6;
  if (num < 10000000ULL)
    return 7;
  if (num < 100000000ULL)
    return 8;
  if (num < 1000000000ULL)
    return 9;
  if (num < 10000000000ULL)
    return 10;
  if (num < 100000000000ULL)
    return 11;
  if (num < 1000000000000ULL)
    return 12;
  if (num < 10000000000000ULL)
    return 13;
  if (num < 100000000000000ULL)
    return 14;
  if (num < 1000000000000000ULL)
    return 15;
  if (num < 10000000000000000ULL)
    return 16;
  if (num < 100000000000000000ULL)
    return 17;
  if (num < 1000000000000000000ULL)
    return 18;
  if (num < 10000000000000000000ULL)
    return 19;
  return 20;
}

/*
 * Get the time elabsed in ms
 */
static inline uint64_t get_time() {
  struct timespec ts;
  clock_gettime(CLOCK_MONOTONIC, &ts);
  return (uint64_t)(ts.tv_sec) * 1000 + (ts.tv_nsec / 1000000);
}

static inline FILE *log_init(const char *path) {
  FILE *res = fopen(path, "a+");
  setvbuf(res, NULL, _IONBF, 0);
  return res;
}

static inline int16_t pollevs(int connfd) {
  struct pollfd pfd;
  pfd.fd = connfd;
  pfd.events = POLLIN | POLLOUT | POLLERR;
  int res = poll(&pfd, 1, 0);
  if (res < 0)
    return POLLERR;
  return pfd.revents;
}

// FIXME This needs to be updated
static inline conn_t *MP_use_once(size_t nblocks, int fd) {

  void *mem = malloc(sizeof(conn_t) + 8 + (IOVEC_NBLOCKS * MP_BLOCK));
  struct conn_t *conn = (conn_t *)mem;
  memset(conn, 0, sizeof(conn_t));
  conn->ios = mem + sizeof(conn_t) + 8;

  if (nblocks > 0) {
    struct iovec *iov = &conn->ios[conn->nios++];
    mem = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (mem == MAP_FAILED)
      return NULL;
    iov->iov_base = mem;
    iov->iov_len = ALIGN_TO_PAGESIZE(nblocks * MP_BLOCK);
  }

  conn->flags |= CF_IN_HEAP;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;

  return conn;
}

static inline int find_freec() {
  uint64_t *word;
  size_t map_size = (sizeof(uint64_t) * 8);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    word = &pool.freecs[i / map_size];

    if (*word == 0) { // All used
      i += (map_size - 1);
      continue;
    }

    i += __builtin_ctzll(*word);
    MARK_BIT_USED(*word, i);
    return i;
  }

  return -1;
}

static inline int MP_init(size_t npages) {
  if (!npages)
    return -1;

  /*** Setup ***/
  pool.npages = npages;
  pool.pagesize = sysconf(_SC_PAGESIZE);

  /*** Pool ***/
  pool.bpool = mmap(NULL, pool.npages * pool.pagesize, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  if (pool.bpool == MAP_FAILED)
    return -1;
  pool.nblocks = (pool.npages * pool.pagesize) / MP_BLOCK;

  /*** Blocks ***/
  pool.blocks = malloc(sizeof(void *) * pool.nblocks);
  if (!pool.blocks)
    return -1;
  for (size_t i = 0; i < pool.nblocks; i++)
    pool.blocks[i] = pool.bpool + (i * MP_BLOCK);

  /*** Freebs ***/
  // if (posix_memalign((void **)&pool.freebs, 64, bitmap_size * sizeof(uint64_t)) < 0)
  size_t bitmap_size = (pool.nblocks + 63) / 64;
  pool.freebs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freebs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freebs[i] = UINT64_MAX;

  /*** Cpool ***/
  pool.cpool = (conn_t *)malloc(sizeof(conn_t) * MAX_CONNS);
  if (!pool.cpool)
    return -1;

  /*** Conns ***/
  pool.conns = (conn_t **)malloc(sizeof(conn_t *) * MAX_CONNS);
  if (!pool.conns)
    return -1;
  size_t conn_size = sizeof(conn_t);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    pool.conns[i] = (conn_t *)((char *)pool.cpool + (i * conn_size));
    pool.conns[i]->fd = -1;
    pool.conns[i]->in_fd = -1;
    pool.conns[i]->out_fd = -1;
  }

  /*** Freecs ***/
  bitmap_size = (MAX_CONNS + 63) / 64;
  pool.freecs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freecs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freecs[i] = UINT64_MAX;

  return 0;
}

static inline int MP_use_blks(size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t max_start = pool.nblocks - nblocks;
  size_t full_chunks = (nblocks / 64) * 64;

  for (size_t i = 0, c = 0; i <= max_start; i++, c++) {
    bool free = true;

    for (size_t j = 0; j < full_chunks; j += 64) {
      size_t word_index = (i + j) / 64;
      if (pool.freebs[word_index] != UINT64_MAX) {
        free = false;
        i += 63;
        break;
      }
    }

    for (size_t j = full_chunks; j < nblocks; j++) {
      size_t bit_index = i + j;
      size_t word_index = bit_index / 64;
      size_t bit_in_word = bit_index % 64;

      if (!BIT_IS_FREE(pool.freebs[word_index], bit_in_word)) {
        free = false;
        i += j;
        break;
      }
    }

    if (free) {
      for (size_t j = 0; j < full_chunks; j += 64) {
        size_t word_index = (i + j) / 64;
        pool.freebs[word_index] = 0;
      }

      for (size_t j = full_chunks; j < nblocks; j++) {
        size_t bit_index = i + j;
        size_t word_index = bit_index / 64;
        size_t bit_in_word = bit_index % 64;

        MARK_BIT_USED(pool.freebs[word_index], bit_in_word);
      }

      return i;
    }
  }

  return -1;
}

static inline int MP_free_blks(size_t bindex, size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t full_chunks = (nblocks / 64) * 64;
  for (size_t i = 0; i < full_chunks; i += 64) {
    size_t word_index = (bindex + i) / 64;
    pool.freebs[word_index] = UINT64_MAX;
  }

  for (size_t i = full_chunks; i < nblocks; i++) {
    size_t bit_index = bindex + i;
    size_t word_index = bit_index / 64;
    size_t bit_in_word = bit_index % 64;

    MARK_BIT_FREE(pool.freebs[word_index], bit_in_word);
  }

  memset(pool.blocks[bindex], 0, nblocks * MP_BLOCK);
  return 0;
}

static inline conn_t *MP_use(size_t nblocks, int fd, bool once) {
  if (fd <= 0)
    return NULL;
  if (once)
    return MP_use_once(nblocks, fd);

  int cindex = find_freec();
  if (cindex < 0) {
    LOG("Err: cindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  conn_t *conn = pool.conns[cindex];

  int ios_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (ios_bindex < 0) {
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }

  struct iovec *ios = pool.blocks[ios_bindex];
  conn->ios = ios;

  int rec_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (rec_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct iovec *rec = pool.blocks[rec_bindex];
  conn->rec = rec;

  int msg_bindex = MP_use_blks(MSG_NBLOCKS);
  if (msg_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct msghdr *msg = pool.blocks[msg_bindex];
  conn->msg = msg;

  if (nblocks > 0) {
    int bindex = MP_use_blks(nblocks);
    if (bindex < 0) {
      MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
      MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
      MP_free_blks(msg_bindex, IOVEC_NBLOCKS);
      MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
      LOG("Err: bindex < 0; will use MP_use_once\n");
      return MP_use_once(nblocks, fd);
    }

    size_t iov_index = conn->nios++;
    struct iovec *iov = &conn->ios[iov_index];
    struct iovec *rec = &conn->rec[iov_index];
    iov->iov_base = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
  }

  conn->msg->msg_iov = conn->ios;
  conn->msg->msg_iovlen = conn->nios;
  conn->cindex = cindex;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;
  return conn;
}

static inline void MP_shed(conn_t *conn, size_t iov_index, size_t nios) {
  struct iovec *iov, *rec;
  size_t bindex, nblocks, index;

  for (size_t i = 0; i < nios; i++) {
    index = iov_index + i;
    iov = &conn->ios[index];
    rec = &conn->rec[index];
    if (!rec || !rec->iov_base)
      continue;
    if (!IN_POOL(rec->iov_base)) {
      munmap(rec->iov_base, rec->iov_len / pool.pagesize);
    } else {
      bindex = ptr_diff((uintptr_t)rec->iov_base, (uintptr_t)pool.bpool) / MP_BLOCK;
      nblocks = rec->iov_len / MP_BLOCK;
      MP_free_blks(bindex, nblocks);
    }
    memset(iov, 0, sizeof(struct iovec));
    memset(rec, 0, sizeof(struct iovec));
    conn->nios--;
  }
}

static inline int MP_expand(conn_t *conn, size_t nblocks, bool once) {
  void *bptr;
  int iov_index, bindex;
  struct iovec *iov, *rec;

  iov_index = conn->nios++;
  iov = &conn->ios[iov_index];
  rec = &conn->rec[iov_index];

  if (nblocks == 0)
    return iov_index;

  if (once) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_base = bptr;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
    return iov_index;
  }

  bindex = MP_use_blks(nblocks);
  if (bindex < 0) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_len = iov->iov_len;
  } else {
    bptr = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_len = iov->iov_len;
  }

  iov->iov_base = bptr;
  rec->iov_base = iov->iov_base;
  return iov_index;
}

static inline int MP_free(conn_t *conn) {
  if (!conn)
    return -1;
  size_t bindex, nblocks;
  uint64_t *word;

  MP_shed(conn, 0, conn->nios);
  if (conn->flags & CF_IN_HEAP) {
    if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
      close(conn->fd);
    free(conn);
    return 0;
  }

  word = &pool.freecs[conn->cindex / 64];
  if (conn->cindex > MAX_CONNS)
    return -1;
  else if (BIT_IS_FREE(*word, conn->cindex))
    return 0;

  bindex = ptr_diff((uintptr_t)conn->ios, (uintptr_t)pool.bpool) / MP_BLOCK;
  nblocks = IOVEC_NBLOCKS;
  MP_free_blks(bindex, nblocks);

  bindex = ptr_diff((uintptr_t)conn->rec, (uintptr_t)pool.bpool) / MP_BLOCK;
  MP_free_blks(bindex, nblocks);

  if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
    close(conn->fd);

  MARK_BIT_FREE(*word, conn->cindex);
  memset(conn, 0, sizeof(conn_t));
  conn->fd = -1;
  conn->in_fd = -1;
  conn->out_fd = -1;
  return 0;
}

static inline void MP_clear(conn_t *conn) {
  conn_t *recv_conn = conn->recv_conn;
  conn_t *send_conn = conn->send_conn;
  if (recv_conn)
    MP_free(recv_conn);
  if (send_conn)
    MP_free(send_conn);
}

static inline void MP_exit(MPool *pool) {
  munmap(pool->bpool, pool->npages);
  free(pool->cpool);
  free(pool->blocks);
  free(pool->conns);
  free(pool->freebs);
  free(pool->freecs);
}

static inline void MP_timeout() {
  conn_t *conn;
  int16_t res;
  uint64_t now;
  size_t windex = 0;
  uint64_t *word = &pool.freecs[0];
  for (size_t i = 0; i < MAX_CONNS; i++) {
    if ((i / 64) < windex)
      word = &pool.freecs[++windex];

    if (*word == UINTMAX_MAX) {
      i = (i / 64) * 64 + 64;
      continue;
    }

    conn = pool.conns[i];
    if (!conn || conn->fd == -1)
      continue;

    res = pollevs(conn->fd);

    now = get_time();
    if (res & POLLERR) {
      MP_clear(conn);
      continue;
    }
    if (res & POLLIN) {
      if (pool.rtimeout > 0 && (now - conn->last_read) >= pool.rtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (res & POLLOUT) {
      if (pool.wtimeout > 0 && (now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (!(res & POLLIN || res & POLLOUT)) {
      if ((pool.rtimeout > 0 && now - conn->last_read) >= pool.rtimeout
          || (pool.wtimeout > 0 && now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
  }
}

/*
 * Calculate the length of a status string
 */
static inline size_t status_len(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return 8;
  case STATUSSWITCHINGPROTOCOLS:
    return 19;
  case STATUSPROCESSING:
    return 10;
  case STATUSEARLYHINTS:
    return 11;
  case STATUSOK:
    return 2;
  case STATUSCREATED:
    return 7;
  case STATUSACCEPTED:
    return 8;
  case STATUSNONAUTHORITATIVE:
    return 29;
  case STATUSNOCONTENT:
    return 10;
  case STATUSRESETCONTENT:
    return 13;
  case STATUSPARTIALCONTENT:
    return 15;
  case STATUSMULTISTATUS:
    return 12;
  case STATUSALREADYREPORTED:
    return 16;
  case STATUSIMUSED:
    return 7;
  case STATUSMULTIPLECHOICES:
    return 16;
  case STATUSMOVEDPERMANENTLY:
    return 17;
  case STATUSFOUND:
    return 5;
  case STATUSSEEOTHER:
    return 9;
  case STATUSNOTMODIFIED:
    return 12;
  case STATUSUSEPROXY:
    return 9;
  case STATUSTEMPORARYREDIRECT:
    return 18;
  case STATUSPERMANENTREDIRECT:
    return 18;
  case STATUSBADREQUEST:
    return 11;
  case STATUSUNAUTHORIZED:
    return 12;
  case STATUSPAYMENTREQUIRED:
    return 16;
  case STATUSFORBIDDEN:
    return 9;
  case STATUSNOTFOUND:
    return 9;
  case STATUSMETHODNOTALLOWED:
    return 18;
  case STATUSNOTACCEPTABLE:
    return 14;
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return 29;
  case STATUSREQUESTTIMEOUT:
    return 15;
  case STATUSCONFLICT:
    return 8;
  case STATUSGONE:
    return 4;
  case STATUSLENGTHREQUIRED:
    return 15;
  case STATUSPRECONDITIONFAILED:
    return 19;
  case CONTENTTOOLARGE:
    return 17;
  case STATUSURITOOLONG:
    return 12;
  case STATUSUNSUPPORTEDMEDIATYPE:
    return 22;
  case STATUSRANGENOTSATISFIABLE:
    return 21;
  case STATUSEXPECTATIONFAILED:
    return 18;
  case STATUSMISDIRECTEDREQUEST:
    return 19;
  case STATUSUNPROCESSABLECONTENT:
    return 21;
  case STATUSLOCKED:
    return 6;
  case STATUSFAILEDDEPENDENCY:
    return 17;
  case STATUSTOOEARLY:
    return 9;
  case STATUSUPGRADEREQUIRED:
    return 16;
  case STATUSPRECONDITIONREQUIRED:
    return 21;
  case STATUSTOOMANYREQUESTS:
    return 17;
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return 31;
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return 29;
  case STATUSInternalServerError:
    return 21;
  case STATUSNOTIMPLEMENTED:
    return 15;
  case STATUSBADGATEWAY:
    return 11;
  case STATUSSERVICEUNAVAILABLE:
    return 19;
  case STATUSGATEWAYTIMEOUT:
    return 15;
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return 26;
  case STATUSVARIANTALSONEGOTIATES:
    return 23;
  case STATUSINSUFFICIENTSTORAGE:
    return 20;
  case STATUSLOOPDETECTED:
    return 13;
  case STATUSNOTEXTENDED:
    return 12;
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return 31;
  default:
    return 0;
  }
}

/*
 * Return the status code string as string literal
 */
static inline char *status_str(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return "Continue";
  case STATUSSWITCHINGPROTOCOLS:
    return "Switching Protocols";
  case STATUSPROCESSING:
    return "Processing";
  case STATUSEARLYHINTS:
    return "Early Hints";
  case STATUSOK:
    return "OK";
  case STATUSCREATED:
    return "Created";
  case STATUSACCEPTED:
    return "Accepted";
  case STATUSNONAUTHORITATIVE:
    return "Non-Authoritative Information";
  case STATUSNOCONTENT:
    return "No Content";
  case STATUSRESETCONTENT:
    return "Reset Content";
  case STATUSPARTIALCONTENT:
    return "Partial Content";
  case STATUSMULTISTATUS:
    return "Multi-Status";
  case STATUSALREADYREPORTED:
    return "Already Reported";
  case STATUSIMUSED:
    return "Im Used";
  case STATUSMULTIPLECHOICES:
    return "Multiple Choices";
  case STATUSMOVEDPERMANENTLY:
    return "Moved Permanently";
  case STATUSFOUND:
    return "Found";
  case STATUSSEEOTHER:
    return "See Other";
  case STATUSNOTMODIFIED:
    return "Not Modified";
  case STATUSUSEPROXY:
    return "Use Proxy";
  case STATUSTEMPORARYREDIRECT:
    return "Temporary Redirect";
  case STATUSPERMANENTREDIRECT:
    return "Permanent Redirect";
  case STATUSBADREQUEST:
    return "Bad Request";
  case STATUSUNAUTHORIZED:
    return "Unauthorized";
  case STATUSPAYMENTREQUIRED:
    return "Payment Required";
  case STATUSFORBIDDEN:
    return "Forbidden";
  case STATUSNOTFOUND:
    return "Not Found";
  case STATUSMETHODNOTALLOWED:
    return "Method Not Allowed";
  case STATUSNOTACCEPTABLE:
    return "Not Acceptable";
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return "Proxy Authentication Required";
  case STATUSREQUESTTIMEOUT:
    return "Request Timeout";
  case STATUSCONFLICT:
    return "Conflict";
  case STATUSGONE:
    return "Gone";
  case STATUSLENGTHREQUIRED:
    return "Length Required";
  case STATUSPRECONDITIONFAILED:
    return "Precondition Failed";
  case CONTENTTOOLARGE:
    return "Content Too Large";
  case STATUSURITOOLONG:
    return "URI Too Long";
  case STATUSUNSUPPORTEDMEDIATYPE:
    return "Unsupported Media Type";
  case STATUSRANGENOTSATISFIABLE:
    return "Range Not Satisfiable";
  case STATUSEXPECTATIONFAILED:
    return "Expectation Failed";
  case STATUSMISDIRECTEDREQUEST:
    return "Misdirected Request";
  case STATUSUNPROCESSABLECONTENT:
    return "Unprocessable Content";
  case STATUSLOCKED:
    return "Locked";
  case STATUSFAILEDDEPENDENCY:
    return "Failed Dependency";
  case STATUSTOOEARLY:
    return "Too Early";
  case STATUSUPGRADEREQUIRED:
    return "Upgrade Required";
  case STATUSPRECONDITIONREQUIRED:
    return "Precondition Required";
  case STATUSTOOMANYREQUESTS:
    return "Too Many Requests";
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return "Request Header Fields Too Large";
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return "Unavailable For Legal Reasons";
  case STATUSInternalServerError:
    return "Internal Server Error";
  case STATUSNOTIMPLEMENTED:
    return "Not Implemented";
  case STATUSBADGATEWAY:
    return "Bad Gateway";
  case STATUSSERVICEUNAVAILABLE:
    return "Service Unavailable";
  case STATUSGATEWAYTIMEOUT:
    return "Gateway Timeout";
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return "HTTP Version Not Supported";
  case STATUSVARIANTALSONEGOTIATES:
    return "Variant Also Negotiates";
  case STATUSINSUFFICIENTSTORAGE:
    return "Insufficient Storage";
  case STATUSLOOPDETECTED:
    return "Loop Detected";
  case STATUSNOTEXTENDED:
    return "Not Extended";
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return "Network Authentication Required";
  default:
    return 0;
  }
}

/*
 * Return true if routes match
 */
static inline bool route_equ(Route *route, Request *req) {
  return route->method == req->method && strncmp(route->path, req->path, strlen(route->path)) == 0;
}

/*
 * Return the matching route index on success. -1 on failure
 */
static inline int match_route(Server *serv, Request *req) {
  for (size_t i = 0; i < serv->_nroutes; i++) {
    Route route = serv->routes[i];
    if (!req->path || !route.path)
      continue;
    if (route_equ(&route, req))
      return i;
    else if (req->method == HEAD && route.method == GET && strcmp(route.path, req->path) == 0)
      return i;
  }
  return -1;
}

/*
 * Return true if the response should contain the Content-Length header
 */
static inline bool should_have_content_length(Request *req, ResWriter *res) {
  return (req->method != CONNECT              // CONNECT request
          && res->status != STATUSNOCONTENT   // 204 response
          && res->status != STATUSNOTMODIFIED // 304 response
          && res->status >= 200);             // 1xx response
}

/*
 * Format http response from the ResWriter.
 * Return response size on success, 0 on failure.
 */
static inline size_t fmt_res(Request *req, ResWriter *res, char *buffer, size_t buffer_size) {
  if (!res || !buffer || buffer_size == 0)
    return 0;

  size_t res_len, total = 0;
  char *dst = buffer;
  size_t maxlen = buffer_size;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t body_length = res->len;

  res_len = snprintf(dst, maxlen, "HTTP/1.1 %d %s", (int)res->status, status_str(res->status));
  total += res_len;
  dst += res_len;
  maxlen -= res_len;

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    res_len = snprintf(dst, maxlen, "\r\n%s: %s", header->key, header->value);
    total += res_len;
    dst += res_len;
    maxlen -= res_len;
  }

  if (have_content_length) {
    res_len = snprintf(dst, maxlen, "\r\nContent-Length: %lu", body_length);
    total += res_len, dst += res_len, maxlen -= res_len;
  }

  memcpy(dst, "\r\n\r\n", 4);
  total += 4, dst += 4, maxlen -= 4;

  return total;
}

static inline size_t res_len(Request *req, ResWriter *res) {
  if (!req || !res)
    return 0;

  if (!res->status)
    res->status = STATUSOK;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t result = 0;
  result += STRLEN("HTTP/1.1 ");     // HTTP version
  result += 4;                       // Status code + space
  result += status_len(res->status); // Status name

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    result += 2;                       // "\r\n"
    result += strlen(header->key) + 2; // Header key + ':' + space
    result += strlen(header->value);   // header value
  }

  if (have_content_length) {
    result += 2;                          // "\r\n"
    result += STRLEN("Content-Length: "); // Header key
    result += countd(res->len);           // Header value
  }

  result += 4; // "\r\n\r\n"

  return result;
}

static inline int send_empty_res(Status status) {
  size_t res_len = STRLEN("HTTP/1.1 ")        // HTTP version
                   + countd((uint64_t)status) // status code
                   + 1                        // space
                   + (int)status_len(status)  // status string
                   + 4;                       // \r\n\r\n

  conn_t *conn = current_send;
  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, res_len);
  if (snprintf((char *)rec->iov_base, res_len + 1, "HTTP/1.1 %d %s\r\n\r\n", (int)status, status_str(status))
      != (int)res_len)
    return -1;

  return usendmsg(conn, 0, 1);
}

static inline ssize_t read_socket(int sockfd, size_t len) {
  if (len == 0 || sockfd <= 0)
    return 0;
  char buff[1024 * 8];
  return read(sockfd, buff, 1024 * 8);
}

static inline int read_method(Method *method, void *src) {
  if (memcmp(src, "GET", 3) == 0)
    *method = GET;
  else if (memcmp(src, "POST", 4) == 0)
    *method = POST;
  else if (memcmp(src, "HEAD", 4) == 0)
    *method = HEAD;
  else if (memcmp(src, "PUT", 3) == 0)
    *method = PUT;
  else if (memcmp(src, "DELETE", 6) == 0)
    *method = DELETE;
  else if (memcmp(src, "CONNECT", 7) == 0)
    *method = CONNECT;
  else if (memcmp(src, "OPTIONS", 7) == 0)
    *method = OPTIONS;
  else if (memcmp(src, "TRACE", 5) == 0)
    *method = TRACE;
  else if (memcmp(src, "PATCH", 5) == 0)
    *method = PATCH;
  else
    return -1;

  return 0;
}

static inline int sendmsg_res(Request *req, ResWriter *res) {
  conn_t *conn;
  size_t head_size, res_size;
  struct iovec *iov;

  conn = current_send;
  iov = &conn->ios[0];
  head_size = res_len(req, res);
  if (head_size == 0)
    return -1;

  conn->data_left += head_size;
  res_size = fmt_res(req, res, iov->iov_base, (head_size + 1));
  if (res_size != head_size)
    return -1;
  iov->iov_len = res_size;

  return usendmsg(conn, 0, conn->nios);
}

static inline int read_req(Request *req, char *req_buffer) {
  if (!req_buffer)
    return -1;
  /*** Method ***/
  char *sep = strchr(req_buffer, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }
  *sep = '\0';
  if (read_method(&req->method, req_buffer) < 0)
    return -1;

  /*** Path ***/
  char *fullpath = sep + 1;
  sep = strchr(fullpath, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }

  *sep = '\0';
  req->path = fullpath;
  /*** Params ***/
  char *paramStart = strchr(fullpath, '?');
  if (paramStart) {
    *paramStart++ = '\0';
    int params_count = 0;
    params_count = HK_parse_params(paramStart, req->params, MAX_URL_PARAMETERS);
    if (params_count > 0)
      req->params_count = params_count;
    else
      req->params_count = 0;
  } else {
    req->params = NULL;
    req->params_count = 0;
  }

  /*** Headers ***/
  char *headStart = strstr(sep + 1, "\r\n");
  char *headEnd = strstr(sep + 1, "\r\n\r\n");
  if (!headStart) {
    LOG("read_req: !headStart\n");
    return -1;
  };

  memset(headStart, 0, 2);
  headStart += 2;
  memset(headEnd, 0, 4);
  headEnd += 4;

  int headers_count = HK_parse_headers(headStart, req->headers, MAX_REQ_HEADERS);
  if (headers_count <= 0)
    return -1;
  req->headers_count = headers_count;

  /*** Host ***/
  int index = HK_get_header(req, "Host");
  if (index < 0)
    return -1;
  char *host = req->headers[index].value;
  req->hostname = host;

  /*** Port ***/
  char *colon = strchr(host, ':');
  if (colon) {
    *colon++ = '\0';
    req->port = atoi(colon);
  } else {
    req->port = PORT;
  }
  return 0;
}
static inline int process_req(Server *serv, conn_t *conn) {
  if (!conn || conn->fd == -1)
    return -1;

  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;
  if (read_req(&req, conn->ios[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    LOG("Err: route_index == -1\n");
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;
  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  sendmsg_res(&req, &res);

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int new_conn(int connfd) {
  if (connfd <= 0)
    return -1;

  current_recv = MP_use(KB * 2, connfd, false);
  current_send = MP_use(KB * 2, connfd, false);

  current_recv->recv_conn = current_recv;
  current_recv->send_conn = current_send;

  current_send->send_conn = current_send;
  current_send->recv_conn = current_recv;

  conn_t *conn = current_recv;
  if (ufrecvmsg(conn, 0, 1) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

static inline int resubmit_sendmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return usendmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int resubmir_recvmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    // FIXME the len should be increased
    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return urecvmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int handle_sendmsg_complete(conn_t *conn) {
  struct iovec *iov, *rec;

  MP_shed(conn, 1, conn->nios - 1);
  iov = &conn->ios[0];
  rec = &conn->rec[0];
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;

  return ufrecvmsg(conn->recv_conn, 0, 1);
}

static inline int handle_sendmsg(conn_t *conn, int res, bool zc) {
  if (!conn || conn->fd == -1)
    return -1;

  conn->data_left -= res;
  if (conn->data_left > 0)
    return resubmit_sendmsg(conn, res);

  if (zc)
    return 0;

  return handle_sendmsg_complete(conn);
}

static inline int handle_insplice(conn_t *conn) {
  conn->op = OUTSPLICE;
  return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
}
static inline int handle_outsplice(conn_t *conn, int res) {
  conn->data_left -= res;
  if (conn->data_left > 0) {
    conn->op = INSPLICE;
    return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
  }

  conn_t *recv_conn = conn->recv_conn;
  struct iovec *iov = &recv_conn->ios[0];
  memset(iov->iov_base, 0, iov->iov_len);
  if (urecv(recv_conn, iov->iov_base, iov->iov_len, MSG_PEEK) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

/*
static inline int handle_recv(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  void *bptr = conn->ios[0].iov_base;
  void *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  void *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  return process_req(serv, conn);
}
*/
static inline int find_route(Server *serv, char *bptr) {
  Request req = {0};
  if (read_method(&req.method, bptr) < 0) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  };
  char *space = strchr(bptr, ' ');
  req.path = (space + 1);
  space = strchr(req.path, ' ');
  *space = '\0';
  int route_index = match_route(serv, &req);
  *space = ' ';
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }
  return route_index;
}

static inline int run_handler(Server *serv, conn_t *conn, bool uses_body) {
  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;

  if (read_req(&req, conn->rec[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  if (uses_body) {
    int h_index = HK_get_header(&req, "Content-Length");
    long body_size = atol(req.headers[h_index].value);
    if (body_size >= 0) {
      req.body.ptr = conn->rec[1].iov_base;
      req.body.size = body_size;
    } else {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    }
  }

  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  if (sendmsg_res(&req, &res) < 0)
    return -1;

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int handle_frecvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  char *bptr = (char *)conn->ios[0].iov_base;
  char *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  char *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  size_t head_size = (headEnd + 4) - bptr;
  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  int route_index = find_route(serv, bptr);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  bool uses_body = serv->routes[route_index].uses_body;
  long body_size = get_content_length(headstart + 2, headEnd + 4);
  if (body_size == -1) {
    if (uses_body) {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    } else {
      body_size = 0;
    }
  }

  conn->head_size = head_size;
  if (!uses_body) {
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  if (res == (int)(head_size + body_size)) {
    size_t iov_index = MP_expand(conn, round_to_blocks(body_size), false);
    memcpy(conn->rec[iov_index].iov_base, headEnd + 4, body_size);
    conn->ios[iov_index].iov_len = body_size;
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  conn->data_left = body_size - (res - head_size);
  bool once = ((size_t)body_size > (size_t)((pool.nblocks * MP_BLOCK) / 10));
  size_t iov_index = MP_expand(conn, round_to_blocks(body_size), once);
  memcpy(conn->rec[iov_index].iov_base, headEnd + 4, (res - head_size));
  conn->ios[iov_index].iov_base += (res - head_size);

  return urecvmsg(conn, iov_index, 1);
}

static inline int handle_recvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  if (conn->data_left > 0) {
    conn->data_left -= res;
    if (conn->data_left == 0) {
      conn->flags &= CF_HANDLER_READY;
      return run_handler(serv, conn, true);
    }

    conn->flags &= ~CF_HANDLER_READY;
    conn->ios[1].iov_base += res;
    return urecvmsg(conn, 1, 1);
  }

  conn->flags &= CF_HANDLER_READY;
  return run_handler(serv, conn, true);
}

static inline int serv_init(Server *serv) {
#if DEBUG
  logfd = log_init("log.txt");
  if (!logfd) {
    printf("log_init failed");
    return -1;
  }
#endif
  serv->_nroutes = get_nroutes(serv->routes);

  int pipefd[2];
  if (pipe(pipefd) < 0)
    return -1;
  pipe_in = pipefd[0];
  pipe_out = pipefd[1];
  nullfd = open("/dev/null", O_WRONLY);
  pipe_sz = fcntl(pipefd[0], F_GETPIPE_SZ);
  if (pipe_sz < 0)
    return -1;

  pool.rtimeout = serv->rtimeout;
  pool.wtimeout = serv->wtimeout;
  if (MP_init(MAX_CONNS * 8) < 0)
    return -1;
  LOG("pool initialized\n");

  if (io_uring_queue_init(MAX_CONNS, &ring, 0) < 0)
    return -1;
  LOG("uring initialized\n");

  int listenfd;
  if ((listenfd = tcp_listen(serv->port)) < 0)
    return -1;
  LOG("socket initialized\n");

  return umaccept(listenfd);
}

static inline int serv_listen(Server *serv) {
  // uint64_t last_check = get_time();
  while (true) {
    // uint64_t now = get_time();
    // if ((now - last_check) >= 200) {
    //   last_check = now;
    //   LOG("CM: CM_check ran\n");
    //   MP_timeout();
    // }

    LOG("SQ ready: %u, CQ ready: %u\n", io_uring_sq_ready(&ring), io_uring_cq_ready(&ring));
    struct io_uring_cqe *cqe;
    if (io_uring_wait_cqe(&ring, &cqe) < 0)
      continue;

    int res = cqe->res;
    LOG("res = %d\n", res);
    conn_t *conn = NULL;
    if (cqe->user_data > 100) {
      conn = (conn_t *)cqe->user_data;
      current_recv = (conn_t *)conn->recv_conn;
      current_send = (conn_t *)conn->send_conn;
    }

    if (res > 0) {
      if (cqe->user_data == ACCEPT) {
        LOG("new conn created\n");
        new_conn(res);
      } else if (conn && conn->fd != -1) {
        LOG("conn[%d]: conn.fd = %d; conn.op = %d\n", conn->cindex, conn->fd, conn->op);
        switch (conn->op) {
        case FRECVMSG:
          if (handle_frecvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case RECVMSG:
          if (handle_recvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case SENDMSG:
        case SENDMSGZC:
          // conn->last_write = get_time();
          bool zc = (conn->op == SENDMSGZC);
          if (handle_sendmsg(conn, res, zc) < 0)
            MP_clear(conn);
          break;
        case INSPLICE:
          if (handle_insplice(conn) < 0)
            MP_clear(conn);
          break;
        case OUTSPLICE:
          if (handle_outsplice(conn, res) < 0)
            MP_clear(conn);
          break;
        }
      }
    } else if (res == 0) {
      if (conn && conn->fd != -1) {
        switch (conn->op) {
        case SENDMSGZC:
          conn->zc_notifs--;
          if (conn->zc_notifs == 0 && handle_sendmsg_complete(conn) < 0)
            MP_clear(conn);
          break;
        case RECV:
          MP_clear(conn);
          break;
        }
      }
    } else {
      if (conn && conn->fd != -1) {
        if (res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR) {
          LOG("conn && conn->fd != -1 && res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR\n");
          MP_clear(conn);
        } else {
          LOG("res == -EAGAIN || res == -EWOULDBLOCK || res == -EINTR\n");
          conn = conn->recv_conn;
          struct iovec *iov = &conn->ios[0];
          memset(iov->iov_base, 0, iov->iov_len);
          if (urecv(conn, iov->iov_base, iov->iov_len, 0) < 0)
            MP_clear(conn);
        }
      }
    }

    LOG("uring operation seen\n");
    io_uring_cqe_seen(&ring, cqe);
  }

  io_uring_queue_exit(&ring);
  MP_exit(&pool);
  return 0;
}

/*** Helper ***/
static inline int _HK_write(void *data, size_t size) {
  size_t nblocks;
  int iov_index;
  conn_t *conn;
  struct iovec *iov;
  bool once;

  conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  nblocks = round_to_blocks(size);
  iov_index = MP_expand(conn, nblocks, once);
  iov = &conn->ios[iov_index];

  memcpy(iov->iov_base, data, size);
  iov->iov_len = size;
  conn->data_left += size;

  return 0;
}
static inline int _HK_write_body(Request *req, size_t offset, size_t size) {
  if (size > req->body.size || offset > req->body.size)
    return -1;

  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  int iov_index = MP_expand(conn, 0, false);
  struct iovec *iov = &conn->ios[iov_index];
  struct iovec *rec = &conn->rec[iov_index];
  rec->iov_base = req->body.ptr + offset;
  rec->iov_len = size;
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;
  conn->data_left += rec->iov_len;
  return 0;
}
/*
static inline int _HK_mem(size_t size, HKMem *mem) {
  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  bool once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  size_t nblocks = round_to_blocks(size);
  int iov_index = MP_expand(conn, nblocks, once);
  struct iovec *iov = &conn->ios[iov_index];
  mem->ptr = iov->iov_base;
  mem->size = iov->iov_len;
  mem->_iov_index = iov_index;
  mem->_flags = (IN_POOL(iov->iov_base)) ? CF_IN_POOL : CF_IN_HEAP;
  return 0;
}

static inline void _HK_send(HKMem *mem, size_t size) {
  conn_t *conn = current_send;
  struct iovec *iov = &conn->ios[mem->_iov_index];
  iov->iov_len = size;
  conn->data_left += size;
}
  */
#endif#define _GNU_SOURCE
#ifndef UTILS_H
#define UTILS_H

#include "hunk.h"
#include <arpa/inet.h>
#include <fcntl.h>
#include <liburing.h>
#include <netdb.h>
#include <signal.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/poll.h>
#include <sys/prctl.h>
#include <sys/socket.h>
#include <sys/sysinfo.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

#define MP_BLOCK  4
#define MAX_CONNS 4096
#define KB        1024
#define NIOS      32

#define IN_POOL(ptr)                 ((void *)ptr >= pool.bpool && (void *)ptr <= (pool.bpool + (pool.npages * pool.pagesize)))
#define ALIGN_TO_PAGESIZE(buff_size) (((buff_size) + (pool.pagesize - 1)) & ~(pool.pagesize - 1))
#define BYTES_TO_BLOCKS(buff_size)   (((buff_size) + (MP_BLOCK - 1)) / MP_BLOCK)
#define CEIL_BLOCKS(nblocks)         ((nblocks + 63) & ~63)
#define CEIL_PAGES(size)             (((size) + ((pool.pagesize) - 1)) & ~((pool.pagesize) - 1))

#define BIT_IS_FREE(word, bit)   (((word) >> (bit)) & 1)
#define MARK_BIT_USED(word, bit) ((word) &= ~(1ULL << (bit)))
#define MARK_BIT_FREE(word, bit) ((word) |= (1ULL << (bit)))
#define FIND_FREE_BIT(word)      ((uint64_t)(word) & -(uint64_t)(word))
#define STRLEN(s)                (sizeof(s) - 1)

#define IOVEC_NBLOCKS (BYTES_TO_BLOCKS(NIOS * sizeof(struct iovec)))
#define MSG_NBLOCKS   (BYTES_TO_BLOCKS(sizeof(struct msghdr)))
#define ZC_RES        KB *KB

#define DEBUG 0
#if DEBUG
#define LOG(...) fprintf(logfd, __VA_ARGS__)
#else
#define LOG(...) ((void)0)
#endif

typedef enum UOP {
  WRITEV = IORING_OP_WRITEV,
  SENDMSG = IORING_OP_SENDMSG,
  RECVMSG = IORING_OP_RECVMSG,
  ACCEPT = IORING_OP_ACCEPT,
  SEND = IORING_OP_SEND,
  RECV = IORING_OP_RECV,
  SENDZC = IORING_OP_SEND_ZC,
  SENDMSGZC = IORING_OP_SENDMSG_ZC,
  PEEK = 50,
  FRECVMSG,
  INSPLICE,
  OUTSPLICE
} UOP;

typedef enum CFS {
  CF_IN_POOL = (1 << 0),       // Connection is in the pool
  CF_IN_HEAP = (1 << 1),       // Connection is in the heap
  CF_SKIP_SOCK = (1 << 2),     // Don't close the socket
  CF_USE_ONCE = (1 << 3),      // Destroy after using
  CF_HANDLER_READY = (1 << 4), // Ready to call the handler
} CFS;

typedef struct conn_t {
  // Socket file descriptor
  int fd;

  // Amount of data left in the current operation
  uint64_t data_left;

  // The index of the connection struct
  uint32_t cindex;

  // The last time the connection was readable
  uint64_t last_read;

  // The last time the connection was writeable
  uint64_t last_write;

  // The operation currently being processed
  uint8_t op;

  // Connection flags
  int flags;

  // Splice fd_in
  int in_fd;

  // Splice fd_out
  int out_fd;

  void *recv_conn;
  void *send_conn;

  struct iovec *ios;
  struct iovec *rec;
  uint16_t nios;

  struct msghdr *msg;
  uint16_t zc_notifs;

  uint16_t head_size;
} conn_t;

typedef struct MPool {
  // The allocated pool of blocks
  void *bpool;

  // The allocated pool of connections
  conn_t *cpool;

  // The size of the pool in pages
  uint32_t npages;

  // The size of the pool in blocks
  uint32_t nblocks;

  // The locations of each page in the pool
  void **blocks;

  // The availability of each block
  uint64_t *freebs;

  // The locations of each conn in the pool
  conn_t **conns;

  // The availability of each conn
  uint64_t *freecs;

  // Clean up callback function
  void (*callback)(conn_t *conn);

  // The page size used
  uint32_t pagesize;

  // Socket read timeout
  uint32_t rtimeout;

  // Socket write timeout
  uint32_t wtimeout;
} MPool;

extern int pipe_sz;
extern int pipe_in, pipe_out, nullfd;
extern FILE *logfd;
extern struct io_uring ring;
extern MPool pool;
extern conn_t *current_recv;
extern conn_t *current_send;

/*
 * Prepare and submit a recv uring op
 */
static inline int urecv(conn_t *conn, void *buffer, size_t buff_size, int flags) {
  if (!conn || conn->fd == -1)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (flags == MSG_PEEK) ? PEEK : RECV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;

  io_uring_prep_recv(sqe, conn->fd, buffer, buff_size, flags);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a multi-shot accept uring op
 */
static inline int umaccept(int listenfd) {
  if (listenfd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = ACCEPT;
  io_uring_prep_multishot_accept(sqe, listenfd, NULL, NULL, SOCK_NONBLOCK);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a splice uring op
 */
static inline int usplice(conn_t *conn, int fd_in, int64_t off_in, int fd_out, int64_t off_out, size_t len) {
  if (!len || !conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = (__u64)conn;
  io_uring_prep_splice(sqe, fd_in, off_in, fd_out, off_out, len, 0);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a writev uring op
 */
static inline int uwritev(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = WRITEV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  io_uring_prep_writev(sqe, conn->fd, &conn->ios[iov_index], nios, -1);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a send uring op
 */
static inline int usend(conn_t *conn, char *res_buff, size_t buff_size, bool zc) {
  if (!conn || conn->fd <= 0 || buff_size == 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (zc) ? SENDZC : SEND;
  conn->data_left = buff_size;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  if (zc)
    io_uring_prep_send_zc(sqe, conn->fd, res_buff, buff_size, 0, 0);
  else
    io_uring_prep_send(sqe, conn->fd, res_buff, buff_size, 0);
  return io_uring_submit(&ring);
}

static inline int ufrecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = FRECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;

  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, rec->iov_len);
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int urecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = RECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int usendmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  bool zc = (conn->data_left > ZC_RES) ? true : false;
  conn->op = (zc) ? SENDMSGZC : SENDMSG;

  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  if (zc) {
    io_uring_prep_sendmsg_zc(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
    conn->zc_notifs++;
  } else {
    io_uring_prep_sendmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  }
  return io_uring_submit(&ring);
}

/*
 * Create and initialize a server socket
 */
static inline int tcp_listen(uint16_t port) {
  int enable;
  int listenfd;
  if ((listenfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    return -1;

  int flags = fcntl(listenfd, F_GETFL, 0);
  fcntl(listenfd, F_SETFL, flags | O_NONBLOCK);
  struct sockaddr_in servaddr;
  memset(&servaddr, 0, sizeof(servaddr));
  servaddr.sin_family = AF_INET;
  servaddr.sin_addr.s_addr = INADDR_ANY;
  servaddr.sin_port = htons(port);

  enable = 1;
  if (setsockopt(listenfd, SOL_SOCKET, SO_REUSEPORT, &enable, sizeof(enable)) < 0)
    return -1;

  if (bind(listenfd, (struct sockaddr *)&servaddr, sizeof(servaddr)) < 0)
    return -1;

  if (listen(listenfd, SOMAXCONN) < 0)
    return -1;

  return listenfd;
}

/*
 * Calculate the difference between two pointers
 */
static inline uintptr_t ptr_diff(uintptr_t p1, uintptr_t p2) { return (uintptr_t)(p1 > p2) ? (p1 - p2) : (p2 - p1); }

static inline size_t get_nroutes(Route *routes) {
  Route *route;
  for (size_t i = 0;; i++) {
    route = &routes[i];
    if (!route->path && !route->handler && !route->method)
      return i;
  }
}

static inline long get_content_length(char *src, char *end) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return -1;
    key = line;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, "Content-Length") != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;

    *line_end = '\0';
    long res = atol(value);
    *line_end = '\r';

    return res;
  }
  return -1;
}

static inline bool have_header(char *src, char *end, const char *header_key, const char *header_value) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    key = line;
    while (*key == ' ')
      key++;
    while (*header_key == ' ')
      header_key++;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return false;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, header_key) != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;
    while (*header_value == ' ')
      header_value++;

    *line_end = '\0';
    bool res = (strcasecmp(value, header_value) == 0);
    *line_end = '\r';

    return res;
  }

  return false;
}

static inline const char *method_str(Method method) {
  switch (method) {
  case GET:
    return "GET";
    break;
  case HEAD:
    return "HEAD";
    break;
  case POST:
    return "POST";
    break;
  case PUT:
    return "PUT";
    break;
  case DELETE:
    return "DELETE";
    break;
  case CONNECT:
    return "CONNECT";
    break;
  case OPTIONS:
    return "OPTIONS";
    break;
  case TRACE:
    return "TRACE";
    break;
  case PATCH:
    return "PATCH";
    break;
  default:
    return NULL;
  }
}

static inline uint8_t method_len(Method method) {
  switch (method) {
  case GET:
    return 3;
    break;
  case HEAD:
    return 4;
    break;
  case POST:
    return 4;
    break;
  case PUT:
    return 3;
    break;
  case DELETE:
    return 6;
    break;
  case CONNECT:
    return 7;
    break;
  case OPTIONS:
    return 7;
    break;
  case TRACE:
    return 5;
    break;
  case PATCH:
    return 5;
    break;
  default:
    return 0;
  }
}

static inline size_t round_to_blocks(size_t size) {
  size_t nblocks = BYTES_TO_BLOCKS(size);
  nblocks = CEIL_BLOCKS(nblocks);
  return nblocks;
}

/*
 * Count the digits in unsigned 64-bit int
 */
static inline int countd(uint64_t num) {
  if (num < 10ULL)
    return 1;
  if (num < 100ULL)
    return 2;
  if (num < 1000ULL)
    return 3;
  if (num < 10000ULL)
    return 4;
  if (num < 100000ULL)
    return 5;
  if (num < 1000000ULL)
    return 6;
  if (num < 10000000ULL)
    return 7;
  if (num < 100000000ULL)
    return 8;
  if (num < 1000000000ULL)
    return 9;
  if (num < 10000000000ULL)
    return 10;
  if (num < 100000000000ULL)
    return 11;
  if (num < 1000000000000ULL)
    return 12;
  if (num < 10000000000000ULL)
    return 13;
  if (num < 100000000000000ULL)
    return 14;
  if (num < 1000000000000000ULL)
    return 15;
  if (num < 10000000000000000ULL)
    return 16;
  if (num < 100000000000000000ULL)
    return 17;
  if (num < 1000000000000000000ULL)
    return 18;
  if (num < 10000000000000000000ULL)
    return 19;
  return 20;
}

/*
 * Get the time elabsed in ms
 */
static inline uint64_t get_time() {
  struct timespec ts;
  clock_gettime(CLOCK_MONOTONIC, &ts);
  return (uint64_t)(ts.tv_sec) * 1000 + (ts.tv_nsec / 1000000);
}

static inline FILE *log_init(const char *path) {
  FILE *res = fopen(path, "a+");
  setvbuf(res, NULL, _IONBF, 0);
  return res;
}

static inline int16_t pollevs(int connfd) {
  struct pollfd pfd;
  pfd.fd = connfd;
  pfd.events = POLLIN | POLLOUT | POLLERR;
  int res = poll(&pfd, 1, 0);
  if (res < 0)
    return POLLERR;
  return pfd.revents;
}

// FIXME This needs to be updated
static inline conn_t *MP_use_once(size_t nblocks, int fd) {

  void *mem = malloc(sizeof(conn_t) + 8 + (IOVEC_NBLOCKS * MP_BLOCK));
  struct conn_t *conn = (conn_t *)mem;
  memset(conn, 0, sizeof(conn_t));
  conn->ios = mem + sizeof(conn_t) + 8;

  if (nblocks > 0) {
    struct iovec *iov = &conn->ios[conn->nios++];
    mem = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (mem == MAP_FAILED)
      return NULL;
    iov->iov_base = mem;
    iov->iov_len = ALIGN_TO_PAGESIZE(nblocks * MP_BLOCK);
  }

  conn->flags |= CF_IN_HEAP;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;

  return conn;
}

static inline int find_freec() {
  uint64_t *word;
  size_t map_size = (sizeof(uint64_t) * 8);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    word = &pool.freecs[i / map_size];

    if (*word == 0) { // All used
      i += (map_size - 1);
      continue;
    }

    i += __builtin_ctzll(*word);
    MARK_BIT_USED(*word, i);
    return i;
  }

  return -1;
}

static inline int MP_init(size_t npages) {
  if (!npages)
    return -1;

  /*** Setup ***/
  pool.npages = npages;
  pool.pagesize = sysconf(_SC_PAGESIZE);

  /*** Pool ***/
  pool.bpool = mmap(NULL, pool.npages * pool.pagesize, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  if (pool.bpool == MAP_FAILED)
    return -1;
  pool.nblocks = (pool.npages * pool.pagesize) / MP_BLOCK;

  /*** Blocks ***/
  pool.blocks = malloc(sizeof(void *) * pool.nblocks);
  if (!pool.blocks)
    return -1;
  for (size_t i = 0; i < pool.nblocks; i++)
    pool.blocks[i] = pool.bpool + (i * MP_BLOCK);

  /*** Freebs ***/
  // if (posix_memalign((void **)&pool.freebs, 64, bitmap_size * sizeof(uint64_t)) < 0)
  size_t bitmap_size = (pool.nblocks + 63) / 64;
  pool.freebs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freebs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freebs[i] = UINT64_MAX;

  /*** Cpool ***/
  pool.cpool = (conn_t *)malloc(sizeof(conn_t) * MAX_CONNS);
  if (!pool.cpool)
    return -1;

  /*** Conns ***/
  pool.conns = (conn_t **)malloc(sizeof(conn_t *) * MAX_CONNS);
  if (!pool.conns)
    return -1;
  size_t conn_size = sizeof(conn_t);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    pool.conns[i] = (conn_t *)((char *)pool.cpool + (i * conn_size));
    pool.conns[i]->fd = -1;
    pool.conns[i]->in_fd = -1;
    pool.conns[i]->out_fd = -1;
  }

  /*** Freecs ***/
  bitmap_size = (MAX_CONNS + 63) / 64;
  pool.freecs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freecs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freecs[i] = UINT64_MAX;

  return 0;
}

static inline int MP_use_blks(size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t max_start = pool.nblocks - nblocks;
  size_t full_chunks = (nblocks / 64) * 64;

  for (size_t i = 0, c = 0; i <= max_start; i++, c++) {
    bool free = true;

    for (size_t j = 0; j < full_chunks; j += 64) {
      size_t word_index = (i + j) / 64;
      if (pool.freebs[word_index] != UINT64_MAX) {
        free = false;
        i += 63;
        break;
      }
    }

    for (size_t j = full_chunks; j < nblocks; j++) {
      size_t bit_index = i + j;
      size_t word_index = bit_index / 64;
      size_t bit_in_word = bit_index % 64;

      if (!BIT_IS_FREE(pool.freebs[word_index], bit_in_word)) {
        free = false;
        i += j;
        break;
      }
    }

    if (free) {
      for (size_t j = 0; j < full_chunks; j += 64) {
        size_t word_index = (i + j) / 64;
        pool.freebs[word_index] = 0;
      }

      for (size_t j = full_chunks; j < nblocks; j++) {
        size_t bit_index = i + j;
        size_t word_index = bit_index / 64;
        size_t bit_in_word = bit_index % 64;

        MARK_BIT_USED(pool.freebs[word_index], bit_in_word);
      }

      return i;
    }
  }

  return -1;
}

static inline int MP_free_blks(size_t bindex, size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t full_chunks = (nblocks / 64) * 64;
  for (size_t i = 0; i < full_chunks; i += 64) {
    size_t word_index = (bindex + i) / 64;
    pool.freebs[word_index] = UINT64_MAX;
  }

  for (size_t i = full_chunks; i < nblocks; i++) {
    size_t bit_index = bindex + i;
    size_t word_index = bit_index / 64;
    size_t bit_in_word = bit_index % 64;

    MARK_BIT_FREE(pool.freebs[word_index], bit_in_word);
  }

  memset(pool.blocks[bindex], 0, nblocks * MP_BLOCK);
  return 0;
}

static inline conn_t *MP_use(size_t nblocks, int fd, bool once) {
  if (fd <= 0)
    return NULL;
  if (once)
    return MP_use_once(nblocks, fd);

  int cindex = find_freec();
  if (cindex < 0) {
    LOG("Err: cindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  conn_t *conn = pool.conns[cindex];

  int ios_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (ios_bindex < 0) {
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }

  struct iovec *ios = pool.blocks[ios_bindex];
  conn->ios = ios;

  int rec_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (rec_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct iovec *rec = pool.blocks[rec_bindex];
  conn->rec = rec;

  int msg_bindex = MP_use_blks(MSG_NBLOCKS);
  if (msg_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct msghdr *msg = pool.blocks[msg_bindex];
  conn->msg = msg;

  if (nblocks > 0) {
    int bindex = MP_use_blks(nblocks);
    if (bindex < 0) {
      MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
      MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
      MP_free_blks(msg_bindex, IOVEC_NBLOCKS);
      MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
      LOG("Err: bindex < 0; will use MP_use_once\n");
      return MP_use_once(nblocks, fd);
    }

    size_t iov_index = conn->nios++;
    struct iovec *iov = &conn->ios[iov_index];
    struct iovec *rec = &conn->rec[iov_index];
    iov->iov_base = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
  }

  conn->msg->msg_iov = conn->ios;
  conn->msg->msg_iovlen = conn->nios;
  conn->cindex = cindex;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;
  return conn;
}

static inline void MP_shed(conn_t *conn, size_t iov_index, size_t nios) {
  struct iovec *iov, *rec;
  size_t bindex, nblocks, index;

  for (size_t i = 0; i < nios; i++) {
    index = iov_index + i;
    iov = &conn->ios[index];
    rec = &conn->rec[index];
    if (!rec || !rec->iov_base)
      continue;
    if (!IN_POOL(rec->iov_base)) {
      munmap(rec->iov_base, rec->iov_len / pool.pagesize);
    } else {
      bindex = ptr_diff((uintptr_t)rec->iov_base, (uintptr_t)pool.bpool) / MP_BLOCK;
      nblocks = rec->iov_len / MP_BLOCK;
      MP_free_blks(bindex, nblocks);
    }
    memset(iov, 0, sizeof(struct iovec));
    memset(rec, 0, sizeof(struct iovec));
    conn->nios--;
  }
}

static inline int MP_expand(conn_t *conn, size_t nblocks, bool once) {
  void *bptr;
  int iov_index, bindex;
  struct iovec *iov, *rec;

  iov_index = conn->nios++;
  iov = &conn->ios[iov_index];
  rec = &conn->rec[iov_index];

  if (nblocks == 0)
    return iov_index;

  if (once) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_base = bptr;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
    return iov_index;
  }

  bindex = MP_use_blks(nblocks);
  if (bindex < 0) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_len = iov->iov_len;
  } else {
    bptr = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_len = iov->iov_len;
  }

  iov->iov_base = bptr;
  rec->iov_base = iov->iov_base;
  return iov_index;
}

static inline int MP_free(conn_t *conn) {
  if (!conn)
    return -1;
  size_t bindex, nblocks;
  uint64_t *word;

  MP_shed(conn, 0, conn->nios);
  if (conn->flags & CF_IN_HEAP) {
    if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
      close(conn->fd);
    free(conn);
    return 0;
  }

  word = &pool.freecs[conn->cindex / 64];
  if (conn->cindex > MAX_CONNS)
    return -1;
  else if (BIT_IS_FREE(*word, conn->cindex))
    return 0;

  bindex = ptr_diff((uintptr_t)conn->ios, (uintptr_t)pool.bpool) / MP_BLOCK;
  nblocks = IOVEC_NBLOCKS;
  MP_free_blks(bindex, nblocks);

  bindex = ptr_diff((uintptr_t)conn->rec, (uintptr_t)pool.bpool) / MP_BLOCK;
  MP_free_blks(bindex, nblocks);

  if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
    close(conn->fd);

  MARK_BIT_FREE(*word, conn->cindex);
  memset(conn, 0, sizeof(conn_t));
  conn->fd = -1;
  conn->in_fd = -1;
  conn->out_fd = -1;
  return 0;
}

static inline void MP_clear(conn_t *conn) {
  conn_t *recv_conn = conn->recv_conn;
  conn_t *send_conn = conn->send_conn;
  if (recv_conn)
    MP_free(recv_conn);
  if (send_conn)
    MP_free(send_conn);
}

static inline void MP_exit(MPool *pool) {
  munmap(pool->bpool, pool->npages);
  free(pool->cpool);
  free(pool->blocks);
  free(pool->conns);
  free(pool->freebs);
  free(pool->freecs);
}

static inline void MP_timeout() {
  conn_t *conn;
  int16_t res;
  uint64_t now;
  size_t windex = 0;
  uint64_t *word = &pool.freecs[0];
  for (size_t i = 0; i < MAX_CONNS; i++) {
    if ((i / 64) < windex)
      word = &pool.freecs[++windex];

    if (*word == UINTMAX_MAX) {
      i = (i / 64) * 64 + 64;
      continue;
    }

    conn = pool.conns[i];
    if (!conn || conn->fd == -1)
      continue;

    res = pollevs(conn->fd);

    now = get_time();
    if (res & POLLERR) {
      MP_clear(conn);
      continue;
    }
    if (res & POLLIN) {
      if (pool.rtimeout > 0 && (now - conn->last_read) >= pool.rtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (res & POLLOUT) {
      if (pool.wtimeout > 0 && (now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (!(res & POLLIN || res & POLLOUT)) {
      if ((pool.rtimeout > 0 && now - conn->last_read) >= pool.rtimeout
          || (pool.wtimeout > 0 && now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
  }
}

/*
 * Calculate the length of a status string
 */
static inline size_t status_len(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return 8;
  case STATUSSWITCHINGPROTOCOLS:
    return 19;
  case STATUSPROCESSING:
    return 10;
  case STATUSEARLYHINTS:
    return 11;
  case STATUSOK:
    return 2;
  case STATUSCREATED:
    return 7;
  case STATUSACCEPTED:
    return 8;
  case STATUSNONAUTHORITATIVE:
    return 29;
  case STATUSNOCONTENT:
    return 10;
  case STATUSRESETCONTENT:
    return 13;
  case STATUSPARTIALCONTENT:
    return 15;
  case STATUSMULTISTATUS:
    return 12;
  case STATUSALREADYREPORTED:
    return 16;
  case STATUSIMUSED:
    return 7;
  case STATUSMULTIPLECHOICES:
    return 16;
  case STATUSMOVEDPERMANENTLY:
    return 17;
  case STATUSFOUND:
    return 5;
  case STATUSSEEOTHER:
    return 9;
  case STATUSNOTMODIFIED:
    return 12;
  case STATUSUSEPROXY:
    return 9;
  case STATUSTEMPORARYREDIRECT:
    return 18;
  case STATUSPERMANENTREDIRECT:
    return 18;
  case STATUSBADREQUEST:
    return 11;
  case STATUSUNAUTHORIZED:
    return 12;
  case STATUSPAYMENTREQUIRED:
    return 16;
  case STATUSFORBIDDEN:
    return 9;
  case STATUSNOTFOUND:
    return 9;
  case STATUSMETHODNOTALLOWED:
    return 18;
  case STATUSNOTACCEPTABLE:
    return 14;
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return 29;
  case STATUSREQUESTTIMEOUT:
    return 15;
  case STATUSCONFLICT:
    return 8;
  case STATUSGONE:
    return 4;
  case STATUSLENGTHREQUIRED:
    return 15;
  case STATUSPRECONDITIONFAILED:
    return 19;
  case CONTENTTOOLARGE:
    return 17;
  case STATUSURITOOLONG:
    return 12;
  case STATUSUNSUPPORTEDMEDIATYPE:
    return 22;
  case STATUSRANGENOTSATISFIABLE:
    return 21;
  case STATUSEXPECTATIONFAILED:
    return 18;
  case STATUSMISDIRECTEDREQUEST:
    return 19;
  case STATUSUNPROCESSABLECONTENT:
    return 21;
  case STATUSLOCKED:
    return 6;
  case STATUSFAILEDDEPENDENCY:
    return 17;
  case STATUSTOOEARLY:
    return 9;
  case STATUSUPGRADEREQUIRED:
    return 16;
  case STATUSPRECONDITIONREQUIRED:
    return 21;
  case STATUSTOOMANYREQUESTS:
    return 17;
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return 31;
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return 29;
  case STATUSInternalServerError:
    return 21;
  case STATUSNOTIMPLEMENTED:
    return 15;
  case STATUSBADGATEWAY:
    return 11;
  case STATUSSERVICEUNAVAILABLE:
    return 19;
  case STATUSGATEWAYTIMEOUT:
    return 15;
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return 26;
  case STATUSVARIANTALSONEGOTIATES:
    return 23;
  case STATUSINSUFFICIENTSTORAGE:
    return 20;
  case STATUSLOOPDETECTED:
    return 13;
  case STATUSNOTEXTENDED:
    return 12;
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return 31;
  default:
    return 0;
  }
}

/*
 * Return the status code string as string literal
 */
static inline char *status_str(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return "Continue";
  case STATUSSWITCHINGPROTOCOLS:
    return "Switching Protocols";
  case STATUSPROCESSING:
    return "Processing";
  case STATUSEARLYHINTS:
    return "Early Hints";
  case STATUSOK:
    return "OK";
  case STATUSCREATED:
    return "Created";
  case STATUSACCEPTED:
    return "Accepted";
  case STATUSNONAUTHORITATIVE:
    return "Non-Authoritative Information";
  case STATUSNOCONTENT:
    return "No Content";
  case STATUSRESETCONTENT:
    return "Reset Content";
  case STATUSPARTIALCONTENT:
    return "Partial Content";
  case STATUSMULTISTATUS:
    return "Multi-Status";
  case STATUSALREADYREPORTED:
    return "Already Reported";
  case STATUSIMUSED:
    return "Im Used";
  case STATUSMULTIPLECHOICES:
    return "Multiple Choices";
  case STATUSMOVEDPERMANENTLY:
    return "Moved Permanently";
  case STATUSFOUND:
    return "Found";
  case STATUSSEEOTHER:
    return "See Other";
  case STATUSNOTMODIFIED:
    return "Not Modified";
  case STATUSUSEPROXY:
    return "Use Proxy";
  case STATUSTEMPORARYREDIRECT:
    return "Temporary Redirect";
  case STATUSPERMANENTREDIRECT:
    return "Permanent Redirect";
  case STATUSBADREQUEST:
    return "Bad Request";
  case STATUSUNAUTHORIZED:
    return "Unauthorized";
  case STATUSPAYMENTREQUIRED:
    return "Payment Required";
  case STATUSFORBIDDEN:
    return "Forbidden";
  case STATUSNOTFOUND:
    return "Not Found";
  case STATUSMETHODNOTALLOWED:
    return "Method Not Allowed";
  case STATUSNOTACCEPTABLE:
    return "Not Acceptable";
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return "Proxy Authentication Required";
  case STATUSREQUESTTIMEOUT:
    return "Request Timeout";
  case STATUSCONFLICT:
    return "Conflict";
  case STATUSGONE:
    return "Gone";
  case STATUSLENGTHREQUIRED:
    return "Length Required";
  case STATUSPRECONDITIONFAILED:
    return "Precondition Failed";
  case CONTENTTOOLARGE:
    return "Content Too Large";
  case STATUSURITOOLONG:
    return "URI Too Long";
  case STATUSUNSUPPORTEDMEDIATYPE:
    return "Unsupported Media Type";
  case STATUSRANGENOTSATISFIABLE:
    return "Range Not Satisfiable";
  case STATUSEXPECTATIONFAILED:
    return "Expectation Failed";
  case STATUSMISDIRECTEDREQUEST:
    return "Misdirected Request";
  case STATUSUNPROCESSABLECONTENT:
    return "Unprocessable Content";
  case STATUSLOCKED:
    return "Locked";
  case STATUSFAILEDDEPENDENCY:
    return "Failed Dependency";
  case STATUSTOOEARLY:
    return "Too Early";
  case STATUSUPGRADEREQUIRED:
    return "Upgrade Required";
  case STATUSPRECONDITIONREQUIRED:
    return "Precondition Required";
  case STATUSTOOMANYREQUESTS:
    return "Too Many Requests";
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return "Request Header Fields Too Large";
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return "Unavailable For Legal Reasons";
  case STATUSInternalServerError:
    return "Internal Server Error";
  case STATUSNOTIMPLEMENTED:
    return "Not Implemented";
  case STATUSBADGATEWAY:
    return "Bad Gateway";
  case STATUSSERVICEUNAVAILABLE:
    return "Service Unavailable";
  case STATUSGATEWAYTIMEOUT:
    return "Gateway Timeout";
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return "HTTP Version Not Supported";
  case STATUSVARIANTALSONEGOTIATES:
    return "Variant Also Negotiates";
  case STATUSINSUFFICIENTSTORAGE:
    return "Insufficient Storage";
  case STATUSLOOPDETECTED:
    return "Loop Detected";
  case STATUSNOTEXTENDED:
    return "Not Extended";
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return "Network Authentication Required";
  default:
    return 0;
  }
}

/*
 * Return true if routes match
 */
static inline bool route_equ(Route *route, Request *req) {
  return route->method == req->method && strncmp(route->path, req->path, strlen(route->path)) == 0;
}

/*
 * Return the matching route index on success. -1 on failure
 */
static inline int match_route(Server *serv, Request *req) {
  for (size_t i = 0; i < serv->_nroutes; i++) {
    Route route = serv->routes[i];
    if (!req->path || !route.path)
      continue;
    if (route_equ(&route, req))
      return i;
    else if (req->method == HEAD && route.method == GET && strcmp(route.path, req->path) == 0)
      return i;
  }
  return -1;
}

/*
 * Return true if the response should contain the Content-Length header
 */
static inline bool should_have_content_length(Request *req, ResWriter *res) {
  return (req->method != CONNECT              // CONNECT request
          && res->status != STATUSNOCONTENT   // 204 response
          && res->status != STATUSNOTMODIFIED // 304 response
          && res->status >= 200);             // 1xx response
}

/*
 * Format http response from the ResWriter.
 * Return response size on success, 0 on failure.
 */
static inline size_t fmt_res(Request *req, ResWriter *res, char *buffer, size_t buffer_size) {
  if (!res || !buffer || buffer_size == 0)
    return 0;

  size_t res_len, total = 0;
  char *dst = buffer;
  size_t maxlen = buffer_size;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t body_length = res->len;

  res_len = snprintf(dst, maxlen, "HTTP/1.1 %d %s", (int)res->status, status_str(res->status));
  total += res_len;
  dst += res_len;
  maxlen -= res_len;

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    res_len = snprintf(dst, maxlen, "\r\n%s: %s", header->key, header->value);
    total += res_len;
    dst += res_len;
    maxlen -= res_len;
  }

  if (have_content_length) {
    res_len = snprintf(dst, maxlen, "\r\nContent-Length: %lu", body_length);
    total += res_len, dst += res_len, maxlen -= res_len;
  }

  memcpy(dst, "\r\n\r\n", 4);
  total += 4, dst += 4, maxlen -= 4;

  return total;
}

static inline size_t res_len(Request *req, ResWriter *res) {
  if (!req || !res)
    return 0;

  if (!res->status)
    res->status = STATUSOK;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t result = 0;
  result += STRLEN("HTTP/1.1 ");     // HTTP version
  result += 4;                       // Status code + space
  result += status_len(res->status); // Status name

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    result += 2;                       // "\r\n"
    result += strlen(header->key) + 2; // Header key + ':' + space
    result += strlen(header->value);   // header value
  }

  if (have_content_length) {
    result += 2;                          // "\r\n"
    result += STRLEN("Content-Length: "); // Header key
    result += countd(res->len);           // Header value
  }

  result += 4; // "\r\n\r\n"

  return result;
}

static inline int send_empty_res(Status status) {
  size_t res_len = STRLEN("HTTP/1.1 ")        // HTTP version
                   + countd((uint64_t)status) // status code
                   + 1                        // space
                   + (int)status_len(status)  // status string
                   + 4;                       // \r\n\r\n

  conn_t *conn = current_send;
  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, res_len);
  if (snprintf((char *)rec->iov_base, res_len + 1, "HTTP/1.1 %d %s\r\n\r\n", (int)status, status_str(status))
      != (int)res_len)
    return -1;

  return usendmsg(conn, 0, 1);
}

static inline ssize_t read_socket(int sockfd, size_t len) {
  if (len == 0 || sockfd <= 0)
    return 0;
  char buff[1024 * 8];
  return read(sockfd, buff, 1024 * 8);
}

static inline int read_method(Method *method, void *src) {
  if (memcmp(src, "GET", 3) == 0)
    *method = GET;
  else if (memcmp(src, "POST", 4) == 0)
    *method = POST;
  else if (memcmp(src, "HEAD", 4) == 0)
    *method = HEAD;
  else if (memcmp(src, "PUT", 3) == 0)
    *method = PUT;
  else if (memcmp(src, "DELETE", 6) == 0)
    *method = DELETE;
  else if (memcmp(src, "CONNECT", 7) == 0)
    *method = CONNECT;
  else if (memcmp(src, "OPTIONS", 7) == 0)
    *method = OPTIONS;
  else if (memcmp(src, "TRACE", 5) == 0)
    *method = TRACE;
  else if (memcmp(src, "PATCH", 5) == 0)
    *method = PATCH;
  else
    return -1;

  return 0;
}

static inline int sendmsg_res(Request *req, ResWriter *res) {
  conn_t *conn;
  size_t head_size, res_size;
  struct iovec *iov;

  conn = current_send;
  iov = &conn->ios[0];
  head_size = res_len(req, res);
  if (head_size == 0)
    return -1;

  conn->data_left += head_size;
  res_size = fmt_res(req, res, iov->iov_base, (head_size + 1));
  if (res_size != head_size)
    return -1;
  iov->iov_len = res_size;

  return usendmsg(conn, 0, conn->nios);
}

static inline int read_req(Request *req, char *req_buffer) {
  if (!req_buffer)
    return -1;
  /*** Method ***/
  char *sep = strchr(req_buffer, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }
  *sep = '\0';
  if (read_method(&req->method, req_buffer) < 0)
    return -1;

  /*** Path ***/
  char *fullpath = sep + 1;
  sep = strchr(fullpath, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }

  *sep = '\0';
  req->path = fullpath;
  /*** Params ***/
  char *paramStart = strchr(fullpath, '?');
  if (paramStart) {
    *paramStart++ = '\0';
    int params_count = 0;
    params_count = HK_parse_params(paramStart, req->params, MAX_URL_PARAMETERS);
    if (params_count > 0)
      req->params_count = params_count;
    else
      req->params_count = 0;
  } else {
    req->params = NULL;
    req->params_count = 0;
  }

  /*** Headers ***/
  char *headStart = strstr(sep + 1, "\r\n");
  char *headEnd = strstr(sep + 1, "\r\n\r\n");
  if (!headStart) {
    LOG("read_req: !headStart\n");
    return -1;
  };

  memset(headStart, 0, 2);
  headStart += 2;
  memset(headEnd, 0, 4);
  headEnd += 4;

  int headers_count = HK_parse_headers(headStart, req->headers, MAX_REQ_HEADERS);
  if (headers_count <= 0)
    return -1;
  req->headers_count = headers_count;

  /*** Host ***/
  int index = HK_get_header(req, "Host");
  if (index < 0)
    return -1;
  char *host = req->headers[index].value;
  req->hostname = host;

  /*** Port ***/
  char *colon = strchr(host, ':');
  if (colon) {
    *colon++ = '\0';
    req->port = atoi(colon);
  } else {
    req->port = PORT;
  }
  return 0;
}
static inline int process_req(Server *serv, conn_t *conn) {
  if (!conn || conn->fd == -1)
    return -1;

  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;
  if (read_req(&req, conn->ios[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    LOG("Err: route_index == -1\n");
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;
  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  sendmsg_res(&req, &res);

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int new_conn(int connfd) {
  if (connfd <= 0)
    return -1;

  current_recv = MP_use(KB * 2, connfd, false);
  current_send = MP_use(KB * 2, connfd, false);

  current_recv->recv_conn = current_recv;
  current_recv->send_conn = current_send;

  current_send->send_conn = current_send;
  current_send->recv_conn = current_recv;

  conn_t *conn = current_recv;
  if (ufrecvmsg(conn, 0, 1) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

static inline int resubmit_sendmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return usendmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int resubmir_recvmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    // FIXME the len should be increased
    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return urecvmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int handle_sendmsg_complete(conn_t *conn) {
  struct iovec *iov, *rec;

  MP_shed(conn, 1, conn->nios - 1);
  iov = &conn->ios[0];
  rec = &conn->rec[0];
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;

  return ufrecvmsg(conn->recv_conn, 0, 1);
}

static inline int handle_sendmsg(conn_t *conn, int res, bool zc) {
  if (!conn || conn->fd == -1)
    return -1;

  conn->data_left -= res;
  if (conn->data_left > 0)
    return resubmit_sendmsg(conn, res);

  if (zc)
    return 0;

  return handle_sendmsg_complete(conn);
}

static inline int handle_insplice(conn_t *conn) {
  conn->op = OUTSPLICE;
  return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
}
static inline int handle_outsplice(conn_t *conn, int res) {
  conn->data_left -= res;
  if (conn->data_left > 0) {
    conn->op = INSPLICE;
    return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
  }

  conn_t *recv_conn = conn->recv_conn;
  struct iovec *iov = &recv_conn->ios[0];
  memset(iov->iov_base, 0, iov->iov_len);
  if (urecv(recv_conn, iov->iov_base, iov->iov_len, MSG_PEEK) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

/*
static inline int handle_recv(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  void *bptr = conn->ios[0].iov_base;
  void *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  void *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  return process_req(serv, conn);
}
*/
static inline int find_route(Server *serv, char *bptr) {
  Request req = {0};
  if (read_method(&req.method, bptr) < 0) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  };
  char *space = strchr(bptr, ' ');
  req.path = (space + 1);
  space = strchr(req.path, ' ');
  *space = '\0';
  int route_index = match_route(serv, &req);
  *space = ' ';
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }
  return route_index;
}

static inline int run_handler(Server *serv, conn_t *conn, bool uses_body) {
  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;

  if (read_req(&req, conn->rec[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  if (uses_body) {
    int h_index = HK_get_header(&req, "Content-Length");
    long body_size = atol(req.headers[h_index].value);
    if (body_size >= 0) {
      req.body.ptr = conn->rec[1].iov_base;
      req.body.size = body_size;
    } else {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    }
  }

  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  if (sendmsg_res(&req, &res) < 0)
    return -1;

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int handle_frecvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  char *bptr = (char *)conn->ios[0].iov_base;
  char *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  char *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  size_t head_size = (headEnd + 4) - bptr;
  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  int route_index = find_route(serv, bptr);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  bool uses_body = serv->routes[route_index].uses_body;
  long body_size = get_content_length(headstart + 2, headEnd + 4);
  if (body_size == -1) {
    if (uses_body) {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    } else {
      body_size = 0;
    }
  }

  conn->head_size = head_size;
  if (!uses_body) {
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  if (res == (int)(head_size + body_size)) {
    size_t iov_index = MP_expand(conn, round_to_blocks(body_size), false);
    memcpy(conn->rec[iov_index].iov_base, headEnd + 4, body_size);
    conn->ios[iov_index].iov_len = body_size;
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  conn->data_left = body_size - (res - head_size);
  bool once = ((size_t)body_size > (size_t)((pool.nblocks * MP_BLOCK) / 10));
  size_t iov_index = MP_expand(conn, round_to_blocks(body_size), once);
  memcpy(conn->rec[iov_index].iov_base, headEnd + 4, (res - head_size));
  conn->ios[iov_index].iov_base += (res - head_size);

  return urecvmsg(conn, iov_index, 1);
}

static inline int handle_recvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  if (conn->data_left > 0) {
    conn->data_left -= res;
    if (conn->data_left == 0) {
      conn->flags &= CF_HANDLER_READY;
      return run_handler(serv, conn, true);
    }

    conn->flags &= ~CF_HANDLER_READY;
    conn->ios[1].iov_base += res;
    return urecvmsg(conn, 1, 1);
  }

  conn->flags &= CF_HANDLER_READY;
  return run_handler(serv, conn, true);
}

static inline int serv_init(Server *serv) {
#if DEBUG
  logfd = log_init("log.txt");
  if (!logfd) {
    printf("log_init failed");
    return -1;
  }
#endif
  serv->_nroutes = get_nroutes(serv->routes);

  int pipefd[2];
  if (pipe(pipefd) < 0)
    return -1;
  pipe_in = pipefd[0];
  pipe_out = pipefd[1];
  nullfd = open("/dev/null", O_WRONLY);
  pipe_sz = fcntl(pipefd[0], F_GETPIPE_SZ);
  if (pipe_sz < 0)
    return -1;

  pool.rtimeout = serv->rtimeout;
  pool.wtimeout = serv->wtimeout;
  if (MP_init(MAX_CONNS * 8) < 0)
    return -1;
  LOG("pool initialized\n");

  if (io_uring_queue_init(MAX_CONNS, &ring, 0) < 0)
    return -1;
  LOG("uring initialized\n");

  int listenfd;
  if ((listenfd = tcp_listen(serv->port)) < 0)
    return -1;
  LOG("socket initialized\n");

  return umaccept(listenfd);
}

static inline int serv_listen(Server *serv) {
  // uint64_t last_check = get_time();
  while (true) {
    // uint64_t now = get_time();
    // if ((now - last_check) >= 200) {
    //   last_check = now;
    //   LOG("CM: CM_check ran\n");
    //   MP_timeout();
    // }

    LOG("SQ ready: %u, CQ ready: %u\n", io_uring_sq_ready(&ring), io_uring_cq_ready(&ring));
    struct io_uring_cqe *cqe;
    if (io_uring_wait_cqe(&ring, &cqe) < 0)
      continue;

    int res = cqe->res;
    LOG("res = %d\n", res);
    conn_t *conn = NULL;
    if (cqe->user_data > 100) {
      conn = (conn_t *)cqe->user_data;
      current_recv = (conn_t *)conn->recv_conn;
      current_send = (conn_t *)conn->send_conn;
    }

    if (res > 0) {
      if (cqe->user_data == ACCEPT) {
        LOG("new conn created\n");
        new_conn(res);
      } else if (conn && conn->fd != -1) {
        LOG("conn[%d]: conn.fd = %d; conn.op = %d\n", conn->cindex, conn->fd, conn->op);
        switch (conn->op) {
        case FRECVMSG:
          if (handle_frecvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case RECVMSG:
          if (handle_recvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case SENDMSG:
        case SENDMSGZC:
          // conn->last_write = get_time();
          bool zc = (conn->op == SENDMSGZC);
          if (handle_sendmsg(conn, res, zc) < 0)
            MP_clear(conn);
          break;
        case INSPLICE:
          if (handle_insplice(conn) < 0)
            MP_clear(conn);
          break;
        case OUTSPLICE:
          if (handle_outsplice(conn, res) < 0)
            MP_clear(conn);
          break;
        }
      }
    } else if (res == 0) {
      if (conn && conn->fd != -1) {
        switch (conn->op) {
        case SENDMSGZC:
          conn->zc_notifs--;
          if (conn->zc_notifs == 0 && handle_sendmsg_complete(conn) < 0)
            MP_clear(conn);
          break;
        case RECV:
          MP_clear(conn);
          break;
        }
      }
    } else {
      if (conn && conn->fd != -1) {
        if (res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR) {
          LOG("conn && conn->fd != -1 && res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR\n");
          MP_clear(conn);
        } else {
          LOG("res == -EAGAIN || res == -EWOULDBLOCK || res == -EINTR\n");
          conn = conn->recv_conn;
          struct iovec *iov = &conn->ios[0];
          memset(iov->iov_base, 0, iov->iov_len);
          if (urecv(conn, iov->iov_base, iov->iov_len, 0) < 0)
            MP_clear(conn);
        }
      }
    }

    LOG("uring operation seen\n");
    io_uring_cqe_seen(&ring, cqe);
  }

  io_uring_queue_exit(&ring);
  MP_exit(&pool);
  return 0;
}

/*** Helper ***/
static inline int _HK_write(void *data, size_t size) {
  size_t nblocks;
  int iov_index;
  conn_t *conn;
  struct iovec *iov;
  bool once;

  conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  nblocks = round_to_blocks(size);
  iov_index = MP_expand(conn, nblocks, once);
  iov = &conn->ios[iov_index];

  memcpy(iov->iov_base, data, size);
  iov->iov_len = size;
  conn->data_left += size;

  return 0;
}
static inline int _HK_write_body(Request *req, size_t offset, size_t size) {
  if (size > req->body.size || offset > req->body.size)
    return -1;

  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  int iov_index = MP_expand(conn, 0, false);
  struct iovec *iov = &conn->ios[iov_index];
  struct iovec *rec = &conn->rec[iov_index];
  rec->iov_base = req->body.ptr + offset;
  rec->iov_len = size;
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;
  conn->data_left += rec->iov_len;
  return 0;
}
/*
static inline int _HK_mem(size_t size, HKMem *mem) {
  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  bool once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  size_t nblocks = round_to_blocks(size);
  int iov_index = MP_expand(conn, nblocks, once);
  struct iovec *iov = &conn->ios[iov_index];
  mem->ptr = iov->iov_base;
  mem->size = iov->iov_len;
  mem->_iov_index = iov_index;
  mem->_flags = (IN_POOL(iov->iov_base)) ? CF_IN_POOL : CF_IN_HEAP;
  return 0;
}

static inline void _HK_send(HKMem *mem, size_t size) {
  conn_t *conn = current_send;
  struct iovec *iov = &conn->ios[mem->_iov_index];
  iov->iov_len = size;
  conn->data_left += size;
}
  */
#endif#define _GNU_SOURCE
#ifndef UTILS_H
#define UTILS_H

#include "hunk.h"
#include <arpa/inet.h>
#include <fcntl.h>
#include <liburing.h>
#include <netdb.h>
#include <signal.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/poll.h>
#include <sys/prctl.h>
#include <sys/socket.h>
#include <sys/sysinfo.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

#define MP_BLOCK  4
#define MAX_CONNS 4096
#define KB        1024
#define NIOS      32

#define IN_POOL(ptr)                 ((void *)ptr >= pool.bpool && (void *)ptr <= (pool.bpool + (pool.npages * pool.pagesize)))
#define ALIGN_TO_PAGESIZE(buff_size) (((buff_size) + (pool.pagesize - 1)) & ~(pool.pagesize - 1))
#define BYTES_TO_BLOCKS(buff_size)   (((buff_size) + (MP_BLOCK - 1)) / MP_BLOCK)
#define CEIL_BLOCKS(nblocks)         ((nblocks + 63) & ~63)
#define CEIL_PAGES(size)             (((size) + ((pool.pagesize) - 1)) & ~((pool.pagesize) - 1))

#define BIT_IS_FREE(word, bit)   (((word) >> (bit)) & 1)
#define MARK_BIT_USED(word, bit) ((word) &= ~(1ULL << (bit)))
#define MARK_BIT_FREE(word, bit) ((word) |= (1ULL << (bit)))
#define FIND_FREE_BIT(word)      ((uint64_t)(word) & -(uint64_t)(word))
#define STRLEN(s)                (sizeof(s) - 1)

#define IOVEC_NBLOCKS (BYTES_TO_BLOCKS(NIOS * sizeof(struct iovec)))
#define MSG_NBLOCKS   (BYTES_TO_BLOCKS(sizeof(struct msghdr)))
#define ZC_RES        KB *KB

#define DEBUG 0
#if DEBUG
#define LOG(...) fprintf(logfd, __VA_ARGS__)
#else
#define LOG(...) ((void)0)
#endif

typedef enum UOP {
  WRITEV = IORING_OP_WRITEV,
  SENDMSG = IORING_OP_SENDMSG,
  RECVMSG = IORING_OP_RECVMSG,
  ACCEPT = IORING_OP_ACCEPT,
  SEND = IORING_OP_SEND,
  RECV = IORING_OP_RECV,
  SENDZC = IORING_OP_SEND_ZC,
  SENDMSGZC = IORING_OP_SENDMSG_ZC,
  PEEK = 50,
  FRECVMSG,
  INSPLICE,
  OUTSPLICE
} UOP;

typedef enum CFS {
  CF_IN_POOL = (1 << 0),       // Connection is in the pool
  CF_IN_HEAP = (1 << 1),       // Connection is in the heap
  CF_SKIP_SOCK = (1 << 2),     // Don't close the socket
  CF_USE_ONCE = (1 << 3),      // Destroy after using
  CF_HANDLER_READY = (1 << 4), // Ready to call the handler
} CFS;

typedef struct conn_t {
  // Socket file descriptor
  int fd;

  // Amount of data left in the current operation
  uint64_t data_left;

  // The index of the connection struct
  uint32_t cindex;

  // The last time the connection was readable
  uint64_t last_read;

  // The last time the connection was writeable
  uint64_t last_write;

  // The operation currently being processed
  uint8_t op;

  // Connection flags
  int flags;

  // Splice fd_in
  int in_fd;

  // Splice fd_out
  int out_fd;

  void *recv_conn;
  void *send_conn;

  struct iovec *ios;
  struct iovec *rec;
  uint16_t nios;

  struct msghdr *msg;
  uint16_t zc_notifs;

  uint16_t head_size;
} conn_t;

typedef struct MPool {
  // The allocated pool of blocks
  void *bpool;

  // The allocated pool of connections
  conn_t *cpool;

  // The size of the pool in pages
  uint32_t npages;

  // The size of the pool in blocks
  uint32_t nblocks;

  // The locations of each page in the pool
  void **blocks;

  // The availability of each block
  uint64_t *freebs;

  // The locations of each conn in the pool
  conn_t **conns;

  // The availability of each conn
  uint64_t *freecs;

  // Clean up callback function
  void (*callback)(conn_t *conn);

  // The page size used
  uint32_t pagesize;

  // Socket read timeout
  uint32_t rtimeout;

  // Socket write timeout
  uint32_t wtimeout;
} MPool;

extern int pipe_sz;
extern int pipe_in, pipe_out, nullfd;
extern FILE *logfd;
extern struct io_uring ring;
extern MPool pool;
extern conn_t *current_recv;
extern conn_t *current_send;

/*
 * Prepare and submit a recv uring op
 */
static inline int urecv(conn_t *conn, void *buffer, size_t buff_size, int flags) {
  if (!conn || conn->fd == -1)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (flags == MSG_PEEK) ? PEEK : RECV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;

  io_uring_prep_recv(sqe, conn->fd, buffer, buff_size, flags);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a multi-shot accept uring op
 */
static inline int umaccept(int listenfd) {
  if (listenfd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = ACCEPT;
  io_uring_prep_multishot_accept(sqe, listenfd, NULL, NULL, SOCK_NONBLOCK);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a splice uring op
 */
static inline int usplice(conn_t *conn, int fd_in, int64_t off_in, int fd_out, int64_t off_out, size_t len) {
  if (!len || !conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = (__u64)conn;
  io_uring_prep_splice(sqe, fd_in, off_in, fd_out, off_out, len, 0);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a writev uring op
 */
static inline int uwritev(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = WRITEV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  io_uring_prep_writev(sqe, conn->fd, &conn->ios[iov_index], nios, -1);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a send uring op
 */
static inline int usend(conn_t *conn, char *res_buff, size_t buff_size, bool zc) {
  if (!conn || conn->fd <= 0 || buff_size == 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (zc) ? SENDZC : SEND;
  conn->data_left = buff_size;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  if (zc)
    io_uring_prep_send_zc(sqe, conn->fd, res_buff, buff_size, 0, 0);
  else
    io_uring_prep_send(sqe, conn->fd, res_buff, buff_size, 0);
  return io_uring_submit(&ring);
}

static inline int ufrecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = FRECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;

  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, rec->iov_len);
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int urecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = RECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int usendmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  bool zc = (conn->data_left > ZC_RES) ? true : false;
  conn->op = (zc) ? SENDMSGZC : SENDMSG;

  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  if (zc) {
    io_uring_prep_sendmsg_zc(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
    conn->zc_notifs++;
  } else {
    io_uring_prep_sendmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  }
  return io_uring_submit(&ring);
}

/*
 * Create and initialize a server socket
 */
static inline int tcp_listen(uint16_t port) {
  int enable;
  int listenfd;
  if ((listenfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    return -1;

  int flags = fcntl(listenfd, F_GETFL, 0);
  fcntl(listenfd, F_SETFL, flags | O_NONBLOCK);
  struct sockaddr_in servaddr;
  memset(&servaddr, 0, sizeof(servaddr));
  servaddr.sin_family = AF_INET;
  servaddr.sin_addr.s_addr = INADDR_ANY;
  servaddr.sin_port = htons(port);

  enable = 1;
  if (setsockopt(listenfd, SOL_SOCKET, SO_REUSEPORT, &enable, sizeof(enable)) < 0)
    return -1;

  if (bind(listenfd, (struct sockaddr *)&servaddr, sizeof(servaddr)) < 0)
    return -1;

  if (listen(listenfd, SOMAXCONN) < 0)
    return -1;

  return listenfd;
}

/*
 * Calculate the difference between two pointers
 */
static inline uintptr_t ptr_diff(uintptr_t p1, uintptr_t p2) { return (uintptr_t)(p1 > p2) ? (p1 - p2) : (p2 - p1); }

static inline size_t get_nroutes(Route *routes) {
  Route *route;
  for (size_t i = 0;; i++) {
    route = &routes[i];
    if (!route->path && !route->handler && !route->method)
      return i;
  }
}

static inline long get_content_length(char *src, char *end) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return -1;
    key = line;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, "Content-Length") != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;

    *line_end = '\0';
    long res = atol(value);
    *line_end = '\r';

    return res;
  }
  return -1;
}

static inline bool have_header(char *src, char *end, const char *header_key, const char *header_value) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    key = line;
    while (*key == ' ')
      key++;
    while (*header_key == ' ')
      header_key++;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return false;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, header_key) != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;
    while (*header_value == ' ')
      header_value++;

    *line_end = '\0';
    bool res = (strcasecmp(value, header_value) == 0);
    *line_end = '\r';

    return res;
  }

  return false;
}

static inline const char *method_str(Method method) {
  switch (method) {
  case GET:
    return "GET";
    break;
  case HEAD:
    return "HEAD";
    break;
  case POST:
    return "POST";
    break;
  case PUT:
    return "PUT";
    break;
  case DELETE:
    return "DELETE";
    break;
  case CONNECT:
    return "CONNECT";
    break;
  case OPTIONS:
    return "OPTIONS";
    break;
  case TRACE:
    return "TRACE";
    break;
  case PATCH:
    return "PATCH";
    break;
  default:
    return NULL;
  }
}

static inline uint8_t method_len(Method method) {
  switch (method) {
  case GET:
    return 3;
    break;
  case HEAD:
    return 4;
    break;
  case POST:
    return 4;
    break;
  case PUT:
    return 3;
    break;
  case DELETE:
    return 6;
    break;
  case CONNECT:
    return 7;
    break;
  case OPTIONS:
    return 7;
    break;
  case TRACE:
    return 5;
    break;
  case PATCH:
    return 5;
    break;
  default:
    return 0;
  }
}

static inline size_t round_to_blocks(size_t size) {
  size_t nblocks = BYTES_TO_BLOCKS(size);
  nblocks = CEIL_BLOCKS(nblocks);
  return nblocks;
}

/*
 * Count the digits in unsigned 64-bit int
 */
static inline int countd(uint64_t num) {
  if (num < 10ULL)
    return 1;
  if (num < 100ULL)
    return 2;
  if (num < 1000ULL)
    return 3;
  if (num < 10000ULL)
    return 4;
  if (num < 100000ULL)
    return 5;
  if (num < 1000000ULL)
    return 6;
  if (num < 10000000ULL)
    return 7;
  if (num < 100000000ULL)
    return 8;
  if (num < 1000000000ULL)
    return 9;
  if (num < 10000000000ULL)
    return 10;
  if (num < 100000000000ULL)
    return 11;
  if (num < 1000000000000ULL)
    return 12;
  if (num < 10000000000000ULL)
    return 13;
  if (num < 100000000000000ULL)
    return 14;
  if (num < 1000000000000000ULL)
    return 15;
  if (num < 10000000000000000ULL)
    return 16;
  if (num < 100000000000000000ULL)
    return 17;
  if (num < 1000000000000000000ULL)
    return 18;
  if (num < 10000000000000000000ULL)
    return 19;
  return 20;
}

/*
 * Get the time elabsed in ms
 */
static inline uint64_t get_time() {
  struct timespec ts;
  clock_gettime(CLOCK_MONOTONIC, &ts);
  return (uint64_t)(ts.tv_sec) * 1000 + (ts.tv_nsec / 1000000);
}

static inline FILE *log_init(const char *path) {
  FILE *res = fopen(path, "a+");
  setvbuf(res, NULL, _IONBF, 0);
  return res;
}

static inline int16_t pollevs(int connfd) {
  struct pollfd pfd;
  pfd.fd = connfd;
  pfd.events = POLLIN | POLLOUT | POLLERR;
  int res = poll(&pfd, 1, 0);
  if (res < 0)
    return POLLERR;
  return pfd.revents;
}

// FIXME This needs to be updated
static inline conn_t *MP_use_once(size_t nblocks, int fd) {

  void *mem = malloc(sizeof(conn_t) + 8 + (IOVEC_NBLOCKS * MP_BLOCK));
  struct conn_t *conn = (conn_t *)mem;
  memset(conn, 0, sizeof(conn_t));
  conn->ios = mem + sizeof(conn_t) + 8;

  if (nblocks > 0) {
    struct iovec *iov = &conn->ios[conn->nios++];
    mem = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (mem == MAP_FAILED)
      return NULL;
    iov->iov_base = mem;
    iov->iov_len = ALIGN_TO_PAGESIZE(nblocks * MP_BLOCK);
  }

  conn->flags |= CF_IN_HEAP;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;

  return conn;
}

static inline int find_freec() {
  uint64_t *word;
  size_t map_size = (sizeof(uint64_t) * 8);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    word = &pool.freecs[i / map_size];

    if (*word == 0) { // All used
      i += (map_size - 1);
      continue;
    }

    i += __builtin_ctzll(*word);
    MARK_BIT_USED(*word, i);
    return i;
  }

  return -1;
}

static inline int MP_init(size_t npages) {
  if (!npages)
    return -1;

  /*** Setup ***/
  pool.npages = npages;
  pool.pagesize = sysconf(_SC_PAGESIZE);

  /*** Pool ***/
  pool.bpool = mmap(NULL, pool.npages * pool.pagesize, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  if (pool.bpool == MAP_FAILED)
    return -1;
  pool.nblocks = (pool.npages * pool.pagesize) / MP_BLOCK;

  /*** Blocks ***/
  pool.blocks = malloc(sizeof(void *) * pool.nblocks);
  if (!pool.blocks)
    return -1;
  for (size_t i = 0; i < pool.nblocks; i++)
    pool.blocks[i] = pool.bpool + (i * MP_BLOCK);

  /*** Freebs ***/
  // if (posix_memalign((void **)&pool.freebs, 64, bitmap_size * sizeof(uint64_t)) < 0)
  size_t bitmap_size = (pool.nblocks + 63) / 64;
  pool.freebs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freebs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freebs[i] = UINT64_MAX;

  /*** Cpool ***/
  pool.cpool = (conn_t *)malloc(sizeof(conn_t) * MAX_CONNS);
  if (!pool.cpool)
    return -1;

  /*** Conns ***/
  pool.conns = (conn_t **)malloc(sizeof(conn_t *) * MAX_CONNS);
  if (!pool.conns)
    return -1;
  size_t conn_size = sizeof(conn_t);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    pool.conns[i] = (conn_t *)((char *)pool.cpool + (i * conn_size));
    pool.conns[i]->fd = -1;
    pool.conns[i]->in_fd = -1;
    pool.conns[i]->out_fd = -1;
  }

  /*** Freecs ***/
  bitmap_size = (MAX_CONNS + 63) / 64;
  pool.freecs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freecs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freecs[i] = UINT64_MAX;

  return 0;
}

static inline int MP_use_blks(size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t max_start = pool.nblocks - nblocks;
  size_t full_chunks = (nblocks / 64) * 64;

  for (size_t i = 0, c = 0; i <= max_start; i++, c++) {
    bool free = true;

    for (size_t j = 0; j < full_chunks; j += 64) {
      size_t word_index = (i + j) / 64;
      if (pool.freebs[word_index] != UINT64_MAX) {
        free = false;
        i += 63;
        break;
      }
    }

    for (size_t j = full_chunks; j < nblocks; j++) {
      size_t bit_index = i + j;
      size_t word_index = bit_index / 64;
      size_t bit_in_word = bit_index % 64;

      if (!BIT_IS_FREE(pool.freebs[word_index], bit_in_word)) {
        free = false;
        i += j;
        break;
      }
    }

    if (free) {
      for (size_t j = 0; j < full_chunks; j += 64) {
        size_t word_index = (i + j) / 64;
        pool.freebs[word_index] = 0;
      }

      for (size_t j = full_chunks; j < nblocks; j++) {
        size_t bit_index = i + j;
        size_t word_index = bit_index / 64;
        size_t bit_in_word = bit_index % 64;

        MARK_BIT_USED(pool.freebs[word_index], bit_in_word);
      }

      return i;
    }
  }

  return -1;
}

static inline int MP_free_blks(size_t bindex, size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t full_chunks = (nblocks / 64) * 64;
  for (size_t i = 0; i < full_chunks; i += 64) {
    size_t word_index = (bindex + i) / 64;
    pool.freebs[word_index] = UINT64_MAX;
  }

  for (size_t i = full_chunks; i < nblocks; i++) {
    size_t bit_index = bindex + i;
    size_t word_index = bit_index / 64;
    size_t bit_in_word = bit_index % 64;

    MARK_BIT_FREE(pool.freebs[word_index], bit_in_word);
  }

  memset(pool.blocks[bindex], 0, nblocks * MP_BLOCK);
  return 0;
}

static inline conn_t *MP_use(size_t nblocks, int fd, bool once) {
  if (fd <= 0)
    return NULL;
  if (once)
    return MP_use_once(nblocks, fd);

  int cindex = find_freec();
  if (cindex < 0) {
    LOG("Err: cindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  conn_t *conn = pool.conns[cindex];

  int ios_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (ios_bindex < 0) {
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }

  struct iovec *ios = pool.blocks[ios_bindex];
  conn->ios = ios;

  int rec_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (rec_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct iovec *rec = pool.blocks[rec_bindex];
  conn->rec = rec;

  int msg_bindex = MP_use_blks(MSG_NBLOCKS);
  if (msg_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct msghdr *msg = pool.blocks[msg_bindex];
  conn->msg = msg;

  if (nblocks > 0) {
    int bindex = MP_use_blks(nblocks);
    if (bindex < 0) {
      MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
      MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
      MP_free_blks(msg_bindex, IOVEC_NBLOCKS);
      MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
      LOG("Err: bindex < 0; will use MP_use_once\n");
      return MP_use_once(nblocks, fd);
    }

    size_t iov_index = conn->nios++;
    struct iovec *iov = &conn->ios[iov_index];
    struct iovec *rec = &conn->rec[iov_index];
    iov->iov_base = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
  }

  conn->msg->msg_iov = conn->ios;
  conn->msg->msg_iovlen = conn->nios;
  conn->cindex = cindex;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;
  return conn;
}

static inline void MP_shed(conn_t *conn, size_t iov_index, size_t nios) {
  struct iovec *iov, *rec;
  size_t bindex, nblocks, index;

  for (size_t i = 0; i < nios; i++) {
    index = iov_index + i;
    iov = &conn->ios[index];
    rec = &conn->rec[index];
    if (!rec || !rec->iov_base)
      continue;
    if (!IN_POOL(rec->iov_base)) {
      munmap(rec->iov_base, rec->iov_len / pool.pagesize);
    } else {
      bindex = ptr_diff((uintptr_t)rec->iov_base, (uintptr_t)pool.bpool) / MP_BLOCK;
      nblocks = rec->iov_len / MP_BLOCK;
      MP_free_blks(bindex, nblocks);
    }
    memset(iov, 0, sizeof(struct iovec));
    memset(rec, 0, sizeof(struct iovec));
    conn->nios--;
  }
}

static inline int MP_expand(conn_t *conn, size_t nblocks, bool once) {
  void *bptr;
  int iov_index, bindex;
  struct iovec *iov, *rec;

  iov_index = conn->nios++;
  iov = &conn->ios[iov_index];
  rec = &conn->rec[iov_index];

  if (nblocks == 0)
    return iov_index;

  if (once) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_base = bptr;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
    return iov_index;
  }

  bindex = MP_use_blks(nblocks);
  if (bindex < 0) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_len = iov->iov_len;
  } else {
    bptr = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_len = iov->iov_len;
  }

  iov->iov_base = bptr;
  rec->iov_base = iov->iov_base;
  return iov_index;
}

static inline int MP_free(conn_t *conn) {
  if (!conn)
    return -1;
  size_t bindex, nblocks;
  uint64_t *word;

  MP_shed(conn, 0, conn->nios);
  if (conn->flags & CF_IN_HEAP) {
    if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
      close(conn->fd);
    free(conn);
    return 0;
  }

  word = &pool.freecs[conn->cindex / 64];
  if (conn->cindex > MAX_CONNS)
    return -1;
  else if (BIT_IS_FREE(*word, conn->cindex))
    return 0;

  bindex = ptr_diff((uintptr_t)conn->ios, (uintptr_t)pool.bpool) / MP_BLOCK;
  nblocks = IOVEC_NBLOCKS;
  MP_free_blks(bindex, nblocks);

  bindex = ptr_diff((uintptr_t)conn->rec, (uintptr_t)pool.bpool) / MP_BLOCK;
  MP_free_blks(bindex, nblocks);

  if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
    close(conn->fd);

  MARK_BIT_FREE(*word, conn->cindex);
  memset(conn, 0, sizeof(conn_t));
  conn->fd = -1;
  conn->in_fd = -1;
  conn->out_fd = -1;
  return 0;
}

static inline void MP_clear(conn_t *conn) {
  conn_t *recv_conn = conn->recv_conn;
  conn_t *send_conn = conn->send_conn;
  if (recv_conn)
    MP_free(recv_conn);
  if (send_conn)
    MP_free(send_conn);
}

static inline void MP_exit(MPool *pool) {
  munmap(pool->bpool, pool->npages);
  free(pool->cpool);
  free(pool->blocks);
  free(pool->conns);
  free(pool->freebs);
  free(pool->freecs);
}

static inline void MP_timeout() {
  conn_t *conn;
  int16_t res;
  uint64_t now;
  size_t windex = 0;
  uint64_t *word = &pool.freecs[0];
  for (size_t i = 0; i < MAX_CONNS; i++) {
    if ((i / 64) < windex)
      word = &pool.freecs[++windex];

    if (*word == UINTMAX_MAX) {
      i = (i / 64) * 64 + 64;
      continue;
    }

    conn = pool.conns[i];
    if (!conn || conn->fd == -1)
      continue;

    res = pollevs(conn->fd);

    now = get_time();
    if (res & POLLERR) {
      MP_clear(conn);
      continue;
    }
    if (res & POLLIN) {
      if (pool.rtimeout > 0 && (now - conn->last_read) >= pool.rtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (res & POLLOUT) {
      if (pool.wtimeout > 0 && (now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (!(res & POLLIN || res & POLLOUT)) {
      if ((pool.rtimeout > 0 && now - conn->last_read) >= pool.rtimeout
          || (pool.wtimeout > 0 && now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
  }
}

/*
 * Calculate the length of a status string
 */
static inline size_t status_len(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return 8;
  case STATUSSWITCHINGPROTOCOLS:
    return 19;
  case STATUSPROCESSING:
    return 10;
  case STATUSEARLYHINTS:
    return 11;
  case STATUSOK:
    return 2;
  case STATUSCREATED:
    return 7;
  case STATUSACCEPTED:
    return 8;
  case STATUSNONAUTHORITATIVE:
    return 29;
  case STATUSNOCONTENT:
    return 10;
  case STATUSRESETCONTENT:
    return 13;
  case STATUSPARTIALCONTENT:
    return 15;
  case STATUSMULTISTATUS:
    return 12;
  case STATUSALREADYREPORTED:
    return 16;
  case STATUSIMUSED:
    return 7;
  case STATUSMULTIPLECHOICES:
    return 16;
  case STATUSMOVEDPERMANENTLY:
    return 17;
  case STATUSFOUND:
    return 5;
  case STATUSSEEOTHER:
    return 9;
  case STATUSNOTMODIFIED:
    return 12;
  case STATUSUSEPROXY:
    return 9;
  case STATUSTEMPORARYREDIRECT:
    return 18;
  case STATUSPERMANENTREDIRECT:
    return 18;
  case STATUSBADREQUEST:
    return 11;
  case STATUSUNAUTHORIZED:
    return 12;
  case STATUSPAYMENTREQUIRED:
    return 16;
  case STATUSFORBIDDEN:
    return 9;
  case STATUSNOTFOUND:
    return 9;
  case STATUSMETHODNOTALLOWED:
    return 18;
  case STATUSNOTACCEPTABLE:
    return 14;
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return 29;
  case STATUSREQUESTTIMEOUT:
    return 15;
  case STATUSCONFLICT:
    return 8;
  case STATUSGONE:
    return 4;
  case STATUSLENGTHREQUIRED:
    return 15;
  case STATUSPRECONDITIONFAILED:
    return 19;
  case CONTENTTOOLARGE:
    return 17;
  case STATUSURITOOLONG:
    return 12;
  case STATUSUNSUPPORTEDMEDIATYPE:
    return 22;
  case STATUSRANGENOTSATISFIABLE:
    return 21;
  case STATUSEXPECTATIONFAILED:
    return 18;
  case STATUSMISDIRECTEDREQUEST:
    return 19;
  case STATUSUNPROCESSABLECONTENT:
    return 21;
  case STATUSLOCKED:
    return 6;
  case STATUSFAILEDDEPENDENCY:
    return 17;
  case STATUSTOOEARLY:
    return 9;
  case STATUSUPGRADEREQUIRED:
    return 16;
  case STATUSPRECONDITIONREQUIRED:
    return 21;
  case STATUSTOOMANYREQUESTS:
    return 17;
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return 31;
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return 29;
  case STATUSInternalServerError:
    return 21;
  case STATUSNOTIMPLEMENTED:
    return 15;
  case STATUSBADGATEWAY:
    return 11;
  case STATUSSERVICEUNAVAILABLE:
    return 19;
  case STATUSGATEWAYTIMEOUT:
    return 15;
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return 26;
  case STATUSVARIANTALSONEGOTIATES:
    return 23;
  case STATUSINSUFFICIENTSTORAGE:
    return 20;
  case STATUSLOOPDETECTED:
    return 13;
  case STATUSNOTEXTENDED:
    return 12;
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return 31;
  default:
    return 0;
  }
}

/*
 * Return the status code string as string literal
 */
static inline char *status_str(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return "Continue";
  case STATUSSWITCHINGPROTOCOLS:
    return "Switching Protocols";
  case STATUSPROCESSING:
    return "Processing";
  case STATUSEARLYHINTS:
    return "Early Hints";
  case STATUSOK:
    return "OK";
  case STATUSCREATED:
    return "Created";
  case STATUSACCEPTED:
    return "Accepted";
  case STATUSNONAUTHORITATIVE:
    return "Non-Authoritative Information";
  case STATUSNOCONTENT:
    return "No Content";
  case STATUSRESETCONTENT:
    return "Reset Content";
  case STATUSPARTIALCONTENT:
    return "Partial Content";
  case STATUSMULTISTATUS:
    return "Multi-Status";
  case STATUSALREADYREPORTED:
    return "Already Reported";
  case STATUSIMUSED:
    return "Im Used";
  case STATUSMULTIPLECHOICES:
    return "Multiple Choices";
  case STATUSMOVEDPERMANENTLY:
    return "Moved Permanently";
  case STATUSFOUND:
    return "Found";
  case STATUSSEEOTHER:
    return "See Other";
  case STATUSNOTMODIFIED:
    return "Not Modified";
  case STATUSUSEPROXY:
    return "Use Proxy";
  case STATUSTEMPORARYREDIRECT:
    return "Temporary Redirect";
  case STATUSPERMANENTREDIRECT:
    return "Permanent Redirect";
  case STATUSBADREQUEST:
    return "Bad Request";
  case STATUSUNAUTHORIZED:
    return "Unauthorized";
  case STATUSPAYMENTREQUIRED:
    return "Payment Required";
  case STATUSFORBIDDEN:
    return "Forbidden";
  case STATUSNOTFOUND:
    return "Not Found";
  case STATUSMETHODNOTALLOWED:
    return "Method Not Allowed";
  case STATUSNOTACCEPTABLE:
    return "Not Acceptable";
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return "Proxy Authentication Required";
  case STATUSREQUESTTIMEOUT:
    return "Request Timeout";
  case STATUSCONFLICT:
    return "Conflict";
  case STATUSGONE:
    return "Gone";
  case STATUSLENGTHREQUIRED:
    return "Length Required";
  case STATUSPRECONDITIONFAILED:
    return "Precondition Failed";
  case CONTENTTOOLARGE:
    return "Content Too Large";
  case STATUSURITOOLONG:
    return "URI Too Long";
  case STATUSUNSUPPORTEDMEDIATYPE:
    return "Unsupported Media Type";
  case STATUSRANGENOTSATISFIABLE:
    return "Range Not Satisfiable";
  case STATUSEXPECTATIONFAILED:
    return "Expectation Failed";
  case STATUSMISDIRECTEDREQUEST:
    return "Misdirected Request";
  case STATUSUNPROCESSABLECONTENT:
    return "Unprocessable Content";
  case STATUSLOCKED:
    return "Locked";
  case STATUSFAILEDDEPENDENCY:
    return "Failed Dependency";
  case STATUSTOOEARLY:
    return "Too Early";
  case STATUSUPGRADEREQUIRED:
    return "Upgrade Required";
  case STATUSPRECONDITIONREQUIRED:
    return "Precondition Required";
  case STATUSTOOMANYREQUESTS:
    return "Too Many Requests";
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return "Request Header Fields Too Large";
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return "Unavailable For Legal Reasons";
  case STATUSInternalServerError:
    return "Internal Server Error";
  case STATUSNOTIMPLEMENTED:
    return "Not Implemented";
  case STATUSBADGATEWAY:
    return "Bad Gateway";
  case STATUSSERVICEUNAVAILABLE:
    return "Service Unavailable";
  case STATUSGATEWAYTIMEOUT:
    return "Gateway Timeout";
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return "HTTP Version Not Supported";
  case STATUSVARIANTALSONEGOTIATES:
    return "Variant Also Negotiates";
  case STATUSINSUFFICIENTSTORAGE:
    return "Insufficient Storage";
  case STATUSLOOPDETECTED:
    return "Loop Detected";
  case STATUSNOTEXTENDED:
    return "Not Extended";
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return "Network Authentication Required";
  default:
    return 0;
  }
}

/*
 * Return true if routes match
 */
static inline bool route_equ(Route *route, Request *req) {
  return route->method == req->method && strncmp(route->path, req->path, strlen(route->path)) == 0;
}

/*
 * Return the matching route index on success. -1 on failure
 */
static inline int match_route(Server *serv, Request *req) {
  for (size_t i = 0; i < serv->_nroutes; i++) {
    Route route = serv->routes[i];
    if (!req->path || !route.path)
      continue;
    if (route_equ(&route, req))
      return i;
    else if (req->method == HEAD && route.method == GET && strcmp(route.path, req->path) == 0)
      return i;
  }
  return -1;
}

/*
 * Return true if the response should contain the Content-Length header
 */
static inline bool should_have_content_length(Request *req, ResWriter *res) {
  return (req->method != CONNECT              // CONNECT request
          && res->status != STATUSNOCONTENT   // 204 response
          && res->status != STATUSNOTMODIFIED // 304 response
          && res->status >= 200);             // 1xx response
}

/*
 * Format http response from the ResWriter.
 * Return response size on success, 0 on failure.
 */
static inline size_t fmt_res(Request *req, ResWriter *res, char *buffer, size_t buffer_size) {
  if (!res || !buffer || buffer_size == 0)
    return 0;

  size_t res_len, total = 0;
  char *dst = buffer;
  size_t maxlen = buffer_size;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t body_length = res->len;

  res_len = snprintf(dst, maxlen, "HTTP/1.1 %d %s", (int)res->status, status_str(res->status));
  total += res_len;
  dst += res_len;
  maxlen -= res_len;

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    res_len = snprintf(dst, maxlen, "\r\n%s: %s", header->key, header->value);
    total += res_len;
    dst += res_len;
    maxlen -= res_len;
  }

  if (have_content_length) {
    res_len = snprintf(dst, maxlen, "\r\nContent-Length: %lu", body_length);
    total += res_len, dst += res_len, maxlen -= res_len;
  }

  memcpy(dst, "\r\n\r\n", 4);
  total += 4, dst += 4, maxlen -= 4;

  return total;
}

static inline size_t res_len(Request *req, ResWriter *res) {
  if (!req || !res)
    return 0;

  if (!res->status)
    res->status = STATUSOK;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t result = 0;
  result += STRLEN("HTTP/1.1 ");     // HTTP version
  result += 4;                       // Status code + space
  result += status_len(res->status); // Status name

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    result += 2;                       // "\r\n"
    result += strlen(header->key) + 2; // Header key + ':' + space
    result += strlen(header->value);   // header value
  }

  if (have_content_length) {
    result += 2;                          // "\r\n"
    result += STRLEN("Content-Length: "); // Header key
    result += countd(res->len);           // Header value
  }

  result += 4; // "\r\n\r\n"

  return result;
}

static inline int send_empty_res(Status status) {
  size_t res_len = STRLEN("HTTP/1.1 ")        // HTTP version
                   + countd((uint64_t)status) // status code
                   + 1                        // space
                   + (int)status_len(status)  // status string
                   + 4;                       // \r\n\r\n

  conn_t *conn = current_send;
  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, res_len);
  if (snprintf((char *)rec->iov_base, res_len + 1, "HTTP/1.1 %d %s\r\n\r\n", (int)status, status_str(status))
      != (int)res_len)
    return -1;

  return usendmsg(conn, 0, 1);
}

static inline ssize_t read_socket(int sockfd, size_t len) {
  if (len == 0 || sockfd <= 0)
    return 0;
  char buff[1024 * 8];
  return read(sockfd, buff, 1024 * 8);
}

static inline int read_method(Method *method, void *src) {
  if (memcmp(src, "GET", 3) == 0)
    *method = GET;
  else if (memcmp(src, "POST", 4) == 0)
    *method = POST;
  else if (memcmp(src, "HEAD", 4) == 0)
    *method = HEAD;
  else if (memcmp(src, "PUT", 3) == 0)
    *method = PUT;
  else if (memcmp(src, "DELETE", 6) == 0)
    *method = DELETE;
  else if (memcmp(src, "CONNECT", 7) == 0)
    *method = CONNECT;
  else if (memcmp(src, "OPTIONS", 7) == 0)
    *method = OPTIONS;
  else if (memcmp(src, "TRACE", 5) == 0)
    *method = TRACE;
  else if (memcmp(src, "PATCH", 5) == 0)
    *method = PATCH;
  else
    return -1;

  return 0;
}

static inline int sendmsg_res(Request *req, ResWriter *res) {
  conn_t *conn;
  size_t head_size, res_size;
  struct iovec *iov;

  conn = current_send;
  iov = &conn->ios[0];
  head_size = res_len(req, res);
  if (head_size == 0)
    return -1;

  conn->data_left += head_size;
  res_size = fmt_res(req, res, iov->iov_base, (head_size + 1));
  if (res_size != head_size)
    return -1;
  iov->iov_len = res_size;

  return usendmsg(conn, 0, conn->nios);
}

static inline int read_req(Request *req, char *req_buffer) {
  if (!req_buffer)
    return -1;
  /*** Method ***/
  char *sep = strchr(req_buffer, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }
  *sep = '\0';
  if (read_method(&req->method, req_buffer) < 0)
    return -1;

  /*** Path ***/
  char *fullpath = sep + 1;
  sep = strchr(fullpath, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }

  *sep = '\0';
  req->path = fullpath;
  /*** Params ***/
  char *paramStart = strchr(fullpath, '?');
  if (paramStart) {
    *paramStart++ = '\0';
    int params_count = 0;
    params_count = HK_parse_params(paramStart, req->params, MAX_URL_PARAMETERS);
    if (params_count > 0)
      req->params_count = params_count;
    else
      req->params_count = 0;
  } else {
    req->params = NULL;
    req->params_count = 0;
  }

  /*** Headers ***/
  char *headStart = strstr(sep + 1, "\r\n");
  char *headEnd = strstr(sep + 1, "\r\n\r\n");
  if (!headStart) {
    LOG("read_req: !headStart\n");
    return -1;
  };

  memset(headStart, 0, 2);
  headStart += 2;
  memset(headEnd, 0, 4);
  headEnd += 4;

  int headers_count = HK_parse_headers(headStart, req->headers, MAX_REQ_HEADERS);
  if (headers_count <= 0)
    return -1;
  req->headers_count = headers_count;

  /*** Host ***/
  int index = HK_get_header(req, "Host");
  if (index < 0)
    return -1;
  char *host = req->headers[index].value;
  req->hostname = host;

  /*** Port ***/
  char *colon = strchr(host, ':');
  if (colon) {
    *colon++ = '\0';
    req->port = atoi(colon);
  } else {
    req->port = PORT;
  }
  return 0;
}
static inline int process_req(Server *serv, conn_t *conn) {
  if (!conn || conn->fd == -1)
    return -1;

  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;
  if (read_req(&req, conn->ios[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    LOG("Err: route_index == -1\n");
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;
  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  sendmsg_res(&req, &res);

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int new_conn(int connfd) {
  if (connfd <= 0)
    return -1;

  current_recv = MP_use(KB * 2, connfd, false);
  current_send = MP_use(KB * 2, connfd, false);

  current_recv->recv_conn = current_recv;
  current_recv->send_conn = current_send;

  current_send->send_conn = current_send;
  current_send->recv_conn = current_recv;

  conn_t *conn = current_recv;
  if (ufrecvmsg(conn, 0, 1) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

static inline int resubmit_sendmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return usendmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int resubmir_recvmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    // FIXME the len should be increased
    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return urecvmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int handle_sendmsg_complete(conn_t *conn) {
  struct iovec *iov, *rec;

  MP_shed(conn, 1, conn->nios - 1);
  iov = &conn->ios[0];
  rec = &conn->rec[0];
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;

  return ufrecvmsg(conn->recv_conn, 0, 1);
}

static inline int handle_sendmsg(conn_t *conn, int res, bool zc) {
  if (!conn || conn->fd == -1)
    return -1;

  conn->data_left -= res;
  if (conn->data_left > 0)
    return resubmit_sendmsg(conn, res);

  if (zc)
    return 0;

  return handle_sendmsg_complete(conn);
}

static inline int handle_insplice(conn_t *conn) {
  conn->op = OUTSPLICE;
  return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
}
static inline int handle_outsplice(conn_t *conn, int res) {
  conn->data_left -= res;
  if (conn->data_left > 0) {
    conn->op = INSPLICE;
    return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
  }

  conn_t *recv_conn = conn->recv_conn;
  struct iovec *iov = &recv_conn->ios[0];
  memset(iov->iov_base, 0, iov->iov_len);
  if (urecv(recv_conn, iov->iov_base, iov->iov_len, MSG_PEEK) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

/*
static inline int handle_recv(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  void *bptr = conn->ios[0].iov_base;
  void *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  void *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  return process_req(serv, conn);
}
*/
static inline int find_route(Server *serv, char *bptr) {
  Request req = {0};
  if (read_method(&req.method, bptr) < 0) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  };
  char *space = strchr(bptr, ' ');
  req.path = (space + 1);
  space = strchr(req.path, ' ');
  *space = '\0';
  int route_index = match_route(serv, &req);
  *space = ' ';
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }
  return route_index;
}

static inline int run_handler(Server *serv, conn_t *conn, bool uses_body) {
  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;

  if (read_req(&req, conn->rec[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  if (uses_body) {
    int h_index = HK_get_header(&req, "Content-Length");
    long body_size = atol(req.headers[h_index].value);
    if (body_size >= 0) {
      req.body.ptr = conn->rec[1].iov_base;
      req.body.size = body_size;
    } else {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    }
  }

  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  if (sendmsg_res(&req, &res) < 0)
    return -1;

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int handle_frecvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  char *bptr = (char *)conn->ios[0].iov_base;
  char *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  char *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  size_t head_size = (headEnd + 4) - bptr;
  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  int route_index = find_route(serv, bptr);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  bool uses_body = serv->routes[route_index].uses_body;
  long body_size = get_content_length(headstart + 2, headEnd + 4);
  if (body_size == -1) {
    if (uses_body) {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    } else {
      body_size = 0;
    }
  }

  conn->head_size = head_size;
  if (!uses_body) {
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  if (res == (int)(head_size + body_size)) {
    size_t iov_index = MP_expand(conn, round_to_blocks(body_size), false);
    memcpy(conn->rec[iov_index].iov_base, headEnd + 4, body_size);
    conn->ios[iov_index].iov_len = body_size;
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  conn->data_left = body_size - (res - head_size);
  bool once = ((size_t)body_size > (size_t)((pool.nblocks * MP_BLOCK) / 10));
  size_t iov_index = MP_expand(conn, round_to_blocks(body_size), once);
  memcpy(conn->rec[iov_index].iov_base, headEnd + 4, (res - head_size));
  conn->ios[iov_index].iov_base += (res - head_size);

  return urecvmsg(conn, iov_index, 1);
}

static inline int handle_recvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  if (conn->data_left > 0) {
    conn->data_left -= res;
    if (conn->data_left == 0) {
      conn->flags &= CF_HANDLER_READY;
      return run_handler(serv, conn, true);
    }

    conn->flags &= ~CF_HANDLER_READY;
    conn->ios[1].iov_base += res;
    return urecvmsg(conn, 1, 1);
  }

  conn->flags &= CF_HANDLER_READY;
  return run_handler(serv, conn, true);
}

static inline int serv_init(Server *serv) {
#if DEBUG
  logfd = log_init("log.txt");
  if (!logfd) {
    printf("log_init failed");
    return -1;
  }
#endif
  serv->_nroutes = get_nroutes(serv->routes);

  int pipefd[2];
  if (pipe(pipefd) < 0)
    return -1;
  pipe_in = pipefd[0];
  pipe_out = pipefd[1];
  nullfd = open("/dev/null", O_WRONLY);
  pipe_sz = fcntl(pipefd[0], F_GETPIPE_SZ);
  if (pipe_sz < 0)
    return -1;

  pool.rtimeout = serv->rtimeout;
  pool.wtimeout = serv->wtimeout;
  if (MP_init(MAX_CONNS * 8) < 0)
    return -1;
  LOG("pool initialized\n");

  if (io_uring_queue_init(MAX_CONNS, &ring, 0) < 0)
    return -1;
  LOG("uring initialized\n");

  int listenfd;
  if ((listenfd = tcp_listen(serv->port)) < 0)
    return -1;
  LOG("socket initialized\n");

  return umaccept(listenfd);
}

static inline int serv_listen(Server *serv) {
  // uint64_t last_check = get_time();
  while (true) {
    // uint64_t now = get_time();
    // if ((now - last_check) >= 200) {
    //   last_check = now;
    //   LOG("CM: CM_check ran\n");
    //   MP_timeout();
    // }

    LOG("SQ ready: %u, CQ ready: %u\n", io_uring_sq_ready(&ring), io_uring_cq_ready(&ring));
    struct io_uring_cqe *cqe;
    if (io_uring_wait_cqe(&ring, &cqe) < 0)
      continue;

    int res = cqe->res;
    LOG("res = %d\n", res);
    conn_t *conn = NULL;
    if (cqe->user_data > 100) {
      conn = (conn_t *)cqe->user_data;
      current_recv = (conn_t *)conn->recv_conn;
      current_send = (conn_t *)conn->send_conn;
    }

    if (res > 0) {
      if (cqe->user_data == ACCEPT) {
        LOG("new conn created\n");
        new_conn(res);
      } else if (conn && conn->fd != -1) {
        LOG("conn[%d]: conn.fd = %d; conn.op = %d\n", conn->cindex, conn->fd, conn->op);
        switch (conn->op) {
        case FRECVMSG:
          if (handle_frecvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case RECVMSG:
          if (handle_recvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case SENDMSG:
        case SENDMSGZC:
          // conn->last_write = get_time();
          bool zc = (conn->op == SENDMSGZC);
          if (handle_sendmsg(conn, res, zc) < 0)
            MP_clear(conn);
          break;
        case INSPLICE:
          if (handle_insplice(conn) < 0)
            MP_clear(conn);
          break;
        case OUTSPLICE:
          if (handle_outsplice(conn, res) < 0)
            MP_clear(conn);
          break;
        }
      }
    } else if (res == 0) {
      if (conn && conn->fd != -1) {
        switch (conn->op) {
        case SENDMSGZC:
          conn->zc_notifs--;
          if (conn->zc_notifs == 0 && handle_sendmsg_complete(conn) < 0)
            MP_clear(conn);
          break;
        case RECV:
          MP_clear(conn);
          break;
        }
      }
    } else {
      if (conn && conn->fd != -1) {
        if (res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR) {
          LOG("conn && conn->fd != -1 && res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR\n");
          MP_clear(conn);
        } else {
          LOG("res == -EAGAIN || res == -EWOULDBLOCK || res == -EINTR\n");
          conn = conn->recv_conn;
          struct iovec *iov = &conn->ios[0];
          memset(iov->iov_base, 0, iov->iov_len);
          if (urecv(conn, iov->iov_base, iov->iov_len, 0) < 0)
            MP_clear(conn);
        }
      }
    }

    LOG("uring operation seen\n");
    io_uring_cqe_seen(&ring, cqe);
  }

  io_uring_queue_exit(&ring);
  MP_exit(&pool);
  return 0;
}

/*** Helper ***/
static inline int _HK_write(void *data, size_t size) {
  size_t nblocks;
  int iov_index;
  conn_t *conn;
  struct iovec *iov;
  bool once;

  conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  nblocks = round_to_blocks(size);
  iov_index = MP_expand(conn, nblocks, once);
  iov = &conn->ios[iov_index];

  memcpy(iov->iov_base, data, size);
  iov->iov_len = size;
  conn->data_left += size;

  return 0;
}
static inline int _HK_write_body(Request *req, size_t offset, size_t size) {
  if (size > req->body.size || offset > req->body.size)
    return -1;

  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  int iov_index = MP_expand(conn, 0, false);
  struct iovec *iov = &conn->ios[iov_index];
  struct iovec *rec = &conn->rec[iov_index];
  rec->iov_base = req->body.ptr + offset;
  rec->iov_len = size;
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;
  conn->data_left += rec->iov_len;
  return 0;
}
/*
static inline int _HK_mem(size_t size, HKMem *mem) {
  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  bool once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  size_t nblocks = round_to_blocks(size);
  int iov_index = MP_expand(conn, nblocks, once);
  struct iovec *iov = &conn->ios[iov_index];
  mem->ptr = iov->iov_base;
  mem->size = iov->iov_len;
  mem->_iov_index = iov_index;
  mem->_flags = (IN_POOL(iov->iov_base)) ? CF_IN_POOL : CF_IN_HEAP;
  return 0;
}

static inline void _HK_send(HKMem *mem, size_t size) {
  conn_t *conn = current_send;
  struct iovec *iov = &conn->ios[mem->_iov_index];
  iov->iov_len = size;
  conn->data_left += size;
}
  */
#endif#define _GNU_SOURCE
#ifndef UTILS_H
#define UTILS_H

#include "hunk.h"
#include <arpa/inet.h>
#include <fcntl.h>
#include <liburing.h>
#include <netdb.h>
#include <signal.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/poll.h>
#include <sys/prctl.h>
#include <sys/socket.h>
#include <sys/sysinfo.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

#define MP_BLOCK  4
#define MAX_CONNS 4096
#define KB        1024
#define NIOS      32

#define IN_POOL(ptr)                 ((void *)ptr >= pool.bpool && (void *)ptr <= (pool.bpool + (pool.npages * pool.pagesize)))
#define ALIGN_TO_PAGESIZE(buff_size) (((buff_size) + (pool.pagesize - 1)) & ~(pool.pagesize - 1))
#define BYTES_TO_BLOCKS(buff_size)   (((buff_size) + (MP_BLOCK - 1)) / MP_BLOCK)
#define CEIL_BLOCKS(nblocks)         ((nblocks + 63) & ~63)
#define CEIL_PAGES(size)             (((size) + ((pool.pagesize) - 1)) & ~((pool.pagesize) - 1))

#define BIT_IS_FREE(word, bit)   (((word) >> (bit)) & 1)
#define MARK_BIT_USED(word, bit) ((word) &= ~(1ULL << (bit)))
#define MARK_BIT_FREE(word, bit) ((word) |= (1ULL << (bit)))
#define FIND_FREE_BIT(word)      ((uint64_t)(word) & -(uint64_t)(word))
#define STRLEN(s)                (sizeof(s) - 1)

#define IOVEC_NBLOCKS (BYTES_TO_BLOCKS(NIOS * sizeof(struct iovec)))
#define MSG_NBLOCKS   (BYTES_TO_BLOCKS(sizeof(struct msghdr)))
#define ZC_RES        KB *KB

#define DEBUG 0
#if DEBUG
#define LOG(...) fprintf(logfd, __VA_ARGS__)
#else
#define LOG(...) ((void)0)
#endif

typedef enum UOP {
  WRITEV = IORING_OP_WRITEV,
  SENDMSG = IORING_OP_SENDMSG,
  RECVMSG = IORING_OP_RECVMSG,
  ACCEPT = IORING_OP_ACCEPT,
  SEND = IORING_OP_SEND,
  RECV = IORING_OP_RECV,
  SENDZC = IORING_OP_SEND_ZC,
  SENDMSGZC = IORING_OP_SENDMSG_ZC,
  PEEK = 50,
  FRECVMSG,
  INSPLICE,
  OUTSPLICE
} UOP;

typedef enum CFS {
  CF_IN_POOL = (1 << 0),       // Connection is in the pool
  CF_IN_HEAP = (1 << 1),       // Connection is in the heap
  CF_SKIP_SOCK = (1 << 2),     // Don't close the socket
  CF_USE_ONCE = (1 << 3),      // Destroy after using
  CF_HANDLER_READY = (1 << 4), // Ready to call the handler
} CFS;

typedef struct conn_t {
  // Socket file descriptor
  int fd;

  // Amount of data left in the current operation
  uint64_t data_left;

  // The index of the connection struct
  uint32_t cindex;

  // The last time the connection was readable
  uint64_t last_read;

  // The last time the connection was writeable
  uint64_t last_write;

  // The operation currently being processed
  uint8_t op;

  // Connection flags
  int flags;

  // Splice fd_in
  int in_fd;

  // Splice fd_out
  int out_fd;

  void *recv_conn;
  void *send_conn;

  struct iovec *ios;
  struct iovec *rec;
  uint16_t nios;

  struct msghdr *msg;
  uint16_t zc_notifs;

  uint16_t head_size;
} conn_t;

typedef struct MPool {
  // The allocated pool of blocks
  void *bpool;

  // The allocated pool of connections
  conn_t *cpool;

  // The size of the pool in pages
  uint32_t npages;

  // The size of the pool in blocks
  uint32_t nblocks;

  // The locations of each page in the pool
  void **blocks;

  // The availability of each block
  uint64_t *freebs;

  // The locations of each conn in the pool
  conn_t **conns;

  // The availability of each conn
  uint64_t *freecs;

  // Clean up callback function
  void (*callback)(conn_t *conn);

  // The page size used
  uint32_t pagesize;

  // Socket read timeout
  uint32_t rtimeout;

  // Socket write timeout
  uint32_t wtimeout;
} MPool;

extern int pipe_sz;
extern int pipe_in, pipe_out, nullfd;
extern FILE *logfd;
extern struct io_uring ring;
extern MPool pool;
extern conn_t *current_recv;
extern conn_t *current_send;

/*
 * Prepare and submit a recv uring op
 */
static inline int urecv(conn_t *conn, void *buffer, size_t buff_size, int flags) {
  if (!conn || conn->fd == -1)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (flags == MSG_PEEK) ? PEEK : RECV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;

  io_uring_prep_recv(sqe, conn->fd, buffer, buff_size, flags);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a multi-shot accept uring op
 */
static inline int umaccept(int listenfd) {
  if (listenfd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = ACCEPT;
  io_uring_prep_multishot_accept(sqe, listenfd, NULL, NULL, SOCK_NONBLOCK);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a splice uring op
 */
static inline int usplice(conn_t *conn, int fd_in, int64_t off_in, int fd_out, int64_t off_out, size_t len) {
  if (!len || !conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = (__u64)conn;
  io_uring_prep_splice(sqe, fd_in, off_in, fd_out, off_out, len, 0);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a writev uring op
 */
static inline int uwritev(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = WRITEV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  io_uring_prep_writev(sqe, conn->fd, &conn->ios[iov_index], nios, -1);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a send uring op
 */
static inline int usend(conn_t *conn, char *res_buff, size_t buff_size, bool zc) {
  if (!conn || conn->fd <= 0 || buff_size == 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (zc) ? SENDZC : SEND;
  conn->data_left = buff_size;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  if (zc)
    io_uring_prep_send_zc(sqe, conn->fd, res_buff, buff_size, 0, 0);
  else
    io_uring_prep_send(sqe, conn->fd, res_buff, buff_size, 0);
  return io_uring_submit(&ring);
}

static inline int ufrecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = FRECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;

  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, rec->iov_len);
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int urecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = RECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int usendmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  bool zc = (conn->data_left > ZC_RES) ? true : false;
  conn->op = (zc) ? SENDMSGZC : SENDMSG;

  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  if (zc) {
    io_uring_prep_sendmsg_zc(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
    conn->zc_notifs++;
  } else {
    io_uring_prep_sendmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  }
  return io_uring_submit(&ring);
}

/*
 * Create and initialize a server socket
 */
static inline int tcp_listen(uint16_t port) {
  int enable;
  int listenfd;
  if ((listenfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    return -1;

  int flags = fcntl(listenfd, F_GETFL, 0);
  fcntl(listenfd, F_SETFL, flags | O_NONBLOCK);
  struct sockaddr_in servaddr;
  memset(&servaddr, 0, sizeof(servaddr));
  servaddr.sin_family = AF_INET;
  servaddr.sin_addr.s_addr = INADDR_ANY;
  servaddr.sin_port = htons(port);

  enable = 1;
  if (setsockopt(listenfd, SOL_SOCKET, SO_REUSEPORT, &enable, sizeof(enable)) < 0)
    return -1;

  if (bind(listenfd, (struct sockaddr *)&servaddr, sizeof(servaddr)) < 0)
    return -1;

  if (listen(listenfd, SOMAXCONN) < 0)
    return -1;

  return listenfd;
}

/*
 * Calculate the difference between two pointers
 */
static inline uintptr_t ptr_diff(uintptr_t p1, uintptr_t p2) { return (uintptr_t)(p1 > p2) ? (p1 - p2) : (p2 - p1); }

static inline size_t get_nroutes(Route *routes) {
  Route *route;
  for (size_t i = 0;; i++) {
    route = &routes[i];
    if (!route->path && !route->handler && !route->method)
      return i;
  }
}

static inline long get_content_length(char *src, char *end) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return -1;
    key = line;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, "Content-Length") != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;

    *line_end = '\0';
    long res = atol(value);
    *line_end = '\r';

    return res;
  }
  return -1;
}

static inline bool have_header(char *src, char *end, const char *header_key, const char *header_value) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    key = line;
    while (*key == ' ')
      key++;
    while (*header_key == ' ')
      header_key++;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return false;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, header_key) != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;
    while (*header_value == ' ')
      header_value++;

    *line_end = '\0';
    bool res = (strcasecmp(value, header_value) == 0);
    *line_end = '\r';

    return res;
  }

  return false;
}

static inline const char *method_str(Method method) {
  switch (method) {
  case GET:
    return "GET";
    break;
  case HEAD:
    return "HEAD";
    break;
  case POST:
    return "POST";
    break;
  case PUT:
    return "PUT";
    break;
  case DELETE:
    return "DELETE";
    break;
  case CONNECT:
    return "CONNECT";
    break;
  case OPTIONS:
    return "OPTIONS";
    break;
  case TRACE:
    return "TRACE";
    break;
  case PATCH:
    return "PATCH";
    break;
  default:
    return NULL;
  }
}

static inline uint8_t method_len(Method method) {
  switch (method) {
  case GET:
    return 3;
    break;
  case HEAD:
    return 4;
    break;
  case POST:
    return 4;
    break;
  case PUT:
    return 3;
    break;
  case DELETE:
    return 6;
    break;
  case CONNECT:
    return 7;
    break;
  case OPTIONS:
    return 7;
    break;
  case TRACE:
    return 5;
    break;
  case PATCH:
    return 5;
    break;
  default:
    return 0;
  }
}

static inline size_t round_to_blocks(size_t size) {
  size_t nblocks = BYTES_TO_BLOCKS(size);
  nblocks = CEIL_BLOCKS(nblocks);
  return nblocks;
}

/*
 * Count the digits in unsigned 64-bit int
 */
static inline int countd(uint64_t num) {
  if (num < 10ULL)
    return 1;
  if (num < 100ULL)
    return 2;
  if (num < 1000ULL)
    return 3;
  if (num < 10000ULL)
    return 4;
  if (num < 100000ULL)
    return 5;
  if (num < 1000000ULL)
    return 6;
  if (num < 10000000ULL)
    return 7;
  if (num < 100000000ULL)
    return 8;
  if (num < 1000000000ULL)
    return 9;
  if (num < 10000000000ULL)
    return 10;
  if (num < 100000000000ULL)
    return 11;
  if (num < 1000000000000ULL)
    return 12;
  if (num < 10000000000000ULL)
    return 13;
  if (num < 100000000000000ULL)
    return 14;
  if (num < 1000000000000000ULL)
    return 15;
  if (num < 10000000000000000ULL)
    return 16;
  if (num < 100000000000000000ULL)
    return 17;
  if (num < 1000000000000000000ULL)
    return 18;
  if (num < 10000000000000000000ULL)
    return 19;
  return 20;
}

/*
 * Get the time elabsed in ms
 */
static inline uint64_t get_time() {
  struct timespec ts;
  clock_gettime(CLOCK_MONOTONIC, &ts);
  return (uint64_t)(ts.tv_sec) * 1000 + (ts.tv_nsec / 1000000);
}

static inline FILE *log_init(const char *path) {
  FILE *res = fopen(path, "a+");
  setvbuf(res, NULL, _IONBF, 0);
  return res;
}

static inline int16_t pollevs(int connfd) {
  struct pollfd pfd;
  pfd.fd = connfd;
  pfd.events = POLLIN | POLLOUT | POLLERR;
  int res = poll(&pfd, 1, 0);
  if (res < 0)
    return POLLERR;
  return pfd.revents;
}

// FIXME This needs to be updated
static inline conn_t *MP_use_once(size_t nblocks, int fd) {

  void *mem = malloc(sizeof(conn_t) + 8 + (IOVEC_NBLOCKS * MP_BLOCK));
  struct conn_t *conn = (conn_t *)mem;
  memset(conn, 0, sizeof(conn_t));
  conn->ios = mem + sizeof(conn_t) + 8;

  if (nblocks > 0) {
    struct iovec *iov = &conn->ios[conn->nios++];
    mem = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (mem == MAP_FAILED)
      return NULL;
    iov->iov_base = mem;
    iov->iov_len = ALIGN_TO_PAGESIZE(nblocks * MP_BLOCK);
  }

  conn->flags |= CF_IN_HEAP;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;

  return conn;
}

static inline int find_freec() {
  uint64_t *word;
  size_t map_size = (sizeof(uint64_t) * 8);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    word = &pool.freecs[i / map_size];

    if (*word == 0) { // All used
      i += (map_size - 1);
      continue;
    }

    i += __builtin_ctzll(*word);
    MARK_BIT_USED(*word, i);
    return i;
  }

  return -1;
}

static inline int MP_init(size_t npages) {
  if (!npages)
    return -1;

  /*** Setup ***/
  pool.npages = npages;
  pool.pagesize = sysconf(_SC_PAGESIZE);

  /*** Pool ***/
  pool.bpool = mmap(NULL, pool.npages * pool.pagesize, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  if (pool.bpool == MAP_FAILED)
    return -1;
  pool.nblocks = (pool.npages * pool.pagesize) / MP_BLOCK;

  /*** Blocks ***/
  pool.blocks = malloc(sizeof(void *) * pool.nblocks);
  if (!pool.blocks)
    return -1;
  for (size_t i = 0; i < pool.nblocks; i++)
    pool.blocks[i] = pool.bpool + (i * MP_BLOCK);

  /*** Freebs ***/
  // if (posix_memalign((void **)&pool.freebs, 64, bitmap_size * sizeof(uint64_t)) < 0)
  size_t bitmap_size = (pool.nblocks + 63) / 64;
  pool.freebs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freebs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freebs[i] = UINT64_MAX;

  /*** Cpool ***/
  pool.cpool = (conn_t *)malloc(sizeof(conn_t) * MAX_CONNS);
  if (!pool.cpool)
    return -1;

  /*** Conns ***/
  pool.conns = (conn_t **)malloc(sizeof(conn_t *) * MAX_CONNS);
  if (!pool.conns)
    return -1;
  size_t conn_size = sizeof(conn_t);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    pool.conns[i] = (conn_t *)((char *)pool.cpool + (i * conn_size));
    pool.conns[i]->fd = -1;
    pool.conns[i]->in_fd = -1;
    pool.conns[i]->out_fd = -1;
  }

  /*** Freecs ***/
  bitmap_size = (MAX_CONNS + 63) / 64;
  pool.freecs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freecs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freecs[i] = UINT64_MAX;

  return 0;
}

static inline int MP_use_blks(size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t max_start = pool.nblocks - nblocks;
  size_t full_chunks = (nblocks / 64) * 64;

  for (size_t i = 0, c = 0; i <= max_start; i++, c++) {
    bool free = true;

    for (size_t j = 0; j < full_chunks; j += 64) {
      size_t word_index = (i + j) / 64;
      if (pool.freebs[word_index] != UINT64_MAX) {
        free = false;
        i += 63;
        break;
      }
    }

    for (size_t j = full_chunks; j < nblocks; j++) {
      size_t bit_index = i + j;
      size_t word_index = bit_index / 64;
      size_t bit_in_word = bit_index % 64;

      if (!BIT_IS_FREE(pool.freebs[word_index], bit_in_word)) {
        free = false;
        i += j;
        break;
      }
    }

    if (free) {
      for (size_t j = 0; j < full_chunks; j += 64) {
        size_t word_index = (i + j) / 64;
        pool.freebs[word_index] = 0;
      }

      for (size_t j = full_chunks; j < nblocks; j++) {
        size_t bit_index = i + j;
        size_t word_index = bit_index / 64;
        size_t bit_in_word = bit_index % 64;

        MARK_BIT_USED(pool.freebs[word_index], bit_in_word);
      }

      return i;
    }
  }

  return -1;
}

static inline int MP_free_blks(size_t bindex, size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t full_chunks = (nblocks / 64) * 64;
  for (size_t i = 0; i < full_chunks; i += 64) {
    size_t word_index = (bindex + i) / 64;
    pool.freebs[word_index] = UINT64_MAX;
  }

  for (size_t i = full_chunks; i < nblocks; i++) {
    size_t bit_index = bindex + i;
    size_t word_index = bit_index / 64;
    size_t bit_in_word = bit_index % 64;

    MARK_BIT_FREE(pool.freebs[word_index], bit_in_word);
  }

  memset(pool.blocks[bindex], 0, nblocks * MP_BLOCK);
  return 0;
}

static inline conn_t *MP_use(size_t nblocks, int fd, bool once) {
  if (fd <= 0)
    return NULL;
  if (once)
    return MP_use_once(nblocks, fd);

  int cindex = find_freec();
  if (cindex < 0) {
    LOG("Err: cindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  conn_t *conn = pool.conns[cindex];

  int ios_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (ios_bindex < 0) {
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }

  struct iovec *ios = pool.blocks[ios_bindex];
  conn->ios = ios;

  int rec_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (rec_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct iovec *rec = pool.blocks[rec_bindex];
  conn->rec = rec;

  int msg_bindex = MP_use_blks(MSG_NBLOCKS);
  if (msg_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct msghdr *msg = pool.blocks[msg_bindex];
  conn->msg = msg;

  if (nblocks > 0) {
    int bindex = MP_use_blks(nblocks);
    if (bindex < 0) {
      MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
      MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
      MP_free_blks(msg_bindex, IOVEC_NBLOCKS);
      MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
      LOG("Err: bindex < 0; will use MP_use_once\n");
      return MP_use_once(nblocks, fd);
    }

    size_t iov_index = conn->nios++;
    struct iovec *iov = &conn->ios[iov_index];
    struct iovec *rec = &conn->rec[iov_index];
    iov->iov_base = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
  }

  conn->msg->msg_iov = conn->ios;
  conn->msg->msg_iovlen = conn->nios;
  conn->cindex = cindex;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;
  return conn;
}

static inline void MP_shed(conn_t *conn, size_t iov_index, size_t nios) {
  struct iovec *iov, *rec;
  size_t bindex, nblocks, index;

  for (size_t i = 0; i < nios; i++) {
    index = iov_index + i;
    iov = &conn->ios[index];
    rec = &conn->rec[index];
    if (!rec || !rec->iov_base)
      continue;
    if (!IN_POOL(rec->iov_base)) {
      munmap(rec->iov_base, rec->iov_len / pool.pagesize);
    } else {
      bindex = ptr_diff((uintptr_t)rec->iov_base, (uintptr_t)pool.bpool) / MP_BLOCK;
      nblocks = rec->iov_len / MP_BLOCK;
      MP_free_blks(bindex, nblocks);
    }
    memset(iov, 0, sizeof(struct iovec));
    memset(rec, 0, sizeof(struct iovec));
    conn->nios--;
  }
}

static inline int MP_expand(conn_t *conn, size_t nblocks, bool once) {
  void *bptr;
  int iov_index, bindex;
  struct iovec *iov, *rec;

  iov_index = conn->nios++;
  iov = &conn->ios[iov_index];
  rec = &conn->rec[iov_index];

  if (nblocks == 0)
    return iov_index;

  if (once) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_base = bptr;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
    return iov_index;
  }

  bindex = MP_use_blks(nblocks);
  if (bindex < 0) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_len = iov->iov_len;
  } else {
    bptr = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_len = iov->iov_len;
  }

  iov->iov_base = bptr;
  rec->iov_base = iov->iov_base;
  return iov_index;
}

static inline int MP_free(conn_t *conn) {
  if (!conn)
    return -1;
  size_t bindex, nblocks;
  uint64_t *word;

  MP_shed(conn, 0, conn->nios);
  if (conn->flags & CF_IN_HEAP) {
    if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
      close(conn->fd);
    free(conn);
    return 0;
  }

  word = &pool.freecs[conn->cindex / 64];
  if (conn->cindex > MAX_CONNS)
    return -1;
  else if (BIT_IS_FREE(*word, conn->cindex))
    return 0;

  bindex = ptr_diff((uintptr_t)conn->ios, (uintptr_t)pool.bpool) / MP_BLOCK;
  nblocks = IOVEC_NBLOCKS;
  MP_free_blks(bindex, nblocks);

  bindex = ptr_diff((uintptr_t)conn->rec, (uintptr_t)pool.bpool) / MP_BLOCK;
  MP_free_blks(bindex, nblocks);

  if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
    close(conn->fd);

  MARK_BIT_FREE(*word, conn->cindex);
  memset(conn, 0, sizeof(conn_t));
  conn->fd = -1;
  conn->in_fd = -1;
  conn->out_fd = -1;
  return 0;
}

static inline void MP_clear(conn_t *conn) {
  conn_t *recv_conn = conn->recv_conn;
  conn_t *send_conn = conn->send_conn;
  if (recv_conn)
    MP_free(recv_conn);
  if (send_conn)
    MP_free(send_conn);
}

static inline void MP_exit(MPool *pool) {
  munmap(pool->bpool, pool->npages);
  free(pool->cpool);
  free(pool->blocks);
  free(pool->conns);
  free(pool->freebs);
  free(pool->freecs);
}

static inline void MP_timeout() {
  conn_t *conn;
  int16_t res;
  uint64_t now;
  size_t windex = 0;
  uint64_t *word = &pool.freecs[0];
  for (size_t i = 0; i < MAX_CONNS; i++) {
    if ((i / 64) < windex)
      word = &pool.freecs[++windex];

    if (*word == UINTMAX_MAX) {
      i = (i / 64) * 64 + 64;
      continue;
    }

    conn = pool.conns[i];
    if (!conn || conn->fd == -1)
      continue;

    res = pollevs(conn->fd);

    now = get_time();
    if (res & POLLERR) {
      MP_clear(conn);
      continue;
    }
    if (res & POLLIN) {
      if (pool.rtimeout > 0 && (now - conn->last_read) >= pool.rtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (res & POLLOUT) {
      if (pool.wtimeout > 0 && (now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (!(res & POLLIN || res & POLLOUT)) {
      if ((pool.rtimeout > 0 && now - conn->last_read) >= pool.rtimeout
          || (pool.wtimeout > 0 && now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
  }
}

/*
 * Calculate the length of a status string
 */
static inline size_t status_len(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return 8;
  case STATUSSWITCHINGPROTOCOLS:
    return 19;
  case STATUSPROCESSING:
    return 10;
  case STATUSEARLYHINTS:
    return 11;
  case STATUSOK:
    return 2;
  case STATUSCREATED:
    return 7;
  case STATUSACCEPTED:
    return 8;
  case STATUSNONAUTHORITATIVE:
    return 29;
  case STATUSNOCONTENT:
    return 10;
  case STATUSRESETCONTENT:
    return 13;
  case STATUSPARTIALCONTENT:
    return 15;
  case STATUSMULTISTATUS:
    return 12;
  case STATUSALREADYREPORTED:
    return 16;
  case STATUSIMUSED:
    return 7;
  case STATUSMULTIPLECHOICES:
    return 16;
  case STATUSMOVEDPERMANENTLY:
    return 17;
  case STATUSFOUND:
    return 5;
  case STATUSSEEOTHER:
    return 9;
  case STATUSNOTMODIFIED:
    return 12;
  case STATUSUSEPROXY:
    return 9;
  case STATUSTEMPORARYREDIRECT:
    return 18;
  case STATUSPERMANENTREDIRECT:
    return 18;
  case STATUSBADREQUEST:
    return 11;
  case STATUSUNAUTHORIZED:
    return 12;
  case STATUSPAYMENTREQUIRED:
    return 16;
  case STATUSFORBIDDEN:
    return 9;
  case STATUSNOTFOUND:
    return 9;
  case STATUSMETHODNOTALLOWED:
    return 18;
  case STATUSNOTACCEPTABLE:
    return 14;
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return 29;
  case STATUSREQUESTTIMEOUT:
    return 15;
  case STATUSCONFLICT:
    return 8;
  case STATUSGONE:
    return 4;
  case STATUSLENGTHREQUIRED:
    return 15;
  case STATUSPRECONDITIONFAILED:
    return 19;
  case CONTENTTOOLARGE:
    return 17;
  case STATUSURITOOLONG:
    return 12;
  case STATUSUNSUPPORTEDMEDIATYPE:
    return 22;
  case STATUSRANGENOTSATISFIABLE:
    return 21;
  case STATUSEXPECTATIONFAILED:
    return 18;
  case STATUSMISDIRECTEDREQUEST:
    return 19;
  case STATUSUNPROCESSABLECONTENT:
    return 21;
  case STATUSLOCKED:
    return 6;
  case STATUSFAILEDDEPENDENCY:
    return 17;
  case STATUSTOOEARLY:
    return 9;
  case STATUSUPGRADEREQUIRED:
    return 16;
  case STATUSPRECONDITIONREQUIRED:
    return 21;
  case STATUSTOOMANYREQUESTS:
    return 17;
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return 31;
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return 29;
  case STATUSInternalServerError:
    return 21;
  case STATUSNOTIMPLEMENTED:
    return 15;
  case STATUSBADGATEWAY:
    return 11;
  case STATUSSERVICEUNAVAILABLE:
    return 19;
  case STATUSGATEWAYTIMEOUT:
    return 15;
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return 26;
  case STATUSVARIANTALSONEGOTIATES:
    return 23;
  case STATUSINSUFFICIENTSTORAGE:
    return 20;
  case STATUSLOOPDETECTED:
    return 13;
  case STATUSNOTEXTENDED:
    return 12;
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return 31;
  default:
    return 0;
  }
}

/*
 * Return the status code string as string literal
 */
static inline char *status_str(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return "Continue";
  case STATUSSWITCHINGPROTOCOLS:
    return "Switching Protocols";
  case STATUSPROCESSING:
    return "Processing";
  case STATUSEARLYHINTS:
    return "Early Hints";
  case STATUSOK:
    return "OK";
  case STATUSCREATED:
    return "Created";
  case STATUSACCEPTED:
    return "Accepted";
  case STATUSNONAUTHORITATIVE:
    return "Non-Authoritative Information";
  case STATUSNOCONTENT:
    return "No Content";
  case STATUSRESETCONTENT:
    return "Reset Content";
  case STATUSPARTIALCONTENT:
    return "Partial Content";
  case STATUSMULTISTATUS:
    return "Multi-Status";
  case STATUSALREADYREPORTED:
    return "Already Reported";
  case STATUSIMUSED:
    return "Im Used";
  case STATUSMULTIPLECHOICES:
    return "Multiple Choices";
  case STATUSMOVEDPERMANENTLY:
    return "Moved Permanently";
  case STATUSFOUND:
    return "Found";
  case STATUSSEEOTHER:
    return "See Other";
  case STATUSNOTMODIFIED:
    return "Not Modified";
  case STATUSUSEPROXY:
    return "Use Proxy";
  case STATUSTEMPORARYREDIRECT:
    return "Temporary Redirect";
  case STATUSPERMANENTREDIRECT:
    return "Permanent Redirect";
  case STATUSBADREQUEST:
    return "Bad Request";
  case STATUSUNAUTHORIZED:
    return "Unauthorized";
  case STATUSPAYMENTREQUIRED:
    return "Payment Required";
  case STATUSFORBIDDEN:
    return "Forbidden";
  case STATUSNOTFOUND:
    return "Not Found";
  case STATUSMETHODNOTALLOWED:
    return "Method Not Allowed";
  case STATUSNOTACCEPTABLE:
    return "Not Acceptable";
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return "Proxy Authentication Required";
  case STATUSREQUESTTIMEOUT:
    return "Request Timeout";
  case STATUSCONFLICT:
    return "Conflict";
  case STATUSGONE:
    return "Gone";
  case STATUSLENGTHREQUIRED:
    return "Length Required";
  case STATUSPRECONDITIONFAILED:
    return "Precondition Failed";
  case CONTENTTOOLARGE:
    return "Content Too Large";
  case STATUSURITOOLONG:
    return "URI Too Long";
  case STATUSUNSUPPORTEDMEDIATYPE:
    return "Unsupported Media Type";
  case STATUSRANGENOTSATISFIABLE:
    return "Range Not Satisfiable";
  case STATUSEXPECTATIONFAILED:
    return "Expectation Failed";
  case STATUSMISDIRECTEDREQUEST:
    return "Misdirected Request";
  case STATUSUNPROCESSABLECONTENT:
    return "Unprocessable Content";
  case STATUSLOCKED:
    return "Locked";
  case STATUSFAILEDDEPENDENCY:
    return "Failed Dependency";
  case STATUSTOOEARLY:
    return "Too Early";
  case STATUSUPGRADEREQUIRED:
    return "Upgrade Required";
  case STATUSPRECONDITIONREQUIRED:
    return "Precondition Required";
  case STATUSTOOMANYREQUESTS:
    return "Too Many Requests";
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return "Request Header Fields Too Large";
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return "Unavailable For Legal Reasons";
  case STATUSInternalServerError:
    return "Internal Server Error";
  case STATUSNOTIMPLEMENTED:
    return "Not Implemented";
  case STATUSBADGATEWAY:
    return "Bad Gateway";
  case STATUSSERVICEUNAVAILABLE:
    return "Service Unavailable";
  case STATUSGATEWAYTIMEOUT:
    return "Gateway Timeout";
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return "HTTP Version Not Supported";
  case STATUSVARIANTALSONEGOTIATES:
    return "Variant Also Negotiates";
  case STATUSINSUFFICIENTSTORAGE:
    return "Insufficient Storage";
  case STATUSLOOPDETECTED:
    return "Loop Detected";
  case STATUSNOTEXTENDED:
    return "Not Extended";
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return "Network Authentication Required";
  default:
    return 0;
  }
}

/*
 * Return true if routes match
 */
static inline bool route_equ(Route *route, Request *req) {
  return route->method == req->method && strncmp(route->path, req->path, strlen(route->path)) == 0;
}

/*
 * Return the matching route index on success. -1 on failure
 */
static inline int match_route(Server *serv, Request *req) {
  for (size_t i = 0; i < serv->_nroutes; i++) {
    Route route = serv->routes[i];
    if (!req->path || !route.path)
      continue;
    if (route_equ(&route, req))
      return i;
    else if (req->method == HEAD && route.method == GET && strcmp(route.path, req->path) == 0)
      return i;
  }
  return -1;
}

/*
 * Return true if the response should contain the Content-Length header
 */
static inline bool should_have_content_length(Request *req, ResWriter *res) {
  return (req->method != CONNECT              // CONNECT request
          && res->status != STATUSNOCONTENT   // 204 response
          && res->status != STATUSNOTMODIFIED // 304 response
          && res->status >= 200);             // 1xx response
}

/*
 * Format http response from the ResWriter.
 * Return response size on success, 0 on failure.
 */
static inline size_t fmt_res(Request *req, ResWriter *res, char *buffer, size_t buffer_size) {
  if (!res || !buffer || buffer_size == 0)
    return 0;

  size_t res_len, total = 0;
  char *dst = buffer;
  size_t maxlen = buffer_size;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t body_length = res->len;

  res_len = snprintf(dst, maxlen, "HTTP/1.1 %d %s", (int)res->status, status_str(res->status));
  total += res_len;
  dst += res_len;
  maxlen -= res_len;

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    res_len = snprintf(dst, maxlen, "\r\n%s: %s", header->key, header->value);
    total += res_len;
    dst += res_len;
    maxlen -= res_len;
  }

  if (have_content_length) {
    res_len = snprintf(dst, maxlen, "\r\nContent-Length: %lu", body_length);
    total += res_len, dst += res_len, maxlen -= res_len;
  }

  memcpy(dst, "\r\n\r\n", 4);
  total += 4, dst += 4, maxlen -= 4;

  return total;
}

static inline size_t res_len(Request *req, ResWriter *res) {
  if (!req || !res)
    return 0;

  if (!res->status)
    res->status = STATUSOK;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t result = 0;
  result += STRLEN("HTTP/1.1 ");     // HTTP version
  result += 4;                       // Status code + space
  result += status_len(res->status); // Status name

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    result += 2;                       // "\r\n"
    result += strlen(header->key) + 2; // Header key + ':' + space
    result += strlen(header->value);   // header value
  }

  if (have_content_length) {
    result += 2;                          // "\r\n"
    result += STRLEN("Content-Length: "); // Header key
    result += countd(res->len);           // Header value
  }

  result += 4; // "\r\n\r\n"

  return result;
}

static inline int send_empty_res(Status status) {
  size_t res_len = STRLEN("HTTP/1.1 ")        // HTTP version
                   + countd((uint64_t)status) // status code
                   + 1                        // space
                   + (int)status_len(status)  // status string
                   + 4;                       // \r\n\r\n

  conn_t *conn = current_send;
  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, res_len);
  if (snprintf((char *)rec->iov_base, res_len + 1, "HTTP/1.1 %d %s\r\n\r\n", (int)status, status_str(status))
      != (int)res_len)
    return -1;

  return usendmsg(conn, 0, 1);
}

static inline ssize_t read_socket(int sockfd, size_t len) {
  if (len == 0 || sockfd <= 0)
    return 0;
  char buff[1024 * 8];
  return read(sockfd, buff, 1024 * 8);
}

static inline int read_method(Method *method, void *src) {
  if (memcmp(src, "GET", 3) == 0)
    *method = GET;
  else if (memcmp(src, "POST", 4) == 0)
    *method = POST;
  else if (memcmp(src, "HEAD", 4) == 0)
    *method = HEAD;
  else if (memcmp(src, "PUT", 3) == 0)
    *method = PUT;
  else if (memcmp(src, "DELETE", 6) == 0)
    *method = DELETE;
  else if (memcmp(src, "CONNECT", 7) == 0)
    *method = CONNECT;
  else if (memcmp(src, "OPTIONS", 7) == 0)
    *method = OPTIONS;
  else if (memcmp(src, "TRACE", 5) == 0)
    *method = TRACE;
  else if (memcmp(src, "PATCH", 5) == 0)
    *method = PATCH;
  else
    return -1;

  return 0;
}

static inline int sendmsg_res(Request *req, ResWriter *res) {
  conn_t *conn;
  size_t head_size, res_size;
  struct iovec *iov;

  conn = current_send;
  iov = &conn->ios[0];
  head_size = res_len(req, res);
  if (head_size == 0)
    return -1;

  conn->data_left += head_size;
  res_size = fmt_res(req, res, iov->iov_base, (head_size + 1));
  if (res_size != head_size)
    return -1;
  iov->iov_len = res_size;

  return usendmsg(conn, 0, conn->nios);
}

static inline int read_req(Request *req, char *req_buffer) {
  if (!req_buffer)
    return -1;
  /*** Method ***/
  char *sep = strchr(req_buffer, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }
  *sep = '\0';
  if (read_method(&req->method, req_buffer) < 0)
    return -1;

  /*** Path ***/
  char *fullpath = sep + 1;
  sep = strchr(fullpath, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }

  *sep = '\0';
  req->path = fullpath;
  /*** Params ***/
  char *paramStart = strchr(fullpath, '?');
  if (paramStart) {
    *paramStart++ = '\0';
    int params_count = 0;
    params_count = HK_parse_params(paramStart, req->params, MAX_URL_PARAMETERS);
    if (params_count > 0)
      req->params_count = params_count;
    else
      req->params_count = 0;
  } else {
    req->params = NULL;
    req->params_count = 0;
  }

  /*** Headers ***/
  char *headStart = strstr(sep + 1, "\r\n");
  char *headEnd = strstr(sep + 1, "\r\n\r\n");
  if (!headStart) {
    LOG("read_req: !headStart\n");
    return -1;
  };

  memset(headStart, 0, 2);
  headStart += 2;
  memset(headEnd, 0, 4);
  headEnd += 4;

  int headers_count = HK_parse_headers(headStart, req->headers, MAX_REQ_HEADERS);
  if (headers_count <= 0)
    return -1;
  req->headers_count = headers_count;

  /*** Host ***/
  int index = HK_get_header(req, "Host");
  if (index < 0)
    return -1;
  char *host = req->headers[index].value;
  req->hostname = host;

  /*** Port ***/
  char *colon = strchr(host, ':');
  if (colon) {
    *colon++ = '\0';
    req->port = atoi(colon);
  } else {
    req->port = PORT;
  }
  return 0;
}
static inline int process_req(Server *serv, conn_t *conn) {
  if (!conn || conn->fd == -1)
    return -1;

  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;
  if (read_req(&req, conn->ios[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    LOG("Err: route_index == -1\n");
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;
  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  sendmsg_res(&req, &res);

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int new_conn(int connfd) {
  if (connfd <= 0)
    return -1;

  current_recv = MP_use(KB * 2, connfd, false);
  current_send = MP_use(KB * 2, connfd, false);

  current_recv->recv_conn = current_recv;
  current_recv->send_conn = current_send;

  current_send->send_conn = current_send;
  current_send->recv_conn = current_recv;

  conn_t *conn = current_recv;
  if (ufrecvmsg(conn, 0, 1) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

static inline int resubmit_sendmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return usendmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int resubmir_recvmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    // FIXME the len should be increased
    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return urecvmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int handle_sendmsg_complete(conn_t *conn) {
  struct iovec *iov, *rec;

  MP_shed(conn, 1, conn->nios - 1);
  iov = &conn->ios[0];
  rec = &conn->rec[0];
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;

  return ufrecvmsg(conn->recv_conn, 0, 1);
}

static inline int handle_sendmsg(conn_t *conn, int res, bool zc) {
  if (!conn || conn->fd == -1)
    return -1;

  conn->data_left -= res;
  if (conn->data_left > 0)
    return resubmit_sendmsg(conn, res);

  if (zc)
    return 0;

  return handle_sendmsg_complete(conn);
}

static inline int handle_insplice(conn_t *conn) {
  conn->op = OUTSPLICE;
  return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
}
static inline int handle_outsplice(conn_t *conn, int res) {
  conn->data_left -= res;
  if (conn->data_left > 0) {
    conn->op = INSPLICE;
    return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
  }

  conn_t *recv_conn = conn->recv_conn;
  struct iovec *iov = &recv_conn->ios[0];
  memset(iov->iov_base, 0, iov->iov_len);
  if (urecv(recv_conn, iov->iov_base, iov->iov_len, MSG_PEEK) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

/*
static inline int handle_recv(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  void *bptr = conn->ios[0].iov_base;
  void *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  void *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  return process_req(serv, conn);
}
*/
static inline int find_route(Server *serv, char *bptr) {
  Request req = {0};
  if (read_method(&req.method, bptr) < 0) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  };
  char *space = strchr(bptr, ' ');
  req.path = (space + 1);
  space = strchr(req.path, ' ');
  *space = '\0';
  int route_index = match_route(serv, &req);
  *space = ' ';
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }
  return route_index;
}

static inline int run_handler(Server *serv, conn_t *conn, bool uses_body) {
  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;

  if (read_req(&req, conn->rec[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  if (uses_body) {
    int h_index = HK_get_header(&req, "Content-Length");
    long body_size = atol(req.headers[h_index].value);
    if (body_size >= 0) {
      req.body.ptr = conn->rec[1].iov_base;
      req.body.size = body_size;
    } else {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    }
  }

  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  if (sendmsg_res(&req, &res) < 0)
    return -1;

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int handle_frecvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  char *bptr = (char *)conn->ios[0].iov_base;
  char *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  char *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  size_t head_size = (headEnd + 4) - bptr;
  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  int route_index = find_route(serv, bptr);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  bool uses_body = serv->routes[route_index].uses_body;
  long body_size = get_content_length(headstart + 2, headEnd + 4);
  if (body_size == -1) {
    if (uses_body) {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    } else {
      body_size = 0;
    }
  }

  conn->head_size = head_size;
  if (!uses_body) {
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  if (res == (int)(head_size + body_size)) {
    size_t iov_index = MP_expand(conn, round_to_blocks(body_size), false);
    memcpy(conn->rec[iov_index].iov_base, headEnd + 4, body_size);
    conn->ios[iov_index].iov_len = body_size;
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  conn->data_left = body_size - (res - head_size);
  bool once = ((size_t)body_size > (size_t)((pool.nblocks * MP_BLOCK) / 10));
  size_t iov_index = MP_expand(conn, round_to_blocks(body_size), once);
  memcpy(conn->rec[iov_index].iov_base, headEnd + 4, (res - head_size));
  conn->ios[iov_index].iov_base += (res - head_size);

  return urecvmsg(conn, iov_index, 1);
}

static inline int handle_recvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  if (conn->data_left > 0) {
    conn->data_left -= res;
    if (conn->data_left == 0) {
      conn->flags &= CF_HANDLER_READY;
      return run_handler(serv, conn, true);
    }

    conn->flags &= ~CF_HANDLER_READY;
    conn->ios[1].iov_base += res;
    return urecvmsg(conn, 1, 1);
  }

  conn->flags &= CF_HANDLER_READY;
  return run_handler(serv, conn, true);
}

static inline int serv_init(Server *serv) {
#if DEBUG
  logfd = log_init("log.txt");
  if (!logfd) {
    printf("log_init failed");
    return -1;
  }
#endif
  serv->_nroutes = get_nroutes(serv->routes);

  int pipefd[2];
  if (pipe(pipefd) < 0)
    return -1;
  pipe_in = pipefd[0];
  pipe_out = pipefd[1];
  nullfd = open("/dev/null", O_WRONLY);
  pipe_sz = fcntl(pipefd[0], F_GETPIPE_SZ);
  if (pipe_sz < 0)
    return -1;

  pool.rtimeout = serv->rtimeout;
  pool.wtimeout = serv->wtimeout;
  if (MP_init(MAX_CONNS * 8) < 0)
    return -1;
  LOG("pool initialized\n");

  if (io_uring_queue_init(MAX_CONNS, &ring, 0) < 0)
    return -1;
  LOG("uring initialized\n");

  int listenfd;
  if ((listenfd = tcp_listen(serv->port)) < 0)
    return -1;
  LOG("socket initialized\n");

  return umaccept(listenfd);
}

static inline int serv_listen(Server *serv) {
  // uint64_t last_check = get_time();
  while (true) {
    // uint64_t now = get_time();
    // if ((now - last_check) >= 200) {
    //   last_check = now;
    //   LOG("CM: CM_check ran\n");
    //   MP_timeout();
    // }

    LOG("SQ ready: %u, CQ ready: %u\n", io_uring_sq_ready(&ring), io_uring_cq_ready(&ring));
    struct io_uring_cqe *cqe;
    if (io_uring_wait_cqe(&ring, &cqe) < 0)
      continue;

    int res = cqe->res;
    LOG("res = %d\n", res);
    conn_t *conn = NULL;
    if (cqe->user_data > 100) {
      conn = (conn_t *)cqe->user_data;
      current_recv = (conn_t *)conn->recv_conn;
      current_send = (conn_t *)conn->send_conn;
    }

    if (res > 0) {
      if (cqe->user_data == ACCEPT) {
        LOG("new conn created\n");
        new_conn(res);
      } else if (conn && conn->fd != -1) {
        LOG("conn[%d]: conn.fd = %d; conn.op = %d\n", conn->cindex, conn->fd, conn->op);
        switch (conn->op) {
        case FRECVMSG:
          if (handle_frecvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case RECVMSG:
          if (handle_recvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case SENDMSG:
        case SENDMSGZC:
          // conn->last_write = get_time();
          bool zc = (conn->op == SENDMSGZC);
          if (handle_sendmsg(conn, res, zc) < 0)
            MP_clear(conn);
          break;
        case INSPLICE:
          if (handle_insplice(conn) < 0)
            MP_clear(conn);
          break;
        case OUTSPLICE:
          if (handle_outsplice(conn, res) < 0)
            MP_clear(conn);
          break;
        }
      }
    } else if (res == 0) {
      if (conn && conn->fd != -1) {
        switch (conn->op) {
        case SENDMSGZC:
          conn->zc_notifs--;
          if (conn->zc_notifs == 0 && handle_sendmsg_complete(conn) < 0)
            MP_clear(conn);
          break;
        case RECV:
          MP_clear(conn);
          break;
        }
      }
    } else {
      if (conn && conn->fd != -1) {
        if (res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR) {
          LOG("conn && conn->fd != -1 && res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR\n");
          MP_clear(conn);
        } else {
          LOG("res == -EAGAIN || res == -EWOULDBLOCK || res == -EINTR\n");
          conn = conn->recv_conn;
          struct iovec *iov = &conn->ios[0];
          memset(iov->iov_base, 0, iov->iov_len);
          if (urecv(conn, iov->iov_base, iov->iov_len, 0) < 0)
            MP_clear(conn);
        }
      }
    }

    LOG("uring operation seen\n");
    io_uring_cqe_seen(&ring, cqe);
  }

  io_uring_queue_exit(&ring);
  MP_exit(&pool);
  return 0;
}

/*** Helper ***/
static inline int _HK_write(void *data, size_t size) {
  size_t nblocks;
  int iov_index;
  conn_t *conn;
  struct iovec *iov;
  bool once;

  conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  nblocks = round_to_blocks(size);
  iov_index = MP_expand(conn, nblocks, once);
  iov = &conn->ios[iov_index];

  memcpy(iov->iov_base, data, size);
  iov->iov_len = size;
  conn->data_left += size;

  return 0;
}
static inline int _HK_write_body(Request *req, size_t offset, size_t size) {
  if (size > req->body.size || offset > req->body.size)
    return -1;

  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  int iov_index = MP_expand(conn, 0, false);
  struct iovec *iov = &conn->ios[iov_index];
  struct iovec *rec = &conn->rec[iov_index];
  rec->iov_base = req->body.ptr + offset;
  rec->iov_len = size;
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;
  conn->data_left += rec->iov_len;
  return 0;
}
/*
static inline int _HK_mem(size_t size, HKMem *mem) {
  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  bool once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  size_t nblocks = round_to_blocks(size);
  int iov_index = MP_expand(conn, nblocks, once);
  struct iovec *iov = &conn->ios[iov_index];
  mem->ptr = iov->iov_base;
  mem->size = iov->iov_len;
  mem->_iov_index = iov_index;
  mem->_flags = (IN_POOL(iov->iov_base)) ? CF_IN_POOL : CF_IN_HEAP;
  return 0;
}

static inline void _HK_send(HKMem *mem, size_t size) {
  conn_t *conn = current_send;
  struct iovec *iov = &conn->ios[mem->_iov_index];
  iov->iov_len = size;
  conn->data_left += size;
}
  */
#endif#define _GNU_SOURCE
#ifndef UTILS_H
#define UTILS_H

#include "hunk.h"
#include <arpa/inet.h>
#include <fcntl.h>
#include <liburing.h>
#include <netdb.h>
#include <signal.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/poll.h>
#include <sys/prctl.h>
#include <sys/socket.h>
#include <sys/sysinfo.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

#define MP_BLOCK  4
#define MAX_CONNS 4096
#define KB        1024
#define NIOS      32

#define IN_POOL(ptr)                 ((void *)ptr >= pool.bpool && (void *)ptr <= (pool.bpool + (pool.npages * pool.pagesize)))
#define ALIGN_TO_PAGESIZE(buff_size) (((buff_size) + (pool.pagesize - 1)) & ~(pool.pagesize - 1))
#define BYTES_TO_BLOCKS(buff_size)   (((buff_size) + (MP_BLOCK - 1)) / MP_BLOCK)
#define CEIL_BLOCKS(nblocks)         ((nblocks + 63) & ~63)
#define CEIL_PAGES(size)             (((size) + ((pool.pagesize) - 1)) & ~((pool.pagesize) - 1))

#define BIT_IS_FREE(word, bit)   (((word) >> (bit)) & 1)
#define MARK_BIT_USED(word, bit) ((word) &= ~(1ULL << (bit)))
#define MARK_BIT_FREE(word, bit) ((word) |= (1ULL << (bit)))
#define FIND_FREE_BIT(word)      ((uint64_t)(word) & -(uint64_t)(word))
#define STRLEN(s)                (sizeof(s) - 1)

#define IOVEC_NBLOCKS (BYTES_TO_BLOCKS(NIOS * sizeof(struct iovec)))
#define MSG_NBLOCKS   (BYTES_TO_BLOCKS(sizeof(struct msghdr)))
#define ZC_RES        KB *KB

#define DEBUG 0
#if DEBUG
#define LOG(...) fprintf(logfd, __VA_ARGS__)
#else
#define LOG(...) ((void)0)
#endif

typedef enum UOP {
  WRITEV = IORING_OP_WRITEV,
  SENDMSG = IORING_OP_SENDMSG,
  RECVMSG = IORING_OP_RECVMSG,
  ACCEPT = IORING_OP_ACCEPT,
  SEND = IORING_OP_SEND,
  RECV = IORING_OP_RECV,
  SENDZC = IORING_OP_SEND_ZC,
  SENDMSGZC = IORING_OP_SENDMSG_ZC,
  PEEK = 50,
  FRECVMSG,
  INSPLICE,
  OUTSPLICE
} UOP;

typedef enum CFS {
  CF_IN_POOL = (1 << 0),       // Connection is in the pool
  CF_IN_HEAP = (1 << 1),       // Connection is in the heap
  CF_SKIP_SOCK = (1 << 2),     // Don't close the socket
  CF_USE_ONCE = (1 << 3),      // Destroy after using
  CF_HANDLER_READY = (1 << 4), // Ready to call the handler
} CFS;

typedef struct conn_t {
  // Socket file descriptor
  int fd;

  // Amount of data left in the current operation
  uint64_t data_left;

  // The index of the connection struct
  uint32_t cindex;

  // The last time the connection was readable
  uint64_t last_read;

  // The last time the connection was writeable
  uint64_t last_write;

  // The operation currently being processed
  uint8_t op;

  // Connection flags
  int flags;

  // Splice fd_in
  int in_fd;

  // Splice fd_out
  int out_fd;

  void *recv_conn;
  void *send_conn;

  struct iovec *ios;
  struct iovec *rec;
  uint16_t nios;

  struct msghdr *msg;
  uint16_t zc_notifs;

  uint16_t head_size;
} conn_t;

typedef struct MPool {
  // The allocated pool of blocks
  void *bpool;

  // The allocated pool of connections
  conn_t *cpool;

  // The size of the pool in pages
  uint32_t npages;

  // The size of the pool in blocks
  uint32_t nblocks;

  // The locations of each page in the pool
  void **blocks;

  // The availability of each block
  uint64_t *freebs;

  // The locations of each conn in the pool
  conn_t **conns;

  // The availability of each conn
  uint64_t *freecs;

  // Clean up callback function
  void (*callback)(conn_t *conn);

  // The page size used
  uint32_t pagesize;

  // Socket read timeout
  uint32_t rtimeout;

  // Socket write timeout
  uint32_t wtimeout;
} MPool;

extern int pipe_sz;
extern int pipe_in, pipe_out, nullfd;
extern FILE *logfd;
extern struct io_uring ring;
extern MPool pool;
extern conn_t *current_recv;
extern conn_t *current_send;

/*
 * Prepare and submit a recv uring op
 */
static inline int urecv(conn_t *conn, void *buffer, size_t buff_size, int flags) {
  if (!conn || conn->fd == -1)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (flags == MSG_PEEK) ? PEEK : RECV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;

  io_uring_prep_recv(sqe, conn->fd, buffer, buff_size, flags);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a multi-shot accept uring op
 */
static inline int umaccept(int listenfd) {
  if (listenfd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = ACCEPT;
  io_uring_prep_multishot_accept(sqe, listenfd, NULL, NULL, SOCK_NONBLOCK);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a splice uring op
 */
static inline int usplice(conn_t *conn, int fd_in, int64_t off_in, int fd_out, int64_t off_out, size_t len) {
  if (!len || !conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = (__u64)conn;
  io_uring_prep_splice(sqe, fd_in, off_in, fd_out, off_out, len, 0);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a writev uring op
 */
static inline int uwritev(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = WRITEV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  io_uring_prep_writev(sqe, conn->fd, &conn->ios[iov_index], nios, -1);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a send uring op
 */
static inline int usend(conn_t *conn, char *res_buff, size_t buff_size, bool zc) {
  if (!conn || conn->fd <= 0 || buff_size == 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (zc) ? SENDZC : SEND;
  conn->data_left = buff_size;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  if (zc)
    io_uring_prep_send_zc(sqe, conn->fd, res_buff, buff_size, 0, 0);
  else
    io_uring_prep_send(sqe, conn->fd, res_buff, buff_size, 0);
  return io_uring_submit(&ring);
}

static inline int ufrecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = FRECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;

  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, rec->iov_len);
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int urecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = RECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int usendmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  bool zc = (conn->data_left > ZC_RES) ? true : false;
  conn->op = (zc) ? SENDMSGZC : SENDMSG;

  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  if (zc) {
    io_uring_prep_sendmsg_zc(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
    conn->zc_notifs++;
  } else {
    io_uring_prep_sendmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  }
  return io_uring_submit(&ring);
}

/*
 * Create and initialize a server socket
 */
static inline int tcp_listen(uint16_t port) {
  int enable;
  int listenfd;
  if ((listenfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    return -1;

  int flags = fcntl(listenfd, F_GETFL, 0);
  fcntl(listenfd, F_SETFL, flags | O_NONBLOCK);
  struct sockaddr_in servaddr;
  memset(&servaddr, 0, sizeof(servaddr));
  servaddr.sin_family = AF_INET;
  servaddr.sin_addr.s_addr = INADDR_ANY;
  servaddr.sin_port = htons(port);

  enable = 1;
  if (setsockopt(listenfd, SOL_SOCKET, SO_REUSEPORT, &enable, sizeof(enable)) < 0)
    return -1;

  if (bind(listenfd, (struct sockaddr *)&servaddr, sizeof(servaddr)) < 0)
    return -1;

  if (listen(listenfd, SOMAXCONN) < 0)
    return -1;

  return listenfd;
}

/*
 * Calculate the difference between two pointers
 */
static inline uintptr_t ptr_diff(uintptr_t p1, uintptr_t p2) { return (uintptr_t)(p1 > p2) ? (p1 - p2) : (p2 - p1); }

static inline size_t get_nroutes(Route *routes) {
  Route *route;
  for (size_t i = 0;; i++) {
    route = &routes[i];
    if (!route->path && !route->handler && !route->method)
      return i;
  }
}

static inline long get_content_length(char *src, char *end) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return -1;
    key = line;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, "Content-Length") != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;

    *line_end = '\0';
    long res = atol(value);
    *line_end = '\r';

    return res;
  }
  return -1;
}

static inline bool have_header(char *src, char *end, const char *header_key, const char *header_value) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    key = line;
    while (*key == ' ')
      key++;
    while (*header_key == ' ')
      header_key++;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return false;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, header_key) != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;
    while (*header_value == ' ')
      header_value++;

    *line_end = '\0';
    bool res = (strcasecmp(value, header_value) == 0);
    *line_end = '\r';

    return res;
  }

  return false;
}

static inline const char *method_str(Method method) {
  switch (method) {
  case GET:
    return "GET";
    break;
  case HEAD:
    return "HEAD";
    break;
  case POST:
    return "POST";
    break;
  case PUT:
    return "PUT";
    break;
  case DELETE:
    return "DELETE";
    break;
  case CONNECT:
    return "CONNECT";
    break;
  case OPTIONS:
    return "OPTIONS";
    break;
  case TRACE:
    return "TRACE";
    break;
  case PATCH:
    return "PATCH";
    break;
  default:
    return NULL;
  }
}

static inline uint8_t method_len(Method method) {
  switch (method) {
  case GET:
    return 3;
    break;
  case HEAD:
    return 4;
    break;
  case POST:
    return 4;
    break;
  case PUT:
    return 3;
    break;
  case DELETE:
    return 6;
    break;
  case CONNECT:
    return 7;
    break;
  case OPTIONS:
    return 7;
    break;
  case TRACE:
    return 5;
    break;
  case PATCH:
    return 5;
    break;
  default:
    return 0;
  }
}

static inline size_t round_to_blocks(size_t size) {
  size_t nblocks = BYTES_TO_BLOCKS(size);
  nblocks = CEIL_BLOCKS(nblocks);
  return nblocks;
}

/*
 * Count the digits in unsigned 64-bit int
 */
static inline int countd(uint64_t num) {
  if (num < 10ULL)
    return 1;
  if (num < 100ULL)
    return 2;
  if (num < 1000ULL)
    return 3;
  if (num < 10000ULL)
    return 4;
  if (num < 100000ULL)
    return 5;
  if (num < 1000000ULL)
    return 6;
  if (num < 10000000ULL)
    return 7;
  if (num < 100000000ULL)
    return 8;
  if (num < 1000000000ULL)
    return 9;
  if (num < 10000000000ULL)
    return 10;
  if (num < 100000000000ULL)
    return 11;
  if (num < 1000000000000ULL)
    return 12;
  if (num < 10000000000000ULL)
    return 13;
  if (num < 100000000000000ULL)
    return 14;
  if (num < 1000000000000000ULL)
    return 15;
  if (num < 10000000000000000ULL)
    return 16;
  if (num < 100000000000000000ULL)
    return 17;
  if (num < 1000000000000000000ULL)
    return 18;
  if (num < 10000000000000000000ULL)
    return 19;
  return 20;
}

/*
 * Get the time elabsed in ms
 */
static inline uint64_t get_time() {
  struct timespec ts;
  clock_gettime(CLOCK_MONOTONIC, &ts);
  return (uint64_t)(ts.tv_sec) * 1000 + (ts.tv_nsec / 1000000);
}

static inline FILE *log_init(const char *path) {
  FILE *res = fopen(path, "a+");
  setvbuf(res, NULL, _IONBF, 0);
  return res;
}

static inline int16_t pollevs(int connfd) {
  struct pollfd pfd;
  pfd.fd = connfd;
  pfd.events = POLLIN | POLLOUT | POLLERR;
  int res = poll(&pfd, 1, 0);
  if (res < 0)
    return POLLERR;
  return pfd.revents;
}

// FIXME This needs to be updated
static inline conn_t *MP_use_once(size_t nblocks, int fd) {

  void *mem = malloc(sizeof(conn_t) + 8 + (IOVEC_NBLOCKS * MP_BLOCK));
  struct conn_t *conn = (conn_t *)mem;
  memset(conn, 0, sizeof(conn_t));
  conn->ios = mem + sizeof(conn_t) + 8;

  if (nblocks > 0) {
    struct iovec *iov = &conn->ios[conn->nios++];
    mem = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (mem == MAP_FAILED)
      return NULL;
    iov->iov_base = mem;
    iov->iov_len = ALIGN_TO_PAGESIZE(nblocks * MP_BLOCK);
  }

  conn->flags |= CF_IN_HEAP;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;

  return conn;
}

static inline int find_freec() {
  uint64_t *word;
  size_t map_size = (sizeof(uint64_t) * 8);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    word = &pool.freecs[i / map_size];

    if (*word == 0) { // All used
      i += (map_size - 1);
      continue;
    }

    i += __builtin_ctzll(*word);
    MARK_BIT_USED(*word, i);
    return i;
  }

  return -1;
}

static inline int MP_init(size_t npages) {
  if (!npages)
    return -1;

  /*** Setup ***/
  pool.npages = npages;
  pool.pagesize = sysconf(_SC_PAGESIZE);

  /*** Pool ***/
  pool.bpool = mmap(NULL, pool.npages * pool.pagesize, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  if (pool.bpool == MAP_FAILED)
    return -1;
  pool.nblocks = (pool.npages * pool.pagesize) / MP_BLOCK;

  /*** Blocks ***/
  pool.blocks = malloc(sizeof(void *) * pool.nblocks);
  if (!pool.blocks)
    return -1;
  for (size_t i = 0; i < pool.nblocks; i++)
    pool.blocks[i] = pool.bpool + (i * MP_BLOCK);

  /*** Freebs ***/
  // if (posix_memalign((void **)&pool.freebs, 64, bitmap_size * sizeof(uint64_t)) < 0)
  size_t bitmap_size = (pool.nblocks + 63) / 64;
  pool.freebs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freebs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freebs[i] = UINT64_MAX;

  /*** Cpool ***/
  pool.cpool = (conn_t *)malloc(sizeof(conn_t) * MAX_CONNS);
  if (!pool.cpool)
    return -1;

  /*** Conns ***/
  pool.conns = (conn_t **)malloc(sizeof(conn_t *) * MAX_CONNS);
  if (!pool.conns)
    return -1;
  size_t conn_size = sizeof(conn_t);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    pool.conns[i] = (conn_t *)((char *)pool.cpool + (i * conn_size));
    pool.conns[i]->fd = -1;
    pool.conns[i]->in_fd = -1;
    pool.conns[i]->out_fd = -1;
  }

  /*** Freecs ***/
  bitmap_size = (MAX_CONNS + 63) / 64;
  pool.freecs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freecs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freecs[i] = UINT64_MAX;

  return 0;
}

static inline int MP_use_blks(size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t max_start = pool.nblocks - nblocks;
  size_t full_chunks = (nblocks / 64) * 64;

  for (size_t i = 0, c = 0; i <= max_start; i++, c++) {
    bool free = true;

    for (size_t j = 0; j < full_chunks; j += 64) {
      size_t word_index = (i + j) / 64;
      if (pool.freebs[word_index] != UINT64_MAX) {
        free = false;
        i += 63;
        break;
      }
    }

    for (size_t j = full_chunks; j < nblocks; j++) {
      size_t bit_index = i + j;
      size_t word_index = bit_index / 64;
      size_t bit_in_word = bit_index % 64;

      if (!BIT_IS_FREE(pool.freebs[word_index], bit_in_word)) {
        free = false;
        i += j;
        break;
      }
    }

    if (free) {
      for (size_t j = 0; j < full_chunks; j += 64) {
        size_t word_index = (i + j) / 64;
        pool.freebs[word_index] = 0;
      }

      for (size_t j = full_chunks; j < nblocks; j++) {
        size_t bit_index = i + j;
        size_t word_index = bit_index / 64;
        size_t bit_in_word = bit_index % 64;

        MARK_BIT_USED(pool.freebs[word_index], bit_in_word);
      }

      return i;
    }
  }

  return -1;
}

static inline int MP_free_blks(size_t bindex, size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t full_chunks = (nblocks / 64) * 64;
  for (size_t i = 0; i < full_chunks; i += 64) {
    size_t word_index = (bindex + i) / 64;
    pool.freebs[word_index] = UINT64_MAX;
  }

  for (size_t i = full_chunks; i < nblocks; i++) {
    size_t bit_index = bindex + i;
    size_t word_index = bit_index / 64;
    size_t bit_in_word = bit_index % 64;

    MARK_BIT_FREE(pool.freebs[word_index], bit_in_word);
  }

  memset(pool.blocks[bindex], 0, nblocks * MP_BLOCK);
  return 0;
}

static inline conn_t *MP_use(size_t nblocks, int fd, bool once) {
  if (fd <= 0)
    return NULL;
  if (once)
    return MP_use_once(nblocks, fd);

  int cindex = find_freec();
  if (cindex < 0) {
    LOG("Err: cindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  conn_t *conn = pool.conns[cindex];

  int ios_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (ios_bindex < 0) {
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }

  struct iovec *ios = pool.blocks[ios_bindex];
  conn->ios = ios;

  int rec_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (rec_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct iovec *rec = pool.blocks[rec_bindex];
  conn->rec = rec;

  int msg_bindex = MP_use_blks(MSG_NBLOCKS);
  if (msg_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct msghdr *msg = pool.blocks[msg_bindex];
  conn->msg = msg;

  if (nblocks > 0) {
    int bindex = MP_use_blks(nblocks);
    if (bindex < 0) {
      MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
      MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
      MP_free_blks(msg_bindex, IOVEC_NBLOCKS);
      MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
      LOG("Err: bindex < 0; will use MP_use_once\n");
      return MP_use_once(nblocks, fd);
    }

    size_t iov_index = conn->nios++;
    struct iovec *iov = &conn->ios[iov_index];
    struct iovec *rec = &conn->rec[iov_index];
    iov->iov_base = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
  }

  conn->msg->msg_iov = conn->ios;
  conn->msg->msg_iovlen = conn->nios;
  conn->cindex = cindex;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;
  return conn;
}

static inline void MP_shed(conn_t *conn, size_t iov_index, size_t nios) {
  struct iovec *iov, *rec;
  size_t bindex, nblocks, index;

  for (size_t i = 0; i < nios; i++) {
    index = iov_index + i;
    iov = &conn->ios[index];
    rec = &conn->rec[index];
    if (!rec || !rec->iov_base)
      continue;
    if (!IN_POOL(rec->iov_base)) {
      munmap(rec->iov_base, rec->iov_len / pool.pagesize);
    } else {
      bindex = ptr_diff((uintptr_t)rec->iov_base, (uintptr_t)pool.bpool) / MP_BLOCK;
      nblocks = rec->iov_len / MP_BLOCK;
      MP_free_blks(bindex, nblocks);
    }
    memset(iov, 0, sizeof(struct iovec));
    memset(rec, 0, sizeof(struct iovec));
    conn->nios--;
  }
}

static inline int MP_expand(conn_t *conn, size_t nblocks, bool once) {
  void *bptr;
  int iov_index, bindex;
  struct iovec *iov, *rec;

  iov_index = conn->nios++;
  iov = &conn->ios[iov_index];
  rec = &conn->rec[iov_index];

  if (nblocks == 0)
    return iov_index;

  if (once) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_base = bptr;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
    return iov_index;
  }

  bindex = MP_use_blks(nblocks);
  if (bindex < 0) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_len = iov->iov_len;
  } else {
    bptr = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_len = iov->iov_len;
  }

  iov->iov_base = bptr;
  rec->iov_base = iov->iov_base;
  return iov_index;
}

static inline int MP_free(conn_t *conn) {
  if (!conn)
    return -1;
  size_t bindex, nblocks;
  uint64_t *word;

  MP_shed(conn, 0, conn->nios);
  if (conn->flags & CF_IN_HEAP) {
    if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
      close(conn->fd);
    free(conn);
    return 0;
  }

  word = &pool.freecs[conn->cindex / 64];
  if (conn->cindex > MAX_CONNS)
    return -1;
  else if (BIT_IS_FREE(*word, conn->cindex))
    return 0;

  bindex = ptr_diff((uintptr_t)conn->ios, (uintptr_t)pool.bpool) / MP_BLOCK;
  nblocks = IOVEC_NBLOCKS;
  MP_free_blks(bindex, nblocks);

  bindex = ptr_diff((uintptr_t)conn->rec, (uintptr_t)pool.bpool) / MP_BLOCK;
  MP_free_blks(bindex, nblocks);

  if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
    close(conn->fd);

  MARK_BIT_FREE(*word, conn->cindex);
  memset(conn, 0, sizeof(conn_t));
  conn->fd = -1;
  conn->in_fd = -1;
  conn->out_fd = -1;
  return 0;
}

static inline void MP_clear(conn_t *conn) {
  conn_t *recv_conn = conn->recv_conn;
  conn_t *send_conn = conn->send_conn;
  if (recv_conn)
    MP_free(recv_conn);
  if (send_conn)
    MP_free(send_conn);
}

static inline void MP_exit(MPool *pool) {
  munmap(pool->bpool, pool->npages);
  free(pool->cpool);
  free(pool->blocks);
  free(pool->conns);
  free(pool->freebs);
  free(pool->freecs);
}

static inline void MP_timeout() {
  conn_t *conn;
  int16_t res;
  uint64_t now;
  size_t windex = 0;
  uint64_t *word = &pool.freecs[0];
  for (size_t i = 0; i < MAX_CONNS; i++) {
    if ((i / 64) < windex)
      word = &pool.freecs[++windex];

    if (*word == UINTMAX_MAX) {
      i = (i / 64) * 64 + 64;
      continue;
    }

    conn = pool.conns[i];
    if (!conn || conn->fd == -1)
      continue;

    res = pollevs(conn->fd);

    now = get_time();
    if (res & POLLERR) {
      MP_clear(conn);
      continue;
    }
    if (res & POLLIN) {
      if (pool.rtimeout > 0 && (now - conn->last_read) >= pool.rtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (res & POLLOUT) {
      if (pool.wtimeout > 0 && (now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (!(res & POLLIN || res & POLLOUT)) {
      if ((pool.rtimeout > 0 && now - conn->last_read) >= pool.rtimeout
          || (pool.wtimeout > 0 && now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
  }
}

/*
 * Calculate the length of a status string
 */
static inline size_t status_len(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return 8;
  case STATUSSWITCHINGPROTOCOLS:
    return 19;
  case STATUSPROCESSING:
    return 10;
  case STATUSEARLYHINTS:
    return 11;
  case STATUSOK:
    return 2;
  case STATUSCREATED:
    return 7;
  case STATUSACCEPTED:
    return 8;
  case STATUSNONAUTHORITATIVE:
    return 29;
  case STATUSNOCONTENT:
    return 10;
  case STATUSRESETCONTENT:
    return 13;
  case STATUSPARTIALCONTENT:
    return 15;
  case STATUSMULTISTATUS:
    return 12;
  case STATUSALREADYREPORTED:
    return 16;
  case STATUSIMUSED:
    return 7;
  case STATUSMULTIPLECHOICES:
    return 16;
  case STATUSMOVEDPERMANENTLY:
    return 17;
  case STATUSFOUND:
    return 5;
  case STATUSSEEOTHER:
    return 9;
  case STATUSNOTMODIFIED:
    return 12;
  case STATUSUSEPROXY:
    return 9;
  case STATUSTEMPORARYREDIRECT:
    return 18;
  case STATUSPERMANENTREDIRECT:
    return 18;
  case STATUSBADREQUEST:
    return 11;
  case STATUSUNAUTHORIZED:
    return 12;
  case STATUSPAYMENTREQUIRED:
    return 16;
  case STATUSFORBIDDEN:
    return 9;
  case STATUSNOTFOUND:
    return 9;
  case STATUSMETHODNOTALLOWED:
    return 18;
  case STATUSNOTACCEPTABLE:
    return 14;
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return 29;
  case STATUSREQUESTTIMEOUT:
    return 15;
  case STATUSCONFLICT:
    return 8;
  case STATUSGONE:
    return 4;
  case STATUSLENGTHREQUIRED:
    return 15;
  case STATUSPRECONDITIONFAILED:
    return 19;
  case CONTENTTOOLARGE:
    return 17;
  case STATUSURITOOLONG:
    return 12;
  case STATUSUNSUPPORTEDMEDIATYPE:
    return 22;
  case STATUSRANGENOTSATISFIABLE:
    return 21;
  case STATUSEXPECTATIONFAILED:
    return 18;
  case STATUSMISDIRECTEDREQUEST:
    return 19;
  case STATUSUNPROCESSABLECONTENT:
    return 21;
  case STATUSLOCKED:
    return 6;
  case STATUSFAILEDDEPENDENCY:
    return 17;
  case STATUSTOOEARLY:
    return 9;
  case STATUSUPGRADEREQUIRED:
    return 16;
  case STATUSPRECONDITIONREQUIRED:
    return 21;
  case STATUSTOOMANYREQUESTS:
    return 17;
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return 31;
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return 29;
  case STATUSInternalServerError:
    return 21;
  case STATUSNOTIMPLEMENTED:
    return 15;
  case STATUSBADGATEWAY:
    return 11;
  case STATUSSERVICEUNAVAILABLE:
    return 19;
  case STATUSGATEWAYTIMEOUT:
    return 15;
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return 26;
  case STATUSVARIANTALSONEGOTIATES:
    return 23;
  case STATUSINSUFFICIENTSTORAGE:
    return 20;
  case STATUSLOOPDETECTED:
    return 13;
  case STATUSNOTEXTENDED:
    return 12;
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return 31;
  default:
    return 0;
  }
}

/*
 * Return the status code string as string literal
 */
static inline char *status_str(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return "Continue";
  case STATUSSWITCHINGPROTOCOLS:
    return "Switching Protocols";
  case STATUSPROCESSING:
    return "Processing";
  case STATUSEARLYHINTS:
    return "Early Hints";
  case STATUSOK:
    return "OK";
  case STATUSCREATED:
    return "Created";
  case STATUSACCEPTED:
    return "Accepted";
  case STATUSNONAUTHORITATIVE:
    return "Non-Authoritative Information";
  case STATUSNOCONTENT:
    return "No Content";
  case STATUSRESETCONTENT:
    return "Reset Content";
  case STATUSPARTIALCONTENT:
    return "Partial Content";
  case STATUSMULTISTATUS:
    return "Multi-Status";
  case STATUSALREADYREPORTED:
    return "Already Reported";
  case STATUSIMUSED:
    return "Im Used";
  case STATUSMULTIPLECHOICES:
    return "Multiple Choices";
  case STATUSMOVEDPERMANENTLY:
    return "Moved Permanently";
  case STATUSFOUND:
    return "Found";
  case STATUSSEEOTHER:
    return "See Other";
  case STATUSNOTMODIFIED:
    return "Not Modified";
  case STATUSUSEPROXY:
    return "Use Proxy";
  case STATUSTEMPORARYREDIRECT:
    return "Temporary Redirect";
  case STATUSPERMANENTREDIRECT:
    return "Permanent Redirect";
  case STATUSBADREQUEST:
    return "Bad Request";
  case STATUSUNAUTHORIZED:
    return "Unauthorized";
  case STATUSPAYMENTREQUIRED:
    return "Payment Required";
  case STATUSFORBIDDEN:
    return "Forbidden";
  case STATUSNOTFOUND:
    return "Not Found";
  case STATUSMETHODNOTALLOWED:
    return "Method Not Allowed";
  case STATUSNOTACCEPTABLE:
    return "Not Acceptable";
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return "Proxy Authentication Required";
  case STATUSREQUESTTIMEOUT:
    return "Request Timeout";
  case STATUSCONFLICT:
    return "Conflict";
  case STATUSGONE:
    return "Gone";
  case STATUSLENGTHREQUIRED:
    return "Length Required";
  case STATUSPRECONDITIONFAILED:
    return "Precondition Failed";
  case CONTENTTOOLARGE:
    return "Content Too Large";
  case STATUSURITOOLONG:
    return "URI Too Long";
  case STATUSUNSUPPORTEDMEDIATYPE:
    return "Unsupported Media Type";
  case STATUSRANGENOTSATISFIABLE:
    return "Range Not Satisfiable";
  case STATUSEXPECTATIONFAILED:
    return "Expectation Failed";
  case STATUSMISDIRECTEDREQUEST:
    return "Misdirected Request";
  case STATUSUNPROCESSABLECONTENT:
    return "Unprocessable Content";
  case STATUSLOCKED:
    return "Locked";
  case STATUSFAILEDDEPENDENCY:
    return "Failed Dependency";
  case STATUSTOOEARLY:
    return "Too Early";
  case STATUSUPGRADEREQUIRED:
    return "Upgrade Required";
  case STATUSPRECONDITIONREQUIRED:
    return "Precondition Required";
  case STATUSTOOMANYREQUESTS:
    return "Too Many Requests";
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return "Request Header Fields Too Large";
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return "Unavailable For Legal Reasons";
  case STATUSInternalServerError:
    return "Internal Server Error";
  case STATUSNOTIMPLEMENTED:
    return "Not Implemented";
  case STATUSBADGATEWAY:
    return "Bad Gateway";
  case STATUSSERVICEUNAVAILABLE:
    return "Service Unavailable";
  case STATUSGATEWAYTIMEOUT:
    return "Gateway Timeout";
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return "HTTP Version Not Supported";
  case STATUSVARIANTALSONEGOTIATES:
    return "Variant Also Negotiates";
  case STATUSINSUFFICIENTSTORAGE:
    return "Insufficient Storage";
  case STATUSLOOPDETECTED:
    return "Loop Detected";
  case STATUSNOTEXTENDED:
    return "Not Extended";
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return "Network Authentication Required";
  default:
    return 0;
  }
}

/*
 * Return true if routes match
 */
static inline bool route_equ(Route *route, Request *req) {
  return route->method == req->method && strncmp(route->path, req->path, strlen(route->path)) == 0;
}

/*
 * Return the matching route index on success. -1 on failure
 */
static inline int match_route(Server *serv, Request *req) {
  for (size_t i = 0; i < serv->_nroutes; i++) {
    Route route = serv->routes[i];
    if (!req->path || !route.path)
      continue;
    if (route_equ(&route, req))
      return i;
    else if (req->method == HEAD && route.method == GET && strcmp(route.path, req->path) == 0)
      return i;
  }
  return -1;
}

/*
 * Return true if the response should contain the Content-Length header
 */
static inline bool should_have_content_length(Request *req, ResWriter *res) {
  return (req->method != CONNECT              // CONNECT request
          && res->status != STATUSNOCONTENT   // 204 response
          && res->status != STATUSNOTMODIFIED // 304 response
          && res->status >= 200);             // 1xx response
}

/*
 * Format http response from the ResWriter.
 * Return response size on success, 0 on failure.
 */
static inline size_t fmt_res(Request *req, ResWriter *res, char *buffer, size_t buffer_size) {
  if (!res || !buffer || buffer_size == 0)
    return 0;

  size_t res_len, total = 0;
  char *dst = buffer;
  size_t maxlen = buffer_size;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t body_length = res->len;

  res_len = snprintf(dst, maxlen, "HTTP/1.1 %d %s", (int)res->status, status_str(res->status));
  total += res_len;
  dst += res_len;
  maxlen -= res_len;

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    res_len = snprintf(dst, maxlen, "\r\n%s: %s", header->key, header->value);
    total += res_len;
    dst += res_len;
    maxlen -= res_len;
  }

  if (have_content_length) {
    res_len = snprintf(dst, maxlen, "\r\nContent-Length: %lu", body_length);
    total += res_len, dst += res_len, maxlen -= res_len;
  }

  memcpy(dst, "\r\n\r\n", 4);
  total += 4, dst += 4, maxlen -= 4;

  return total;
}

static inline size_t res_len(Request *req, ResWriter *res) {
  if (!req || !res)
    return 0;

  if (!res->status)
    res->status = STATUSOK;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t result = 0;
  result += STRLEN("HTTP/1.1 ");     // HTTP version
  result += 4;                       // Status code + space
  result += status_len(res->status); // Status name

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    result += 2;                       // "\r\n"
    result += strlen(header->key) + 2; // Header key + ':' + space
    result += strlen(header->value);   // header value
  }

  if (have_content_length) {
    result += 2;                          // "\r\n"
    result += STRLEN("Content-Length: "); // Header key
    result += countd(res->len);           // Header value
  }

  result += 4; // "\r\n\r\n"

  return result;
}

static inline int send_empty_res(Status status) {
  size_t res_len = STRLEN("HTTP/1.1 ")        // HTTP version
                   + countd((uint64_t)status) // status code
                   + 1                        // space
                   + (int)status_len(status)  // status string
                   + 4;                       // \r\n\r\n

  conn_t *conn = current_send;
  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, res_len);
  if (snprintf((char *)rec->iov_base, res_len + 1, "HTTP/1.1 %d %s\r\n\r\n", (int)status, status_str(status))
      != (int)res_len)
    return -1;

  return usendmsg(conn, 0, 1);
}

static inline ssize_t read_socket(int sockfd, size_t len) {
  if (len == 0 || sockfd <= 0)
    return 0;
  char buff[1024 * 8];
  return read(sockfd, buff, 1024 * 8);
}

static inline int read_method(Method *method, void *src) {
  if (memcmp(src, "GET", 3) == 0)
    *method = GET;
  else if (memcmp(src, "POST", 4) == 0)
    *method = POST;
  else if (memcmp(src, "HEAD", 4) == 0)
    *method = HEAD;
  else if (memcmp(src, "PUT", 3) == 0)
    *method = PUT;
  else if (memcmp(src, "DELETE", 6) == 0)
    *method = DELETE;
  else if (memcmp(src, "CONNECT", 7) == 0)
    *method = CONNECT;
  else if (memcmp(src, "OPTIONS", 7) == 0)
    *method = OPTIONS;
  else if (memcmp(src, "TRACE", 5) == 0)
    *method = TRACE;
  else if (memcmp(src, "PATCH", 5) == 0)
    *method = PATCH;
  else
    return -1;

  return 0;
}

static inline int sendmsg_res(Request *req, ResWriter *res) {
  conn_t *conn;
  size_t head_size, res_size;
  struct iovec *iov;

  conn = current_send;
  iov = &conn->ios[0];
  head_size = res_len(req, res);
  if (head_size == 0)
    return -1;

  conn->data_left += head_size;
  res_size = fmt_res(req, res, iov->iov_base, (head_size + 1));
  if (res_size != head_size)
    return -1;
  iov->iov_len = res_size;

  return usendmsg(conn, 0, conn->nios);
}

static inline int read_req(Request *req, char *req_buffer) {
  if (!req_buffer)
    return -1;
  /*** Method ***/
  char *sep = strchr(req_buffer, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }
  *sep = '\0';
  if (read_method(&req->method, req_buffer) < 0)
    return -1;

  /*** Path ***/
  char *fullpath = sep + 1;
  sep = strchr(fullpath, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }

  *sep = '\0';
  req->path = fullpath;
  /*** Params ***/
  char *paramStart = strchr(fullpath, '?');
  if (paramStart) {
    *paramStart++ = '\0';
    int params_count = 0;
    params_count = HK_parse_params(paramStart, req->params, MAX_URL_PARAMETERS);
    if (params_count > 0)
      req->params_count = params_count;
    else
      req->params_count = 0;
  } else {
    req->params = NULL;
    req->params_count = 0;
  }

  /*** Headers ***/
  char *headStart = strstr(sep + 1, "\r\n");
  char *headEnd = strstr(sep + 1, "\r\n\r\n");
  if (!headStart) {
    LOG("read_req: !headStart\n");
    return -1;
  };

  memset(headStart, 0, 2);
  headStart += 2;
  memset(headEnd, 0, 4);
  headEnd += 4;

  int headers_count = HK_parse_headers(headStart, req->headers, MAX_REQ_HEADERS);
  if (headers_count <= 0)
    return -1;
  req->headers_count = headers_count;

  /*** Host ***/
  int index = HK_get_header(req, "Host");
  if (index < 0)
    return -1;
  char *host = req->headers[index].value;
  req->hostname = host;

  /*** Port ***/
  char *colon = strchr(host, ':');
  if (colon) {
    *colon++ = '\0';
    req->port = atoi(colon);
  } else {
    req->port = PORT;
  }
  return 0;
}
static inline int process_req(Server *serv, conn_t *conn) {
  if (!conn || conn->fd == -1)
    return -1;

  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;
  if (read_req(&req, conn->ios[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    LOG("Err: route_index == -1\n");
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;
  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  sendmsg_res(&req, &res);

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int new_conn(int connfd) {
  if (connfd <= 0)
    return -1;

  current_recv = MP_use(KB * 2, connfd, false);
  current_send = MP_use(KB * 2, connfd, false);

  current_recv->recv_conn = current_recv;
  current_recv->send_conn = current_send;

  current_send->send_conn = current_send;
  current_send->recv_conn = current_recv;

  conn_t *conn = current_recv;
  if (ufrecvmsg(conn, 0, 1) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

static inline int resubmit_sendmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return usendmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int resubmir_recvmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    // FIXME the len should be increased
    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return urecvmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int handle_sendmsg_complete(conn_t *conn) {
  struct iovec *iov, *rec;

  MP_shed(conn, 1, conn->nios - 1);
  iov = &conn->ios[0];
  rec = &conn->rec[0];
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;

  return ufrecvmsg(conn->recv_conn, 0, 1);
}

static inline int handle_sendmsg(conn_t *conn, int res, bool zc) {
  if (!conn || conn->fd == -1)
    return -1;

  conn->data_left -= res;
  if (conn->data_left > 0)
    return resubmit_sendmsg(conn, res);

  if (zc)
    return 0;

  return handle_sendmsg_complete(conn);
}

static inline int handle_insplice(conn_t *conn) {
  conn->op = OUTSPLICE;
  return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
}
static inline int handle_outsplice(conn_t *conn, int res) {
  conn->data_left -= res;
  if (conn->data_left > 0) {
    conn->op = INSPLICE;
    return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
  }

  conn_t *recv_conn = conn->recv_conn;
  struct iovec *iov = &recv_conn->ios[0];
  memset(iov->iov_base, 0, iov->iov_len);
  if (urecv(recv_conn, iov->iov_base, iov->iov_len, MSG_PEEK) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

/*
static inline int handle_recv(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  void *bptr = conn->ios[0].iov_base;
  void *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  void *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  return process_req(serv, conn);
}
*/
static inline int find_route(Server *serv, char *bptr) {
  Request req = {0};
  if (read_method(&req.method, bptr) < 0) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  };
  char *space = strchr(bptr, ' ');
  req.path = (space + 1);
  space = strchr(req.path, ' ');
  *space = '\0';
  int route_index = match_route(serv, &req);
  *space = ' ';
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }
  return route_index;
}

static inline int run_handler(Server *serv, conn_t *conn, bool uses_body) {
  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;

  if (read_req(&req, conn->rec[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  if (uses_body) {
    int h_index = HK_get_header(&req, "Content-Length");
    long body_size = atol(req.headers[h_index].value);
    if (body_size >= 0) {
      req.body.ptr = conn->rec[1].iov_base;
      req.body.size = body_size;
    } else {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    }
  }

  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  if (sendmsg_res(&req, &res) < 0)
    return -1;

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int handle_frecvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  char *bptr = (char *)conn->ios[0].iov_base;
  char *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  char *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  size_t head_size = (headEnd + 4) - bptr;
  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  int route_index = find_route(serv, bptr);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  bool uses_body = serv->routes[route_index].uses_body;
  long body_size = get_content_length(headstart + 2, headEnd + 4);
  if (body_size == -1) {
    if (uses_body) {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    } else {
      body_size = 0;
    }
  }

  conn->head_size = head_size;
  if (!uses_body) {
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  if (res == (int)(head_size + body_size)) {
    size_t iov_index = MP_expand(conn, round_to_blocks(body_size), false);
    memcpy(conn->rec[iov_index].iov_base, headEnd + 4, body_size);
    conn->ios[iov_index].iov_len = body_size;
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  conn->data_left = body_size - (res - head_size);
  bool once = ((size_t)body_size > (size_t)((pool.nblocks * MP_BLOCK) / 10));
  size_t iov_index = MP_expand(conn, round_to_blocks(body_size), once);
  memcpy(conn->rec[iov_index].iov_base, headEnd + 4, (res - head_size));
  conn->ios[iov_index].iov_base += (res - head_size);

  return urecvmsg(conn, iov_index, 1);
}

static inline int handle_recvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  if (conn->data_left > 0) {
    conn->data_left -= res;
    if (conn->data_left == 0) {
      conn->flags &= CF_HANDLER_READY;
      return run_handler(serv, conn, true);
    }

    conn->flags &= ~CF_HANDLER_READY;
    conn->ios[1].iov_base += res;
    return urecvmsg(conn, 1, 1);
  }

  conn->flags &= CF_HANDLER_READY;
  return run_handler(serv, conn, true);
}

static inline int serv_init(Server *serv) {
#if DEBUG
  logfd = log_init("log.txt");
  if (!logfd) {
    printf("log_init failed");
    return -1;
  }
#endif
  serv->_nroutes = get_nroutes(serv->routes);

  int pipefd[2];
  if (pipe(pipefd) < 0)
    return -1;
  pipe_in = pipefd[0];
  pipe_out = pipefd[1];
  nullfd = open("/dev/null", O_WRONLY);
  pipe_sz = fcntl(pipefd[0], F_GETPIPE_SZ);
  if (pipe_sz < 0)
    return -1;

  pool.rtimeout = serv->rtimeout;
  pool.wtimeout = serv->wtimeout;
  if (MP_init(MAX_CONNS * 8) < 0)
    return -1;
  LOG("pool initialized\n");

  if (io_uring_queue_init(MAX_CONNS, &ring, 0) < 0)
    return -1;
  LOG("uring initialized\n");

  int listenfd;
  if ((listenfd = tcp_listen(serv->port)) < 0)
    return -1;
  LOG("socket initialized\n");

  return umaccept(listenfd);
}

static inline int serv_listen(Server *serv) {
  // uint64_t last_check = get_time();
  while (true) {
    // uint64_t now = get_time();
    // if ((now - last_check) >= 200) {
    //   last_check = now;
    //   LOG("CM: CM_check ran\n");
    //   MP_timeout();
    // }

    LOG("SQ ready: %u, CQ ready: %u\n", io_uring_sq_ready(&ring), io_uring_cq_ready(&ring));
    struct io_uring_cqe *cqe;
    if (io_uring_wait_cqe(&ring, &cqe) < 0)
      continue;

    int res = cqe->res;
    LOG("res = %d\n", res);
    conn_t *conn = NULL;
    if (cqe->user_data > 100) {
      conn = (conn_t *)cqe->user_data;
      current_recv = (conn_t *)conn->recv_conn;
      current_send = (conn_t *)conn->send_conn;
    }

    if (res > 0) {
      if (cqe->user_data == ACCEPT) {
        LOG("new conn created\n");
        new_conn(res);
      } else if (conn && conn->fd != -1) {
        LOG("conn[%d]: conn.fd = %d; conn.op = %d\n", conn->cindex, conn->fd, conn->op);
        switch (conn->op) {
        case FRECVMSG:
          if (handle_frecvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case RECVMSG:
          if (handle_recvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case SENDMSG:
        case SENDMSGZC:
          // conn->last_write = get_time();
          bool zc = (conn->op == SENDMSGZC);
          if (handle_sendmsg(conn, res, zc) < 0)
            MP_clear(conn);
          break;
        case INSPLICE:
          if (handle_insplice(conn) < 0)
            MP_clear(conn);
          break;
        case OUTSPLICE:
          if (handle_outsplice(conn, res) < 0)
            MP_clear(conn);
          break;
        }
      }
    } else if (res == 0) {
      if (conn && conn->fd != -1) {
        switch (conn->op) {
        case SENDMSGZC:
          conn->zc_notifs--;
          if (conn->zc_notifs == 0 && handle_sendmsg_complete(conn) < 0)
            MP_clear(conn);
          break;
        case RECV:
          MP_clear(conn);
          break;
        }
      }
    } else {
      if (conn && conn->fd != -1) {
        if (res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR) {
          LOG("conn && conn->fd != -1 && res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR\n");
          MP_clear(conn);
        } else {
          LOG("res == -EAGAIN || res == -EWOULDBLOCK || res == -EINTR\n");
          conn = conn->recv_conn;
          struct iovec *iov = &conn->ios[0];
          memset(iov->iov_base, 0, iov->iov_len);
          if (urecv(conn, iov->iov_base, iov->iov_len, 0) < 0)
            MP_clear(conn);
        }
      }
    }

    LOG("uring operation seen\n");
    io_uring_cqe_seen(&ring, cqe);
  }

  io_uring_queue_exit(&ring);
  MP_exit(&pool);
  return 0;
}

/*** Helper ***/
static inline int _HK_write(void *data, size_t size) {
  size_t nblocks;
  int iov_index;
  conn_t *conn;
  struct iovec *iov;
  bool once;

  conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  nblocks = round_to_blocks(size);
  iov_index = MP_expand(conn, nblocks, once);
  iov = &conn->ios[iov_index];

  memcpy(iov->iov_base, data, size);
  iov->iov_len = size;
  conn->data_left += size;

  return 0;
}
static inline int _HK_write_body(Request *req, size_t offset, size_t size) {
  if (size > req->body.size || offset > req->body.size)
    return -1;

  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  int iov_index = MP_expand(conn, 0, false);
  struct iovec *iov = &conn->ios[iov_index];
  struct iovec *rec = &conn->rec[iov_index];
  rec->iov_base = req->body.ptr + offset;
  rec->iov_len = size;
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;
  conn->data_left += rec->iov_len;
  return 0;
}
/*
static inline int _HK_mem(size_t size, HKMem *mem) {
  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  bool once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  size_t nblocks = round_to_blocks(size);
  int iov_index = MP_expand(conn, nblocks, once);
  struct iovec *iov = &conn->ios[iov_index];
  mem->ptr = iov->iov_base;
  mem->size = iov->iov_len;
  mem->_iov_index = iov_index;
  mem->_flags = (IN_POOL(iov->iov_base)) ? CF_IN_POOL : CF_IN_HEAP;
  return 0;
}

static inline void _HK_send(HKMem *mem, size_t size) {
  conn_t *conn = current_send;
  struct iovec *iov = &conn->ios[mem->_iov_index];
  iov->iov_len = size;
  conn->data_left += size;
}
  */
#endif#define _GNU_SOURCE
#ifndef UTILS_H
#define UTILS_H

#include "hunk.h"
#include <arpa/inet.h>
#include <fcntl.h>
#include <liburing.h>
#include <netdb.h>
#include <signal.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/poll.h>
#include <sys/prctl.h>
#include <sys/socket.h>
#include <sys/sysinfo.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

#define MP_BLOCK  4
#define MAX_CONNS 4096
#define KB        1024
#define NIOS      32

#define IN_POOL(ptr)                 ((void *)ptr >= pool.bpool && (void *)ptr <= (pool.bpool + (pool.npages * pool.pagesize)))
#define ALIGN_TO_PAGESIZE(buff_size) (((buff_size) + (pool.pagesize - 1)) & ~(pool.pagesize - 1))
#define BYTES_TO_BLOCKS(buff_size)   (((buff_size) + (MP_BLOCK - 1)) / MP_BLOCK)
#define CEIL_BLOCKS(nblocks)         ((nblocks + 63) & ~63)
#define CEIL_PAGES(size)             (((size) + ((pool.pagesize) - 1)) & ~((pool.pagesize) - 1))

#define BIT_IS_FREE(word, bit)   (((word) >> (bit)) & 1)
#define MARK_BIT_USED(word, bit) ((word) &= ~(1ULL << (bit)))
#define MARK_BIT_FREE(word, bit) ((word) |= (1ULL << (bit)))
#define FIND_FREE_BIT(word)      ((uint64_t)(word) & -(uint64_t)(word))
#define STRLEN(s)                (sizeof(s) - 1)

#define IOVEC_NBLOCKS (BYTES_TO_BLOCKS(NIOS * sizeof(struct iovec)))
#define MSG_NBLOCKS   (BYTES_TO_BLOCKS(sizeof(struct msghdr)))
#define ZC_RES        KB *KB

#define DEBUG 0
#if DEBUG
#define LOG(...) fprintf(logfd, __VA_ARGS__)
#else
#define LOG(...) ((void)0)
#endif

typedef enum UOP {
  WRITEV = IORING_OP_WRITEV,
  SENDMSG = IORING_OP_SENDMSG,
  RECVMSG = IORING_OP_RECVMSG,
  ACCEPT = IORING_OP_ACCEPT,
  SEND = IORING_OP_SEND,
  RECV = IORING_OP_RECV,
  SENDZC = IORING_OP_SEND_ZC,
  SENDMSGZC = IORING_OP_SENDMSG_ZC,
  PEEK = 50,
  FRECVMSG,
  INSPLICE,
  OUTSPLICE
} UOP;

typedef enum CFS {
  CF_IN_POOL = (1 << 0),       // Connection is in the pool
  CF_IN_HEAP = (1 << 1),       // Connection is in the heap
  CF_SKIP_SOCK = (1 << 2),     // Don't close the socket
  CF_USE_ONCE = (1 << 3),      // Destroy after using
  CF_HANDLER_READY = (1 << 4), // Ready to call the handler
} CFS;

typedef struct conn_t {
  // Socket file descriptor
  int fd;

  // Amount of data left in the current operation
  uint64_t data_left;

  // The index of the connection struct
  uint32_t cindex;

  // The last time the connection was readable
  uint64_t last_read;

  // The last time the connection was writeable
  uint64_t last_write;

  // The operation currently being processed
  uint8_t op;

  // Connection flags
  int flags;

  // Splice fd_in
  int in_fd;

  // Splice fd_out
  int out_fd;

  void *recv_conn;
  void *send_conn;

  struct iovec *ios;
  struct iovec *rec;
  uint16_t nios;

  struct msghdr *msg;
  uint16_t zc_notifs;

  uint16_t head_size;
} conn_t;

typedef struct MPool {
  // The allocated pool of blocks
  void *bpool;

  // The allocated pool of connections
  conn_t *cpool;

  // The size of the pool in pages
  uint32_t npages;

  // The size of the pool in blocks
  uint32_t nblocks;

  // The locations of each page in the pool
  void **blocks;

  // The availability of each block
  uint64_t *freebs;

  // The locations of each conn in the pool
  conn_t **conns;

  // The availability of each conn
  uint64_t *freecs;

  // Clean up callback function
  void (*callback)(conn_t *conn);

  // The page size used
  uint32_t pagesize;

  // Socket read timeout
  uint32_t rtimeout;

  // Socket write timeout
  uint32_t wtimeout;
} MPool;

extern int pipe_sz;
extern int pipe_in, pipe_out, nullfd;
extern FILE *logfd;
extern struct io_uring ring;
extern MPool pool;
extern conn_t *current_recv;
extern conn_t *current_send;

/*
 * Prepare and submit a recv uring op
 */
static inline int urecv(conn_t *conn, void *buffer, size_t buff_size, int flags) {
  if (!conn || conn->fd == -1)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (flags == MSG_PEEK) ? PEEK : RECV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;

  io_uring_prep_recv(sqe, conn->fd, buffer, buff_size, flags);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a multi-shot accept uring op
 */
static inline int umaccept(int listenfd) {
  if (listenfd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = ACCEPT;
  io_uring_prep_multishot_accept(sqe, listenfd, NULL, NULL, SOCK_NONBLOCK);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a splice uring op
 */
static inline int usplice(conn_t *conn, int fd_in, int64_t off_in, int fd_out, int64_t off_out, size_t len) {
  if (!len || !conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = (__u64)conn;
  io_uring_prep_splice(sqe, fd_in, off_in, fd_out, off_out, len, 0);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a writev uring op
 */
static inline int uwritev(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = WRITEV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  io_uring_prep_writev(sqe, conn->fd, &conn->ios[iov_index], nios, -1);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a send uring op
 */
static inline int usend(conn_t *conn, char *res_buff, size_t buff_size, bool zc) {
  if (!conn || conn->fd <= 0 || buff_size == 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (zc) ? SENDZC : SEND;
  conn->data_left = buff_size;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  if (zc)
    io_uring_prep_send_zc(sqe, conn->fd, res_buff, buff_size, 0, 0);
  else
    io_uring_prep_send(sqe, conn->fd, res_buff, buff_size, 0);
  return io_uring_submit(&ring);
}

static inline int ufrecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = FRECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;

  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, rec->iov_len);
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int urecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = RECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int usendmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  bool zc = (conn->data_left > ZC_RES) ? true : false;
  conn->op = (zc) ? SENDMSGZC : SENDMSG;

  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  if (zc) {
    io_uring_prep_sendmsg_zc(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
    conn->zc_notifs++;
  } else {
    io_uring_prep_sendmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  }
  return io_uring_submit(&ring);
}

/*
 * Create and initialize a server socket
 */
static inline int tcp_listen(uint16_t port) {
  int enable;
  int listenfd;
  if ((listenfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    return -1;

  int flags = fcntl(listenfd, F_GETFL, 0);
  fcntl(listenfd, F_SETFL, flags | O_NONBLOCK);
  struct sockaddr_in servaddr;
  memset(&servaddr, 0, sizeof(servaddr));
  servaddr.sin_family = AF_INET;
  servaddr.sin_addr.s_addr = INADDR_ANY;
  servaddr.sin_port = htons(port);

  enable = 1;
  if (setsockopt(listenfd, SOL_SOCKET, SO_REUSEPORT, &enable, sizeof(enable)) < 0)
    return -1;

  if (bind(listenfd, (struct sockaddr *)&servaddr, sizeof(servaddr)) < 0)
    return -1;

  if (listen(listenfd, SOMAXCONN) < 0)
    return -1;

  return listenfd;
}

/*
 * Calculate the difference between two pointers
 */
static inline uintptr_t ptr_diff(uintptr_t p1, uintptr_t p2) { return (uintptr_t)(p1 > p2) ? (p1 - p2) : (p2 - p1); }

static inline size_t get_nroutes(Route *routes) {
  Route *route;
  for (size_t i = 0;; i++) {
    route = &routes[i];
    if (!route->path && !route->handler && !route->method)
      return i;
  }
}

static inline long get_content_length(char *src, char *end) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return -1;
    key = line;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, "Content-Length") != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;

    *line_end = '\0';
    long res = atol(value);
    *line_end = '\r';

    return res;
  }
  return -1;
}

static inline bool have_header(char *src, char *end, const char *header_key, const char *header_value) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    key = line;
    while (*key == ' ')
      key++;
    while (*header_key == ' ')
      header_key++;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return false;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, header_key) != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;
    while (*header_value == ' ')
      header_value++;

    *line_end = '\0';
    bool res = (strcasecmp(value, header_value) == 0);
    *line_end = '\r';

    return res;
  }

  return false;
}

static inline const char *method_str(Method method) {
  switch (method) {
  case GET:
    return "GET";
    break;
  case HEAD:
    return "HEAD";
    break;
  case POST:
    return "POST";
    break;
  case PUT:
    return "PUT";
    break;
  case DELETE:
    return "DELETE";
    break;
  case CONNECT:
    return "CONNECT";
    break;
  case OPTIONS:
    return "OPTIONS";
    break;
  case TRACE:
    return "TRACE";
    break;
  case PATCH:
    return "PATCH";
    break;
  default:
    return NULL;
  }
}

static inline uint8_t method_len(Method method) {
  switch (method) {
  case GET:
    return 3;
    break;
  case HEAD:
    return 4;
    break;
  case POST:
    return 4;
    break;
  case PUT:
    return 3;
    break;
  case DELETE:
    return 6;
    break;
  case CONNECT:
    return 7;
    break;
  case OPTIONS:
    return 7;
    break;
  case TRACE:
    return 5;
    break;
  case PATCH:
    return 5;
    break;
  default:
    return 0;
  }
}

static inline size_t round_to_blocks(size_t size) {
  size_t nblocks = BYTES_TO_BLOCKS(size);
  nblocks = CEIL_BLOCKS(nblocks);
  return nblocks;
}

/*
 * Count the digits in unsigned 64-bit int
 */
static inline int countd(uint64_t num) {
  if (num < 10ULL)
    return 1;
  if (num < 100ULL)
    return 2;
  if (num < 1000ULL)
    return 3;
  if (num < 10000ULL)
    return 4;
  if (num < 100000ULL)
    return 5;
  if (num < 1000000ULL)
    return 6;
  if (num < 10000000ULL)
    return 7;
  if (num < 100000000ULL)
    return 8;
  if (num < 1000000000ULL)
    return 9;
  if (num < 10000000000ULL)
    return 10;
  if (num < 100000000000ULL)
    return 11;
  if (num < 1000000000000ULL)
    return 12;
  if (num < 10000000000000ULL)
    return 13;
  if (num < 100000000000000ULL)
    return 14;
  if (num < 1000000000000000ULL)
    return 15;
  if (num < 10000000000000000ULL)
    return 16;
  if (num < 100000000000000000ULL)
    return 17;
  if (num < 1000000000000000000ULL)
    return 18;
  if (num < 10000000000000000000ULL)
    return 19;
  return 20;
}

/*
 * Get the time elabsed in ms
 */
static inline uint64_t get_time() {
  struct timespec ts;
  clock_gettime(CLOCK_MONOTONIC, &ts);
  return (uint64_t)(ts.tv_sec) * 1000 + (ts.tv_nsec / 1000000);
}

static inline FILE *log_init(const char *path) {
  FILE *res = fopen(path, "a+");
  setvbuf(res, NULL, _IONBF, 0);
  return res;
}

static inline int16_t pollevs(int connfd) {
  struct pollfd pfd;
  pfd.fd = connfd;
  pfd.events = POLLIN | POLLOUT | POLLERR;
  int res = poll(&pfd, 1, 0);
  if (res < 0)
    return POLLERR;
  return pfd.revents;
}

// FIXME This needs to be updated
static inline conn_t *MP_use_once(size_t nblocks, int fd) {

  void *mem = malloc(sizeof(conn_t) + 8 + (IOVEC_NBLOCKS * MP_BLOCK));
  struct conn_t *conn = (conn_t *)mem;
  memset(conn, 0, sizeof(conn_t));
  conn->ios = mem + sizeof(conn_t) + 8;

  if (nblocks > 0) {
    struct iovec *iov = &conn->ios[conn->nios++];
    mem = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (mem == MAP_FAILED)
      return NULL;
    iov->iov_base = mem;
    iov->iov_len = ALIGN_TO_PAGESIZE(nblocks * MP_BLOCK);
  }

  conn->flags |= CF_IN_HEAP;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;

  return conn;
}

static inline int find_freec() {
  uint64_t *word;
  size_t map_size = (sizeof(uint64_t) * 8);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    word = &pool.freecs[i / map_size];

    if (*word == 0) { // All used
      i += (map_size - 1);
      continue;
    }

    i += __builtin_ctzll(*word);
    MARK_BIT_USED(*word, i);
    return i;
  }

  return -1;
}

static inline int MP_init(size_t npages) {
  if (!npages)
    return -1;

  /*** Setup ***/
  pool.npages = npages;
  pool.pagesize = sysconf(_SC_PAGESIZE);

  /*** Pool ***/
  pool.bpool = mmap(NULL, pool.npages * pool.pagesize, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  if (pool.bpool == MAP_FAILED)
    return -1;
  pool.nblocks = (pool.npages * pool.pagesize) / MP_BLOCK;

  /*** Blocks ***/
  pool.blocks = malloc(sizeof(void *) * pool.nblocks);
  if (!pool.blocks)
    return -1;
  for (size_t i = 0; i < pool.nblocks; i++)
    pool.blocks[i] = pool.bpool + (i * MP_BLOCK);

  /*** Freebs ***/
  // if (posix_memalign((void **)&pool.freebs, 64, bitmap_size * sizeof(uint64_t)) < 0)
  size_t bitmap_size = (pool.nblocks + 63) / 64;
  pool.freebs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freebs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freebs[i] = UINT64_MAX;

  /*** Cpool ***/
  pool.cpool = (conn_t *)malloc(sizeof(conn_t) * MAX_CONNS);
  if (!pool.cpool)
    return -1;

  /*** Conns ***/
  pool.conns = (conn_t **)malloc(sizeof(conn_t *) * MAX_CONNS);
  if (!pool.conns)
    return -1;
  size_t conn_size = sizeof(conn_t);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    pool.conns[i] = (conn_t *)((char *)pool.cpool + (i * conn_size));
    pool.conns[i]->fd = -1;
    pool.conns[i]->in_fd = -1;
    pool.conns[i]->out_fd = -1;
  }

  /*** Freecs ***/
  bitmap_size = (MAX_CONNS + 63) / 64;
  pool.freecs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freecs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freecs[i] = UINT64_MAX;

  return 0;
}

static inline int MP_use_blks(size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t max_start = pool.nblocks - nblocks;
  size_t full_chunks = (nblocks / 64) * 64;

  for (size_t i = 0, c = 0; i <= max_start; i++, c++) {
    bool free = true;

    for (size_t j = 0; j < full_chunks; j += 64) {
      size_t word_index = (i + j) / 64;
      if (pool.freebs[word_index] != UINT64_MAX) {
        free = false;
        i += 63;
        break;
      }
    }

    for (size_t j = full_chunks; j < nblocks; j++) {
      size_t bit_index = i + j;
      size_t word_index = bit_index / 64;
      size_t bit_in_word = bit_index % 64;

      if (!BIT_IS_FREE(pool.freebs[word_index], bit_in_word)) {
        free = false;
        i += j;
        break;
      }
    }

    if (free) {
      for (size_t j = 0; j < full_chunks; j += 64) {
        size_t word_index = (i + j) / 64;
        pool.freebs[word_index] = 0;
      }

      for (size_t j = full_chunks; j < nblocks; j++) {
        size_t bit_index = i + j;
        size_t word_index = bit_index / 64;
        size_t bit_in_word = bit_index % 64;

        MARK_BIT_USED(pool.freebs[word_index], bit_in_word);
      }

      return i;
    }
  }

  return -1;
}

static inline int MP_free_blks(size_t bindex, size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t full_chunks = (nblocks / 64) * 64;
  for (size_t i = 0; i < full_chunks; i += 64) {
    size_t word_index = (bindex + i) / 64;
    pool.freebs[word_index] = UINT64_MAX;
  }

  for (size_t i = full_chunks; i < nblocks; i++) {
    size_t bit_index = bindex + i;
    size_t word_index = bit_index / 64;
    size_t bit_in_word = bit_index % 64;

    MARK_BIT_FREE(pool.freebs[word_index], bit_in_word);
  }

  memset(pool.blocks[bindex], 0, nblocks * MP_BLOCK);
  return 0;
}

static inline conn_t *MP_use(size_t nblocks, int fd, bool once) {
  if (fd <= 0)
    return NULL;
  if (once)
    return MP_use_once(nblocks, fd);

  int cindex = find_freec();
  if (cindex < 0) {
    LOG("Err: cindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  conn_t *conn = pool.conns[cindex];

  int ios_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (ios_bindex < 0) {
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }

  struct iovec *ios = pool.blocks[ios_bindex];
  conn->ios = ios;

  int rec_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (rec_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct iovec *rec = pool.blocks[rec_bindex];
  conn->rec = rec;

  int msg_bindex = MP_use_blks(MSG_NBLOCKS);
  if (msg_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct msghdr *msg = pool.blocks[msg_bindex];
  conn->msg = msg;

  if (nblocks > 0) {
    int bindex = MP_use_blks(nblocks);
    if (bindex < 0) {
      MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
      MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
      MP_free_blks(msg_bindex, IOVEC_NBLOCKS);
      MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
      LOG("Err: bindex < 0; will use MP_use_once\n");
      return MP_use_once(nblocks, fd);
    }

    size_t iov_index = conn->nios++;
    struct iovec *iov = &conn->ios[iov_index];
    struct iovec *rec = &conn->rec[iov_index];
    iov->iov_base = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
  }

  conn->msg->msg_iov = conn->ios;
  conn->msg->msg_iovlen = conn->nios;
  conn->cindex = cindex;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;
  return conn;
}

static inline void MP_shed(conn_t *conn, size_t iov_index, size_t nios) {
  struct iovec *iov, *rec;
  size_t bindex, nblocks, index;

  for (size_t i = 0; i < nios; i++) {
    index = iov_index + i;
    iov = &conn->ios[index];
    rec = &conn->rec[index];
    if (!rec || !rec->iov_base)
      continue;
    if (!IN_POOL(rec->iov_base)) {
      munmap(rec->iov_base, rec->iov_len / pool.pagesize);
    } else {
      bindex = ptr_diff((uintptr_t)rec->iov_base, (uintptr_t)pool.bpool) / MP_BLOCK;
      nblocks = rec->iov_len / MP_BLOCK;
      MP_free_blks(bindex, nblocks);
    }
    memset(iov, 0, sizeof(struct iovec));
    memset(rec, 0, sizeof(struct iovec));
    conn->nios--;
  }
}

static inline int MP_expand(conn_t *conn, size_t nblocks, bool once) {
  void *bptr;
  int iov_index, bindex;
  struct iovec *iov, *rec;

  iov_index = conn->nios++;
  iov = &conn->ios[iov_index];
  rec = &conn->rec[iov_index];

  if (nblocks == 0)
    return iov_index;

  if (once) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_base = bptr;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
    return iov_index;
  }

  bindex = MP_use_blks(nblocks);
  if (bindex < 0) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_len = iov->iov_len;
  } else {
    bptr = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_len = iov->iov_len;
  }

  iov->iov_base = bptr;
  rec->iov_base = iov->iov_base;
  return iov_index;
}

static inline int MP_free(conn_t *conn) {
  if (!conn)
    return -1;
  size_t bindex, nblocks;
  uint64_t *word;

  MP_shed(conn, 0, conn->nios);
  if (conn->flags & CF_IN_HEAP) {
    if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
      close(conn->fd);
    free(conn);
    return 0;
  }

  word = &pool.freecs[conn->cindex / 64];
  if (conn->cindex > MAX_CONNS)
    return -1;
  else if (BIT_IS_FREE(*word, conn->cindex))
    return 0;

  bindex = ptr_diff((uintptr_t)conn->ios, (uintptr_t)pool.bpool) / MP_BLOCK;
  nblocks = IOVEC_NBLOCKS;
  MP_free_blks(bindex, nblocks);

  bindex = ptr_diff((uintptr_t)conn->rec, (uintptr_t)pool.bpool) / MP_BLOCK;
  MP_free_blks(bindex, nblocks);

  if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
    close(conn->fd);

  MARK_BIT_FREE(*word, conn->cindex);
  memset(conn, 0, sizeof(conn_t));
  conn->fd = -1;
  conn->in_fd = -1;
  conn->out_fd = -1;
  return 0;
}

static inline void MP_clear(conn_t *conn) {
  conn_t *recv_conn = conn->recv_conn;
  conn_t *send_conn = conn->send_conn;
  if (recv_conn)
    MP_free(recv_conn);
  if (send_conn)
    MP_free(send_conn);
}

static inline void MP_exit(MPool *pool) {
  munmap(pool->bpool, pool->npages);
  free(pool->cpool);
  free(pool->blocks);
  free(pool->conns);
  free(pool->freebs);
  free(pool->freecs);
}

static inline void MP_timeout() {
  conn_t *conn;
  int16_t res;
  uint64_t now;
  size_t windex = 0;
  uint64_t *word = &pool.freecs[0];
  for (size_t i = 0; i < MAX_CONNS; i++) {
    if ((i / 64) < windex)
      word = &pool.freecs[++windex];

    if (*word == UINTMAX_MAX) {
      i = (i / 64) * 64 + 64;
      continue;
    }

    conn = pool.conns[i];
    if (!conn || conn->fd == -1)
      continue;

    res = pollevs(conn->fd);

    now = get_time();
    if (res & POLLERR) {
      MP_clear(conn);
      continue;
    }
    if (res & POLLIN) {
      if (pool.rtimeout > 0 && (now - conn->last_read) >= pool.rtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (res & POLLOUT) {
      if (pool.wtimeout > 0 && (now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (!(res & POLLIN || res & POLLOUT)) {
      if ((pool.rtimeout > 0 && now - conn->last_read) >= pool.rtimeout
          || (pool.wtimeout > 0 && now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
  }
}

/*
 * Calculate the length of a status string
 */
static inline size_t status_len(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return 8;
  case STATUSSWITCHINGPROTOCOLS:
    return 19;
  case STATUSPROCESSING:
    return 10;
  case STATUSEARLYHINTS:
    return 11;
  case STATUSOK:
    return 2;
  case STATUSCREATED:
    return 7;
  case STATUSACCEPTED:
    return 8;
  case STATUSNONAUTHORITATIVE:
    return 29;
  case STATUSNOCONTENT:
    return 10;
  case STATUSRESETCONTENT:
    return 13;
  case STATUSPARTIALCONTENT:
    return 15;
  case STATUSMULTISTATUS:
    return 12;
  case STATUSALREADYREPORTED:
    return 16;
  case STATUSIMUSED:
    return 7;
  case STATUSMULTIPLECHOICES:
    return 16;
  case STATUSMOVEDPERMANENTLY:
    return 17;
  case STATUSFOUND:
    return 5;
  case STATUSSEEOTHER:
    return 9;
  case STATUSNOTMODIFIED:
    return 12;
  case STATUSUSEPROXY:
    return 9;
  case STATUSTEMPORARYREDIRECT:
    return 18;
  case STATUSPERMANENTREDIRECT:
    return 18;
  case STATUSBADREQUEST:
    return 11;
  case STATUSUNAUTHORIZED:
    return 12;
  case STATUSPAYMENTREQUIRED:
    return 16;
  case STATUSFORBIDDEN:
    return 9;
  case STATUSNOTFOUND:
    return 9;
  case STATUSMETHODNOTALLOWED:
    return 18;
  case STATUSNOTACCEPTABLE:
    return 14;
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return 29;
  case STATUSREQUESTTIMEOUT:
    return 15;
  case STATUSCONFLICT:
    return 8;
  case STATUSGONE:
    return 4;
  case STATUSLENGTHREQUIRED:
    return 15;
  case STATUSPRECONDITIONFAILED:
    return 19;
  case CONTENTTOOLARGE:
    return 17;
  case STATUSURITOOLONG:
    return 12;
  case STATUSUNSUPPORTEDMEDIATYPE:
    return 22;
  case STATUSRANGENOTSATISFIABLE:
    return 21;
  case STATUSEXPECTATIONFAILED:
    return 18;
  case STATUSMISDIRECTEDREQUEST:
    return 19;
  case STATUSUNPROCESSABLECONTENT:
    return 21;
  case STATUSLOCKED:
    return 6;
  case STATUSFAILEDDEPENDENCY:
    return 17;
  case STATUSTOOEARLY:
    return 9;
  case STATUSUPGRADEREQUIRED:
    return 16;
  case STATUSPRECONDITIONREQUIRED:
    return 21;
  case STATUSTOOMANYREQUESTS:
    return 17;
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return 31;
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return 29;
  case STATUSInternalServerError:
    return 21;
  case STATUSNOTIMPLEMENTED:
    return 15;
  case STATUSBADGATEWAY:
    return 11;
  case STATUSSERVICEUNAVAILABLE:
    return 19;
  case STATUSGATEWAYTIMEOUT:
    return 15;
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return 26;
  case STATUSVARIANTALSONEGOTIATES:
    return 23;
  case STATUSINSUFFICIENTSTORAGE:
    return 20;
  case STATUSLOOPDETECTED:
    return 13;
  case STATUSNOTEXTENDED:
    return 12;
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return 31;
  default:
    return 0;
  }
}

/*
 * Return the status code string as string literal
 */
static inline char *status_str(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return "Continue";
  case STATUSSWITCHINGPROTOCOLS:
    return "Switching Protocols";
  case STATUSPROCESSING:
    return "Processing";
  case STATUSEARLYHINTS:
    return "Early Hints";
  case STATUSOK:
    return "OK";
  case STATUSCREATED:
    return "Created";
  case STATUSACCEPTED:
    return "Accepted";
  case STATUSNONAUTHORITATIVE:
    return "Non-Authoritative Information";
  case STATUSNOCONTENT:
    return "No Content";
  case STATUSRESETCONTENT:
    return "Reset Content";
  case STATUSPARTIALCONTENT:
    return "Partial Content";
  case STATUSMULTISTATUS:
    return "Multi-Status";
  case STATUSALREADYREPORTED:
    return "Already Reported";
  case STATUSIMUSED:
    return "Im Used";
  case STATUSMULTIPLECHOICES:
    return "Multiple Choices";
  case STATUSMOVEDPERMANENTLY:
    return "Moved Permanently";
  case STATUSFOUND:
    return "Found";
  case STATUSSEEOTHER:
    return "See Other";
  case STATUSNOTMODIFIED:
    return "Not Modified";
  case STATUSUSEPROXY:
    return "Use Proxy";
  case STATUSTEMPORARYREDIRECT:
    return "Temporary Redirect";
  case STATUSPERMANENTREDIRECT:
    return "Permanent Redirect";
  case STATUSBADREQUEST:
    return "Bad Request";
  case STATUSUNAUTHORIZED:
    return "Unauthorized";
  case STATUSPAYMENTREQUIRED:
    return "Payment Required";
  case STATUSFORBIDDEN:
    return "Forbidden";
  case STATUSNOTFOUND:
    return "Not Found";
  case STATUSMETHODNOTALLOWED:
    return "Method Not Allowed";
  case STATUSNOTACCEPTABLE:
    return "Not Acceptable";
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return "Proxy Authentication Required";
  case STATUSREQUESTTIMEOUT:
    return "Request Timeout";
  case STATUSCONFLICT:
    return "Conflict";
  case STATUSGONE:
    return "Gone";
  case STATUSLENGTHREQUIRED:
    return "Length Required";
  case STATUSPRECONDITIONFAILED:
    return "Precondition Failed";
  case CONTENTTOOLARGE:
    return "Content Too Large";
  case STATUSURITOOLONG:
    return "URI Too Long";
  case STATUSUNSUPPORTEDMEDIATYPE:
    return "Unsupported Media Type";
  case STATUSRANGENOTSATISFIABLE:
    return "Range Not Satisfiable";
  case STATUSEXPECTATIONFAILED:
    return "Expectation Failed";
  case STATUSMISDIRECTEDREQUEST:
    return "Misdirected Request";
  case STATUSUNPROCESSABLECONTENT:
    return "Unprocessable Content";
  case STATUSLOCKED:
    return "Locked";
  case STATUSFAILEDDEPENDENCY:
    return "Failed Dependency";
  case STATUSTOOEARLY:
    return "Too Early";
  case STATUSUPGRADEREQUIRED:
    return "Upgrade Required";
  case STATUSPRECONDITIONREQUIRED:
    return "Precondition Required";
  case STATUSTOOMANYREQUESTS:
    return "Too Many Requests";
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return "Request Header Fields Too Large";
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return "Unavailable For Legal Reasons";
  case STATUSInternalServerError:
    return "Internal Server Error";
  case STATUSNOTIMPLEMENTED:
    return "Not Implemented";
  case STATUSBADGATEWAY:
    return "Bad Gateway";
  case STATUSSERVICEUNAVAILABLE:
    return "Service Unavailable";
  case STATUSGATEWAYTIMEOUT:
    return "Gateway Timeout";
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return "HTTP Version Not Supported";
  case STATUSVARIANTALSONEGOTIATES:
    return "Variant Also Negotiates";
  case STATUSINSUFFICIENTSTORAGE:
    return "Insufficient Storage";
  case STATUSLOOPDETECTED:
    return "Loop Detected";
  case STATUSNOTEXTENDED:
    return "Not Extended";
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return "Network Authentication Required";
  default:
    return 0;
  }
}

/*
 * Return true if routes match
 */
static inline bool route_equ(Route *route, Request *req) {
  return route->method == req->method && strncmp(route->path, req->path, strlen(route->path)) == 0;
}

/*
 * Return the matching route index on success. -1 on failure
 */
static inline int match_route(Server *serv, Request *req) {
  for (size_t i = 0; i < serv->_nroutes; i++) {
    Route route = serv->routes[i];
    if (!req->path || !route.path)
      continue;
    if (route_equ(&route, req))
      return i;
    else if (req->method == HEAD && route.method == GET && strcmp(route.path, req->path) == 0)
      return i;
  }
  return -1;
}

/*
 * Return true if the response should contain the Content-Length header
 */
static inline bool should_have_content_length(Request *req, ResWriter *res) {
  return (req->method != CONNECT              // CONNECT request
          && res->status != STATUSNOCONTENT   // 204 response
          && res->status != STATUSNOTMODIFIED // 304 response
          && res->status >= 200);             // 1xx response
}

/*
 * Format http response from the ResWriter.
 * Return response size on success, 0 on failure.
 */
static inline size_t fmt_res(Request *req, ResWriter *res, char *buffer, size_t buffer_size) {
  if (!res || !buffer || buffer_size == 0)
    return 0;

  size_t res_len, total = 0;
  char *dst = buffer;
  size_t maxlen = buffer_size;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t body_length = res->len;

  res_len = snprintf(dst, maxlen, "HTTP/1.1 %d %s", (int)res->status, status_str(res->status));
  total += res_len;
  dst += res_len;
  maxlen -= res_len;

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    res_len = snprintf(dst, maxlen, "\r\n%s: %s", header->key, header->value);
    total += res_len;
    dst += res_len;
    maxlen -= res_len;
  }

  if (have_content_length) {
    res_len = snprintf(dst, maxlen, "\r\nContent-Length: %lu", body_length);
    total += res_len, dst += res_len, maxlen -= res_len;
  }

  memcpy(dst, "\r\n\r\n", 4);
  total += 4, dst += 4, maxlen -= 4;

  return total;
}

static inline size_t res_len(Request *req, ResWriter *res) {
  if (!req || !res)
    return 0;

  if (!res->status)
    res->status = STATUSOK;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t result = 0;
  result += STRLEN("HTTP/1.1 ");     // HTTP version
  result += 4;                       // Status code + space
  result += status_len(res->status); // Status name

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    result += 2;                       // "\r\n"
    result += strlen(header->key) + 2; // Header key + ':' + space
    result += strlen(header->value);   // header value
  }

  if (have_content_length) {
    result += 2;                          // "\r\n"
    result += STRLEN("Content-Length: "); // Header key
    result += countd(res->len);           // Header value
  }

  result += 4; // "\r\n\r\n"

  return result;
}

static inline int send_empty_res(Status status) {
  size_t res_len = STRLEN("HTTP/1.1 ")        // HTTP version
                   + countd((uint64_t)status) // status code
                   + 1                        // space
                   + (int)status_len(status)  // status string
                   + 4;                       // \r\n\r\n

  conn_t *conn = current_send;
  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, res_len);
  if (snprintf((char *)rec->iov_base, res_len + 1, "HTTP/1.1 %d %s\r\n\r\n", (int)status, status_str(status))
      != (int)res_len)
    return -1;

  return usendmsg(conn, 0, 1);
}

static inline ssize_t read_socket(int sockfd, size_t len) {
  if (len == 0 || sockfd <= 0)
    return 0;
  char buff[1024 * 8];
  return read(sockfd, buff, 1024 * 8);
}

static inline int read_method(Method *method, void *src) {
  if (memcmp(src, "GET", 3) == 0)
    *method = GET;
  else if (memcmp(src, "POST", 4) == 0)
    *method = POST;
  else if (memcmp(src, "HEAD", 4) == 0)
    *method = HEAD;
  else if (memcmp(src, "PUT", 3) == 0)
    *method = PUT;
  else if (memcmp(src, "DELETE", 6) == 0)
    *method = DELETE;
  else if (memcmp(src, "CONNECT", 7) == 0)
    *method = CONNECT;
  else if (memcmp(src, "OPTIONS", 7) == 0)
    *method = OPTIONS;
  else if (memcmp(src, "TRACE", 5) == 0)
    *method = TRACE;
  else if (memcmp(src, "PATCH", 5) == 0)
    *method = PATCH;
  else
    return -1;

  return 0;
}

static inline int sendmsg_res(Request *req, ResWriter *res) {
  conn_t *conn;
  size_t head_size, res_size;
  struct iovec *iov;

  conn = current_send;
  iov = &conn->ios[0];
  head_size = res_len(req, res);
  if (head_size == 0)
    return -1;

  conn->data_left += head_size;
  res_size = fmt_res(req, res, iov->iov_base, (head_size + 1));
  if (res_size != head_size)
    return -1;
  iov->iov_len = res_size;

  return usendmsg(conn, 0, conn->nios);
}

static inline int read_req(Request *req, char *req_buffer) {
  if (!req_buffer)
    return -1;
  /*** Method ***/
  char *sep = strchr(req_buffer, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }
  *sep = '\0';
  if (read_method(&req->method, req_buffer) < 0)
    return -1;

  /*** Path ***/
  char *fullpath = sep + 1;
  sep = strchr(fullpath, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }

  *sep = '\0';
  req->path = fullpath;
  /*** Params ***/
  char *paramStart = strchr(fullpath, '?');
  if (paramStart) {
    *paramStart++ = '\0';
    int params_count = 0;
    params_count = HK_parse_params(paramStart, req->params, MAX_URL_PARAMETERS);
    if (params_count > 0)
      req->params_count = params_count;
    else
      req->params_count = 0;
  } else {
    req->params = NULL;
    req->params_count = 0;
  }

  /*** Headers ***/
  char *headStart = strstr(sep + 1, "\r\n");
  char *headEnd = strstr(sep + 1, "\r\n\r\n");
  if (!headStart) {
    LOG("read_req: !headStart\n");
    return -1;
  };

  memset(headStart, 0, 2);
  headStart += 2;
  memset(headEnd, 0, 4);
  headEnd += 4;

  int headers_count = HK_parse_headers(headStart, req->headers, MAX_REQ_HEADERS);
  if (headers_count <= 0)
    return -1;
  req->headers_count = headers_count;

  /*** Host ***/
  int index = HK_get_header(req, "Host");
  if (index < 0)
    return -1;
  char *host = req->headers[index].value;
  req->hostname = host;

  /*** Port ***/
  char *colon = strchr(host, ':');
  if (colon) {
    *colon++ = '\0';
    req->port = atoi(colon);
  } else {
    req->port = PORT;
  }
  return 0;
}
static inline int process_req(Server *serv, conn_t *conn) {
  if (!conn || conn->fd == -1)
    return -1;

  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;
  if (read_req(&req, conn->ios[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    LOG("Err: route_index == -1\n");
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;
  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  sendmsg_res(&req, &res);

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int new_conn(int connfd) {
  if (connfd <= 0)
    return -1;

  current_recv = MP_use(KB * 2, connfd, false);
  current_send = MP_use(KB * 2, connfd, false);

  current_recv->recv_conn = current_recv;
  current_recv->send_conn = current_send;

  current_send->send_conn = current_send;
  current_send->recv_conn = current_recv;

  conn_t *conn = current_recv;
  if (ufrecvmsg(conn, 0, 1) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

static inline int resubmit_sendmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return usendmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int resubmir_recvmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    // FIXME the len should be increased
    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return urecvmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int handle_sendmsg_complete(conn_t *conn) {
  struct iovec *iov, *rec;

  MP_shed(conn, 1, conn->nios - 1);
  iov = &conn->ios[0];
  rec = &conn->rec[0];
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;

  return ufrecvmsg(conn->recv_conn, 0, 1);
}

static inline int handle_sendmsg(conn_t *conn, int res, bool zc) {
  if (!conn || conn->fd == -1)
    return -1;

  conn->data_left -= res;
  if (conn->data_left > 0)
    return resubmit_sendmsg(conn, res);

  if (zc)
    return 0;

  return handle_sendmsg_complete(conn);
}

static inline int handle_insplice(conn_t *conn) {
  conn->op = OUTSPLICE;
  return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
}
static inline int handle_outsplice(conn_t *conn, int res) {
  conn->data_left -= res;
  if (conn->data_left > 0) {
    conn->op = INSPLICE;
    return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
  }

  conn_t *recv_conn = conn->recv_conn;
  struct iovec *iov = &recv_conn->ios[0];
  memset(iov->iov_base, 0, iov->iov_len);
  if (urecv(recv_conn, iov->iov_base, iov->iov_len, MSG_PEEK) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

/*
static inline int handle_recv(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  void *bptr = conn->ios[0].iov_base;
  void *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  void *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  return process_req(serv, conn);
}
*/
static inline int find_route(Server *serv, char *bptr) {
  Request req = {0};
  if (read_method(&req.method, bptr) < 0) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  };
  char *space = strchr(bptr, ' ');
  req.path = (space + 1);
  space = strchr(req.path, ' ');
  *space = '\0';
  int route_index = match_route(serv, &req);
  *space = ' ';
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }
  return route_index;
}

static inline int run_handler(Server *serv, conn_t *conn, bool uses_body) {
  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;

  if (read_req(&req, conn->rec[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  if (uses_body) {
    int h_index = HK_get_header(&req, "Content-Length");
    long body_size = atol(req.headers[h_index].value);
    if (body_size >= 0) {
      req.body.ptr = conn->rec[1].iov_base;
      req.body.size = body_size;
    } else {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    }
  }

  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  if (sendmsg_res(&req, &res) < 0)
    return -1;

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int handle_frecvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  char *bptr = (char *)conn->ios[0].iov_base;
  char *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  char *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  size_t head_size = (headEnd + 4) - bptr;
  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  int route_index = find_route(serv, bptr);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  bool uses_body = serv->routes[route_index].uses_body;
  long body_size = get_content_length(headstart + 2, headEnd + 4);
  if (body_size == -1) {
    if (uses_body) {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    } else {
      body_size = 0;
    }
  }

  conn->head_size = head_size;
  if (!uses_body) {
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  if (res == (int)(head_size + body_size)) {
    size_t iov_index = MP_expand(conn, round_to_blocks(body_size), false);
    memcpy(conn->rec[iov_index].iov_base, headEnd + 4, body_size);
    conn->ios[iov_index].iov_len = body_size;
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  conn->data_left = body_size - (res - head_size);
  bool once = ((size_t)body_size > (size_t)((pool.nblocks * MP_BLOCK) / 10));
  size_t iov_index = MP_expand(conn, round_to_blocks(body_size), once);
  memcpy(conn->rec[iov_index].iov_base, headEnd + 4, (res - head_size));
  conn->ios[iov_index].iov_base += (res - head_size);

  return urecvmsg(conn, iov_index, 1);
}

static inline int handle_recvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  if (conn->data_left > 0) {
    conn->data_left -= res;
    if (conn->data_left == 0) {
      conn->flags &= CF_HANDLER_READY;
      return run_handler(serv, conn, true);
    }

    conn->flags &= ~CF_HANDLER_READY;
    conn->ios[1].iov_base += res;
    return urecvmsg(conn, 1, 1);
  }

  conn->flags &= CF_HANDLER_READY;
  return run_handler(serv, conn, true);
}

static inline int serv_init(Server *serv) {
#if DEBUG
  logfd = log_init("log.txt");
  if (!logfd) {
    printf("log_init failed");
    return -1;
  }
#endif
  serv->_nroutes = get_nroutes(serv->routes);

  int pipefd[2];
  if (pipe(pipefd) < 0)
    return -1;
  pipe_in = pipefd[0];
  pipe_out = pipefd[1];
  nullfd = open("/dev/null", O_WRONLY);
  pipe_sz = fcntl(pipefd[0], F_GETPIPE_SZ);
  if (pipe_sz < 0)
    return -1;

  pool.rtimeout = serv->rtimeout;
  pool.wtimeout = serv->wtimeout;
  if (MP_init(MAX_CONNS * 8) < 0)
    return -1;
  LOG("pool initialized\n");

  if (io_uring_queue_init(MAX_CONNS, &ring, 0) < 0)
    return -1;
  LOG("uring initialized\n");

  int listenfd;
  if ((listenfd = tcp_listen(serv->port)) < 0)
    return -1;
  LOG("socket initialized\n");

  return umaccept(listenfd);
}

static inline int serv_listen(Server *serv) {
  // uint64_t last_check = get_time();
  while (true) {
    // uint64_t now = get_time();
    // if ((now - last_check) >= 200) {
    //   last_check = now;
    //   LOG("CM: CM_check ran\n");
    //   MP_timeout();
    // }

    LOG("SQ ready: %u, CQ ready: %u\n", io_uring_sq_ready(&ring), io_uring_cq_ready(&ring));
    struct io_uring_cqe *cqe;
    if (io_uring_wait_cqe(&ring, &cqe) < 0)
      continue;

    int res = cqe->res;
    LOG("res = %d\n", res);
    conn_t *conn = NULL;
    if (cqe->user_data > 100) {
      conn = (conn_t *)cqe->user_data;
      current_recv = (conn_t *)conn->recv_conn;
      current_send = (conn_t *)conn->send_conn;
    }

    if (res > 0) {
      if (cqe->user_data == ACCEPT) {
        LOG("new conn created\n");
        new_conn(res);
      } else if (conn && conn->fd != -1) {
        LOG("conn[%d]: conn.fd = %d; conn.op = %d\n", conn->cindex, conn->fd, conn->op);
        switch (conn->op) {
        case FRECVMSG:
          if (handle_frecvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case RECVMSG:
          if (handle_recvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case SENDMSG:
        case SENDMSGZC:
          // conn->last_write = get_time();
          bool zc = (conn->op == SENDMSGZC);
          if (handle_sendmsg(conn, res, zc) < 0)
            MP_clear(conn);
          break;
        case INSPLICE:
          if (handle_insplice(conn) < 0)
            MP_clear(conn);
          break;
        case OUTSPLICE:
          if (handle_outsplice(conn, res) < 0)
            MP_clear(conn);
          break;
        }
      }
    } else if (res == 0) {
      if (conn && conn->fd != -1) {
        switch (conn->op) {
        case SENDMSGZC:
          conn->zc_notifs--;
          if (conn->zc_notifs == 0 && handle_sendmsg_complete(conn) < 0)
            MP_clear(conn);
          break;
        case RECV:
          MP_clear(conn);
          break;
        }
      }
    } else {
      if (conn && conn->fd != -1) {
        if (res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR) {
          LOG("conn && conn->fd != -1 && res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR\n");
          MP_clear(conn);
        } else {
          LOG("res == -EAGAIN || res == -EWOULDBLOCK || res == -EINTR\n");
          conn = conn->recv_conn;
          struct iovec *iov = &conn->ios[0];
          memset(iov->iov_base, 0, iov->iov_len);
          if (urecv(conn, iov->iov_base, iov->iov_len, 0) < 0)
            MP_clear(conn);
        }
      }
    }

    LOG("uring operation seen\n");
    io_uring_cqe_seen(&ring, cqe);
  }

  io_uring_queue_exit(&ring);
  MP_exit(&pool);
  return 0;
}

/*** Helper ***/
static inline int _HK_write(void *data, size_t size) {
  size_t nblocks;
  int iov_index;
  conn_t *conn;
  struct iovec *iov;
  bool once;

  conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  nblocks = round_to_blocks(size);
  iov_index = MP_expand(conn, nblocks, once);
  iov = &conn->ios[iov_index];

  memcpy(iov->iov_base, data, size);
  iov->iov_len = size;
  conn->data_left += size;

  return 0;
}
static inline int _HK_write_body(Request *req, size_t offset, size_t size) {
  if (size > req->body.size || offset > req->body.size)
    return -1;

  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  int iov_index = MP_expand(conn, 0, false);
  struct iovec *iov = &conn->ios[iov_index];
  struct iovec *rec = &conn->rec[iov_index];
  rec->iov_base = req->body.ptr + offset;
  rec->iov_len = size;
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;
  conn->data_left += rec->iov_len;
  return 0;
}
/*
static inline int _HK_mem(size_t size, HKMem *mem) {
  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  bool once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  size_t nblocks = round_to_blocks(size);
  int iov_index = MP_expand(conn, nblocks, once);
  struct iovec *iov = &conn->ios[iov_index];
  mem->ptr = iov->iov_base;
  mem->size = iov->iov_len;
  mem->_iov_index = iov_index;
  mem->_flags = (IN_POOL(iov->iov_base)) ? CF_IN_POOL : CF_IN_HEAP;
  return 0;
}

static inline void _HK_send(HKMem *mem, size_t size) {
  conn_t *conn = current_send;
  struct iovec *iov = &conn->ios[mem->_iov_index];
  iov->iov_len = size;
  conn->data_left += size;
}
  */
#endif#define _GNU_SOURCE
#ifndef UTILS_H
#define UTILS_H

#include "hunk.h"
#include <arpa/inet.h>
#include <fcntl.h>
#include <liburing.h>
#include <netdb.h>
#include <signal.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/poll.h>
#include <sys/prctl.h>
#include <sys/socket.h>
#include <sys/sysinfo.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

#define MP_BLOCK  4
#define MAX_CONNS 4096
#define KB        1024
#define NIOS      32

#define IN_POOL(ptr)                 ((void *)ptr >= pool.bpool && (void *)ptr <= (pool.bpool + (pool.npages * pool.pagesize)))
#define ALIGN_TO_PAGESIZE(buff_size) (((buff_size) + (pool.pagesize - 1)) & ~(pool.pagesize - 1))
#define BYTES_TO_BLOCKS(buff_size)   (((buff_size) + (MP_BLOCK - 1)) / MP_BLOCK)
#define CEIL_BLOCKS(nblocks)         ((nblocks + 63) & ~63)
#define CEIL_PAGES(size)             (((size) + ((pool.pagesize) - 1)) & ~((pool.pagesize) - 1))

#define BIT_IS_FREE(word, bit)   (((word) >> (bit)) & 1)
#define MARK_BIT_USED(word, bit) ((word) &= ~(1ULL << (bit)))
#define MARK_BIT_FREE(word, bit) ((word) |= (1ULL << (bit)))
#define FIND_FREE_BIT(word)      ((uint64_t)(word) & -(uint64_t)(word))
#define STRLEN(s)                (sizeof(s) - 1)

#define IOVEC_NBLOCKS (BYTES_TO_BLOCKS(NIOS * sizeof(struct iovec)))
#define MSG_NBLOCKS   (BYTES_TO_BLOCKS(sizeof(struct msghdr)))
#define ZC_RES        KB *KB

#define DEBUG 0
#if DEBUG
#define LOG(...) fprintf(logfd, __VA_ARGS__)
#else
#define LOG(...) ((void)0)
#endif

typedef enum UOP {
  WRITEV = IORING_OP_WRITEV,
  SENDMSG = IORING_OP_SENDMSG,
  RECVMSG = IORING_OP_RECVMSG,
  ACCEPT = IORING_OP_ACCEPT,
  SEND = IORING_OP_SEND,
  RECV = IORING_OP_RECV,
  SENDZC = IORING_OP_SEND_ZC,
  SENDMSGZC = IORING_OP_SENDMSG_ZC,
  PEEK = 50,
  FRECVMSG,
  INSPLICE,
  OUTSPLICE
} UOP;

typedef enum CFS {
  CF_IN_POOL = (1 << 0),       // Connection is in the pool
  CF_IN_HEAP = (1 << 1),       // Connection is in the heap
  CF_SKIP_SOCK = (1 << 2),     // Don't close the socket
  CF_USE_ONCE = (1 << 3),      // Destroy after using
  CF_HANDLER_READY = (1 << 4), // Ready to call the handler
} CFS;

typedef struct conn_t {
  // Socket file descriptor
  int fd;

  // Amount of data left in the current operation
  uint64_t data_left;

  // The index of the connection struct
  uint32_t cindex;

  // The last time the connection was readable
  uint64_t last_read;

  // The last time the connection was writeable
  uint64_t last_write;

  // The operation currently being processed
  uint8_t op;

  // Connection flags
  int flags;

  // Splice fd_in
  int in_fd;

  // Splice fd_out
  int out_fd;

  void *recv_conn;
  void *send_conn;

  struct iovec *ios;
  struct iovec *rec;
  uint16_t nios;

  struct msghdr *msg;
  uint16_t zc_notifs;

  uint16_t head_size;
} conn_t;

typedef struct MPool {
  // The allocated pool of blocks
  void *bpool;

  // The allocated pool of connections
  conn_t *cpool;

  // The size of the pool in pages
  uint32_t npages;

  // The size of the pool in blocks
  uint32_t nblocks;

  // The locations of each page in the pool
  void **blocks;

  // The availability of each block
  uint64_t *freebs;

  // The locations of each conn in the pool
  conn_t **conns;

  // The availability of each conn
  uint64_t *freecs;

  // Clean up callback function
  void (*callback)(conn_t *conn);

  // The page size used
  uint32_t pagesize;

  // Socket read timeout
  uint32_t rtimeout;

  // Socket write timeout
  uint32_t wtimeout;
} MPool;

extern int pipe_sz;
extern int pipe_in, pipe_out, nullfd;
extern FILE *logfd;
extern struct io_uring ring;
extern MPool pool;
extern conn_t *current_recv;
extern conn_t *current_send;

/*
 * Prepare and submit a recv uring op
 */
static inline int urecv(conn_t *conn, void *buffer, size_t buff_size, int flags) {
  if (!conn || conn->fd == -1)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (flags == MSG_PEEK) ? PEEK : RECV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;

  io_uring_prep_recv(sqe, conn->fd, buffer, buff_size, flags);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a multi-shot accept uring op
 */
static inline int umaccept(int listenfd) {
  if (listenfd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = ACCEPT;
  io_uring_prep_multishot_accept(sqe, listenfd, NULL, NULL, SOCK_NONBLOCK);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a splice uring op
 */
static inline int usplice(conn_t *conn, int fd_in, int64_t off_in, int fd_out, int64_t off_out, size_t len) {
  if (!len || !conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = (__u64)conn;
  io_uring_prep_splice(sqe, fd_in, off_in, fd_out, off_out, len, 0);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a writev uring op
 */
static inline int uwritev(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = WRITEV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  io_uring_prep_writev(sqe, conn->fd, &conn->ios[iov_index], nios, -1);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a send uring op
 */
static inline int usend(conn_t *conn, char *res_buff, size_t buff_size, bool zc) {
  if (!conn || conn->fd <= 0 || buff_size == 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (zc) ? SENDZC : SEND;
  conn->data_left = buff_size;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  if (zc)
    io_uring_prep_send_zc(sqe, conn->fd, res_buff, buff_size, 0, 0);
  else
    io_uring_prep_send(sqe, conn->fd, res_buff, buff_size, 0);
  return io_uring_submit(&ring);
}

static inline int ufrecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = FRECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;

  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, rec->iov_len);
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int urecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = RECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int usendmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  bool zc = (conn->data_left > ZC_RES) ? true : false;
  conn->op = (zc) ? SENDMSGZC : SENDMSG;

  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  if (zc) {
    io_uring_prep_sendmsg_zc(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
    conn->zc_notifs++;
  } else {
    io_uring_prep_sendmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  }
  return io_uring_submit(&ring);
}

/*
 * Create and initialize a server socket
 */
static inline int tcp_listen(uint16_t port) {
  int enable;
  int listenfd;
  if ((listenfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    return -1;

  int flags = fcntl(listenfd, F_GETFL, 0);
  fcntl(listenfd, F_SETFL, flags | O_NONBLOCK);
  struct sockaddr_in servaddr;
  memset(&servaddr, 0, sizeof(servaddr));
  servaddr.sin_family = AF_INET;
  servaddr.sin_addr.s_addr = INADDR_ANY;
  servaddr.sin_port = htons(port);

  enable = 1;
  if (setsockopt(listenfd, SOL_SOCKET, SO_REUSEPORT, &enable, sizeof(enable)) < 0)
    return -1;

  if (bind(listenfd, (struct sockaddr *)&servaddr, sizeof(servaddr)) < 0)
    return -1;

  if (listen(listenfd, SOMAXCONN) < 0)
    return -1;

  return listenfd;
}

/*
 * Calculate the difference between two pointers
 */
static inline uintptr_t ptr_diff(uintptr_t p1, uintptr_t p2) { return (uintptr_t)(p1 > p2) ? (p1 - p2) : (p2 - p1); }

static inline size_t get_nroutes(Route *routes) {
  Route *route;
  for (size_t i = 0;; i++) {
    route = &routes[i];
    if (!route->path && !route->handler && !route->method)
      return i;
  }
}

static inline long get_content_length(char *src, char *end) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return -1;
    key = line;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, "Content-Length") != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;

    *line_end = '\0';
    long res = atol(value);
    *line_end = '\r';

    return res;
  }
  return -1;
}

static inline bool have_header(char *src, char *end, const char *header_key, const char *header_value) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    key = line;
    while (*key == ' ')
      key++;
    while (*header_key == ' ')
      header_key++;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return false;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, header_key) != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;
    while (*header_value == ' ')
      header_value++;

    *line_end = '\0';
    bool res = (strcasecmp(value, header_value) == 0);
    *line_end = '\r';

    return res;
  }

  return false;
}

static inline const char *method_str(Method method) {
  switch (method) {
  case GET:
    return "GET";
    break;
  case HEAD:
    return "HEAD";
    break;
  case POST:
    return "POST";
    break;
  case PUT:
    return "PUT";
    break;
  case DELETE:
    return "DELETE";
    break;
  case CONNECT:
    return "CONNECT";
    break;
  case OPTIONS:
    return "OPTIONS";
    break;
  case TRACE:
    return "TRACE";
    break;
  case PATCH:
    return "PATCH";
    break;
  default:
    return NULL;
  }
}

static inline uint8_t method_len(Method method) {
  switch (method) {
  case GET:
    return 3;
    break;
  case HEAD:
    return 4;
    break;
  case POST:
    return 4;
    break;
  case PUT:
    return 3;
    break;
  case DELETE:
    return 6;
    break;
  case CONNECT:
    return 7;
    break;
  case OPTIONS:
    return 7;
    break;
  case TRACE:
    return 5;
    break;
  case PATCH:
    return 5;
    break;
  default:
    return 0;
  }
}

static inline size_t round_to_blocks(size_t size) {
  size_t nblocks = BYTES_TO_BLOCKS(size);
  nblocks = CEIL_BLOCKS(nblocks);
  return nblocks;
}

/*
 * Count the digits in unsigned 64-bit int
 */
static inline int countd(uint64_t num) {
  if (num < 10ULL)
    return 1;
  if (num < 100ULL)
    return 2;
  if (num < 1000ULL)
    return 3;
  if (num < 10000ULL)
    return 4;
  if (num < 100000ULL)
    return 5;
  if (num < 1000000ULL)
    return 6;
  if (num < 10000000ULL)
    return 7;
  if (num < 100000000ULL)
    return 8;
  if (num < 1000000000ULL)
    return 9;
  if (num < 10000000000ULL)
    return 10;
  if (num < 100000000000ULL)
    return 11;
  if (num < 1000000000000ULL)
    return 12;
  if (num < 10000000000000ULL)
    return 13;
  if (num < 100000000000000ULL)
    return 14;
  if (num < 1000000000000000ULL)
    return 15;
  if (num < 10000000000000000ULL)
    return 16;
  if (num < 100000000000000000ULL)
    return 17;
  if (num < 1000000000000000000ULL)
    return 18;
  if (num < 10000000000000000000ULL)
    return 19;
  return 20;
}

/*
 * Get the time elabsed in ms
 */
static inline uint64_t get_time() {
  struct timespec ts;
  clock_gettime(CLOCK_MONOTONIC, &ts);
  return (uint64_t)(ts.tv_sec) * 1000 + (ts.tv_nsec / 1000000);
}

static inline FILE *log_init(const char *path) {
  FILE *res = fopen(path, "a+");
  setvbuf(res, NULL, _IONBF, 0);
  return res;
}

static inline int16_t pollevs(int connfd) {
  struct pollfd pfd;
  pfd.fd = connfd;
  pfd.events = POLLIN | POLLOUT | POLLERR;
  int res = poll(&pfd, 1, 0);
  if (res < 0)
    return POLLERR;
  return pfd.revents;
}

// FIXME This needs to be updated
static inline conn_t *MP_use_once(size_t nblocks, int fd) {

  void *mem = malloc(sizeof(conn_t) + 8 + (IOVEC_NBLOCKS * MP_BLOCK));
  struct conn_t *conn = (conn_t *)mem;
  memset(conn, 0, sizeof(conn_t));
  conn->ios = mem + sizeof(conn_t) + 8;

  if (nblocks > 0) {
    struct iovec *iov = &conn->ios[conn->nios++];
    mem = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (mem == MAP_FAILED)
      return NULL;
    iov->iov_base = mem;
    iov->iov_len = ALIGN_TO_PAGESIZE(nblocks * MP_BLOCK);
  }

  conn->flags |= CF_IN_HEAP;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;

  return conn;
}

static inline int find_freec() {
  uint64_t *word;
  size_t map_size = (sizeof(uint64_t) * 8);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    word = &pool.freecs[i / map_size];

    if (*word == 0) { // All used
      i += (map_size - 1);
      continue;
    }

    i += __builtin_ctzll(*word);
    MARK_BIT_USED(*word, i);
    return i;
  }

  return -1;
}

static inline int MP_init(size_t npages) {
  if (!npages)
    return -1;

  /*** Setup ***/
  pool.npages = npages;
  pool.pagesize = sysconf(_SC_PAGESIZE);

  /*** Pool ***/
  pool.bpool = mmap(NULL, pool.npages * pool.pagesize, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  if (pool.bpool == MAP_FAILED)
    return -1;
  pool.nblocks = (pool.npages * pool.pagesize) / MP_BLOCK;

  /*** Blocks ***/
  pool.blocks = malloc(sizeof(void *) * pool.nblocks);
  if (!pool.blocks)
    return -1;
  for (size_t i = 0; i < pool.nblocks; i++)
    pool.blocks[i] = pool.bpool + (i * MP_BLOCK);

  /*** Freebs ***/
  // if (posix_memalign((void **)&pool.freebs, 64, bitmap_size * sizeof(uint64_t)) < 0)
  size_t bitmap_size = (pool.nblocks + 63) / 64;
  pool.freebs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freebs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freebs[i] = UINT64_MAX;

  /*** Cpool ***/
  pool.cpool = (conn_t *)malloc(sizeof(conn_t) * MAX_CONNS);
  if (!pool.cpool)
    return -1;

  /*** Conns ***/
  pool.conns = (conn_t **)malloc(sizeof(conn_t *) * MAX_CONNS);
  if (!pool.conns)
    return -1;
  size_t conn_size = sizeof(conn_t);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    pool.conns[i] = (conn_t *)((char *)pool.cpool + (i * conn_size));
    pool.conns[i]->fd = -1;
    pool.conns[i]->in_fd = -1;
    pool.conns[i]->out_fd = -1;
  }

  /*** Freecs ***/
  bitmap_size = (MAX_CONNS + 63) / 64;
  pool.freecs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freecs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freecs[i] = UINT64_MAX;

  return 0;
}

static inline int MP_use_blks(size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t max_start = pool.nblocks - nblocks;
  size_t full_chunks = (nblocks / 64) * 64;

  for (size_t i = 0, c = 0; i <= max_start; i++, c++) {
    bool free = true;

    for (size_t j = 0; j < full_chunks; j += 64) {
      size_t word_index = (i + j) / 64;
      if (pool.freebs[word_index] != UINT64_MAX) {
        free = false;
        i += 63;
        break;
      }
    }

    for (size_t j = full_chunks; j < nblocks; j++) {
      size_t bit_index = i + j;
      size_t word_index = bit_index / 64;
      size_t bit_in_word = bit_index % 64;

      if (!BIT_IS_FREE(pool.freebs[word_index], bit_in_word)) {
        free = false;
        i += j;
        break;
      }
    }

    if (free) {
      for (size_t j = 0; j < full_chunks; j += 64) {
        size_t word_index = (i + j) / 64;
        pool.freebs[word_index] = 0;
      }

      for (size_t j = full_chunks; j < nblocks; j++) {
        size_t bit_index = i + j;
        size_t word_index = bit_index / 64;
        size_t bit_in_word = bit_index % 64;

        MARK_BIT_USED(pool.freebs[word_index], bit_in_word);
      }

      return i;
    }
  }

  return -1;
}

static inline int MP_free_blks(size_t bindex, size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t full_chunks = (nblocks / 64) * 64;
  for (size_t i = 0; i < full_chunks; i += 64) {
    size_t word_index = (bindex + i) / 64;
    pool.freebs[word_index] = UINT64_MAX;
  }

  for (size_t i = full_chunks; i < nblocks; i++) {
    size_t bit_index = bindex + i;
    size_t word_index = bit_index / 64;
    size_t bit_in_word = bit_index % 64;

    MARK_BIT_FREE(pool.freebs[word_index], bit_in_word);
  }

  memset(pool.blocks[bindex], 0, nblocks * MP_BLOCK);
  return 0;
}

static inline conn_t *MP_use(size_t nblocks, int fd, bool once) {
  if (fd <= 0)
    return NULL;
  if (once)
    return MP_use_once(nblocks, fd);

  int cindex = find_freec();
  if (cindex < 0) {
    LOG("Err: cindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  conn_t *conn = pool.conns[cindex];

  int ios_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (ios_bindex < 0) {
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }

  struct iovec *ios = pool.blocks[ios_bindex];
  conn->ios = ios;

  int rec_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (rec_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct iovec *rec = pool.blocks[rec_bindex];
  conn->rec = rec;

  int msg_bindex = MP_use_blks(MSG_NBLOCKS);
  if (msg_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct msghdr *msg = pool.blocks[msg_bindex];
  conn->msg = msg;

  if (nblocks > 0) {
    int bindex = MP_use_blks(nblocks);
    if (bindex < 0) {
      MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
      MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
      MP_free_blks(msg_bindex, IOVEC_NBLOCKS);
      MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
      LOG("Err: bindex < 0; will use MP_use_once\n");
      return MP_use_once(nblocks, fd);
    }

    size_t iov_index = conn->nios++;
    struct iovec *iov = &conn->ios[iov_index];
    struct iovec *rec = &conn->rec[iov_index];
    iov->iov_base = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
  }

  conn->msg->msg_iov = conn->ios;
  conn->msg->msg_iovlen = conn->nios;
  conn->cindex = cindex;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;
  return conn;
}

static inline void MP_shed(conn_t *conn, size_t iov_index, size_t nios) {
  struct iovec *iov, *rec;
  size_t bindex, nblocks, index;

  for (size_t i = 0; i < nios; i++) {
    index = iov_index + i;
    iov = &conn->ios[index];
    rec = &conn->rec[index];
    if (!rec || !rec->iov_base)
      continue;
    if (!IN_POOL(rec->iov_base)) {
      munmap(rec->iov_base, rec->iov_len / pool.pagesize);
    } else {
      bindex = ptr_diff((uintptr_t)rec->iov_base, (uintptr_t)pool.bpool) / MP_BLOCK;
      nblocks = rec->iov_len / MP_BLOCK;
      MP_free_blks(bindex, nblocks);
    }
    memset(iov, 0, sizeof(struct iovec));
    memset(rec, 0, sizeof(struct iovec));
    conn->nios--;
  }
}

static inline int MP_expand(conn_t *conn, size_t nblocks, bool once) {
  void *bptr;
  int iov_index, bindex;
  struct iovec *iov, *rec;

  iov_index = conn->nios++;
  iov = &conn->ios[iov_index];
  rec = &conn->rec[iov_index];

  if (nblocks == 0)
    return iov_index;

  if (once) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_base = bptr;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
    return iov_index;
  }

  bindex = MP_use_blks(nblocks);
  if (bindex < 0) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_len = iov->iov_len;
  } else {
    bptr = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_len = iov->iov_len;
  }

  iov->iov_base = bptr;
  rec->iov_base = iov->iov_base;
  return iov_index;
}

static inline int MP_free(conn_t *conn) {
  if (!conn)
    return -1;
  size_t bindex, nblocks;
  uint64_t *word;

  MP_shed(conn, 0, conn->nios);
  if (conn->flags & CF_IN_HEAP) {
    if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
      close(conn->fd);
    free(conn);
    return 0;
  }

  word = &pool.freecs[conn->cindex / 64];
  if (conn->cindex > MAX_CONNS)
    return -1;
  else if (BIT_IS_FREE(*word, conn->cindex))
    return 0;

  bindex = ptr_diff((uintptr_t)conn->ios, (uintptr_t)pool.bpool) / MP_BLOCK;
  nblocks = IOVEC_NBLOCKS;
  MP_free_blks(bindex, nblocks);

  bindex = ptr_diff((uintptr_t)conn->rec, (uintptr_t)pool.bpool) / MP_BLOCK;
  MP_free_blks(bindex, nblocks);

  if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
    close(conn->fd);

  MARK_BIT_FREE(*word, conn->cindex);
  memset(conn, 0, sizeof(conn_t));
  conn->fd = -1;
  conn->in_fd = -1;
  conn->out_fd = -1;
  return 0;
}

static inline void MP_clear(conn_t *conn) {
  conn_t *recv_conn = conn->recv_conn;
  conn_t *send_conn = conn->send_conn;
  if (recv_conn)
    MP_free(recv_conn);
  if (send_conn)
    MP_free(send_conn);
}

static inline void MP_exit(MPool *pool) {
  munmap(pool->bpool, pool->npages);
  free(pool->cpool);
  free(pool->blocks);
  free(pool->conns);
  free(pool->freebs);
  free(pool->freecs);
}

static inline void MP_timeout() {
  conn_t *conn;
  int16_t res;
  uint64_t now;
  size_t windex = 0;
  uint64_t *word = &pool.freecs[0];
  for (size_t i = 0; i < MAX_CONNS; i++) {
    if ((i / 64) < windex)
      word = &pool.freecs[++windex];

    if (*word == UINTMAX_MAX) {
      i = (i / 64) * 64 + 64;
      continue;
    }

    conn = pool.conns[i];
    if (!conn || conn->fd == -1)
      continue;

    res = pollevs(conn->fd);

    now = get_time();
    if (res & POLLERR) {
      MP_clear(conn);
      continue;
    }
    if (res & POLLIN) {
      if (pool.rtimeout > 0 && (now - conn->last_read) >= pool.rtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (res & POLLOUT) {
      if (pool.wtimeout > 0 && (now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (!(res & POLLIN || res & POLLOUT)) {
      if ((pool.rtimeout > 0 && now - conn->last_read) >= pool.rtimeout
          || (pool.wtimeout > 0 && now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
  }
}

/*
 * Calculate the length of a status string
 */
static inline size_t status_len(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return 8;
  case STATUSSWITCHINGPROTOCOLS:
    return 19;
  case STATUSPROCESSING:
    return 10;
  case STATUSEARLYHINTS:
    return 11;
  case STATUSOK:
    return 2;
  case STATUSCREATED:
    return 7;
  case STATUSACCEPTED:
    return 8;
  case STATUSNONAUTHORITATIVE:
    return 29;
  case STATUSNOCONTENT:
    return 10;
  case STATUSRESETCONTENT:
    return 13;
  case STATUSPARTIALCONTENT:
    return 15;
  case STATUSMULTISTATUS:
    return 12;
  case STATUSALREADYREPORTED:
    return 16;
  case STATUSIMUSED:
    return 7;
  case STATUSMULTIPLECHOICES:
    return 16;
  case STATUSMOVEDPERMANENTLY:
    return 17;
  case STATUSFOUND:
    return 5;
  case STATUSSEEOTHER:
    return 9;
  case STATUSNOTMODIFIED:
    return 12;
  case STATUSUSEPROXY:
    return 9;
  case STATUSTEMPORARYREDIRECT:
    return 18;
  case STATUSPERMANENTREDIRECT:
    return 18;
  case STATUSBADREQUEST:
    return 11;
  case STATUSUNAUTHORIZED:
    return 12;
  case STATUSPAYMENTREQUIRED:
    return 16;
  case STATUSFORBIDDEN:
    return 9;
  case STATUSNOTFOUND:
    return 9;
  case STATUSMETHODNOTALLOWED:
    return 18;
  case STATUSNOTACCEPTABLE:
    return 14;
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return 29;
  case STATUSREQUESTTIMEOUT:
    return 15;
  case STATUSCONFLICT:
    return 8;
  case STATUSGONE:
    return 4;
  case STATUSLENGTHREQUIRED:
    return 15;
  case STATUSPRECONDITIONFAILED:
    return 19;
  case CONTENTTOOLARGE:
    return 17;
  case STATUSURITOOLONG:
    return 12;
  case STATUSUNSUPPORTEDMEDIATYPE:
    return 22;
  case STATUSRANGENOTSATISFIABLE:
    return 21;
  case STATUSEXPECTATIONFAILED:
    return 18;
  case STATUSMISDIRECTEDREQUEST:
    return 19;
  case STATUSUNPROCESSABLECONTENT:
    return 21;
  case STATUSLOCKED:
    return 6;
  case STATUSFAILEDDEPENDENCY:
    return 17;
  case STATUSTOOEARLY:
    return 9;
  case STATUSUPGRADEREQUIRED:
    return 16;
  case STATUSPRECONDITIONREQUIRED:
    return 21;
  case STATUSTOOMANYREQUESTS:
    return 17;
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return 31;
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return 29;
  case STATUSInternalServerError:
    return 21;
  case STATUSNOTIMPLEMENTED:
    return 15;
  case STATUSBADGATEWAY:
    return 11;
  case STATUSSERVICEUNAVAILABLE:
    return 19;
  case STATUSGATEWAYTIMEOUT:
    return 15;
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return 26;
  case STATUSVARIANTALSONEGOTIATES:
    return 23;
  case STATUSINSUFFICIENTSTORAGE:
    return 20;
  case STATUSLOOPDETECTED:
    return 13;
  case STATUSNOTEXTENDED:
    return 12;
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return 31;
  default:
    return 0;
  }
}

/*
 * Return the status code string as string literal
 */
static inline char *status_str(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return "Continue";
  case STATUSSWITCHINGPROTOCOLS:
    return "Switching Protocols";
  case STATUSPROCESSING:
    return "Processing";
  case STATUSEARLYHINTS:
    return "Early Hints";
  case STATUSOK:
    return "OK";
  case STATUSCREATED:
    return "Created";
  case STATUSACCEPTED:
    return "Accepted";
  case STATUSNONAUTHORITATIVE:
    return "Non-Authoritative Information";
  case STATUSNOCONTENT:
    return "No Content";
  case STATUSRESETCONTENT:
    return "Reset Content";
  case STATUSPARTIALCONTENT:
    return "Partial Content";
  case STATUSMULTISTATUS:
    return "Multi-Status";
  case STATUSALREADYREPORTED:
    return "Already Reported";
  case STATUSIMUSED:
    return "Im Used";
  case STATUSMULTIPLECHOICES:
    return "Multiple Choices";
  case STATUSMOVEDPERMANENTLY:
    return "Moved Permanently";
  case STATUSFOUND:
    return "Found";
  case STATUSSEEOTHER:
    return "See Other";
  case STATUSNOTMODIFIED:
    return "Not Modified";
  case STATUSUSEPROXY:
    return "Use Proxy";
  case STATUSTEMPORARYREDIRECT:
    return "Temporary Redirect";
  case STATUSPERMANENTREDIRECT:
    return "Permanent Redirect";
  case STATUSBADREQUEST:
    return "Bad Request";
  case STATUSUNAUTHORIZED:
    return "Unauthorized";
  case STATUSPAYMENTREQUIRED:
    return "Payment Required";
  case STATUSFORBIDDEN:
    return "Forbidden";
  case STATUSNOTFOUND:
    return "Not Found";
  case STATUSMETHODNOTALLOWED:
    return "Method Not Allowed";
  case STATUSNOTACCEPTABLE:
    return "Not Acceptable";
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return "Proxy Authentication Required";
  case STATUSREQUESTTIMEOUT:
    return "Request Timeout";
  case STATUSCONFLICT:
    return "Conflict";
  case STATUSGONE:
    return "Gone";
  case STATUSLENGTHREQUIRED:
    return "Length Required";
  case STATUSPRECONDITIONFAILED:
    return "Precondition Failed";
  case CONTENTTOOLARGE:
    return "Content Too Large";
  case STATUSURITOOLONG:
    return "URI Too Long";
  case STATUSUNSUPPORTEDMEDIATYPE:
    return "Unsupported Media Type";
  case STATUSRANGENOTSATISFIABLE:
    return "Range Not Satisfiable";
  case STATUSEXPECTATIONFAILED:
    return "Expectation Failed";
  case STATUSMISDIRECTEDREQUEST:
    return "Misdirected Request";
  case STATUSUNPROCESSABLECONTENT:
    return "Unprocessable Content";
  case STATUSLOCKED:
    return "Locked";
  case STATUSFAILEDDEPENDENCY:
    return "Failed Dependency";
  case STATUSTOOEARLY:
    return "Too Early";
  case STATUSUPGRADEREQUIRED:
    return "Upgrade Required";
  case STATUSPRECONDITIONREQUIRED:
    return "Precondition Required";
  case STATUSTOOMANYREQUESTS:
    return "Too Many Requests";
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return "Request Header Fields Too Large";
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return "Unavailable For Legal Reasons";
  case STATUSInternalServerError:
    return "Internal Server Error";
  case STATUSNOTIMPLEMENTED:
    return "Not Implemented";
  case STATUSBADGATEWAY:
    return "Bad Gateway";
  case STATUSSERVICEUNAVAILABLE:
    return "Service Unavailable";
  case STATUSGATEWAYTIMEOUT:
    return "Gateway Timeout";
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return "HTTP Version Not Supported";
  case STATUSVARIANTALSONEGOTIATES:
    return "Variant Also Negotiates";
  case STATUSINSUFFICIENTSTORAGE:
    return "Insufficient Storage";
  case STATUSLOOPDETECTED:
    return "Loop Detected";
  case STATUSNOTEXTENDED:
    return "Not Extended";
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return "Network Authentication Required";
  default:
    return 0;
  }
}

/*
 * Return true if routes match
 */
static inline bool route_equ(Route *route, Request *req) {
  return route->method == req->method && strncmp(route->path, req->path, strlen(route->path)) == 0;
}

/*
 * Return the matching route index on success. -1 on failure
 */
static inline int match_route(Server *serv, Request *req) {
  for (size_t i = 0; i < serv->_nroutes; i++) {
    Route route = serv->routes[i];
    if (!req->path || !route.path)
      continue;
    if (route_equ(&route, req))
      return i;
    else if (req->method == HEAD && route.method == GET && strcmp(route.path, req->path) == 0)
      return i;
  }
  return -1;
}

/*
 * Return true if the response should contain the Content-Length header
 */
static inline bool should_have_content_length(Request *req, ResWriter *res) {
  return (req->method != CONNECT              // CONNECT request
          && res->status != STATUSNOCONTENT   // 204 response
          && res->status != STATUSNOTMODIFIED // 304 response
          && res->status >= 200);             // 1xx response
}

/*
 * Format http response from the ResWriter.
 * Return response size on success, 0 on failure.
 */
static inline size_t fmt_res(Request *req, ResWriter *res, char *buffer, size_t buffer_size) {
  if (!res || !buffer || buffer_size == 0)
    return 0;

  size_t res_len, total = 0;
  char *dst = buffer;
  size_t maxlen = buffer_size;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t body_length = res->len;

  res_len = snprintf(dst, maxlen, "HTTP/1.1 %d %s", (int)res->status, status_str(res->status));
  total += res_len;
  dst += res_len;
  maxlen -= res_len;

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    res_len = snprintf(dst, maxlen, "\r\n%s: %s", header->key, header->value);
    total += res_len;
    dst += res_len;
    maxlen -= res_len;
  }

  if (have_content_length) {
    res_len = snprintf(dst, maxlen, "\r\nContent-Length: %lu", body_length);
    total += res_len, dst += res_len, maxlen -= res_len;
  }

  memcpy(dst, "\r\n\r\n", 4);
  total += 4, dst += 4, maxlen -= 4;

  return total;
}

static inline size_t res_len(Request *req, ResWriter *res) {
  if (!req || !res)
    return 0;

  if (!res->status)
    res->status = STATUSOK;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t result = 0;
  result += STRLEN("HTTP/1.1 ");     // HTTP version
  result += 4;                       // Status code + space
  result += status_len(res->status); // Status name

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    result += 2;                       // "\r\n"
    result += strlen(header->key) + 2; // Header key + ':' + space
    result += strlen(header->value);   // header value
  }

  if (have_content_length) {
    result += 2;                          // "\r\n"
    result += STRLEN("Content-Length: "); // Header key
    result += countd(res->len);           // Header value
  }

  result += 4; // "\r\n\r\n"

  return result;
}

static inline int send_empty_res(Status status) {
  size_t res_len = STRLEN("HTTP/1.1 ")        // HTTP version
                   + countd((uint64_t)status) // status code
                   + 1                        // space
                   + (int)status_len(status)  // status string
                   + 4;                       // \r\n\r\n

  conn_t *conn = current_send;
  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, res_len);
  if (snprintf((char *)rec->iov_base, res_len + 1, "HTTP/1.1 %d %s\r\n\r\n", (int)status, status_str(status))
      != (int)res_len)
    return -1;

  return usendmsg(conn, 0, 1);
}

static inline ssize_t read_socket(int sockfd, size_t len) {
  if (len == 0 || sockfd <= 0)
    return 0;
  char buff[1024 * 8];
  return read(sockfd, buff, 1024 * 8);
}

static inline int read_method(Method *method, void *src) {
  if (memcmp(src, "GET", 3) == 0)
    *method = GET;
  else if (memcmp(src, "POST", 4) == 0)
    *method = POST;
  else if (memcmp(src, "HEAD", 4) == 0)
    *method = HEAD;
  else if (memcmp(src, "PUT", 3) == 0)
    *method = PUT;
  else if (memcmp(src, "DELETE", 6) == 0)
    *method = DELETE;
  else if (memcmp(src, "CONNECT", 7) == 0)
    *method = CONNECT;
  else if (memcmp(src, "OPTIONS", 7) == 0)
    *method = OPTIONS;
  else if (memcmp(src, "TRACE", 5) == 0)
    *method = TRACE;
  else if (memcmp(src, "PATCH", 5) == 0)
    *method = PATCH;
  else
    return -1;

  return 0;
}

static inline int sendmsg_res(Request *req, ResWriter *res) {
  conn_t *conn;
  size_t head_size, res_size;
  struct iovec *iov;

  conn = current_send;
  iov = &conn->ios[0];
  head_size = res_len(req, res);
  if (head_size == 0)
    return -1;

  conn->data_left += head_size;
  res_size = fmt_res(req, res, iov->iov_base, (head_size + 1));
  if (res_size != head_size)
    return -1;
  iov->iov_len = res_size;

  return usendmsg(conn, 0, conn->nios);
}

static inline int read_req(Request *req, char *req_buffer) {
  if (!req_buffer)
    return -1;
  /*** Method ***/
  char *sep = strchr(req_buffer, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }
  *sep = '\0';
  if (read_method(&req->method, req_buffer) < 0)
    return -1;

  /*** Path ***/
  char *fullpath = sep + 1;
  sep = strchr(fullpath, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }

  *sep = '\0';
  req->path = fullpath;
  /*** Params ***/
  char *paramStart = strchr(fullpath, '?');
  if (paramStart) {
    *paramStart++ = '\0';
    int params_count = 0;
    params_count = HK_parse_params(paramStart, req->params, MAX_URL_PARAMETERS);
    if (params_count > 0)
      req->params_count = params_count;
    else
      req->params_count = 0;
  } else {
    req->params = NULL;
    req->params_count = 0;
  }

  /*** Headers ***/
  char *headStart = strstr(sep + 1, "\r\n");
  char *headEnd = strstr(sep + 1, "\r\n\r\n");
  if (!headStart) {
    LOG("read_req: !headStart\n");
    return -1;
  };

  memset(headStart, 0, 2);
  headStart += 2;
  memset(headEnd, 0, 4);
  headEnd += 4;

  int headers_count = HK_parse_headers(headStart, req->headers, MAX_REQ_HEADERS);
  if (headers_count <= 0)
    return -1;
  req->headers_count = headers_count;

  /*** Host ***/
  int index = HK_get_header(req, "Host");
  if (index < 0)
    return -1;
  char *host = req->headers[index].value;
  req->hostname = host;

  /*** Port ***/
  char *colon = strchr(host, ':');
  if (colon) {
    *colon++ = '\0';
    req->port = atoi(colon);
  } else {
    req->port = PORT;
  }
  return 0;
}
static inline int process_req(Server *serv, conn_t *conn) {
  if (!conn || conn->fd == -1)
    return -1;

  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;
  if (read_req(&req, conn->ios[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    LOG("Err: route_index == -1\n");
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;
  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  sendmsg_res(&req, &res);

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int new_conn(int connfd) {
  if (connfd <= 0)
    return -1;

  current_recv = MP_use(KB * 2, connfd, false);
  current_send = MP_use(KB * 2, connfd, false);

  current_recv->recv_conn = current_recv;
  current_recv->send_conn = current_send;

  current_send->send_conn = current_send;
  current_send->recv_conn = current_recv;

  conn_t *conn = current_recv;
  if (ufrecvmsg(conn, 0, 1) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

static inline int resubmit_sendmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return usendmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int resubmir_recvmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    // FIXME the len should be increased
    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return urecvmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int handle_sendmsg_complete(conn_t *conn) {
  struct iovec *iov, *rec;

  MP_shed(conn, 1, conn->nios - 1);
  iov = &conn->ios[0];
  rec = &conn->rec[0];
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;

  return ufrecvmsg(conn->recv_conn, 0, 1);
}

static inline int handle_sendmsg(conn_t *conn, int res, bool zc) {
  if (!conn || conn->fd == -1)
    return -1;

  conn->data_left -= res;
  if (conn->data_left > 0)
    return resubmit_sendmsg(conn, res);

  if (zc)
    return 0;

  return handle_sendmsg_complete(conn);
}

static inline int handle_insplice(conn_t *conn) {
  conn->op = OUTSPLICE;
  return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
}
static inline int handle_outsplice(conn_t *conn, int res) {
  conn->data_left -= res;
  if (conn->data_left > 0) {
    conn->op = INSPLICE;
    return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
  }

  conn_t *recv_conn = conn->recv_conn;
  struct iovec *iov = &recv_conn->ios[0];
  memset(iov->iov_base, 0, iov->iov_len);
  if (urecv(recv_conn, iov->iov_base, iov->iov_len, MSG_PEEK) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

/*
static inline int handle_recv(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  void *bptr = conn->ios[0].iov_base;
  void *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  void *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  return process_req(serv, conn);
}
*/
static inline int find_route(Server *serv, char *bptr) {
  Request req = {0};
  if (read_method(&req.method, bptr) < 0) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  };
  char *space = strchr(bptr, ' ');
  req.path = (space + 1);
  space = strchr(req.path, ' ');
  *space = '\0';
  int route_index = match_route(serv, &req);
  *space = ' ';
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }
  return route_index;
}

static inline int run_handler(Server *serv, conn_t *conn, bool uses_body) {
  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;

  if (read_req(&req, conn->rec[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  if (uses_body) {
    int h_index = HK_get_header(&req, "Content-Length");
    long body_size = atol(req.headers[h_index].value);
    if (body_size >= 0) {
      req.body.ptr = conn->rec[1].iov_base;
      req.body.size = body_size;
    } else {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    }
  }

  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  if (sendmsg_res(&req, &res) < 0)
    return -1;

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int handle_frecvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  char *bptr = (char *)conn->ios[0].iov_base;
  char *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  char *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  size_t head_size = (headEnd + 4) - bptr;
  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  int route_index = find_route(serv, bptr);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  bool uses_body = serv->routes[route_index].uses_body;
  long body_size = get_content_length(headstart + 2, headEnd + 4);
  if (body_size == -1) {
    if (uses_body) {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    } else {
      body_size = 0;
    }
  }

  conn->head_size = head_size;
  if (!uses_body) {
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  if (res == (int)(head_size + body_size)) {
    size_t iov_index = MP_expand(conn, round_to_blocks(body_size), false);
    memcpy(conn->rec[iov_index].iov_base, headEnd + 4, body_size);
    conn->ios[iov_index].iov_len = body_size;
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  conn->data_left = body_size - (res - head_size);
  bool once = ((size_t)body_size > (size_t)((pool.nblocks * MP_BLOCK) / 10));
  size_t iov_index = MP_expand(conn, round_to_blocks(body_size), once);
  memcpy(conn->rec[iov_index].iov_base, headEnd + 4, (res - head_size));
  conn->ios[iov_index].iov_base += (res - head_size);

  return urecvmsg(conn, iov_index, 1);
}

static inline int handle_recvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  if (conn->data_left > 0) {
    conn->data_left -= res;
    if (conn->data_left == 0) {
      conn->flags &= CF_HANDLER_READY;
      return run_handler(serv, conn, true);
    }

    conn->flags &= ~CF_HANDLER_READY;
    conn->ios[1].iov_base += res;
    return urecvmsg(conn, 1, 1);
  }

  conn->flags &= CF_HANDLER_READY;
  return run_handler(serv, conn, true);
}

static inline int serv_init(Server *serv) {
#if DEBUG
  logfd = log_init("log.txt");
  if (!logfd) {
    printf("log_init failed");
    return -1;
  }
#endif
  serv->_nroutes = get_nroutes(serv->routes);

  int pipefd[2];
  if (pipe(pipefd) < 0)
    return -1;
  pipe_in = pipefd[0];
  pipe_out = pipefd[1];
  nullfd = open("/dev/null", O_WRONLY);
  pipe_sz = fcntl(pipefd[0], F_GETPIPE_SZ);
  if (pipe_sz < 0)
    return -1;

  pool.rtimeout = serv->rtimeout;
  pool.wtimeout = serv->wtimeout;
  if (MP_init(MAX_CONNS * 8) < 0)
    return -1;
  LOG("pool initialized\n");

  if (io_uring_queue_init(MAX_CONNS, &ring, 0) < 0)
    return -1;
  LOG("uring initialized\n");

  int listenfd;
  if ((listenfd = tcp_listen(serv->port)) < 0)
    return -1;
  LOG("socket initialized\n");

  return umaccept(listenfd);
}

static inline int serv_listen(Server *serv) {
  // uint64_t last_check = get_time();
  while (true) {
    // uint64_t now = get_time();
    // if ((now - last_check) >= 200) {
    //   last_check = now;
    //   LOG("CM: CM_check ran\n");
    //   MP_timeout();
    // }

    LOG("SQ ready: %u, CQ ready: %u\n", io_uring_sq_ready(&ring), io_uring_cq_ready(&ring));
    struct io_uring_cqe *cqe;
    if (io_uring_wait_cqe(&ring, &cqe) < 0)
      continue;

    int res = cqe->res;
    LOG("res = %d\n", res);
    conn_t *conn = NULL;
    if (cqe->user_data > 100) {
      conn = (conn_t *)cqe->user_data;
      current_recv = (conn_t *)conn->recv_conn;
      current_send = (conn_t *)conn->send_conn;
    }

    if (res > 0) {
      if (cqe->user_data == ACCEPT) {
        LOG("new conn created\n");
        new_conn(res);
      } else if (conn && conn->fd != -1) {
        LOG("conn[%d]: conn.fd = %d; conn.op = %d\n", conn->cindex, conn->fd, conn->op);
        switch (conn->op) {
        case FRECVMSG:
          if (handle_frecvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case RECVMSG:
          if (handle_recvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case SENDMSG:
        case SENDMSGZC:
          // conn->last_write = get_time();
          bool zc = (conn->op == SENDMSGZC);
          if (handle_sendmsg(conn, res, zc) < 0)
            MP_clear(conn);
          break;
        case INSPLICE:
          if (handle_insplice(conn) < 0)
            MP_clear(conn);
          break;
        case OUTSPLICE:
          if (handle_outsplice(conn, res) < 0)
            MP_clear(conn);
          break;
        }
      }
    } else if (res == 0) {
      if (conn && conn->fd != -1) {
        switch (conn->op) {
        case SENDMSGZC:
          conn->zc_notifs--;
          if (conn->zc_notifs == 0 && handle_sendmsg_complete(conn) < 0)
            MP_clear(conn);
          break;
        case RECV:
          MP_clear(conn);
          break;
        }
      }
    } else {
      if (conn && conn->fd != -1) {
        if (res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR) {
          LOG("conn && conn->fd != -1 && res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR\n");
          MP_clear(conn);
        } else {
          LOG("res == -EAGAIN || res == -EWOULDBLOCK || res == -EINTR\n");
          conn = conn->recv_conn;
          struct iovec *iov = &conn->ios[0];
          memset(iov->iov_base, 0, iov->iov_len);
          if (urecv(conn, iov->iov_base, iov->iov_len, 0) < 0)
            MP_clear(conn);
        }
      }
    }

    LOG("uring operation seen\n");
    io_uring_cqe_seen(&ring, cqe);
  }

  io_uring_queue_exit(&ring);
  MP_exit(&pool);
  return 0;
}

/*** Helper ***/
static inline int _HK_write(void *data, size_t size) {
  size_t nblocks;
  int iov_index;
  conn_t *conn;
  struct iovec *iov;
  bool once;

  conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  nblocks = round_to_blocks(size);
  iov_index = MP_expand(conn, nblocks, once);
  iov = &conn->ios[iov_index];

  memcpy(iov->iov_base, data, size);
  iov->iov_len = size;
  conn->data_left += size;

  return 0;
}
static inline int _HK_write_body(Request *req, size_t offset, size_t size) {
  if (size > req->body.size || offset > req->body.size)
    return -1;

  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  int iov_index = MP_expand(conn, 0, false);
  struct iovec *iov = &conn->ios[iov_index];
  struct iovec *rec = &conn->rec[iov_index];
  rec->iov_base = req->body.ptr + offset;
  rec->iov_len = size;
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;
  conn->data_left += rec->iov_len;
  return 0;
}
/*
static inline int _HK_mem(size_t size, HKMem *mem) {
  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  bool once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  size_t nblocks = round_to_blocks(size);
  int iov_index = MP_expand(conn, nblocks, once);
  struct iovec *iov = &conn->ios[iov_index];
  mem->ptr = iov->iov_base;
  mem->size = iov->iov_len;
  mem->_iov_index = iov_index;
  mem->_flags = (IN_POOL(iov->iov_base)) ? CF_IN_POOL : CF_IN_HEAP;
  return 0;
}

static inline void _HK_send(HKMem *mem, size_t size) {
  conn_t *conn = current_send;
  struct iovec *iov = &conn->ios[mem->_iov_index];
  iov->iov_len = size;
  conn->data_left += size;
}
  */
#endif#define _GNU_SOURCE
#ifndef UTILS_H
#define UTILS_H

#include "hunk.h"
#include <arpa/inet.h>
#include <fcntl.h>
#include <liburing.h>
#include <netdb.h>
#include <signal.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/poll.h>
#include <sys/prctl.h>
#include <sys/socket.h>
#include <sys/sysinfo.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

#define MP_BLOCK  4
#define MAX_CONNS 4096
#define KB        1024
#define NIOS      32

#define IN_POOL(ptr)                 ((void *)ptr >= pool.bpool && (void *)ptr <= (pool.bpool + (pool.npages * pool.pagesize)))
#define ALIGN_TO_PAGESIZE(buff_size) (((buff_size) + (pool.pagesize - 1)) & ~(pool.pagesize - 1))
#define BYTES_TO_BLOCKS(buff_size)   (((buff_size) + (MP_BLOCK - 1)) / MP_BLOCK)
#define CEIL_BLOCKS(nblocks)         ((nblocks + 63) & ~63)
#define CEIL_PAGES(size)             (((size) + ((pool.pagesize) - 1)) & ~((pool.pagesize) - 1))

#define BIT_IS_FREE(word, bit)   (((word) >> (bit)) & 1)
#define MARK_BIT_USED(word, bit) ((word) &= ~(1ULL << (bit)))
#define MARK_BIT_FREE(word, bit) ((word) |= (1ULL << (bit)))
#define FIND_FREE_BIT(word)      ((uint64_t)(word) & -(uint64_t)(word))
#define STRLEN(s)                (sizeof(s) - 1)

#define IOVEC_NBLOCKS (BYTES_TO_BLOCKS(NIOS * sizeof(struct iovec)))
#define MSG_NBLOCKS   (BYTES_TO_BLOCKS(sizeof(struct msghdr)))
#define ZC_RES        KB *KB

#define DEBUG 0
#if DEBUG
#define LOG(...) fprintf(logfd, __VA_ARGS__)
#else
#define LOG(...) ((void)0)
#endif

typedef enum UOP {
  WRITEV = IORING_OP_WRITEV,
  SENDMSG = IORING_OP_SENDMSG,
  RECVMSG = IORING_OP_RECVMSG,
  ACCEPT = IORING_OP_ACCEPT,
  SEND = IORING_OP_SEND,
  RECV = IORING_OP_RECV,
  SENDZC = IORING_OP_SEND_ZC,
  SENDMSGZC = IORING_OP_SENDMSG_ZC,
  PEEK = 50,
  FRECVMSG,
  INSPLICE,
  OUTSPLICE
} UOP;

typedef enum CFS {
  CF_IN_POOL = (1 << 0),       // Connection is in the pool
  CF_IN_HEAP = (1 << 1),       // Connection is in the heap
  CF_SKIP_SOCK = (1 << 2),     // Don't close the socket
  CF_USE_ONCE = (1 << 3),      // Destroy after using
  CF_HANDLER_READY = (1 << 4), // Ready to call the handler
} CFS;

typedef struct conn_t {
  // Socket file descriptor
  int fd;

  // Amount of data left in the current operation
  uint64_t data_left;

  // The index of the connection struct
  uint32_t cindex;

  // The last time the connection was readable
  uint64_t last_read;

  // The last time the connection was writeable
  uint64_t last_write;

  // The operation currently being processed
  uint8_t op;

  // Connection flags
  int flags;

  // Splice fd_in
  int in_fd;

  // Splice fd_out
  int out_fd;

  void *recv_conn;
  void *send_conn;

  struct iovec *ios;
  struct iovec *rec;
  uint16_t nios;

  struct msghdr *msg;
  uint16_t zc_notifs;

  uint16_t head_size;
} conn_t;

typedef struct MPool {
  // The allocated pool of blocks
  void *bpool;

  // The allocated pool of connections
  conn_t *cpool;

  // The size of the pool in pages
  uint32_t npages;

  // The size of the pool in blocks
  uint32_t nblocks;

  // The locations of each page in the pool
  void **blocks;

  // The availability of each block
  uint64_t *freebs;

  // The locations of each conn in the pool
  conn_t **conns;

  // The availability of each conn
  uint64_t *freecs;

  // Clean up callback function
  void (*callback)(conn_t *conn);

  // The page size used
  uint32_t pagesize;

  // Socket read timeout
  uint32_t rtimeout;

  // Socket write timeout
  uint32_t wtimeout;
} MPool;

extern int pipe_sz;
extern int pipe_in, pipe_out, nullfd;
extern FILE *logfd;
extern struct io_uring ring;
extern MPool pool;
extern conn_t *current_recv;
extern conn_t *current_send;

/*
 * Prepare and submit a recv uring op
 */
static inline int urecv(conn_t *conn, void *buffer, size_t buff_size, int flags) {
  if (!conn || conn->fd == -1)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (flags == MSG_PEEK) ? PEEK : RECV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;

  io_uring_prep_recv(sqe, conn->fd, buffer, buff_size, flags);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a multi-shot accept uring op
 */
static inline int umaccept(int listenfd) {
  if (listenfd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = ACCEPT;
  io_uring_prep_multishot_accept(sqe, listenfd, NULL, NULL, SOCK_NONBLOCK);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a splice uring op
 */
static inline int usplice(conn_t *conn, int fd_in, int64_t off_in, int fd_out, int64_t off_out, size_t len) {
  if (!len || !conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = (__u64)conn;
  io_uring_prep_splice(sqe, fd_in, off_in, fd_out, off_out, len, 0);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a writev uring op
 */
static inline int uwritev(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = WRITEV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  io_uring_prep_writev(sqe, conn->fd, &conn->ios[iov_index], nios, -1);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a send uring op
 */
static inline int usend(conn_t *conn, char *res_buff, size_t buff_size, bool zc) {
  if (!conn || conn->fd <= 0 || buff_size == 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (zc) ? SENDZC : SEND;
  conn->data_left = buff_size;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  if (zc)
    io_uring_prep_send_zc(sqe, conn->fd, res_buff, buff_size, 0, 0);
  else
    io_uring_prep_send(sqe, conn->fd, res_buff, buff_size, 0);
  return io_uring_submit(&ring);
}

static inline int ufrecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = FRECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;

  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, rec->iov_len);
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int urecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = RECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int usendmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  bool zc = (conn->data_left > ZC_RES) ? true : false;
  conn->op = (zc) ? SENDMSGZC : SENDMSG;

  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  if (zc) {
    io_uring_prep_sendmsg_zc(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
    conn->zc_notifs++;
  } else {
    io_uring_prep_sendmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  }
  return io_uring_submit(&ring);
}

/*
 * Create and initialize a server socket
 */
static inline int tcp_listen(uint16_t port) {
  int enable;
  int listenfd;
  if ((listenfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    return -1;

  int flags = fcntl(listenfd, F_GETFL, 0);
  fcntl(listenfd, F_SETFL, flags | O_NONBLOCK);
  struct sockaddr_in servaddr;
  memset(&servaddr, 0, sizeof(servaddr));
  servaddr.sin_family = AF_INET;
  servaddr.sin_addr.s_addr = INADDR_ANY;
  servaddr.sin_port = htons(port);

  enable = 1;
  if (setsockopt(listenfd, SOL_SOCKET, SO_REUSEPORT, &enable, sizeof(enable)) < 0)
    return -1;

  if (bind(listenfd, (struct sockaddr *)&servaddr, sizeof(servaddr)) < 0)
    return -1;

  if (listen(listenfd, SOMAXCONN) < 0)
    return -1;

  return listenfd;
}

/*
 * Calculate the difference between two pointers
 */
static inline uintptr_t ptr_diff(uintptr_t p1, uintptr_t p2) { return (uintptr_t)(p1 > p2) ? (p1 - p2) : (p2 - p1); }

static inline size_t get_nroutes(Route *routes) {
  Route *route;
  for (size_t i = 0;; i++) {
    route = &routes[i];
    if (!route->path && !route->handler && !route->method)
      return i;
  }
}

static inline long get_content_length(char *src, char *end) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return -1;
    key = line;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, "Content-Length") != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;

    *line_end = '\0';
    long res = atol(value);
    *line_end = '\r';

    return res;
  }
  return -1;
}

static inline bool have_header(char *src, char *end, const char *header_key, const char *header_value) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    key = line;
    while (*key == ' ')
      key++;
    while (*header_key == ' ')
      header_key++;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return false;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, header_key) != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;
    while (*header_value == ' ')
      header_value++;

    *line_end = '\0';
    bool res = (strcasecmp(value, header_value) == 0);
    *line_end = '\r';

    return res;
  }

  return false;
}

static inline const char *method_str(Method method) {
  switch (method) {
  case GET:
    return "GET";
    break;
  case HEAD:
    return "HEAD";
    break;
  case POST:
    return "POST";
    break;
  case PUT:
    return "PUT";
    break;
  case DELETE:
    return "DELETE";
    break;
  case CONNECT:
    return "CONNECT";
    break;
  case OPTIONS:
    return "OPTIONS";
    break;
  case TRACE:
    return "TRACE";
    break;
  case PATCH:
    return "PATCH";
    break;
  default:
    return NULL;
  }
}

static inline uint8_t method_len(Method method) {
  switch (method) {
  case GET:
    return 3;
    break;
  case HEAD:
    return 4;
    break;
  case POST:
    return 4;
    break;
  case PUT:
    return 3;
    break;
  case DELETE:
    return 6;
    break;
  case CONNECT:
    return 7;
    break;
  case OPTIONS:
    return 7;
    break;
  case TRACE:
    return 5;
    break;
  case PATCH:
    return 5;
    break;
  default:
    return 0;
  }
}

static inline size_t round_to_blocks(size_t size) {
  size_t nblocks = BYTES_TO_BLOCKS(size);
  nblocks = CEIL_BLOCKS(nblocks);
  return nblocks;
}

/*
 * Count the digits in unsigned 64-bit int
 */
static inline int countd(uint64_t num) {
  if (num < 10ULL)
    return 1;
  if (num < 100ULL)
    return 2;
  if (num < 1000ULL)
    return 3;
  if (num < 10000ULL)
    return 4;
  if (num < 100000ULL)
    return 5;
  if (num < 1000000ULL)
    return 6;
  if (num < 10000000ULL)
    return 7;
  if (num < 100000000ULL)
    return 8;
  if (num < 1000000000ULL)
    return 9;
  if (num < 10000000000ULL)
    return 10;
  if (num < 100000000000ULL)
    return 11;
  if (num < 1000000000000ULL)
    return 12;
  if (num < 10000000000000ULL)
    return 13;
  if (num < 100000000000000ULL)
    return 14;
  if (num < 1000000000000000ULL)
    return 15;
  if (num < 10000000000000000ULL)
    return 16;
  if (num < 100000000000000000ULL)
    return 17;
  if (num < 1000000000000000000ULL)
    return 18;
  if (num < 10000000000000000000ULL)
    return 19;
  return 20;
}

/*
 * Get the time elabsed in ms
 */
static inline uint64_t get_time() {
  struct timespec ts;
  clock_gettime(CLOCK_MONOTONIC, &ts);
  return (uint64_t)(ts.tv_sec) * 1000 + (ts.tv_nsec / 1000000);
}

static inline FILE *log_init(const char *path) {
  FILE *res = fopen(path, "a+");
  setvbuf(res, NULL, _IONBF, 0);
  return res;
}

static inline int16_t pollevs(int connfd) {
  struct pollfd pfd;
  pfd.fd = connfd;
  pfd.events = POLLIN | POLLOUT | POLLERR;
  int res = poll(&pfd, 1, 0);
  if (res < 0)
    return POLLERR;
  return pfd.revents;
}

// FIXME This needs to be updated
static inline conn_t *MP_use_once(size_t nblocks, int fd) {

  void *mem = malloc(sizeof(conn_t) + 8 + (IOVEC_NBLOCKS * MP_BLOCK));
  struct conn_t *conn = (conn_t *)mem;
  memset(conn, 0, sizeof(conn_t));
  conn->ios = mem + sizeof(conn_t) + 8;

  if (nblocks > 0) {
    struct iovec *iov = &conn->ios[conn->nios++];
    mem = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (mem == MAP_FAILED)
      return NULL;
    iov->iov_base = mem;
    iov->iov_len = ALIGN_TO_PAGESIZE(nblocks * MP_BLOCK);
  }

  conn->flags |= CF_IN_HEAP;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;

  return conn;
}

static inline int find_freec() {
  uint64_t *word;
  size_t map_size = (sizeof(uint64_t) * 8);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    word = &pool.freecs[i / map_size];

    if (*word == 0) { // All used
      i += (map_size - 1);
      continue;
    }

    i += __builtin_ctzll(*word);
    MARK_BIT_USED(*word, i);
    return i;
  }

  return -1;
}

static inline int MP_init(size_t npages) {
  if (!npages)
    return -1;

  /*** Setup ***/
  pool.npages = npages;
  pool.pagesize = sysconf(_SC_PAGESIZE);

  /*** Pool ***/
  pool.bpool = mmap(NULL, pool.npages * pool.pagesize, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  if (pool.bpool == MAP_FAILED)
    return -1;
  pool.nblocks = (pool.npages * pool.pagesize) / MP_BLOCK;

  /*** Blocks ***/
  pool.blocks = malloc(sizeof(void *) * pool.nblocks);
  if (!pool.blocks)
    return -1;
  for (size_t i = 0; i < pool.nblocks; i++)
    pool.blocks[i] = pool.bpool + (i * MP_BLOCK);

  /*** Freebs ***/
  // if (posix_memalign((void **)&pool.freebs, 64, bitmap_size * sizeof(uint64_t)) < 0)
  size_t bitmap_size = (pool.nblocks + 63) / 64;
  pool.freebs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freebs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freebs[i] = UINT64_MAX;

  /*** Cpool ***/
  pool.cpool = (conn_t *)malloc(sizeof(conn_t) * MAX_CONNS);
  if (!pool.cpool)
    return -1;

  /*** Conns ***/
  pool.conns = (conn_t **)malloc(sizeof(conn_t *) * MAX_CONNS);
  if (!pool.conns)
    return -1;
  size_t conn_size = sizeof(conn_t);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    pool.conns[i] = (conn_t *)((char *)pool.cpool + (i * conn_size));
    pool.conns[i]->fd = -1;
    pool.conns[i]->in_fd = -1;
    pool.conns[i]->out_fd = -1;
  }

  /*** Freecs ***/
  bitmap_size = (MAX_CONNS + 63) / 64;
  pool.freecs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freecs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freecs[i] = UINT64_MAX;

  return 0;
}

static inline int MP_use_blks(size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t max_start = pool.nblocks - nblocks;
  size_t full_chunks = (nblocks / 64) * 64;

  for (size_t i = 0, c = 0; i <= max_start; i++, c++) {
    bool free = true;

    for (size_t j = 0; j < full_chunks; j += 64) {
      size_t word_index = (i + j) / 64;
      if (pool.freebs[word_index] != UINT64_MAX) {
        free = false;
        i += 63;
        break;
      }
    }

    for (size_t j = full_chunks; j < nblocks; j++) {
      size_t bit_index = i + j;
      size_t word_index = bit_index / 64;
      size_t bit_in_word = bit_index % 64;

      if (!BIT_IS_FREE(pool.freebs[word_index], bit_in_word)) {
        free = false;
        i += j;
        break;
      }
    }

    if (free) {
      for (size_t j = 0; j < full_chunks; j += 64) {
        size_t word_index = (i + j) / 64;
        pool.freebs[word_index] = 0;
      }

      for (size_t j = full_chunks; j < nblocks; j++) {
        size_t bit_index = i + j;
        size_t word_index = bit_index / 64;
        size_t bit_in_word = bit_index % 64;

        MARK_BIT_USED(pool.freebs[word_index], bit_in_word);
      }

      return i;
    }
  }

  return -1;
}

static inline int MP_free_blks(size_t bindex, size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t full_chunks = (nblocks / 64) * 64;
  for (size_t i = 0; i < full_chunks; i += 64) {
    size_t word_index = (bindex + i) / 64;
    pool.freebs[word_index] = UINT64_MAX;
  }

  for (size_t i = full_chunks; i < nblocks; i++) {
    size_t bit_index = bindex + i;
    size_t word_index = bit_index / 64;
    size_t bit_in_word = bit_index % 64;

    MARK_BIT_FREE(pool.freebs[word_index], bit_in_word);
  }

  memset(pool.blocks[bindex], 0, nblocks * MP_BLOCK);
  return 0;
}

static inline conn_t *MP_use(size_t nblocks, int fd, bool once) {
  if (fd <= 0)
    return NULL;
  if (once)
    return MP_use_once(nblocks, fd);

  int cindex = find_freec();
  if (cindex < 0) {
    LOG("Err: cindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  conn_t *conn = pool.conns[cindex];

  int ios_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (ios_bindex < 0) {
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }

  struct iovec *ios = pool.blocks[ios_bindex];
  conn->ios = ios;

  int rec_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (rec_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct iovec *rec = pool.blocks[rec_bindex];
  conn->rec = rec;

  int msg_bindex = MP_use_blks(MSG_NBLOCKS);
  if (msg_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct msghdr *msg = pool.blocks[msg_bindex];
  conn->msg = msg;

  if (nblocks > 0) {
    int bindex = MP_use_blks(nblocks);
    if (bindex < 0) {
      MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
      MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
      MP_free_blks(msg_bindex, IOVEC_NBLOCKS);
      MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
      LOG("Err: bindex < 0; will use MP_use_once\n");
      return MP_use_once(nblocks, fd);
    }

    size_t iov_index = conn->nios++;
    struct iovec *iov = &conn->ios[iov_index];
    struct iovec *rec = &conn->rec[iov_index];
    iov->iov_base = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
  }

  conn->msg->msg_iov = conn->ios;
  conn->msg->msg_iovlen = conn->nios;
  conn->cindex = cindex;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;
  return conn;
}

static inline void MP_shed(conn_t *conn, size_t iov_index, size_t nios) {
  struct iovec *iov, *rec;
  size_t bindex, nblocks, index;

  for (size_t i = 0; i < nios; i++) {
    index = iov_index + i;
    iov = &conn->ios[index];
    rec = &conn->rec[index];
    if (!rec || !rec->iov_base)
      continue;
    if (!IN_POOL(rec->iov_base)) {
      munmap(rec->iov_base, rec->iov_len / pool.pagesize);
    } else {
      bindex = ptr_diff((uintptr_t)rec->iov_base, (uintptr_t)pool.bpool) / MP_BLOCK;
      nblocks = rec->iov_len / MP_BLOCK;
      MP_free_blks(bindex, nblocks);
    }
    memset(iov, 0, sizeof(struct iovec));
    memset(rec, 0, sizeof(struct iovec));
    conn->nios--;
  }
}

static inline int MP_expand(conn_t *conn, size_t nblocks, bool once) {
  void *bptr;
  int iov_index, bindex;
  struct iovec *iov, *rec;

  iov_index = conn->nios++;
  iov = &conn->ios[iov_index];
  rec = &conn->rec[iov_index];

  if (nblocks == 0)
    return iov_index;

  if (once) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_base = bptr;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
    return iov_index;
  }

  bindex = MP_use_blks(nblocks);
  if (bindex < 0) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_len = iov->iov_len;
  } else {
    bptr = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_len = iov->iov_len;
  }

  iov->iov_base = bptr;
  rec->iov_base = iov->iov_base;
  return iov_index;
}

static inline int MP_free(conn_t *conn) {
  if (!conn)
    return -1;
  size_t bindex, nblocks;
  uint64_t *word;

  MP_shed(conn, 0, conn->nios);
  if (conn->flags & CF_IN_HEAP) {
    if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
      close(conn->fd);
    free(conn);
    return 0;
  }

  word = &pool.freecs[conn->cindex / 64];
  if (conn->cindex > MAX_CONNS)
    return -1;
  else if (BIT_IS_FREE(*word, conn->cindex))
    return 0;

  bindex = ptr_diff((uintptr_t)conn->ios, (uintptr_t)pool.bpool) / MP_BLOCK;
  nblocks = IOVEC_NBLOCKS;
  MP_free_blks(bindex, nblocks);

  bindex = ptr_diff((uintptr_t)conn->rec, (uintptr_t)pool.bpool) / MP_BLOCK;
  MP_free_blks(bindex, nblocks);

  if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
    close(conn->fd);

  MARK_BIT_FREE(*word, conn->cindex);
  memset(conn, 0, sizeof(conn_t));
  conn->fd = -1;
  conn->in_fd = -1;
  conn->out_fd = -1;
  return 0;
}

static inline void MP_clear(conn_t *conn) {
  conn_t *recv_conn = conn->recv_conn;
  conn_t *send_conn = conn->send_conn;
  if (recv_conn)
    MP_free(recv_conn);
  if (send_conn)
    MP_free(send_conn);
}

static inline void MP_exit(MPool *pool) {
  munmap(pool->bpool, pool->npages);
  free(pool->cpool);
  free(pool->blocks);
  free(pool->conns);
  free(pool->freebs);
  free(pool->freecs);
}

static inline void MP_timeout() {
  conn_t *conn;
  int16_t res;
  uint64_t now;
  size_t windex = 0;
  uint64_t *word = &pool.freecs[0];
  for (size_t i = 0; i < MAX_CONNS; i++) {
    if ((i / 64) < windex)
      word = &pool.freecs[++windex];

    if (*word == UINTMAX_MAX) {
      i = (i / 64) * 64 + 64;
      continue;
    }

    conn = pool.conns[i];
    if (!conn || conn->fd == -1)
      continue;

    res = pollevs(conn->fd);

    now = get_time();
    if (res & POLLERR) {
      MP_clear(conn);
      continue;
    }
    if (res & POLLIN) {
      if (pool.rtimeout > 0 && (now - conn->last_read) >= pool.rtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (res & POLLOUT) {
      if (pool.wtimeout > 0 && (now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (!(res & POLLIN || res & POLLOUT)) {
      if ((pool.rtimeout > 0 && now - conn->last_read) >= pool.rtimeout
          || (pool.wtimeout > 0 && now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
  }
}

/*
 * Calculate the length of a status string
 */
static inline size_t status_len(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return 8;
  case STATUSSWITCHINGPROTOCOLS:
    return 19;
  case STATUSPROCESSING:
    return 10;
  case STATUSEARLYHINTS:
    return 11;
  case STATUSOK:
    return 2;
  case STATUSCREATED:
    return 7;
  case STATUSACCEPTED:
    return 8;
  case STATUSNONAUTHORITATIVE:
    return 29;
  case STATUSNOCONTENT:
    return 10;
  case STATUSRESETCONTENT:
    return 13;
  case STATUSPARTIALCONTENT:
    return 15;
  case STATUSMULTISTATUS:
    return 12;
  case STATUSALREADYREPORTED:
    return 16;
  case STATUSIMUSED:
    return 7;
  case STATUSMULTIPLECHOICES:
    return 16;
  case STATUSMOVEDPERMANENTLY:
    return 17;
  case STATUSFOUND:
    return 5;
  case STATUSSEEOTHER:
    return 9;
  case STATUSNOTMODIFIED:
    return 12;
  case STATUSUSEPROXY:
    return 9;
  case STATUSTEMPORARYREDIRECT:
    return 18;
  case STATUSPERMANENTREDIRECT:
    return 18;
  case STATUSBADREQUEST:
    return 11;
  case STATUSUNAUTHORIZED:
    return 12;
  case STATUSPAYMENTREQUIRED:
    return 16;
  case STATUSFORBIDDEN:
    return 9;
  case STATUSNOTFOUND:
    return 9;
  case STATUSMETHODNOTALLOWED:
    return 18;
  case STATUSNOTACCEPTABLE:
    return 14;
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return 29;
  case STATUSREQUESTTIMEOUT:
    return 15;
  case STATUSCONFLICT:
    return 8;
  case STATUSGONE:
    return 4;
  case STATUSLENGTHREQUIRED:
    return 15;
  case STATUSPRECONDITIONFAILED:
    return 19;
  case CONTENTTOOLARGE:
    return 17;
  case STATUSURITOOLONG:
    return 12;
  case STATUSUNSUPPORTEDMEDIATYPE:
    return 22;
  case STATUSRANGENOTSATISFIABLE:
    return 21;
  case STATUSEXPECTATIONFAILED:
    return 18;
  case STATUSMISDIRECTEDREQUEST:
    return 19;
  case STATUSUNPROCESSABLECONTENT:
    return 21;
  case STATUSLOCKED:
    return 6;
  case STATUSFAILEDDEPENDENCY:
    return 17;
  case STATUSTOOEARLY:
    return 9;
  case STATUSUPGRADEREQUIRED:
    return 16;
  case STATUSPRECONDITIONREQUIRED:
    return 21;
  case STATUSTOOMANYREQUESTS:
    return 17;
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return 31;
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return 29;
  case STATUSInternalServerError:
    return 21;
  case STATUSNOTIMPLEMENTED:
    return 15;
  case STATUSBADGATEWAY:
    return 11;
  case STATUSSERVICEUNAVAILABLE:
    return 19;
  case STATUSGATEWAYTIMEOUT:
    return 15;
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return 26;
  case STATUSVARIANTALSONEGOTIATES:
    return 23;
  case STATUSINSUFFICIENTSTORAGE:
    return 20;
  case STATUSLOOPDETECTED:
    return 13;
  case STATUSNOTEXTENDED:
    return 12;
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return 31;
  default:
    return 0;
  }
}

/*
 * Return the status code string as string literal
 */
static inline char *status_str(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return "Continue";
  case STATUSSWITCHINGPROTOCOLS:
    return "Switching Protocols";
  case STATUSPROCESSING:
    return "Processing";
  case STATUSEARLYHINTS:
    return "Early Hints";
  case STATUSOK:
    return "OK";
  case STATUSCREATED:
    return "Created";
  case STATUSACCEPTED:
    return "Accepted";
  case STATUSNONAUTHORITATIVE:
    return "Non-Authoritative Information";
  case STATUSNOCONTENT:
    return "No Content";
  case STATUSRESETCONTENT:
    return "Reset Content";
  case STATUSPARTIALCONTENT:
    return "Partial Content";
  case STATUSMULTISTATUS:
    return "Multi-Status";
  case STATUSALREADYREPORTED:
    return "Already Reported";
  case STATUSIMUSED:
    return "Im Used";
  case STATUSMULTIPLECHOICES:
    return "Multiple Choices";
  case STATUSMOVEDPERMANENTLY:
    return "Moved Permanently";
  case STATUSFOUND:
    return "Found";
  case STATUSSEEOTHER:
    return "See Other";
  case STATUSNOTMODIFIED:
    return "Not Modified";
  case STATUSUSEPROXY:
    return "Use Proxy";
  case STATUSTEMPORARYREDIRECT:
    return "Temporary Redirect";
  case STATUSPERMANENTREDIRECT:
    return "Permanent Redirect";
  case STATUSBADREQUEST:
    return "Bad Request";
  case STATUSUNAUTHORIZED:
    return "Unauthorized";
  case STATUSPAYMENTREQUIRED:
    return "Payment Required";
  case STATUSFORBIDDEN:
    return "Forbidden";
  case STATUSNOTFOUND:
    return "Not Found";
  case STATUSMETHODNOTALLOWED:
    return "Method Not Allowed";
  case STATUSNOTACCEPTABLE:
    return "Not Acceptable";
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return "Proxy Authentication Required";
  case STATUSREQUESTTIMEOUT:
    return "Request Timeout";
  case STATUSCONFLICT:
    return "Conflict";
  case STATUSGONE:
    return "Gone";
  case STATUSLENGTHREQUIRED:
    return "Length Required";
  case STATUSPRECONDITIONFAILED:
    return "Precondition Failed";
  case CONTENTTOOLARGE:
    return "Content Too Large";
  case STATUSURITOOLONG:
    return "URI Too Long";
  case STATUSUNSUPPORTEDMEDIATYPE:
    return "Unsupported Media Type";
  case STATUSRANGENOTSATISFIABLE:
    return "Range Not Satisfiable";
  case STATUSEXPECTATIONFAILED:
    return "Expectation Failed";
  case STATUSMISDIRECTEDREQUEST:
    return "Misdirected Request";
  case STATUSUNPROCESSABLECONTENT:
    return "Unprocessable Content";
  case STATUSLOCKED:
    return "Locked";
  case STATUSFAILEDDEPENDENCY:
    return "Failed Dependency";
  case STATUSTOOEARLY:
    return "Too Early";
  case STATUSUPGRADEREQUIRED:
    return "Upgrade Required";
  case STATUSPRECONDITIONREQUIRED:
    return "Precondition Required";
  case STATUSTOOMANYREQUESTS:
    return "Too Many Requests";
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return "Request Header Fields Too Large";
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return "Unavailable For Legal Reasons";
  case STATUSInternalServerError:
    return "Internal Server Error";
  case STATUSNOTIMPLEMENTED:
    return "Not Implemented";
  case STATUSBADGATEWAY:
    return "Bad Gateway";
  case STATUSSERVICEUNAVAILABLE:
    return "Service Unavailable";
  case STATUSGATEWAYTIMEOUT:
    return "Gateway Timeout";
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return "HTTP Version Not Supported";
  case STATUSVARIANTALSONEGOTIATES:
    return "Variant Also Negotiates";
  case STATUSINSUFFICIENTSTORAGE:
    return "Insufficient Storage";
  case STATUSLOOPDETECTED:
    return "Loop Detected";
  case STATUSNOTEXTENDED:
    return "Not Extended";
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return "Network Authentication Required";
  default:
    return 0;
  }
}

/*
 * Return true if routes match
 */
static inline bool route_equ(Route *route, Request *req) {
  return route->method == req->method && strncmp(route->path, req->path, strlen(route->path)) == 0;
}

/*
 * Return the matching route index on success. -1 on failure
 */
static inline int match_route(Server *serv, Request *req) {
  for (size_t i = 0; i < serv->_nroutes; i++) {
    Route route = serv->routes[i];
    if (!req->path || !route.path)
      continue;
    if (route_equ(&route, req))
      return i;
    else if (req->method == HEAD && route.method == GET && strcmp(route.path, req->path) == 0)
      return i;
  }
  return -1;
}

/*
 * Return true if the response should contain the Content-Length header
 */
static inline bool should_have_content_length(Request *req, ResWriter *res) {
  return (req->method != CONNECT              // CONNECT request
          && res->status != STATUSNOCONTENT   // 204 response
          && res->status != STATUSNOTMODIFIED // 304 response
          && res->status >= 200);             // 1xx response
}

/*
 * Format http response from the ResWriter.
 * Return response size on success, 0 on failure.
 */
static inline size_t fmt_res(Request *req, ResWriter *res, char *buffer, size_t buffer_size) {
  if (!res || !buffer || buffer_size == 0)
    return 0;

  size_t res_len, total = 0;
  char *dst = buffer;
  size_t maxlen = buffer_size;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t body_length = res->len;

  res_len = snprintf(dst, maxlen, "HTTP/1.1 %d %s", (int)res->status, status_str(res->status));
  total += res_len;
  dst += res_len;
  maxlen -= res_len;

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    res_len = snprintf(dst, maxlen, "\r\n%s: %s", header->key, header->value);
    total += res_len;
    dst += res_len;
    maxlen -= res_len;
  }

  if (have_content_length) {
    res_len = snprintf(dst, maxlen, "\r\nContent-Length: %lu", body_length);
    total += res_len, dst += res_len, maxlen -= res_len;
  }

  memcpy(dst, "\r\n\r\n", 4);
  total += 4, dst += 4, maxlen -= 4;

  return total;
}

static inline size_t res_len(Request *req, ResWriter *res) {
  if (!req || !res)
    return 0;

  if (!res->status)
    res->status = STATUSOK;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t result = 0;
  result += STRLEN("HTTP/1.1 ");     // HTTP version
  result += 4;                       // Status code + space
  result += status_len(res->status); // Status name

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    result += 2;                       // "\r\n"
    result += strlen(header->key) + 2; // Header key + ':' + space
    result += strlen(header->value);   // header value
  }

  if (have_content_length) {
    result += 2;                          // "\r\n"
    result += STRLEN("Content-Length: "); // Header key
    result += countd(res->len);           // Header value
  }

  result += 4; // "\r\n\r\n"

  return result;
}

static inline int send_empty_res(Status status) {
  size_t res_len = STRLEN("HTTP/1.1 ")        // HTTP version
                   + countd((uint64_t)status) // status code
                   + 1                        // space
                   + (int)status_len(status)  // status string
                   + 4;                       // \r\n\r\n

  conn_t *conn = current_send;
  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, res_len);
  if (snprintf((char *)rec->iov_base, res_len + 1, "HTTP/1.1 %d %s\r\n\r\n", (int)status, status_str(status))
      != (int)res_len)
    return -1;

  return usendmsg(conn, 0, 1);
}

static inline ssize_t read_socket(int sockfd, size_t len) {
  if (len == 0 || sockfd <= 0)
    return 0;
  char buff[1024 * 8];
  return read(sockfd, buff, 1024 * 8);
}

static inline int read_method(Method *method, void *src) {
  if (memcmp(src, "GET", 3) == 0)
    *method = GET;
  else if (memcmp(src, "POST", 4) == 0)
    *method = POST;
  else if (memcmp(src, "HEAD", 4) == 0)
    *method = HEAD;
  else if (memcmp(src, "PUT", 3) == 0)
    *method = PUT;
  else if (memcmp(src, "DELETE", 6) == 0)
    *method = DELETE;
  else if (memcmp(src, "CONNECT", 7) == 0)
    *method = CONNECT;
  else if (memcmp(src, "OPTIONS", 7) == 0)
    *method = OPTIONS;
  else if (memcmp(src, "TRACE", 5) == 0)
    *method = TRACE;
  else if (memcmp(src, "PATCH", 5) == 0)
    *method = PATCH;
  else
    return -1;

  return 0;
}

static inline int sendmsg_res(Request *req, ResWriter *res) {
  conn_t *conn;
  size_t head_size, res_size;
  struct iovec *iov;

  conn = current_send;
  iov = &conn->ios[0];
  head_size = res_len(req, res);
  if (head_size == 0)
    return -1;

  conn->data_left += head_size;
  res_size = fmt_res(req, res, iov->iov_base, (head_size + 1));
  if (res_size != head_size)
    return -1;
  iov->iov_len = res_size;

  return usendmsg(conn, 0, conn->nios);
}

static inline int read_req(Request *req, char *req_buffer) {
  if (!req_buffer)
    return -1;
  /*** Method ***/
  char *sep = strchr(req_buffer, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }
  *sep = '\0';
  if (read_method(&req->method, req_buffer) < 0)
    return -1;

  /*** Path ***/
  char *fullpath = sep + 1;
  sep = strchr(fullpath, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }

  *sep = '\0';
  req->path = fullpath;
  /*** Params ***/
  char *paramStart = strchr(fullpath, '?');
  if (paramStart) {
    *paramStart++ = '\0';
    int params_count = 0;
    params_count = HK_parse_params(paramStart, req->params, MAX_URL_PARAMETERS);
    if (params_count > 0)
      req->params_count = params_count;
    else
      req->params_count = 0;
  } else {
    req->params = NULL;
    req->params_count = 0;
  }

  /*** Headers ***/
  char *headStart = strstr(sep + 1, "\r\n");
  char *headEnd = strstr(sep + 1, "\r\n\r\n");
  if (!headStart) {
    LOG("read_req: !headStart\n");
    return -1;
  };

  memset(headStart, 0, 2);
  headStart += 2;
  memset(headEnd, 0, 4);
  headEnd += 4;

  int headers_count = HK_parse_headers(headStart, req->headers, MAX_REQ_HEADERS);
  if (headers_count <= 0)
    return -1;
  req->headers_count = headers_count;

  /*** Host ***/
  int index = HK_get_header(req, "Host");
  if (index < 0)
    return -1;
  char *host = req->headers[index].value;
  req->hostname = host;

  /*** Port ***/
  char *colon = strchr(host, ':');
  if (colon) {
    *colon++ = '\0';
    req->port = atoi(colon);
  } else {
    req->port = PORT;
  }
  return 0;
}
static inline int process_req(Server *serv, conn_t *conn) {
  if (!conn || conn->fd == -1)
    return -1;

  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;
  if (read_req(&req, conn->ios[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    LOG("Err: route_index == -1\n");
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;
  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  sendmsg_res(&req, &res);

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int new_conn(int connfd) {
  if (connfd <= 0)
    return -1;

  current_recv = MP_use(KB * 2, connfd, false);
  current_send = MP_use(KB * 2, connfd, false);

  current_recv->recv_conn = current_recv;
  current_recv->send_conn = current_send;

  current_send->send_conn = current_send;
  current_send->recv_conn = current_recv;

  conn_t *conn = current_recv;
  if (ufrecvmsg(conn, 0, 1) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

static inline int resubmit_sendmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return usendmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int resubmir_recvmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    // FIXME the len should be increased
    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return urecvmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int handle_sendmsg_complete(conn_t *conn) {
  struct iovec *iov, *rec;

  MP_shed(conn, 1, conn->nios - 1);
  iov = &conn->ios[0];
  rec = &conn->rec[0];
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;

  return ufrecvmsg(conn->recv_conn, 0, 1);
}

static inline int handle_sendmsg(conn_t *conn, int res, bool zc) {
  if (!conn || conn->fd == -1)
    return -1;

  conn->data_left -= res;
  if (conn->data_left > 0)
    return resubmit_sendmsg(conn, res);

  if (zc)
    return 0;

  return handle_sendmsg_complete(conn);
}

static inline int handle_insplice(conn_t *conn) {
  conn->op = OUTSPLICE;
  return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
}
static inline int handle_outsplice(conn_t *conn, int res) {
  conn->data_left -= res;
  if (conn->data_left > 0) {
    conn->op = INSPLICE;
    return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
  }

  conn_t *recv_conn = conn->recv_conn;
  struct iovec *iov = &recv_conn->ios[0];
  memset(iov->iov_base, 0, iov->iov_len);
  if (urecv(recv_conn, iov->iov_base, iov->iov_len, MSG_PEEK) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

/*
static inline int handle_recv(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  void *bptr = conn->ios[0].iov_base;
  void *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  void *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  return process_req(serv, conn);
}
*/
static inline int find_route(Server *serv, char *bptr) {
  Request req = {0};
  if (read_method(&req.method, bptr) < 0) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  };
  char *space = strchr(bptr, ' ');
  req.path = (space + 1);
  space = strchr(req.path, ' ');
  *space = '\0';
  int route_index = match_route(serv, &req);
  *space = ' ';
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }
  return route_index;
}

static inline int run_handler(Server *serv, conn_t *conn, bool uses_body) {
  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;

  if (read_req(&req, conn->rec[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  if (uses_body) {
    int h_index = HK_get_header(&req, "Content-Length");
    long body_size = atol(req.headers[h_index].value);
    if (body_size >= 0) {
      req.body.ptr = conn->rec[1].iov_base;
      req.body.size = body_size;
    } else {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    }
  }

  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  if (sendmsg_res(&req, &res) < 0)
    return -1;

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int handle_frecvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  char *bptr = (char *)conn->ios[0].iov_base;
  char *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  char *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  size_t head_size = (headEnd + 4) - bptr;
  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  int route_index = find_route(serv, bptr);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  bool uses_body = serv->routes[route_index].uses_body;
  long body_size = get_content_length(headstart + 2, headEnd + 4);
  if (body_size == -1) {
    if (uses_body) {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    } else {
      body_size = 0;
    }
  }

  conn->head_size = head_size;
  if (!uses_body) {
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  if (res == (int)(head_size + body_size)) {
    size_t iov_index = MP_expand(conn, round_to_blocks(body_size), false);
    memcpy(conn->rec[iov_index].iov_base, headEnd + 4, body_size);
    conn->ios[iov_index].iov_len = body_size;
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  conn->data_left = body_size - (res - head_size);
  bool once = ((size_t)body_size > (size_t)((pool.nblocks * MP_BLOCK) / 10));
  size_t iov_index = MP_expand(conn, round_to_blocks(body_size), once);
  memcpy(conn->rec[iov_index].iov_base, headEnd + 4, (res - head_size));
  conn->ios[iov_index].iov_base += (res - head_size);

  return urecvmsg(conn, iov_index, 1);
}

static inline int handle_recvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  if (conn->data_left > 0) {
    conn->data_left -= res;
    if (conn->data_left == 0) {
      conn->flags &= CF_HANDLER_READY;
      return run_handler(serv, conn, true);
    }

    conn->flags &= ~CF_HANDLER_READY;
    conn->ios[1].iov_base += res;
    return urecvmsg(conn, 1, 1);
  }

  conn->flags &= CF_HANDLER_READY;
  return run_handler(serv, conn, true);
}

static inline int serv_init(Server *serv) {
#if DEBUG
  logfd = log_init("log.txt");
  if (!logfd) {
    printf("log_init failed");
    return -1;
  }
#endif
  serv->_nroutes = get_nroutes(serv->routes);

  int pipefd[2];
  if (pipe(pipefd) < 0)
    return -1;
  pipe_in = pipefd[0];
  pipe_out = pipefd[1];
  nullfd = open("/dev/null", O_WRONLY);
  pipe_sz = fcntl(pipefd[0], F_GETPIPE_SZ);
  if (pipe_sz < 0)
    return -1;

  pool.rtimeout = serv->rtimeout;
  pool.wtimeout = serv->wtimeout;
  if (MP_init(MAX_CONNS * 8) < 0)
    return -1;
  LOG("pool initialized\n");

  if (io_uring_queue_init(MAX_CONNS, &ring, 0) < 0)
    return -1;
  LOG("uring initialized\n");

  int listenfd;
  if ((listenfd = tcp_listen(serv->port)) < 0)
    return -1;
  LOG("socket initialized\n");

  return umaccept(listenfd);
}

static inline int serv_listen(Server *serv) {
  // uint64_t last_check = get_time();
  while (true) {
    // uint64_t now = get_time();
    // if ((now - last_check) >= 200) {
    //   last_check = now;
    //   LOG("CM: CM_check ran\n");
    //   MP_timeout();
    // }

    LOG("SQ ready: %u, CQ ready: %u\n", io_uring_sq_ready(&ring), io_uring_cq_ready(&ring));
    struct io_uring_cqe *cqe;
    if (io_uring_wait_cqe(&ring, &cqe) < 0)
      continue;

    int res = cqe->res;
    LOG("res = %d\n", res);
    conn_t *conn = NULL;
    if (cqe->user_data > 100) {
      conn = (conn_t *)cqe->user_data;
      current_recv = (conn_t *)conn->recv_conn;
      current_send = (conn_t *)conn->send_conn;
    }

    if (res > 0) {
      if (cqe->user_data == ACCEPT) {
        LOG("new conn created\n");
        new_conn(res);
      } else if (conn && conn->fd != -1) {
        LOG("conn[%d]: conn.fd = %d; conn.op = %d\n", conn->cindex, conn->fd, conn->op);
        switch (conn->op) {
        case FRECVMSG:
          if (handle_frecvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case RECVMSG:
          if (handle_recvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case SENDMSG:
        case SENDMSGZC:
          // conn->last_write = get_time();
          bool zc = (conn->op == SENDMSGZC);
          if (handle_sendmsg(conn, res, zc) < 0)
            MP_clear(conn);
          break;
        case INSPLICE:
          if (handle_insplice(conn) < 0)
            MP_clear(conn);
          break;
        case OUTSPLICE:
          if (handle_outsplice(conn, res) < 0)
            MP_clear(conn);
          break;
        }
      }
    } else if (res == 0) {
      if (conn && conn->fd != -1) {
        switch (conn->op) {
        case SENDMSGZC:
          conn->zc_notifs--;
          if (conn->zc_notifs == 0 && handle_sendmsg_complete(conn) < 0)
            MP_clear(conn);
          break;
        case RECV:
          MP_clear(conn);
          break;
        }
      }
    } else {
      if (conn && conn->fd != -1) {
        if (res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR) {
          LOG("conn && conn->fd != -1 && res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR\n");
          MP_clear(conn);
        } else {
          LOG("res == -EAGAIN || res == -EWOULDBLOCK || res == -EINTR\n");
          conn = conn->recv_conn;
          struct iovec *iov = &conn->ios[0];
          memset(iov->iov_base, 0, iov->iov_len);
          if (urecv(conn, iov->iov_base, iov->iov_len, 0) < 0)
            MP_clear(conn);
        }
      }
    }

    LOG("uring operation seen\n");
    io_uring_cqe_seen(&ring, cqe);
  }

  io_uring_queue_exit(&ring);
  MP_exit(&pool);
  return 0;
}

/*** Helper ***/
static inline int _HK_write(void *data, size_t size) {
  size_t nblocks;
  int iov_index;
  conn_t *conn;
  struct iovec *iov;
  bool once;

  conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  nblocks = round_to_blocks(size);
  iov_index = MP_expand(conn, nblocks, once);
  iov = &conn->ios[iov_index];

  memcpy(iov->iov_base, data, size);
  iov->iov_len = size;
  conn->data_left += size;

  return 0;
}
static inline int _HK_write_body(Request *req, size_t offset, size_t size) {
  if (size > req->body.size || offset > req->body.size)
    return -1;

  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  int iov_index = MP_expand(conn, 0, false);
  struct iovec *iov = &conn->ios[iov_index];
  struct iovec *rec = &conn->rec[iov_index];
  rec->iov_base = req->body.ptr + offset;
  rec->iov_len = size;
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;
  conn->data_left += rec->iov_len;
  return 0;
}
/*
static inline int _HK_mem(size_t size, HKMem *mem) {
  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  bool once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  size_t nblocks = round_to_blocks(size);
  int iov_index = MP_expand(conn, nblocks, once);
  struct iovec *iov = &conn->ios[iov_index];
  mem->ptr = iov->iov_base;
  mem->size = iov->iov_len;
  mem->_iov_index = iov_index;
  mem->_flags = (IN_POOL(iov->iov_base)) ? CF_IN_POOL : CF_IN_HEAP;
  return 0;
}

static inline void _HK_send(HKMem *mem, size_t size) {
  conn_t *conn = current_send;
  struct iovec *iov = &conn->ios[mem->_iov_index];
  iov->iov_len = size;
  conn->data_left += size;
}
  */
#endif#define _GNU_SOURCE
#ifndef UTILS_H
#define UTILS_H

#include "hunk.h"
#include <arpa/inet.h>
#include <fcntl.h>
#include <liburing.h>
#include <netdb.h>
#include <signal.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/poll.h>
#include <sys/prctl.h>
#include <sys/socket.h>
#include <sys/sysinfo.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

#define MP_BLOCK  4
#define MAX_CONNS 4096
#define KB        1024
#define NIOS      32

#define IN_POOL(ptr)                 ((void *)ptr >= pool.bpool && (void *)ptr <= (pool.bpool + (pool.npages * pool.pagesize)))
#define ALIGN_TO_PAGESIZE(buff_size) (((buff_size) + (pool.pagesize - 1)) & ~(pool.pagesize - 1))
#define BYTES_TO_BLOCKS(buff_size)   (((buff_size) + (MP_BLOCK - 1)) / MP_BLOCK)
#define CEIL_BLOCKS(nblocks)         ((nblocks + 63) & ~63)
#define CEIL_PAGES(size)             (((size) + ((pool.pagesize) - 1)) & ~((pool.pagesize) - 1))

#define BIT_IS_FREE(word, bit)   (((word) >> (bit)) & 1)
#define MARK_BIT_USED(word, bit) ((word) &= ~(1ULL << (bit)))
#define MARK_BIT_FREE(word, bit) ((word) |= (1ULL << (bit)))
#define FIND_FREE_BIT(word)      ((uint64_t)(word) & -(uint64_t)(word))
#define STRLEN(s)                (sizeof(s) - 1)

#define IOVEC_NBLOCKS (BYTES_TO_BLOCKS(NIOS * sizeof(struct iovec)))
#define MSG_NBLOCKS   (BYTES_TO_BLOCKS(sizeof(struct msghdr)))
#define ZC_RES        KB *KB

#define DEBUG 0
#if DEBUG
#define LOG(...) fprintf(logfd, __VA_ARGS__)
#else
#define LOG(...) ((void)0)
#endif

typedef enum UOP {
  WRITEV = IORING_OP_WRITEV,
  SENDMSG = IORING_OP_SENDMSG,
  RECVMSG = IORING_OP_RECVMSG,
  ACCEPT = IORING_OP_ACCEPT,
  SEND = IORING_OP_SEND,
  RECV = IORING_OP_RECV,
  SENDZC = IORING_OP_SEND_ZC,
  SENDMSGZC = IORING_OP_SENDMSG_ZC,
  PEEK = 50,
  FRECVMSG,
  INSPLICE,
  OUTSPLICE
} UOP;

typedef enum CFS {
  CF_IN_POOL = (1 << 0),       // Connection is in the pool
  CF_IN_HEAP = (1 << 1),       // Connection is in the heap
  CF_SKIP_SOCK = (1 << 2),     // Don't close the socket
  CF_USE_ONCE = (1 << 3),      // Destroy after using
  CF_HANDLER_READY = (1 << 4), // Ready to call the handler
} CFS;

typedef struct conn_t {
  // Socket file descriptor
  int fd;

  // Amount of data left in the current operation
  uint64_t data_left;

  // The index of the connection struct
  uint32_t cindex;

  // The last time the connection was readable
  uint64_t last_read;

  // The last time the connection was writeable
  uint64_t last_write;

  // The operation currently being processed
  uint8_t op;

  // Connection flags
  int flags;

  // Splice fd_in
  int in_fd;

  // Splice fd_out
  int out_fd;

  void *recv_conn;
  void *send_conn;

  struct iovec *ios;
  struct iovec *rec;
  uint16_t nios;

  struct msghdr *msg;
  uint16_t zc_notifs;

  uint16_t head_size;
} conn_t;

typedef struct MPool {
  // The allocated pool of blocks
  void *bpool;

  // The allocated pool of connections
  conn_t *cpool;

  // The size of the pool in pages
  uint32_t npages;

  // The size of the pool in blocks
  uint32_t nblocks;

  // The locations of each page in the pool
  void **blocks;

  // The availability of each block
  uint64_t *freebs;

  // The locations of each conn in the pool
  conn_t **conns;

  // The availability of each conn
  uint64_t *freecs;

  // Clean up callback function
  void (*callback)(conn_t *conn);

  // The page size used
  uint32_t pagesize;

  // Socket read timeout
  uint32_t rtimeout;

  // Socket write timeout
  uint32_t wtimeout;
} MPool;

extern int pipe_sz;
extern int pipe_in, pipe_out, nullfd;
extern FILE *logfd;
extern struct io_uring ring;
extern MPool pool;
extern conn_t *current_recv;
extern conn_t *current_send;

/*
 * Prepare and submit a recv uring op
 */
static inline int urecv(conn_t *conn, void *buffer, size_t buff_size, int flags) {
  if (!conn || conn->fd == -1)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (flags == MSG_PEEK) ? PEEK : RECV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;

  io_uring_prep_recv(sqe, conn->fd, buffer, buff_size, flags);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a multi-shot accept uring op
 */
static inline int umaccept(int listenfd) {
  if (listenfd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = ACCEPT;
  io_uring_prep_multishot_accept(sqe, listenfd, NULL, NULL, SOCK_NONBLOCK);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a splice uring op
 */
static inline int usplice(conn_t *conn, int fd_in, int64_t off_in, int fd_out, int64_t off_out, size_t len) {
  if (!len || !conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = (__u64)conn;
  io_uring_prep_splice(sqe, fd_in, off_in, fd_out, off_out, len, 0);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a writev uring op
 */
static inline int uwritev(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = WRITEV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  io_uring_prep_writev(sqe, conn->fd, &conn->ios[iov_index], nios, -1);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a send uring op
 */
static inline int usend(conn_t *conn, char *res_buff, size_t buff_size, bool zc) {
  if (!conn || conn->fd <= 0 || buff_size == 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (zc) ? SENDZC : SEND;
  conn->data_left = buff_size;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  if (zc)
    io_uring_prep_send_zc(sqe, conn->fd, res_buff, buff_size, 0, 0);
  else
    io_uring_prep_send(sqe, conn->fd, res_buff, buff_size, 0);
  return io_uring_submit(&ring);
}

static inline int ufrecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = FRECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;

  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, rec->iov_len);
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int urecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = RECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int usendmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  bool zc = (conn->data_left > ZC_RES) ? true : false;
  conn->op = (zc) ? SENDMSGZC : SENDMSG;

  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  if (zc) {
    io_uring_prep_sendmsg_zc(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
    conn->zc_notifs++;
  } else {
    io_uring_prep_sendmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  }
  return io_uring_submit(&ring);
}

/*
 * Create and initialize a server socket
 */
static inline int tcp_listen(uint16_t port) {
  int enable;
  int listenfd;
  if ((listenfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    return -1;

  int flags = fcntl(listenfd, F_GETFL, 0);
  fcntl(listenfd, F_SETFL, flags | O_NONBLOCK);
  struct sockaddr_in servaddr;
  memset(&servaddr, 0, sizeof(servaddr));
  servaddr.sin_family = AF_INET;
  servaddr.sin_addr.s_addr = INADDR_ANY;
  servaddr.sin_port = htons(port);

  enable = 1;
  if (setsockopt(listenfd, SOL_SOCKET, SO_REUSEPORT, &enable, sizeof(enable)) < 0)
    return -1;

  if (bind(listenfd, (struct sockaddr *)&servaddr, sizeof(servaddr)) < 0)
    return -1;

  if (listen(listenfd, SOMAXCONN) < 0)
    return -1;

  return listenfd;
}

/*
 * Calculate the difference between two pointers
 */
static inline uintptr_t ptr_diff(uintptr_t p1, uintptr_t p2) { return (uintptr_t)(p1 > p2) ? (p1 - p2) : (p2 - p1); }

static inline size_t get_nroutes(Route *routes) {
  Route *route;
  for (size_t i = 0;; i++) {
    route = &routes[i];
    if (!route->path && !route->handler && !route->method)
      return i;
  }
}

static inline long get_content_length(char *src, char *end) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return -1;
    key = line;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, "Content-Length") != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;

    *line_end = '\0';
    long res = atol(value);
    *line_end = '\r';

    return res;
  }
  return -1;
}

static inline bool have_header(char *src, char *end, const char *header_key, const char *header_value) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    key = line;
    while (*key == ' ')
      key++;
    while (*header_key == ' ')
      header_key++;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return false;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, header_key) != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;
    while (*header_value == ' ')
      header_value++;

    *line_end = '\0';
    bool res = (strcasecmp(value, header_value) == 0);
    *line_end = '\r';

    return res;
  }

  return false;
}

static inline const char *method_str(Method method) {
  switch (method) {
  case GET:
    return "GET";
    break;
  case HEAD:
    return "HEAD";
    break;
  case POST:
    return "POST";
    break;
  case PUT:
    return "PUT";
    break;
  case DELETE:
    return "DELETE";
    break;
  case CONNECT:
    return "CONNECT";
    break;
  case OPTIONS:
    return "OPTIONS";
    break;
  case TRACE:
    return "TRACE";
    break;
  case PATCH:
    return "PATCH";
    break;
  default:
    return NULL;
  }
}

static inline uint8_t method_len(Method method) {
  switch (method) {
  case GET:
    return 3;
    break;
  case HEAD:
    return 4;
    break;
  case POST:
    return 4;
    break;
  case PUT:
    return 3;
    break;
  case DELETE:
    return 6;
    break;
  case CONNECT:
    return 7;
    break;
  case OPTIONS:
    return 7;
    break;
  case TRACE:
    return 5;
    break;
  case PATCH:
    return 5;
    break;
  default:
    return 0;
  }
}

static inline size_t round_to_blocks(size_t size) {
  size_t nblocks = BYTES_TO_BLOCKS(size);
  nblocks = CEIL_BLOCKS(nblocks);
  return nblocks;
}

/*
 * Count the digits in unsigned 64-bit int
 */
static inline int countd(uint64_t num) {
  if (num < 10ULL)
    return 1;
  if (num < 100ULL)
    return 2;
  if (num < 1000ULL)
    return 3;
  if (num < 10000ULL)
    return 4;
  if (num < 100000ULL)
    return 5;
  if (num < 1000000ULL)
    return 6;
  if (num < 10000000ULL)
    return 7;
  if (num < 100000000ULL)
    return 8;
  if (num < 1000000000ULL)
    return 9;
  if (num < 10000000000ULL)
    return 10;
  if (num < 100000000000ULL)
    return 11;
  if (num < 1000000000000ULL)
    return 12;
  if (num < 10000000000000ULL)
    return 13;
  if (num < 100000000000000ULL)
    return 14;
  if (num < 1000000000000000ULL)
    return 15;
  if (num < 10000000000000000ULL)
    return 16;
  if (num < 100000000000000000ULL)
    return 17;
  if (num < 1000000000000000000ULL)
    return 18;
  if (num < 10000000000000000000ULL)
    return 19;
  return 20;
}

/*
 * Get the time elabsed in ms
 */
static inline uint64_t get_time() {
  struct timespec ts;
  clock_gettime(CLOCK_MONOTONIC, &ts);
  return (uint64_t)(ts.tv_sec) * 1000 + (ts.tv_nsec / 1000000);
}

static inline FILE *log_init(const char *path) {
  FILE *res = fopen(path, "a+");
  setvbuf(res, NULL, _IONBF, 0);
  return res;
}

static inline int16_t pollevs(int connfd) {
  struct pollfd pfd;
  pfd.fd = connfd;
  pfd.events = POLLIN | POLLOUT | POLLERR;
  int res = poll(&pfd, 1, 0);
  if (res < 0)
    return POLLERR;
  return pfd.revents;
}

// FIXME This needs to be updated
static inline conn_t *MP_use_once(size_t nblocks, int fd) {

  void *mem = malloc(sizeof(conn_t) + 8 + (IOVEC_NBLOCKS * MP_BLOCK));
  struct conn_t *conn = (conn_t *)mem;
  memset(conn, 0, sizeof(conn_t));
  conn->ios = mem + sizeof(conn_t) + 8;

  if (nblocks > 0) {
    struct iovec *iov = &conn->ios[conn->nios++];
    mem = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (mem == MAP_FAILED)
      return NULL;
    iov->iov_base = mem;
    iov->iov_len = ALIGN_TO_PAGESIZE(nblocks * MP_BLOCK);
  }

  conn->flags |= CF_IN_HEAP;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;

  return conn;
}

static inline int find_freec() {
  uint64_t *word;
  size_t map_size = (sizeof(uint64_t) * 8);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    word = &pool.freecs[i / map_size];

    if (*word == 0) { // All used
      i += (map_size - 1);
      continue;
    }

    i += __builtin_ctzll(*word);
    MARK_BIT_USED(*word, i);
    return i;
  }

  return -1;
}

static inline int MP_init(size_t npages) {
  if (!npages)
    return -1;

  /*** Setup ***/
  pool.npages = npages;
  pool.pagesize = sysconf(_SC_PAGESIZE);

  /*** Pool ***/
  pool.bpool = mmap(NULL, pool.npages * pool.pagesize, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  if (pool.bpool == MAP_FAILED)
    return -1;
  pool.nblocks = (pool.npages * pool.pagesize) / MP_BLOCK;

  /*** Blocks ***/
  pool.blocks = malloc(sizeof(void *) * pool.nblocks);
  if (!pool.blocks)
    return -1;
  for (size_t i = 0; i < pool.nblocks; i++)
    pool.blocks[i] = pool.bpool + (i * MP_BLOCK);

  /*** Freebs ***/
  // if (posix_memalign((void **)&pool.freebs, 64, bitmap_size * sizeof(uint64_t)) < 0)
  size_t bitmap_size = (pool.nblocks + 63) / 64;
  pool.freebs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freebs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freebs[i] = UINT64_MAX;

  /*** Cpool ***/
  pool.cpool = (conn_t *)malloc(sizeof(conn_t) * MAX_CONNS);
  if (!pool.cpool)
    return -1;

  /*** Conns ***/
  pool.conns = (conn_t **)malloc(sizeof(conn_t *) * MAX_CONNS);
  if (!pool.conns)
    return -1;
  size_t conn_size = sizeof(conn_t);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    pool.conns[i] = (conn_t *)((char *)pool.cpool + (i * conn_size));
    pool.conns[i]->fd = -1;
    pool.conns[i]->in_fd = -1;
    pool.conns[i]->out_fd = -1;
  }

  /*** Freecs ***/
  bitmap_size = (MAX_CONNS + 63) / 64;
  pool.freecs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freecs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freecs[i] = UINT64_MAX;

  return 0;
}

static inline int MP_use_blks(size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t max_start = pool.nblocks - nblocks;
  size_t full_chunks = (nblocks / 64) * 64;

  for (size_t i = 0, c = 0; i <= max_start; i++, c++) {
    bool free = true;

    for (size_t j = 0; j < full_chunks; j += 64) {
      size_t word_index = (i + j) / 64;
      if (pool.freebs[word_index] != UINT64_MAX) {
        free = false;
        i += 63;
        break;
      }
    }

    for (size_t j = full_chunks; j < nblocks; j++) {
      size_t bit_index = i + j;
      size_t word_index = bit_index / 64;
      size_t bit_in_word = bit_index % 64;

      if (!BIT_IS_FREE(pool.freebs[word_index], bit_in_word)) {
        free = false;
        i += j;
        break;
      }
    }

    if (free) {
      for (size_t j = 0; j < full_chunks; j += 64) {
        size_t word_index = (i + j) / 64;
        pool.freebs[word_index] = 0;
      }

      for (size_t j = full_chunks; j < nblocks; j++) {
        size_t bit_index = i + j;
        size_t word_index = bit_index / 64;
        size_t bit_in_word = bit_index % 64;

        MARK_BIT_USED(pool.freebs[word_index], bit_in_word);
      }

      return i;
    }
  }

  return -1;
}

static inline int MP_free_blks(size_t bindex, size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t full_chunks = (nblocks / 64) * 64;
  for (size_t i = 0; i < full_chunks; i += 64) {
    size_t word_index = (bindex + i) / 64;
    pool.freebs[word_index] = UINT64_MAX;
  }

  for (size_t i = full_chunks; i < nblocks; i++) {
    size_t bit_index = bindex + i;
    size_t word_index = bit_index / 64;
    size_t bit_in_word = bit_index % 64;

    MARK_BIT_FREE(pool.freebs[word_index], bit_in_word);
  }

  memset(pool.blocks[bindex], 0, nblocks * MP_BLOCK);
  return 0;
}

static inline conn_t *MP_use(size_t nblocks, int fd, bool once) {
  if (fd <= 0)
    return NULL;
  if (once)
    return MP_use_once(nblocks, fd);

  int cindex = find_freec();
  if (cindex < 0) {
    LOG("Err: cindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  conn_t *conn = pool.conns[cindex];

  int ios_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (ios_bindex < 0) {
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }

  struct iovec *ios = pool.blocks[ios_bindex];
  conn->ios = ios;

  int rec_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (rec_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct iovec *rec = pool.blocks[rec_bindex];
  conn->rec = rec;

  int msg_bindex = MP_use_blks(MSG_NBLOCKS);
  if (msg_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct msghdr *msg = pool.blocks[msg_bindex];
  conn->msg = msg;

  if (nblocks > 0) {
    int bindex = MP_use_blks(nblocks);
    if (bindex < 0) {
      MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
      MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
      MP_free_blks(msg_bindex, IOVEC_NBLOCKS);
      MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
      LOG("Err: bindex < 0; will use MP_use_once\n");
      return MP_use_once(nblocks, fd);
    }

    size_t iov_index = conn->nios++;
    struct iovec *iov = &conn->ios[iov_index];
    struct iovec *rec = &conn->rec[iov_index];
    iov->iov_base = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
  }

  conn->msg->msg_iov = conn->ios;
  conn->msg->msg_iovlen = conn->nios;
  conn->cindex = cindex;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;
  return conn;
}

static inline void MP_shed(conn_t *conn, size_t iov_index, size_t nios) {
  struct iovec *iov, *rec;
  size_t bindex, nblocks, index;

  for (size_t i = 0; i < nios; i++) {
    index = iov_index + i;
    iov = &conn->ios[index];
    rec = &conn->rec[index];
    if (!rec || !rec->iov_base)
      continue;
    if (!IN_POOL(rec->iov_base)) {
      munmap(rec->iov_base, rec->iov_len / pool.pagesize);
    } else {
      bindex = ptr_diff((uintptr_t)rec->iov_base, (uintptr_t)pool.bpool) / MP_BLOCK;
      nblocks = rec->iov_len / MP_BLOCK;
      MP_free_blks(bindex, nblocks);
    }
    memset(iov, 0, sizeof(struct iovec));
    memset(rec, 0, sizeof(struct iovec));
    conn->nios--;
  }
}

static inline int MP_expand(conn_t *conn, size_t nblocks, bool once) {
  void *bptr;
  int iov_index, bindex;
  struct iovec *iov, *rec;

  iov_index = conn->nios++;
  iov = &conn->ios[iov_index];
  rec = &conn->rec[iov_index];

  if (nblocks == 0)
    return iov_index;

  if (once) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_base = bptr;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
    return iov_index;
  }

  bindex = MP_use_blks(nblocks);
  if (bindex < 0) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_len = iov->iov_len;
  } else {
    bptr = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_len = iov->iov_len;
  }

  iov->iov_base = bptr;
  rec->iov_base = iov->iov_base;
  return iov_index;
}

static inline int MP_free(conn_t *conn) {
  if (!conn)
    return -1;
  size_t bindex, nblocks;
  uint64_t *word;

  MP_shed(conn, 0, conn->nios);
  if (conn->flags & CF_IN_HEAP) {
    if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
      close(conn->fd);
    free(conn);
    return 0;
  }

  word = &pool.freecs[conn->cindex / 64];
  if (conn->cindex > MAX_CONNS)
    return -1;
  else if (BIT_IS_FREE(*word, conn->cindex))
    return 0;

  bindex = ptr_diff((uintptr_t)conn->ios, (uintptr_t)pool.bpool) / MP_BLOCK;
  nblocks = IOVEC_NBLOCKS;
  MP_free_blks(bindex, nblocks);

  bindex = ptr_diff((uintptr_t)conn->rec, (uintptr_t)pool.bpool) / MP_BLOCK;
  MP_free_blks(bindex, nblocks);

  if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
    close(conn->fd);

  MARK_BIT_FREE(*word, conn->cindex);
  memset(conn, 0, sizeof(conn_t));
  conn->fd = -1;
  conn->in_fd = -1;
  conn->out_fd = -1;
  return 0;
}

static inline void MP_clear(conn_t *conn) {
  conn_t *recv_conn = conn->recv_conn;
  conn_t *send_conn = conn->send_conn;
  if (recv_conn)
    MP_free(recv_conn);
  if (send_conn)
    MP_free(send_conn);
}

static inline void MP_exit(MPool *pool) {
  munmap(pool->bpool, pool->npages);
  free(pool->cpool);
  free(pool->blocks);
  free(pool->conns);
  free(pool->freebs);
  free(pool->freecs);
}

static inline void MP_timeout() {
  conn_t *conn;
  int16_t res;
  uint64_t now;
  size_t windex = 0;
  uint64_t *word = &pool.freecs[0];
  for (size_t i = 0; i < MAX_CONNS; i++) {
    if ((i / 64) < windex)
      word = &pool.freecs[++windex];

    if (*word == UINTMAX_MAX) {
      i = (i / 64) * 64 + 64;
      continue;
    }

    conn = pool.conns[i];
    if (!conn || conn->fd == -1)
      continue;

    res = pollevs(conn->fd);

    now = get_time();
    if (res & POLLERR) {
      MP_clear(conn);
      continue;
    }
    if (res & POLLIN) {
      if (pool.rtimeout > 0 && (now - conn->last_read) >= pool.rtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (res & POLLOUT) {
      if (pool.wtimeout > 0 && (now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (!(res & POLLIN || res & POLLOUT)) {
      if ((pool.rtimeout > 0 && now - conn->last_read) >= pool.rtimeout
          || (pool.wtimeout > 0 && now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
  }
}

/*
 * Calculate the length of a status string
 */
static inline size_t status_len(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return 8;
  case STATUSSWITCHINGPROTOCOLS:
    return 19;
  case STATUSPROCESSING:
    return 10;
  case STATUSEARLYHINTS:
    return 11;
  case STATUSOK:
    return 2;
  case STATUSCREATED:
    return 7;
  case STATUSACCEPTED:
    return 8;
  case STATUSNONAUTHORITATIVE:
    return 29;
  case STATUSNOCONTENT:
    return 10;
  case STATUSRESETCONTENT:
    return 13;
  case STATUSPARTIALCONTENT:
    return 15;
  case STATUSMULTISTATUS:
    return 12;
  case STATUSALREADYREPORTED:
    return 16;
  case STATUSIMUSED:
    return 7;
  case STATUSMULTIPLECHOICES:
    return 16;
  case STATUSMOVEDPERMANENTLY:
    return 17;
  case STATUSFOUND:
    return 5;
  case STATUSSEEOTHER:
    return 9;
  case STATUSNOTMODIFIED:
    return 12;
  case STATUSUSEPROXY:
    return 9;
  case STATUSTEMPORARYREDIRECT:
    return 18;
  case STATUSPERMANENTREDIRECT:
    return 18;
  case STATUSBADREQUEST:
    return 11;
  case STATUSUNAUTHORIZED:
    return 12;
  case STATUSPAYMENTREQUIRED:
    return 16;
  case STATUSFORBIDDEN:
    return 9;
  case STATUSNOTFOUND:
    return 9;
  case STATUSMETHODNOTALLOWED:
    return 18;
  case STATUSNOTACCEPTABLE:
    return 14;
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return 29;
  case STATUSREQUESTTIMEOUT:
    return 15;
  case STATUSCONFLICT:
    return 8;
  case STATUSGONE:
    return 4;
  case STATUSLENGTHREQUIRED:
    return 15;
  case STATUSPRECONDITIONFAILED:
    return 19;
  case CONTENTTOOLARGE:
    return 17;
  case STATUSURITOOLONG:
    return 12;
  case STATUSUNSUPPORTEDMEDIATYPE:
    return 22;
  case STATUSRANGENOTSATISFIABLE:
    return 21;
  case STATUSEXPECTATIONFAILED:
    return 18;
  case STATUSMISDIRECTEDREQUEST:
    return 19;
  case STATUSUNPROCESSABLECONTENT:
    return 21;
  case STATUSLOCKED:
    return 6;
  case STATUSFAILEDDEPENDENCY:
    return 17;
  case STATUSTOOEARLY:
    return 9;
  case STATUSUPGRADEREQUIRED:
    return 16;
  case STATUSPRECONDITIONREQUIRED:
    return 21;
  case STATUSTOOMANYREQUESTS:
    return 17;
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return 31;
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return 29;
  case STATUSInternalServerError:
    return 21;
  case STATUSNOTIMPLEMENTED:
    return 15;
  case STATUSBADGATEWAY:
    return 11;
  case STATUSSERVICEUNAVAILABLE:
    return 19;
  case STATUSGATEWAYTIMEOUT:
    return 15;
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return 26;
  case STATUSVARIANTALSONEGOTIATES:
    return 23;
  case STATUSINSUFFICIENTSTORAGE:
    return 20;
  case STATUSLOOPDETECTED:
    return 13;
  case STATUSNOTEXTENDED:
    return 12;
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return 31;
  default:
    return 0;
  }
}

/*
 * Return the status code string as string literal
 */
static inline char *status_str(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return "Continue";
  case STATUSSWITCHINGPROTOCOLS:
    return "Switching Protocols";
  case STATUSPROCESSING:
    return "Processing";
  case STATUSEARLYHINTS:
    return "Early Hints";
  case STATUSOK:
    return "OK";
  case STATUSCREATED:
    return "Created";
  case STATUSACCEPTED:
    return "Accepted";
  case STATUSNONAUTHORITATIVE:
    return "Non-Authoritative Information";
  case STATUSNOCONTENT:
    return "No Content";
  case STATUSRESETCONTENT:
    return "Reset Content";
  case STATUSPARTIALCONTENT:
    return "Partial Content";
  case STATUSMULTISTATUS:
    return "Multi-Status";
  case STATUSALREADYREPORTED:
    return "Already Reported";
  case STATUSIMUSED:
    return "Im Used";
  case STATUSMULTIPLECHOICES:
    return "Multiple Choices";
  case STATUSMOVEDPERMANENTLY:
    return "Moved Permanently";
  case STATUSFOUND:
    return "Found";
  case STATUSSEEOTHER:
    return "See Other";
  case STATUSNOTMODIFIED:
    return "Not Modified";
  case STATUSUSEPROXY:
    return "Use Proxy";
  case STATUSTEMPORARYREDIRECT:
    return "Temporary Redirect";
  case STATUSPERMANENTREDIRECT:
    return "Permanent Redirect";
  case STATUSBADREQUEST:
    return "Bad Request";
  case STATUSUNAUTHORIZED:
    return "Unauthorized";
  case STATUSPAYMENTREQUIRED:
    return "Payment Required";
  case STATUSFORBIDDEN:
    return "Forbidden";
  case STATUSNOTFOUND:
    return "Not Found";
  case STATUSMETHODNOTALLOWED:
    return "Method Not Allowed";
  case STATUSNOTACCEPTABLE:
    return "Not Acceptable";
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return "Proxy Authentication Required";
  case STATUSREQUESTTIMEOUT:
    return "Request Timeout";
  case STATUSCONFLICT:
    return "Conflict";
  case STATUSGONE:
    return "Gone";
  case STATUSLENGTHREQUIRED:
    return "Length Required";
  case STATUSPRECONDITIONFAILED:
    return "Precondition Failed";
  case CONTENTTOOLARGE:
    return "Content Too Large";
  case STATUSURITOOLONG:
    return "URI Too Long";
  case STATUSUNSUPPORTEDMEDIATYPE:
    return "Unsupported Media Type";
  case STATUSRANGENOTSATISFIABLE:
    return "Range Not Satisfiable";
  case STATUSEXPECTATIONFAILED:
    return "Expectation Failed";
  case STATUSMISDIRECTEDREQUEST:
    return "Misdirected Request";
  case STATUSUNPROCESSABLECONTENT:
    return "Unprocessable Content";
  case STATUSLOCKED:
    return "Locked";
  case STATUSFAILEDDEPENDENCY:
    return "Failed Dependency";
  case STATUSTOOEARLY:
    return "Too Early";
  case STATUSUPGRADEREQUIRED:
    return "Upgrade Required";
  case STATUSPRECONDITIONREQUIRED:
    return "Precondition Required";
  case STATUSTOOMANYREQUESTS:
    return "Too Many Requests";
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return "Request Header Fields Too Large";
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return "Unavailable For Legal Reasons";
  case STATUSInternalServerError:
    return "Internal Server Error";
  case STATUSNOTIMPLEMENTED:
    return "Not Implemented";
  case STATUSBADGATEWAY:
    return "Bad Gateway";
  case STATUSSERVICEUNAVAILABLE:
    return "Service Unavailable";
  case STATUSGATEWAYTIMEOUT:
    return "Gateway Timeout";
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return "HTTP Version Not Supported";
  case STATUSVARIANTALSONEGOTIATES:
    return "Variant Also Negotiates";
  case STATUSINSUFFICIENTSTORAGE:
    return "Insufficient Storage";
  case STATUSLOOPDETECTED:
    return "Loop Detected";
  case STATUSNOTEXTENDED:
    return "Not Extended";
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return "Network Authentication Required";
  default:
    return 0;
  }
}

/*
 * Return true if routes match
 */
static inline bool route_equ(Route *route, Request *req) {
  return route->method == req->method && strncmp(route->path, req->path, strlen(route->path)) == 0;
}

/*
 * Return the matching route index on success. -1 on failure
 */
static inline int match_route(Server *serv, Request *req) {
  for (size_t i = 0; i < serv->_nroutes; i++) {
    Route route = serv->routes[i];
    if (!req->path || !route.path)
      continue;
    if (route_equ(&route, req))
      return i;
    else if (req->method == HEAD && route.method == GET && strcmp(route.path, req->path) == 0)
      return i;
  }
  return -1;
}

/*
 * Return true if the response should contain the Content-Length header
 */
static inline bool should_have_content_length(Request *req, ResWriter *res) {
  return (req->method != CONNECT              // CONNECT request
          && res->status != STATUSNOCONTENT   // 204 response
          && res->status != STATUSNOTMODIFIED // 304 response
          && res->status >= 200);             // 1xx response
}

/*
 * Format http response from the ResWriter.
 * Return response size on success, 0 on failure.
 */
static inline size_t fmt_res(Request *req, ResWriter *res, char *buffer, size_t buffer_size) {
  if (!res || !buffer || buffer_size == 0)
    return 0;

  size_t res_len, total = 0;
  char *dst = buffer;
  size_t maxlen = buffer_size;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t body_length = res->len;

  res_len = snprintf(dst, maxlen, "HTTP/1.1 %d %s", (int)res->status, status_str(res->status));
  total += res_len;
  dst += res_len;
  maxlen -= res_len;

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    res_len = snprintf(dst, maxlen, "\r\n%s: %s", header->key, header->value);
    total += res_len;
    dst += res_len;
    maxlen -= res_len;
  }

  if (have_content_length) {
    res_len = snprintf(dst, maxlen, "\r\nContent-Length: %lu", body_length);
    total += res_len, dst += res_len, maxlen -= res_len;
  }

  memcpy(dst, "\r\n\r\n", 4);
  total += 4, dst += 4, maxlen -= 4;

  return total;
}

static inline size_t res_len(Request *req, ResWriter *res) {
  if (!req || !res)
    return 0;

  if (!res->status)
    res->status = STATUSOK;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t result = 0;
  result += STRLEN("HTTP/1.1 ");     // HTTP version
  result += 4;                       // Status code + space
  result += status_len(res->status); // Status name

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    result += 2;                       // "\r\n"
    result += strlen(header->key) + 2; // Header key + ':' + space
    result += strlen(header->value);   // header value
  }

  if (have_content_length) {
    result += 2;                          // "\r\n"
    result += STRLEN("Content-Length: "); // Header key
    result += countd(res->len);           // Header value
  }

  result += 4; // "\r\n\r\n"

  return result;
}

static inline int send_empty_res(Status status) {
  size_t res_len = STRLEN("HTTP/1.1 ")        // HTTP version
                   + countd((uint64_t)status) // status code
                   + 1                        // space
                   + (int)status_len(status)  // status string
                   + 4;                       // \r\n\r\n

  conn_t *conn = current_send;
  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, res_len);
  if (snprintf((char *)rec->iov_base, res_len + 1, "HTTP/1.1 %d %s\r\n\r\n", (int)status, status_str(status))
      != (int)res_len)
    return -1;

  return usendmsg(conn, 0, 1);
}

static inline ssize_t read_socket(int sockfd, size_t len) {
  if (len == 0 || sockfd <= 0)
    return 0;
  char buff[1024 * 8];
  return read(sockfd, buff, 1024 * 8);
}

static inline int read_method(Method *method, void *src) {
  if (memcmp(src, "GET", 3) == 0)
    *method = GET;
  else if (memcmp(src, "POST", 4) == 0)
    *method = POST;
  else if (memcmp(src, "HEAD", 4) == 0)
    *method = HEAD;
  else if (memcmp(src, "PUT", 3) == 0)
    *method = PUT;
  else if (memcmp(src, "DELETE", 6) == 0)
    *method = DELETE;
  else if (memcmp(src, "CONNECT", 7) == 0)
    *method = CONNECT;
  else if (memcmp(src, "OPTIONS", 7) == 0)
    *method = OPTIONS;
  else if (memcmp(src, "TRACE", 5) == 0)
    *method = TRACE;
  else if (memcmp(src, "PATCH", 5) == 0)
    *method = PATCH;
  else
    return -1;

  return 0;
}

static inline int sendmsg_res(Request *req, ResWriter *res) {
  conn_t *conn;
  size_t head_size, res_size;
  struct iovec *iov;

  conn = current_send;
  iov = &conn->ios[0];
  head_size = res_len(req, res);
  if (head_size == 0)
    return -1;

  conn->data_left += head_size;
  res_size = fmt_res(req, res, iov->iov_base, (head_size + 1));
  if (res_size != head_size)
    return -1;
  iov->iov_len = res_size;

  return usendmsg(conn, 0, conn->nios);
}

static inline int read_req(Request *req, char *req_buffer) {
  if (!req_buffer)
    return -1;
  /*** Method ***/
  char *sep = strchr(req_buffer, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }
  *sep = '\0';
  if (read_method(&req->method, req_buffer) < 0)
    return -1;

  /*** Path ***/
  char *fullpath = sep + 1;
  sep = strchr(fullpath, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }

  *sep = '\0';
  req->path = fullpath;
  /*** Params ***/
  char *paramStart = strchr(fullpath, '?');
  if (paramStart) {
    *paramStart++ = '\0';
    int params_count = 0;
    params_count = HK_parse_params(paramStart, req->params, MAX_URL_PARAMETERS);
    if (params_count > 0)
      req->params_count = params_count;
    else
      req->params_count = 0;
  } else {
    req->params = NULL;
    req->params_count = 0;
  }

  /*** Headers ***/
  char *headStart = strstr(sep + 1, "\r\n");
  char *headEnd = strstr(sep + 1, "\r\n\r\n");
  if (!headStart) {
    LOG("read_req: !headStart\n");
    return -1;
  };

  memset(headStart, 0, 2);
  headStart += 2;
  memset(headEnd, 0, 4);
  headEnd += 4;

  int headers_count = HK_parse_headers(headStart, req->headers, MAX_REQ_HEADERS);
  if (headers_count <= 0)
    return -1;
  req->headers_count = headers_count;

  /*** Host ***/
  int index = HK_get_header(req, "Host");
  if (index < 0)
    return -1;
  char *host = req->headers[index].value;
  req->hostname = host;

  /*** Port ***/
  char *colon = strchr(host, ':');
  if (colon) {
    *colon++ = '\0';
    req->port = atoi(colon);
  } else {
    req->port = PORT;
  }
  return 0;
}
static inline int process_req(Server *serv, conn_t *conn) {
  if (!conn || conn->fd == -1)
    return -1;

  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;
  if (read_req(&req, conn->ios[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    LOG("Err: route_index == -1\n");
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;
  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  sendmsg_res(&req, &res);

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int new_conn(int connfd) {
  if (connfd <= 0)
    return -1;

  current_recv = MP_use(KB * 2, connfd, false);
  current_send = MP_use(KB * 2, connfd, false);

  current_recv->recv_conn = current_recv;
  current_recv->send_conn = current_send;

  current_send->send_conn = current_send;
  current_send->recv_conn = current_recv;

  conn_t *conn = current_recv;
  if (ufrecvmsg(conn, 0, 1) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

static inline int resubmit_sendmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return usendmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int resubmir_recvmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    // FIXME the len should be increased
    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return urecvmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int handle_sendmsg_complete(conn_t *conn) {
  struct iovec *iov, *rec;

  MP_shed(conn, 1, conn->nios - 1);
  iov = &conn->ios[0];
  rec = &conn->rec[0];
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;

  return ufrecvmsg(conn->recv_conn, 0, 1);
}

static inline int handle_sendmsg(conn_t *conn, int res, bool zc) {
  if (!conn || conn->fd == -1)
    return -1;

  conn->data_left -= res;
  if (conn->data_left > 0)
    return resubmit_sendmsg(conn, res);

  if (zc)
    return 0;

  return handle_sendmsg_complete(conn);
}

static inline int handle_insplice(conn_t *conn) {
  conn->op = OUTSPLICE;
  return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
}
static inline int handle_outsplice(conn_t *conn, int res) {
  conn->data_left -= res;
  if (conn->data_left > 0) {
    conn->op = INSPLICE;
    return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
  }

  conn_t *recv_conn = conn->recv_conn;
  struct iovec *iov = &recv_conn->ios[0];
  memset(iov->iov_base, 0, iov->iov_len);
  if (urecv(recv_conn, iov->iov_base, iov->iov_len, MSG_PEEK) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

/*
static inline int handle_recv(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  void *bptr = conn->ios[0].iov_base;
  void *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  void *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  return process_req(serv, conn);
}
*/
static inline int find_route(Server *serv, char *bptr) {
  Request req = {0};
  if (read_method(&req.method, bptr) < 0) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  };
  char *space = strchr(bptr, ' ');
  req.path = (space + 1);
  space = strchr(req.path, ' ');
  *space = '\0';
  int route_index = match_route(serv, &req);
  *space = ' ';
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }
  return route_index;
}

static inline int run_handler(Server *serv, conn_t *conn, bool uses_body) {
  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;

  if (read_req(&req, conn->rec[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  if (uses_body) {
    int h_index = HK_get_header(&req, "Content-Length");
    long body_size = atol(req.headers[h_index].value);
    if (body_size >= 0) {
      req.body.ptr = conn->rec[1].iov_base;
      req.body.size = body_size;
    } else {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    }
  }

  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  if (sendmsg_res(&req, &res) < 0)
    return -1;

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int handle_frecvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  char *bptr = (char *)conn->ios[0].iov_base;
  char *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  char *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  size_t head_size = (headEnd + 4) - bptr;
  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  int route_index = find_route(serv, bptr);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  bool uses_body = serv->routes[route_index].uses_body;
  long body_size = get_content_length(headstart + 2, headEnd + 4);
  if (body_size == -1) {
    if (uses_body) {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    } else {
      body_size = 0;
    }
  }

  conn->head_size = head_size;
  if (!uses_body) {
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  if (res == (int)(head_size + body_size)) {
    size_t iov_index = MP_expand(conn, round_to_blocks(body_size), false);
    memcpy(conn->rec[iov_index].iov_base, headEnd + 4, body_size);
    conn->ios[iov_index].iov_len = body_size;
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  conn->data_left = body_size - (res - head_size);
  bool once = ((size_t)body_size > (size_t)((pool.nblocks * MP_BLOCK) / 10));
  size_t iov_index = MP_expand(conn, round_to_blocks(body_size), once);
  memcpy(conn->rec[iov_index].iov_base, headEnd + 4, (res - head_size));
  conn->ios[iov_index].iov_base += (res - head_size);

  return urecvmsg(conn, iov_index, 1);
}

static inline int handle_recvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  if (conn->data_left > 0) {
    conn->data_left -= res;
    if (conn->data_left == 0) {
      conn->flags &= CF_HANDLER_READY;
      return run_handler(serv, conn, true);
    }

    conn->flags &= ~CF_HANDLER_READY;
    conn->ios[1].iov_base += res;
    return urecvmsg(conn, 1, 1);
  }

  conn->flags &= CF_HANDLER_READY;
  return run_handler(serv, conn, true);
}

static inline int serv_init(Server *serv) {
#if DEBUG
  logfd = log_init("log.txt");
  if (!logfd) {
    printf("log_init failed");
    return -1;
  }
#endif
  serv->_nroutes = get_nroutes(serv->routes);

  int pipefd[2];
  if (pipe(pipefd) < 0)
    return -1;
  pipe_in = pipefd[0];
  pipe_out = pipefd[1];
  nullfd = open("/dev/null", O_WRONLY);
  pipe_sz = fcntl(pipefd[0], F_GETPIPE_SZ);
  if (pipe_sz < 0)
    return -1;

  pool.rtimeout = serv->rtimeout;
  pool.wtimeout = serv->wtimeout;
  if (MP_init(MAX_CONNS * 8) < 0)
    return -1;
  LOG("pool initialized\n");

  if (io_uring_queue_init(MAX_CONNS, &ring, 0) < 0)
    return -1;
  LOG("uring initialized\n");

  int listenfd;
  if ((listenfd = tcp_listen(serv->port)) < 0)
    return -1;
  LOG("socket initialized\n");

  return umaccept(listenfd);
}

static inline int serv_listen(Server *serv) {
  // uint64_t last_check = get_time();
  while (true) {
    // uint64_t now = get_time();
    // if ((now - last_check) >= 200) {
    //   last_check = now;
    //   LOG("CM: CM_check ran\n");
    //   MP_timeout();
    // }

    LOG("SQ ready: %u, CQ ready: %u\n", io_uring_sq_ready(&ring), io_uring_cq_ready(&ring));
    struct io_uring_cqe *cqe;
    if (io_uring_wait_cqe(&ring, &cqe) < 0)
      continue;

    int res = cqe->res;
    LOG("res = %d\n", res);
    conn_t *conn = NULL;
    if (cqe->user_data > 100) {
      conn = (conn_t *)cqe->user_data;
      current_recv = (conn_t *)conn->recv_conn;
      current_send = (conn_t *)conn->send_conn;
    }

    if (res > 0) {
      if (cqe->user_data == ACCEPT) {
        LOG("new conn created\n");
        new_conn(res);
      } else if (conn && conn->fd != -1) {
        LOG("conn[%d]: conn.fd = %d; conn.op = %d\n", conn->cindex, conn->fd, conn->op);
        switch (conn->op) {
        case FRECVMSG:
          if (handle_frecvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case RECVMSG:
          if (handle_recvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case SENDMSG:
        case SENDMSGZC:
          // conn->last_write = get_time();
          bool zc = (conn->op == SENDMSGZC);
          if (handle_sendmsg(conn, res, zc) < 0)
            MP_clear(conn);
          break;
        case INSPLICE:
          if (handle_insplice(conn) < 0)
            MP_clear(conn);
          break;
        case OUTSPLICE:
          if (handle_outsplice(conn, res) < 0)
            MP_clear(conn);
          break;
        }
      }
    } else if (res == 0) {
      if (conn && conn->fd != -1) {
        switch (conn->op) {
        case SENDMSGZC:
          conn->zc_notifs--;
          if (conn->zc_notifs == 0 && handle_sendmsg_complete(conn) < 0)
            MP_clear(conn);
          break;
        case RECV:
          MP_clear(conn);
          break;
        }
      }
    } else {
      if (conn && conn->fd != -1) {
        if (res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR) {
          LOG("conn && conn->fd != -1 && res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR\n");
          MP_clear(conn);
        } else {
          LOG("res == -EAGAIN || res == -EWOULDBLOCK || res == -EINTR\n");
          conn = conn->recv_conn;
          struct iovec *iov = &conn->ios[0];
          memset(iov->iov_base, 0, iov->iov_len);
          if (urecv(conn, iov->iov_base, iov->iov_len, 0) < 0)
            MP_clear(conn);
        }
      }
    }

    LOG("uring operation seen\n");
    io_uring_cqe_seen(&ring, cqe);
  }

  io_uring_queue_exit(&ring);
  MP_exit(&pool);
  return 0;
}

/*** Helper ***/
static inline int _HK_write(void *data, size_t size) {
  size_t nblocks;
  int iov_index;
  conn_t *conn;
  struct iovec *iov;
  bool once;

  conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  nblocks = round_to_blocks(size);
  iov_index = MP_expand(conn, nblocks, once);
  iov = &conn->ios[iov_index];

  memcpy(iov->iov_base, data, size);
  iov->iov_len = size;
  conn->data_left += size;

  return 0;
}
static inline int _HK_write_body(Request *req, size_t offset, size_t size) {
  if (size > req->body.size || offset > req->body.size)
    return -1;

  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  int iov_index = MP_expand(conn, 0, false);
  struct iovec *iov = &conn->ios[iov_index];
  struct iovec *rec = &conn->rec[iov_index];
  rec->iov_base = req->body.ptr + offset;
  rec->iov_len = size;
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;
  conn->data_left += rec->iov_len;
  return 0;
}
/*
static inline int _HK_mem(size_t size, HKMem *mem) {
  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  bool once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  size_t nblocks = round_to_blocks(size);
  int iov_index = MP_expand(conn, nblocks, once);
  struct iovec *iov = &conn->ios[iov_index];
  mem->ptr = iov->iov_base;
  mem->size = iov->iov_len;
  mem->_iov_index = iov_index;
  mem->_flags = (IN_POOL(iov->iov_base)) ? CF_IN_POOL : CF_IN_HEAP;
  return 0;
}

static inline void _HK_send(HKMem *mem, size_t size) {
  conn_t *conn = current_send;
  struct iovec *iov = &conn->ios[mem->_iov_index];
  iov->iov_len = size;
  conn->data_left += size;
}
  */
#endif#define _GNU_SOURCE
#ifndef UTILS_H
#define UTILS_H

#include "hunk.h"
#include <arpa/inet.h>
#include <fcntl.h>
#include <liburing.h>
#include <netdb.h>
#include <signal.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/poll.h>
#include <sys/prctl.h>
#include <sys/socket.h>
#include <sys/sysinfo.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

#define MP_BLOCK  4
#define MAX_CONNS 4096
#define KB        1024
#define NIOS      32

#define IN_POOL(ptr)                 ((void *)ptr >= pool.bpool && (void *)ptr <= (pool.bpool + (pool.npages * pool.pagesize)))
#define ALIGN_TO_PAGESIZE(buff_size) (((buff_size) + (pool.pagesize - 1)) & ~(pool.pagesize - 1))
#define BYTES_TO_BLOCKS(buff_size)   (((buff_size) + (MP_BLOCK - 1)) / MP_BLOCK)
#define CEIL_BLOCKS(nblocks)         ((nblocks + 63) & ~63)
#define CEIL_PAGES(size)             (((size) + ((pool.pagesize) - 1)) & ~((pool.pagesize) - 1))

#define BIT_IS_FREE(word, bit)   (((word) >> (bit)) & 1)
#define MARK_BIT_USED(word, bit) ((word) &= ~(1ULL << (bit)))
#define MARK_BIT_FREE(word, bit) ((word) |= (1ULL << (bit)))
#define FIND_FREE_BIT(word)      ((uint64_t)(word) & -(uint64_t)(word))
#define STRLEN(s)                (sizeof(s) - 1)

#define IOVEC_NBLOCKS (BYTES_TO_BLOCKS(NIOS * sizeof(struct iovec)))
#define MSG_NBLOCKS   (BYTES_TO_BLOCKS(sizeof(struct msghdr)))
#define ZC_RES        KB *KB

#define DEBUG 0
#if DEBUG
#define LOG(...) fprintf(logfd, __VA_ARGS__)
#else
#define LOG(...) ((void)0)
#endif

typedef enum UOP {
  WRITEV = IORING_OP_WRITEV,
  SENDMSG = IORING_OP_SENDMSG,
  RECVMSG = IORING_OP_RECVMSG,
  ACCEPT = IORING_OP_ACCEPT,
  SEND = IORING_OP_SEND,
  RECV = IORING_OP_RECV,
  SENDZC = IORING_OP_SEND_ZC,
  SENDMSGZC = IORING_OP_SENDMSG_ZC,
  PEEK = 50,
  FRECVMSG,
  INSPLICE,
  OUTSPLICE
} UOP;

typedef enum CFS {
  CF_IN_POOL = (1 << 0),       // Connection is in the pool
  CF_IN_HEAP = (1 << 1),       // Connection is in the heap
  CF_SKIP_SOCK = (1 << 2),     // Don't close the socket
  CF_USE_ONCE = (1 << 3),      // Destroy after using
  CF_HANDLER_READY = (1 << 4), // Ready to call the handler
} CFS;

typedef struct conn_t {
  // Socket file descriptor
  int fd;

  // Amount of data left in the current operation
  uint64_t data_left;

  // The index of the connection struct
  uint32_t cindex;

  // The last time the connection was readable
  uint64_t last_read;

  // The last time the connection was writeable
  uint64_t last_write;

  // The operation currently being processed
  uint8_t op;

  // Connection flags
  int flags;

  // Splice fd_in
  int in_fd;

  // Splice fd_out
  int out_fd;

  void *recv_conn;
  void *send_conn;

  struct iovec *ios;
  struct iovec *rec;
  uint16_t nios;

  struct msghdr *msg;
  uint16_t zc_notifs;

  uint16_t head_size;
} conn_t;

typedef struct MPool {
  // The allocated pool of blocks
  void *bpool;

  // The allocated pool of connections
  conn_t *cpool;

  // The size of the pool in pages
  uint32_t npages;

  // The size of the pool in blocks
  uint32_t nblocks;

  // The locations of each page in the pool
  void **blocks;

  // The availability of each block
  uint64_t *freebs;

  // The locations of each conn in the pool
  conn_t **conns;

  // The availability of each conn
  uint64_t *freecs;

  // Clean up callback function
  void (*callback)(conn_t *conn);

  // The page size used
  uint32_t pagesize;

  // Socket read timeout
  uint32_t rtimeout;

  // Socket write timeout
  uint32_t wtimeout;
} MPool;

extern int pipe_sz;
extern int pipe_in, pipe_out, nullfd;
extern FILE *logfd;
extern struct io_uring ring;
extern MPool pool;
extern conn_t *current_recv;
extern conn_t *current_send;

/*
 * Prepare and submit a recv uring op
 */
static inline int urecv(conn_t *conn, void *buffer, size_t buff_size, int flags) {
  if (!conn || conn->fd == -1)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (flags == MSG_PEEK) ? PEEK : RECV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;

  io_uring_prep_recv(sqe, conn->fd, buffer, buff_size, flags);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a multi-shot accept uring op
 */
static inline int umaccept(int listenfd) {
  if (listenfd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = ACCEPT;
  io_uring_prep_multishot_accept(sqe, listenfd, NULL, NULL, SOCK_NONBLOCK);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a splice uring op
 */
static inline int usplice(conn_t *conn, int fd_in, int64_t off_in, int fd_out, int64_t off_out, size_t len) {
  if (!len || !conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = (__u64)conn;
  io_uring_prep_splice(sqe, fd_in, off_in, fd_out, off_out, len, 0);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a writev uring op
 */
static inline int uwritev(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = WRITEV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  io_uring_prep_writev(sqe, conn->fd, &conn->ios[iov_index], nios, -1);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a send uring op
 */
static inline int usend(conn_t *conn, char *res_buff, size_t buff_size, bool zc) {
  if (!conn || conn->fd <= 0 || buff_size == 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (zc) ? SENDZC : SEND;
  conn->data_left = buff_size;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  if (zc)
    io_uring_prep_send_zc(sqe, conn->fd, res_buff, buff_size, 0, 0);
  else
    io_uring_prep_send(sqe, conn->fd, res_buff, buff_size, 0);
  return io_uring_submit(&ring);
}

static inline int ufrecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = FRECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;

  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, rec->iov_len);
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int urecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = RECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int usendmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  bool zc = (conn->data_left > ZC_RES) ? true : false;
  conn->op = (zc) ? SENDMSGZC : SENDMSG;

  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  if (zc) {
    io_uring_prep_sendmsg_zc(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
    conn->zc_notifs++;
  } else {
    io_uring_prep_sendmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  }
  return io_uring_submit(&ring);
}

/*
 * Create and initialize a server socket
 */
static inline int tcp_listen(uint16_t port) {
  int enable;
  int listenfd;
  if ((listenfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    return -1;

  int flags = fcntl(listenfd, F_GETFL, 0);
  fcntl(listenfd, F_SETFL, flags | O_NONBLOCK);
  struct sockaddr_in servaddr;
  memset(&servaddr, 0, sizeof(servaddr));
  servaddr.sin_family = AF_INET;
  servaddr.sin_addr.s_addr = INADDR_ANY;
  servaddr.sin_port = htons(port);

  enable = 1;
  if (setsockopt(listenfd, SOL_SOCKET, SO_REUSEPORT, &enable, sizeof(enable)) < 0)
    return -1;

  if (bind(listenfd, (struct sockaddr *)&servaddr, sizeof(servaddr)) < 0)
    return -1;

  if (listen(listenfd, SOMAXCONN) < 0)
    return -1;

  return listenfd;
}

/*
 * Calculate the difference between two pointers
 */
static inline uintptr_t ptr_diff(uintptr_t p1, uintptr_t p2) { return (uintptr_t)(p1 > p2) ? (p1 - p2) : (p2 - p1); }

static inline size_t get_nroutes(Route *routes) {
  Route *route;
  for (size_t i = 0;; i++) {
    route = &routes[i];
    if (!route->path && !route->handler && !route->method)
      return i;
  }
}

static inline long get_content_length(char *src, char *end) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return -1;
    key = line;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, "Content-Length") != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;

    *line_end = '\0';
    long res = atol(value);
    *line_end = '\r';

    return res;
  }
  return -1;
}

static inline bool have_header(char *src, char *end, const char *header_key, const char *header_value) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    key = line;
    while (*key == ' ')
      key++;
    while (*header_key == ' ')
      header_key++;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return false;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, header_key) != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;
    while (*header_value == ' ')
      header_value++;

    *line_end = '\0';
    bool res = (strcasecmp(value, header_value) == 0);
    *line_end = '\r';

    return res;
  }

  return false;
}

static inline const char *method_str(Method method) {
  switch (method) {
  case GET:
    return "GET";
    break;
  case HEAD:
    return "HEAD";
    break;
  case POST:
    return "POST";
    break;
  case PUT:
    return "PUT";
    break;
  case DELETE:
    return "DELETE";
    break;
  case CONNECT:
    return "CONNECT";
    break;
  case OPTIONS:
    return "OPTIONS";
    break;
  case TRACE:
    return "TRACE";
    break;
  case PATCH:
    return "PATCH";
    break;
  default:
    return NULL;
  }
}

static inline uint8_t method_len(Method method) {
  switch (method) {
  case GET:
    return 3;
    break;
  case HEAD:
    return 4;
    break;
  case POST:
    return 4;
    break;
  case PUT:
    return 3;
    break;
  case DELETE:
    return 6;
    break;
  case CONNECT:
    return 7;
    break;
  case OPTIONS:
    return 7;
    break;
  case TRACE:
    return 5;
    break;
  case PATCH:
    return 5;
    break;
  default:
    return 0;
  }
}

static inline size_t round_to_blocks(size_t size) {
  size_t nblocks = BYTES_TO_BLOCKS(size);
  nblocks = CEIL_BLOCKS(nblocks);
  return nblocks;
}

/*
 * Count the digits in unsigned 64-bit int
 */
static inline int countd(uint64_t num) {
  if (num < 10ULL)
    return 1;
  if (num < 100ULL)
    return 2;
  if (num < 1000ULL)
    return 3;
  if (num < 10000ULL)
    return 4;
  if (num < 100000ULL)
    return 5;
  if (num < 1000000ULL)
    return 6;
  if (num < 10000000ULL)
    return 7;
  if (num < 100000000ULL)
    return 8;
  if (num < 1000000000ULL)
    return 9;
  if (num < 10000000000ULL)
    return 10;
  if (num < 100000000000ULL)
    return 11;
  if (num < 1000000000000ULL)
    return 12;
  if (num < 10000000000000ULL)
    return 13;
  if (num < 100000000000000ULL)
    return 14;
  if (num < 1000000000000000ULL)
    return 15;
  if (num < 10000000000000000ULL)
    return 16;
  if (num < 100000000000000000ULL)
    return 17;
  if (num < 1000000000000000000ULL)
    return 18;
  if (num < 10000000000000000000ULL)
    return 19;
  return 20;
}

/*
 * Get the time elabsed in ms
 */
static inline uint64_t get_time() {
  struct timespec ts;
  clock_gettime(CLOCK_MONOTONIC, &ts);
  return (uint64_t)(ts.tv_sec) * 1000 + (ts.tv_nsec / 1000000);
}

static inline FILE *log_init(const char *path) {
  FILE *res = fopen(path, "a+");
  setvbuf(res, NULL, _IONBF, 0);
  return res;
}

static inline int16_t pollevs(int connfd) {
  struct pollfd pfd;
  pfd.fd = connfd;
  pfd.events = POLLIN | POLLOUT | POLLERR;
  int res = poll(&pfd, 1, 0);
  if (res < 0)
    return POLLERR;
  return pfd.revents;
}

// FIXME This needs to be updated
static inline conn_t *MP_use_once(size_t nblocks, int fd) {

  void *mem = malloc(sizeof(conn_t) + 8 + (IOVEC_NBLOCKS * MP_BLOCK));
  struct conn_t *conn = (conn_t *)mem;
  memset(conn, 0, sizeof(conn_t));
  conn->ios = mem + sizeof(conn_t) + 8;

  if (nblocks > 0) {
    struct iovec *iov = &conn->ios[conn->nios++];
    mem = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (mem == MAP_FAILED)
      return NULL;
    iov->iov_base = mem;
    iov->iov_len = ALIGN_TO_PAGESIZE(nblocks * MP_BLOCK);
  }

  conn->flags |= CF_IN_HEAP;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;

  return conn;
}

static inline int find_freec() {
  uint64_t *word;
  size_t map_size = (sizeof(uint64_t) * 8);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    word = &pool.freecs[i / map_size];

    if (*word == 0) { // All used
      i += (map_size - 1);
      continue;
    }

    i += __builtin_ctzll(*word);
    MARK_BIT_USED(*word, i);
    return i;
  }

  return -1;
}

static inline int MP_init(size_t npages) {
  if (!npages)
    return -1;

  /*** Setup ***/
  pool.npages = npages;
  pool.pagesize = sysconf(_SC_PAGESIZE);

  /*** Pool ***/
  pool.bpool = mmap(NULL, pool.npages * pool.pagesize, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  if (pool.bpool == MAP_FAILED)
    return -1;
  pool.nblocks = (pool.npages * pool.pagesize) / MP_BLOCK;

  /*** Blocks ***/
  pool.blocks = malloc(sizeof(void *) * pool.nblocks);
  if (!pool.blocks)
    return -1;
  for (size_t i = 0; i < pool.nblocks; i++)
    pool.blocks[i] = pool.bpool + (i * MP_BLOCK);

  /*** Freebs ***/
  // if (posix_memalign((void **)&pool.freebs, 64, bitmap_size * sizeof(uint64_t)) < 0)
  size_t bitmap_size = (pool.nblocks + 63) / 64;
  pool.freebs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freebs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freebs[i] = UINT64_MAX;

  /*** Cpool ***/
  pool.cpool = (conn_t *)malloc(sizeof(conn_t) * MAX_CONNS);
  if (!pool.cpool)
    return -1;

  /*** Conns ***/
  pool.conns = (conn_t **)malloc(sizeof(conn_t *) * MAX_CONNS);
  if (!pool.conns)
    return -1;
  size_t conn_size = sizeof(conn_t);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    pool.conns[i] = (conn_t *)((char *)pool.cpool + (i * conn_size));
    pool.conns[i]->fd = -1;
    pool.conns[i]->in_fd = -1;
    pool.conns[i]->out_fd = -1;
  }

  /*** Freecs ***/
  bitmap_size = (MAX_CONNS + 63) / 64;
  pool.freecs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freecs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freecs[i] = UINT64_MAX;

  return 0;
}

static inline int MP_use_blks(size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t max_start = pool.nblocks - nblocks;
  size_t full_chunks = (nblocks / 64) * 64;

  for (size_t i = 0, c = 0; i <= max_start; i++, c++) {
    bool free = true;

    for (size_t j = 0; j < full_chunks; j += 64) {
      size_t word_index = (i + j) / 64;
      if (pool.freebs[word_index] != UINT64_MAX) {
        free = false;
        i += 63;
        break;
      }
    }

    for (size_t j = full_chunks; j < nblocks; j++) {
      size_t bit_index = i + j;
      size_t word_index = bit_index / 64;
      size_t bit_in_word = bit_index % 64;

      if (!BIT_IS_FREE(pool.freebs[word_index], bit_in_word)) {
        free = false;
        i += j;
        break;
      }
    }

    if (free) {
      for (size_t j = 0; j < full_chunks; j += 64) {
        size_t word_index = (i + j) / 64;
        pool.freebs[word_index] = 0;
      }

      for (size_t j = full_chunks; j < nblocks; j++) {
        size_t bit_index = i + j;
        size_t word_index = bit_index / 64;
        size_t bit_in_word = bit_index % 64;

        MARK_BIT_USED(pool.freebs[word_index], bit_in_word);
      }

      return i;
    }
  }

  return -1;
}

static inline int MP_free_blks(size_t bindex, size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t full_chunks = (nblocks / 64) * 64;
  for (size_t i = 0; i < full_chunks; i += 64) {
    size_t word_index = (bindex + i) / 64;
    pool.freebs[word_index] = UINT64_MAX;
  }

  for (size_t i = full_chunks; i < nblocks; i++) {
    size_t bit_index = bindex + i;
    size_t word_index = bit_index / 64;
    size_t bit_in_word = bit_index % 64;

    MARK_BIT_FREE(pool.freebs[word_index], bit_in_word);
  }

  memset(pool.blocks[bindex], 0, nblocks * MP_BLOCK);
  return 0;
}

static inline conn_t *MP_use(size_t nblocks, int fd, bool once) {
  if (fd <= 0)
    return NULL;
  if (once)
    return MP_use_once(nblocks, fd);

  int cindex = find_freec();
  if (cindex < 0) {
    LOG("Err: cindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  conn_t *conn = pool.conns[cindex];

  int ios_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (ios_bindex < 0) {
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }

  struct iovec *ios = pool.blocks[ios_bindex];
  conn->ios = ios;

  int rec_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (rec_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct iovec *rec = pool.blocks[rec_bindex];
  conn->rec = rec;

  int msg_bindex = MP_use_blks(MSG_NBLOCKS);
  if (msg_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct msghdr *msg = pool.blocks[msg_bindex];
  conn->msg = msg;

  if (nblocks > 0) {
    int bindex = MP_use_blks(nblocks);
    if (bindex < 0) {
      MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
      MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
      MP_free_blks(msg_bindex, IOVEC_NBLOCKS);
      MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
      LOG("Err: bindex < 0; will use MP_use_once\n");
      return MP_use_once(nblocks, fd);
    }

    size_t iov_index = conn->nios++;
    struct iovec *iov = &conn->ios[iov_index];
    struct iovec *rec = &conn->rec[iov_index];
    iov->iov_base = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
  }

  conn->msg->msg_iov = conn->ios;
  conn->msg->msg_iovlen = conn->nios;
  conn->cindex = cindex;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;
  return conn;
}

static inline void MP_shed(conn_t *conn, size_t iov_index, size_t nios) {
  struct iovec *iov, *rec;
  size_t bindex, nblocks, index;

  for (size_t i = 0; i < nios; i++) {
    index = iov_index + i;
    iov = &conn->ios[index];
    rec = &conn->rec[index];
    if (!rec || !rec->iov_base)
      continue;
    if (!IN_POOL(rec->iov_base)) {
      munmap(rec->iov_base, rec->iov_len / pool.pagesize);
    } else {
      bindex = ptr_diff((uintptr_t)rec->iov_base, (uintptr_t)pool.bpool) / MP_BLOCK;
      nblocks = rec->iov_len / MP_BLOCK;
      MP_free_blks(bindex, nblocks);
    }
    memset(iov, 0, sizeof(struct iovec));
    memset(rec, 0, sizeof(struct iovec));
    conn->nios--;
  }
}

static inline int MP_expand(conn_t *conn, size_t nblocks, bool once) {
  void *bptr;
  int iov_index, bindex;
  struct iovec *iov, *rec;

  iov_index = conn->nios++;
  iov = &conn->ios[iov_index];
  rec = &conn->rec[iov_index];

  if (nblocks == 0)
    return iov_index;

  if (once) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_base = bptr;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
    return iov_index;
  }

  bindex = MP_use_blks(nblocks);
  if (bindex < 0) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_len = iov->iov_len;
  } else {
    bptr = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_len = iov->iov_len;
  }

  iov->iov_base = bptr;
  rec->iov_base = iov->iov_base;
  return iov_index;
}

static inline int MP_free(conn_t *conn) {
  if (!conn)
    return -1;
  size_t bindex, nblocks;
  uint64_t *word;

  MP_shed(conn, 0, conn->nios);
  if (conn->flags & CF_IN_HEAP) {
    if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
      close(conn->fd);
    free(conn);
    return 0;
  }

  word = &pool.freecs[conn->cindex / 64];
  if (conn->cindex > MAX_CONNS)
    return -1;
  else if (BIT_IS_FREE(*word, conn->cindex))
    return 0;

  bindex = ptr_diff((uintptr_t)conn->ios, (uintptr_t)pool.bpool) / MP_BLOCK;
  nblocks = IOVEC_NBLOCKS;
  MP_free_blks(bindex, nblocks);

  bindex = ptr_diff((uintptr_t)conn->rec, (uintptr_t)pool.bpool) / MP_BLOCK;
  MP_free_blks(bindex, nblocks);

  if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
    close(conn->fd);

  MARK_BIT_FREE(*word, conn->cindex);
  memset(conn, 0, sizeof(conn_t));
  conn->fd = -1;
  conn->in_fd = -1;
  conn->out_fd = -1;
  return 0;
}

static inline void MP_clear(conn_t *conn) {
  conn_t *recv_conn = conn->recv_conn;
  conn_t *send_conn = conn->send_conn;
  if (recv_conn)
    MP_free(recv_conn);
  if (send_conn)
    MP_free(send_conn);
}

static inline void MP_exit(MPool *pool) {
  munmap(pool->bpool, pool->npages);
  free(pool->cpool);
  free(pool->blocks);
  free(pool->conns);
  free(pool->freebs);
  free(pool->freecs);
}

static inline void MP_timeout() {
  conn_t *conn;
  int16_t res;
  uint64_t now;
  size_t windex = 0;
  uint64_t *word = &pool.freecs[0];
  for (size_t i = 0; i < MAX_CONNS; i++) {
    if ((i / 64) < windex)
      word = &pool.freecs[++windex];

    if (*word == UINTMAX_MAX) {
      i = (i / 64) * 64 + 64;
      continue;
    }

    conn = pool.conns[i];
    if (!conn || conn->fd == -1)
      continue;

    res = pollevs(conn->fd);

    now = get_time();
    if (res & POLLERR) {
      MP_clear(conn);
      continue;
    }
    if (res & POLLIN) {
      if (pool.rtimeout > 0 && (now - conn->last_read) >= pool.rtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (res & POLLOUT) {
      if (pool.wtimeout > 0 && (now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (!(res & POLLIN || res & POLLOUT)) {
      if ((pool.rtimeout > 0 && now - conn->last_read) >= pool.rtimeout
          || (pool.wtimeout > 0 && now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
  }
}

/*
 * Calculate the length of a status string
 */
static inline size_t status_len(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return 8;
  case STATUSSWITCHINGPROTOCOLS:
    return 19;
  case STATUSPROCESSING:
    return 10;
  case STATUSEARLYHINTS:
    return 11;
  case STATUSOK:
    return 2;
  case STATUSCREATED:
    return 7;
  case STATUSACCEPTED:
    return 8;
  case STATUSNONAUTHORITATIVE:
    return 29;
  case STATUSNOCONTENT:
    return 10;
  case STATUSRESETCONTENT:
    return 13;
  case STATUSPARTIALCONTENT:
    return 15;
  case STATUSMULTISTATUS:
    return 12;
  case STATUSALREADYREPORTED:
    return 16;
  case STATUSIMUSED:
    return 7;
  case STATUSMULTIPLECHOICES:
    return 16;
  case STATUSMOVEDPERMANENTLY:
    return 17;
  case STATUSFOUND:
    return 5;
  case STATUSSEEOTHER:
    return 9;
  case STATUSNOTMODIFIED:
    return 12;
  case STATUSUSEPROXY:
    return 9;
  case STATUSTEMPORARYREDIRECT:
    return 18;
  case STATUSPERMANENTREDIRECT:
    return 18;
  case STATUSBADREQUEST:
    return 11;
  case STATUSUNAUTHORIZED:
    return 12;
  case STATUSPAYMENTREQUIRED:
    return 16;
  case STATUSFORBIDDEN:
    return 9;
  case STATUSNOTFOUND:
    return 9;
  case STATUSMETHODNOTALLOWED:
    return 18;
  case STATUSNOTACCEPTABLE:
    return 14;
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return 29;
  case STATUSREQUESTTIMEOUT:
    return 15;
  case STATUSCONFLICT:
    return 8;
  case STATUSGONE:
    return 4;
  case STATUSLENGTHREQUIRED:
    return 15;
  case STATUSPRECONDITIONFAILED:
    return 19;
  case CONTENTTOOLARGE:
    return 17;
  case STATUSURITOOLONG:
    return 12;
  case STATUSUNSUPPORTEDMEDIATYPE:
    return 22;
  case STATUSRANGENOTSATISFIABLE:
    return 21;
  case STATUSEXPECTATIONFAILED:
    return 18;
  case STATUSMISDIRECTEDREQUEST:
    return 19;
  case STATUSUNPROCESSABLECONTENT:
    return 21;
  case STATUSLOCKED:
    return 6;
  case STATUSFAILEDDEPENDENCY:
    return 17;
  case STATUSTOOEARLY:
    return 9;
  case STATUSUPGRADEREQUIRED:
    return 16;
  case STATUSPRECONDITIONREQUIRED:
    return 21;
  case STATUSTOOMANYREQUESTS:
    return 17;
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return 31;
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return 29;
  case STATUSInternalServerError:
    return 21;
  case STATUSNOTIMPLEMENTED:
    return 15;
  case STATUSBADGATEWAY:
    return 11;
  case STATUSSERVICEUNAVAILABLE:
    return 19;
  case STATUSGATEWAYTIMEOUT:
    return 15;
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return 26;
  case STATUSVARIANTALSONEGOTIATES:
    return 23;
  case STATUSINSUFFICIENTSTORAGE:
    return 20;
  case STATUSLOOPDETECTED:
    return 13;
  case STATUSNOTEXTENDED:
    return 12;
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return 31;
  default:
    return 0;
  }
}

/*
 * Return the status code string as string literal
 */
static inline char *status_str(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return "Continue";
  case STATUSSWITCHINGPROTOCOLS:
    return "Switching Protocols";
  case STATUSPROCESSING:
    return "Processing";
  case STATUSEARLYHINTS:
    return "Early Hints";
  case STATUSOK:
    return "OK";
  case STATUSCREATED:
    return "Created";
  case STATUSACCEPTED:
    return "Accepted";
  case STATUSNONAUTHORITATIVE:
    return "Non-Authoritative Information";
  case STATUSNOCONTENT:
    return "No Content";
  case STATUSRESETCONTENT:
    return "Reset Content";
  case STATUSPARTIALCONTENT:
    return "Partial Content";
  case STATUSMULTISTATUS:
    return "Multi-Status";
  case STATUSALREADYREPORTED:
    return "Already Reported";
  case STATUSIMUSED:
    return "Im Used";
  case STATUSMULTIPLECHOICES:
    return "Multiple Choices";
  case STATUSMOVEDPERMANENTLY:
    return "Moved Permanently";
  case STATUSFOUND:
    return "Found";
  case STATUSSEEOTHER:
    return "See Other";
  case STATUSNOTMODIFIED:
    return "Not Modified";
  case STATUSUSEPROXY:
    return "Use Proxy";
  case STATUSTEMPORARYREDIRECT:
    return "Temporary Redirect";
  case STATUSPERMANENTREDIRECT:
    return "Permanent Redirect";
  case STATUSBADREQUEST:
    return "Bad Request";
  case STATUSUNAUTHORIZED:
    return "Unauthorized";
  case STATUSPAYMENTREQUIRED:
    return "Payment Required";
  case STATUSFORBIDDEN:
    return "Forbidden";
  case STATUSNOTFOUND:
    return "Not Found";
  case STATUSMETHODNOTALLOWED:
    return "Method Not Allowed";
  case STATUSNOTACCEPTABLE:
    return "Not Acceptable";
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return "Proxy Authentication Required";
  case STATUSREQUESTTIMEOUT:
    return "Request Timeout";
  case STATUSCONFLICT:
    return "Conflict";
  case STATUSGONE:
    return "Gone";
  case STATUSLENGTHREQUIRED:
    return "Length Required";
  case STATUSPRECONDITIONFAILED:
    return "Precondition Failed";
  case CONTENTTOOLARGE:
    return "Content Too Large";
  case STATUSURITOOLONG:
    return "URI Too Long";
  case STATUSUNSUPPORTEDMEDIATYPE:
    return "Unsupported Media Type";
  case STATUSRANGENOTSATISFIABLE:
    return "Range Not Satisfiable";
  case STATUSEXPECTATIONFAILED:
    return "Expectation Failed";
  case STATUSMISDIRECTEDREQUEST:
    return "Misdirected Request";
  case STATUSUNPROCESSABLECONTENT:
    return "Unprocessable Content";
  case STATUSLOCKED:
    return "Locked";
  case STATUSFAILEDDEPENDENCY:
    return "Failed Dependency";
  case STATUSTOOEARLY:
    return "Too Early";
  case STATUSUPGRADEREQUIRED:
    return "Upgrade Required";
  case STATUSPRECONDITIONREQUIRED:
    return "Precondition Required";
  case STATUSTOOMANYREQUESTS:
    return "Too Many Requests";
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return "Request Header Fields Too Large";
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return "Unavailable For Legal Reasons";
  case STATUSInternalServerError:
    return "Internal Server Error";
  case STATUSNOTIMPLEMENTED:
    return "Not Implemented";
  case STATUSBADGATEWAY:
    return "Bad Gateway";
  case STATUSSERVICEUNAVAILABLE:
    return "Service Unavailable";
  case STATUSGATEWAYTIMEOUT:
    return "Gateway Timeout";
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return "HTTP Version Not Supported";
  case STATUSVARIANTALSONEGOTIATES:
    return "Variant Also Negotiates";
  case STATUSINSUFFICIENTSTORAGE:
    return "Insufficient Storage";
  case STATUSLOOPDETECTED:
    return "Loop Detected";
  case STATUSNOTEXTENDED:
    return "Not Extended";
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return "Network Authentication Required";
  default:
    return 0;
  }
}

/*
 * Return true if routes match
 */
static inline bool route_equ(Route *route, Request *req) {
  return route->method == req->method && strncmp(route->path, req->path, strlen(route->path)) == 0;
}

/*
 * Return the matching route index on success. -1 on failure
 */
static inline int match_route(Server *serv, Request *req) {
  for (size_t i = 0; i < serv->_nroutes; i++) {
    Route route = serv->routes[i];
    if (!req->path || !route.path)
      continue;
    if (route_equ(&route, req))
      return i;
    else if (req->method == HEAD && route.method == GET && strcmp(route.path, req->path) == 0)
      return i;
  }
  return -1;
}

/*
 * Return true if the response should contain the Content-Length header
 */
static inline bool should_have_content_length(Request *req, ResWriter *res) {
  return (req->method != CONNECT              // CONNECT request
          && res->status != STATUSNOCONTENT   // 204 response
          && res->status != STATUSNOTMODIFIED // 304 response
          && res->status >= 200);             // 1xx response
}

/*
 * Format http response from the ResWriter.
 * Return response size on success, 0 on failure.
 */
static inline size_t fmt_res(Request *req, ResWriter *res, char *buffer, size_t buffer_size) {
  if (!res || !buffer || buffer_size == 0)
    return 0;

  size_t res_len, total = 0;
  char *dst = buffer;
  size_t maxlen = buffer_size;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t body_length = res->len;

  res_len = snprintf(dst, maxlen, "HTTP/1.1 %d %s", (int)res->status, status_str(res->status));
  total += res_len;
  dst += res_len;
  maxlen -= res_len;

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    res_len = snprintf(dst, maxlen, "\r\n%s: %s", header->key, header->value);
    total += res_len;
    dst += res_len;
    maxlen -= res_len;
  }

  if (have_content_length) {
    res_len = snprintf(dst, maxlen, "\r\nContent-Length: %lu", body_length);
    total += res_len, dst += res_len, maxlen -= res_len;
  }

  memcpy(dst, "\r\n\r\n", 4);
  total += 4, dst += 4, maxlen -= 4;

  return total;
}

static inline size_t res_len(Request *req, ResWriter *res) {
  if (!req || !res)
    return 0;

  if (!res->status)
    res->status = STATUSOK;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t result = 0;
  result += STRLEN("HTTP/1.1 ");     // HTTP version
  result += 4;                       // Status code + space
  result += status_len(res->status); // Status name

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    result += 2;                       // "\r\n"
    result += strlen(header->key) + 2; // Header key + ':' + space
    result += strlen(header->value);   // header value
  }

  if (have_content_length) {
    result += 2;                          // "\r\n"
    result += STRLEN("Content-Length: "); // Header key
    result += countd(res->len);           // Header value
  }

  result += 4; // "\r\n\r\n"

  return result;
}

static inline int send_empty_res(Status status) {
  size_t res_len = STRLEN("HTTP/1.1 ")        // HTTP version
                   + countd((uint64_t)status) // status code
                   + 1                        // space
                   + (int)status_len(status)  // status string
                   + 4;                       // \r\n\r\n

  conn_t *conn = current_send;
  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, res_len);
  if (snprintf((char *)rec->iov_base, res_len + 1, "HTTP/1.1 %d %s\r\n\r\n", (int)status, status_str(status))
      != (int)res_len)
    return -1;

  return usendmsg(conn, 0, 1);
}

static inline ssize_t read_socket(int sockfd, size_t len) {
  if (len == 0 || sockfd <= 0)
    return 0;
  char buff[1024 * 8];
  return read(sockfd, buff, 1024 * 8);
}

static inline int read_method(Method *method, void *src) {
  if (memcmp(src, "GET", 3) == 0)
    *method = GET;
  else if (memcmp(src, "POST", 4) == 0)
    *method = POST;
  else if (memcmp(src, "HEAD", 4) == 0)
    *method = HEAD;
  else if (memcmp(src, "PUT", 3) == 0)
    *method = PUT;
  else if (memcmp(src, "DELETE", 6) == 0)
    *method = DELETE;
  else if (memcmp(src, "CONNECT", 7) == 0)
    *method = CONNECT;
  else if (memcmp(src, "OPTIONS", 7) == 0)
    *method = OPTIONS;
  else if (memcmp(src, "TRACE", 5) == 0)
    *method = TRACE;
  else if (memcmp(src, "PATCH", 5) == 0)
    *method = PATCH;
  else
    return -1;

  return 0;
}

static inline int sendmsg_res(Request *req, ResWriter *res) {
  conn_t *conn;
  size_t head_size, res_size;
  struct iovec *iov;

  conn = current_send;
  iov = &conn->ios[0];
  head_size = res_len(req, res);
  if (head_size == 0)
    return -1;

  conn->data_left += head_size;
  res_size = fmt_res(req, res, iov->iov_base, (head_size + 1));
  if (res_size != head_size)
    return -1;
  iov->iov_len = res_size;

  return usendmsg(conn, 0, conn->nios);
}

static inline int read_req(Request *req, char *req_buffer) {
  if (!req_buffer)
    return -1;
  /*** Method ***/
  char *sep = strchr(req_buffer, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }
  *sep = '\0';
  if (read_method(&req->method, req_buffer) < 0)
    return -1;

  /*** Path ***/
  char *fullpath = sep + 1;
  sep = strchr(fullpath, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }

  *sep = '\0';
  req->path = fullpath;
  /*** Params ***/
  char *paramStart = strchr(fullpath, '?');
  if (paramStart) {
    *paramStart++ = '\0';
    int params_count = 0;
    params_count = HK_parse_params(paramStart, req->params, MAX_URL_PARAMETERS);
    if (params_count > 0)
      req->params_count = params_count;
    else
      req->params_count = 0;
  } else {
    req->params = NULL;
    req->params_count = 0;
  }

  /*** Headers ***/
  char *headStart = strstr(sep + 1, "\r\n");
  char *headEnd = strstr(sep + 1, "\r\n\r\n");
  if (!headStart) {
    LOG("read_req: !headStart\n");
    return -1;
  };

  memset(headStart, 0, 2);
  headStart += 2;
  memset(headEnd, 0, 4);
  headEnd += 4;

  int headers_count = HK_parse_headers(headStart, req->headers, MAX_REQ_HEADERS);
  if (headers_count <= 0)
    return -1;
  req->headers_count = headers_count;

  /*** Host ***/
  int index = HK_get_header(req, "Host");
  if (index < 0)
    return -1;
  char *host = req->headers[index].value;
  req->hostname = host;

  /*** Port ***/
  char *colon = strchr(host, ':');
  if (colon) {
    *colon++ = '\0';
    req->port = atoi(colon);
  } else {
    req->port = PORT;
  }
  return 0;
}
static inline int process_req(Server *serv, conn_t *conn) {
  if (!conn || conn->fd == -1)
    return -1;

  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;
  if (read_req(&req, conn->ios[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    LOG("Err: route_index == -1\n");
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;
  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  sendmsg_res(&req, &res);

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int new_conn(int connfd) {
  if (connfd <= 0)
    return -1;

  current_recv = MP_use(KB * 2, connfd, false);
  current_send = MP_use(KB * 2, connfd, false);

  current_recv->recv_conn = current_recv;
  current_recv->send_conn = current_send;

  current_send->send_conn = current_send;
  current_send->recv_conn = current_recv;

  conn_t *conn = current_recv;
  if (ufrecvmsg(conn, 0, 1) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

static inline int resubmit_sendmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return usendmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int resubmir_recvmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    // FIXME the len should be increased
    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return urecvmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int handle_sendmsg_complete(conn_t *conn) {
  struct iovec *iov, *rec;

  MP_shed(conn, 1, conn->nios - 1);
  iov = &conn->ios[0];
  rec = &conn->rec[0];
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;

  return ufrecvmsg(conn->recv_conn, 0, 1);
}

static inline int handle_sendmsg(conn_t *conn, int res, bool zc) {
  if (!conn || conn->fd == -1)
    return -1;

  conn->data_left -= res;
  if (conn->data_left > 0)
    return resubmit_sendmsg(conn, res);

  if (zc)
    return 0;

  return handle_sendmsg_complete(conn);
}

static inline int handle_insplice(conn_t *conn) {
  conn->op = OUTSPLICE;
  return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
}
static inline int handle_outsplice(conn_t *conn, int res) {
  conn->data_left -= res;
  if (conn->data_left > 0) {
    conn->op = INSPLICE;
    return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
  }

  conn_t *recv_conn = conn->recv_conn;
  struct iovec *iov = &recv_conn->ios[0];
  memset(iov->iov_base, 0, iov->iov_len);
  if (urecv(recv_conn, iov->iov_base, iov->iov_len, MSG_PEEK) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

/*
static inline int handle_recv(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  void *bptr = conn->ios[0].iov_base;
  void *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  void *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  return process_req(serv, conn);
}
*/
static inline int find_route(Server *serv, char *bptr) {
  Request req = {0};
  if (read_method(&req.method, bptr) < 0) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  };
  char *space = strchr(bptr, ' ');
  req.path = (space + 1);
  space = strchr(req.path, ' ');
  *space = '\0';
  int route_index = match_route(serv, &req);
  *space = ' ';
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }
  return route_index;
}

static inline int run_handler(Server *serv, conn_t *conn, bool uses_body) {
  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;

  if (read_req(&req, conn->rec[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  if (uses_body) {
    int h_index = HK_get_header(&req, "Content-Length");
    long body_size = atol(req.headers[h_index].value);
    if (body_size >= 0) {
      req.body.ptr = conn->rec[1].iov_base;
      req.body.size = body_size;
    } else {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    }
  }

  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  if (sendmsg_res(&req, &res) < 0)
    return -1;

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int handle_frecvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  char *bptr = (char *)conn->ios[0].iov_base;
  char *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  char *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  size_t head_size = (headEnd + 4) - bptr;
  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  int route_index = find_route(serv, bptr);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  bool uses_body = serv->routes[route_index].uses_body;
  long body_size = get_content_length(headstart + 2, headEnd + 4);
  if (body_size == -1) {
    if (uses_body) {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    } else {
      body_size = 0;
    }
  }

  conn->head_size = head_size;
  if (!uses_body) {
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  if (res == (int)(head_size + body_size)) {
    size_t iov_index = MP_expand(conn, round_to_blocks(body_size), false);
    memcpy(conn->rec[iov_index].iov_base, headEnd + 4, body_size);
    conn->ios[iov_index].iov_len = body_size;
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  conn->data_left = body_size - (res - head_size);
  bool once = ((size_t)body_size > (size_t)((pool.nblocks * MP_BLOCK) / 10));
  size_t iov_index = MP_expand(conn, round_to_blocks(body_size), once);
  memcpy(conn->rec[iov_index].iov_base, headEnd + 4, (res - head_size));
  conn->ios[iov_index].iov_base += (res - head_size);

  return urecvmsg(conn, iov_index, 1);
}

static inline int handle_recvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  if (conn->data_left > 0) {
    conn->data_left -= res;
    if (conn->data_left == 0) {
      conn->flags &= CF_HANDLER_READY;
      return run_handler(serv, conn, true);
    }

    conn->flags &= ~CF_HANDLER_READY;
    conn->ios[1].iov_base += res;
    return urecvmsg(conn, 1, 1);
  }

  conn->flags &= CF_HANDLER_READY;
  return run_handler(serv, conn, true);
}

static inline int serv_init(Server *serv) {
#if DEBUG
  logfd = log_init("log.txt");
  if (!logfd) {
    printf("log_init failed");
    return -1;
  }
#endif
  serv->_nroutes = get_nroutes(serv->routes);

  int pipefd[2];
  if (pipe(pipefd) < 0)
    return -1;
  pipe_in = pipefd[0];
  pipe_out = pipefd[1];
  nullfd = open("/dev/null", O_WRONLY);
  pipe_sz = fcntl(pipefd[0], F_GETPIPE_SZ);
  if (pipe_sz < 0)
    return -1;

  pool.rtimeout = serv->rtimeout;
  pool.wtimeout = serv->wtimeout;
  if (MP_init(MAX_CONNS * 8) < 0)
    return -1;
  LOG("pool initialized\n");

  if (io_uring_queue_init(MAX_CONNS, &ring, 0) < 0)
    return -1;
  LOG("uring initialized\n");

  int listenfd;
  if ((listenfd = tcp_listen(serv->port)) < 0)
    return -1;
  LOG("socket initialized\n");

  return umaccept(listenfd);
}

static inline int serv_listen(Server *serv) {
  // uint64_t last_check = get_time();
  while (true) {
    // uint64_t now = get_time();
    // if ((now - last_check) >= 200) {
    //   last_check = now;
    //   LOG("CM: CM_check ran\n");
    //   MP_timeout();
    // }

    LOG("SQ ready: %u, CQ ready: %u\n", io_uring_sq_ready(&ring), io_uring_cq_ready(&ring));
    struct io_uring_cqe *cqe;
    if (io_uring_wait_cqe(&ring, &cqe) < 0)
      continue;

    int res = cqe->res;
    LOG("res = %d\n", res);
    conn_t *conn = NULL;
    if (cqe->user_data > 100) {
      conn = (conn_t *)cqe->user_data;
      current_recv = (conn_t *)conn->recv_conn;
      current_send = (conn_t *)conn->send_conn;
    }

    if (res > 0) {
      if (cqe->user_data == ACCEPT) {
        LOG("new conn created\n");
        new_conn(res);
      } else if (conn && conn->fd != -1) {
        LOG("conn[%d]: conn.fd = %d; conn.op = %d\n", conn->cindex, conn->fd, conn->op);
        switch (conn->op) {
        case FRECVMSG:
          if (handle_frecvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case RECVMSG:
          if (handle_recvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case SENDMSG:
        case SENDMSGZC:
          // conn->last_write = get_time();
          bool zc = (conn->op == SENDMSGZC);
          if (handle_sendmsg(conn, res, zc) < 0)
            MP_clear(conn);
          break;
        case INSPLICE:
          if (handle_insplice(conn) < 0)
            MP_clear(conn);
          break;
        case OUTSPLICE:
          if (handle_outsplice(conn, res) < 0)
            MP_clear(conn);
          break;
        }
      }
    } else if (res == 0) {
      if (conn && conn->fd != -1) {
        switch (conn->op) {
        case SENDMSGZC:
          conn->zc_notifs--;
          if (conn->zc_notifs == 0 && handle_sendmsg_complete(conn) < 0)
            MP_clear(conn);
          break;
        case RECV:
          MP_clear(conn);
          break;
        }
      }
    } else {
      if (conn && conn->fd != -1) {
        if (res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR) {
          LOG("conn && conn->fd != -1 && res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR\n");
          MP_clear(conn);
        } else {
          LOG("res == -EAGAIN || res == -EWOULDBLOCK || res == -EINTR\n");
          conn = conn->recv_conn;
          struct iovec *iov = &conn->ios[0];
          memset(iov->iov_base, 0, iov->iov_len);
          if (urecv(conn, iov->iov_base, iov->iov_len, 0) < 0)
            MP_clear(conn);
        }
      }
    }

    LOG("uring operation seen\n");
    io_uring_cqe_seen(&ring, cqe);
  }

  io_uring_queue_exit(&ring);
  MP_exit(&pool);
  return 0;
}

/*** Helper ***/
static inline int _HK_write(void *data, size_t size) {
  size_t nblocks;
  int iov_index;
  conn_t *conn;
  struct iovec *iov;
  bool once;

  conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  nblocks = round_to_blocks(size);
  iov_index = MP_expand(conn, nblocks, once);
  iov = &conn->ios[iov_index];

  memcpy(iov->iov_base, data, size);
  iov->iov_len = size;
  conn->data_left += size;

  return 0;
}
static inline int _HK_write_body(Request *req, size_t offset, size_t size) {
  if (size > req->body.size || offset > req->body.size)
    return -1;

  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  int iov_index = MP_expand(conn, 0, false);
  struct iovec *iov = &conn->ios[iov_index];
  struct iovec *rec = &conn->rec[iov_index];
  rec->iov_base = req->body.ptr + offset;
  rec->iov_len = size;
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;
  conn->data_left += rec->iov_len;
  return 0;
}
/*
static inline int _HK_mem(size_t size, HKMem *mem) {
  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  bool once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  size_t nblocks = round_to_blocks(size);
  int iov_index = MP_expand(conn, nblocks, once);
  struct iovec *iov = &conn->ios[iov_index];
  mem->ptr = iov->iov_base;
  mem->size = iov->iov_len;
  mem->_iov_index = iov_index;
  mem->_flags = (IN_POOL(iov->iov_base)) ? CF_IN_POOL : CF_IN_HEAP;
  return 0;
}

static inline void _HK_send(HKMem *mem, size_t size) {
  conn_t *conn = current_send;
  struct iovec *iov = &conn->ios[mem->_iov_index];
  iov->iov_len = size;
  conn->data_left += size;
}
  */
#endif
#define _GNU_SOURCE
#ifndef UTILS_H
#define UTILS_H

#include "hunk.h"
#include <arpa/inet.h>
#include <fcntl.h>
#include <liburing.h>
#include <netdb.h>
#include <signal.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/poll.h>
#include <sys/prctl.h>
#include <sys/socket.h>
#include <sys/sysinfo.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

#define MP_BLOCK  4
#define MAX_CONNS 4096
#define KB        1024
#define NIOS      32

#define IN_POOL(ptr)                 ((void *)ptr >= pool.bpool && (void *)ptr <= (pool.bpool + (pool.npages * pool.pagesize)))
#define ALIGN_TO_PAGESIZE(buff_size) (((buff_size) + (pool.pagesize - 1)) & ~(pool.pagesize - 1))
#define BYTES_TO_BLOCKS(buff_size)   (((buff_size) + (MP_BLOCK - 1)) / MP_BLOCK)
#define CEIL_BLOCKS(nblocks)         ((nblocks + 63) & ~63)
#define CEIL_PAGES(size)             (((size) + ((pool.pagesize) - 1)) & ~((pool.pagesize) - 1))

#define BIT_IS_FREE(word, bit)   (((word) >> (bit)) & 1)
#define MARK_BIT_USED(word, bit) ((word) &= ~(1ULL << (bit)))
#define MARK_BIT_FREE(word, bit) ((word) |= (1ULL << (bit)))
#define FIND_FREE_BIT(word)      ((uint64_t)(word) & -(uint64_t)(word))
#define STRLEN(s)                (sizeof(s) - 1)

#define IOVEC_NBLOCKS (BYTES_TO_BLOCKS(NIOS * sizeof(struct iovec)))
#define MSG_NBLOCKS   (BYTES_TO_BLOCKS(sizeof(struct msghdr)))
#define ZC_RES        KB *KB

#define DEBUG 0
#if DEBUG
#define LOG(...) fprintf(logfd, __VA_ARGS__)
#else
#define LOG(...) ((void)0)
#endif

typedef enum UOP {
  WRITEV = IORING_OP_WRITEV,
  SENDMSG = IORING_OP_SENDMSG,
  RECVMSG = IORING_OP_RECVMSG,
  ACCEPT = IORING_OP_ACCEPT,
  SEND = IORING_OP_SEND,
  RECV = IORING_OP_RECV,
  SENDZC = IORING_OP_SEND_ZC,
  SENDMSGZC = IORING_OP_SENDMSG_ZC,
  PEEK = 50,
  FRECVMSG,
  INSPLICE,
  OUTSPLICE
} UOP;

typedef enum CFS {
  CF_IN_POOL = (1 << 0),       // Connection is in the pool
  CF_IN_HEAP = (1 << 1),       // Connection is in the heap
  CF_SKIP_SOCK = (1 << 2),     // Don't close the socket
  CF_USE_ONCE = (1 << 3),      // Destroy after using
  CF_HANDLER_READY = (1 << 4), // Ready to call the handler
} CFS;

typedef struct conn_t {
  // Socket file descriptor
  int fd;

  // Amount of data left in the current operation
  uint64_t data_left;

  // The index of the connection struct
  uint32_t cindex;

  // The last time the connection was readable
  uint64_t last_read;

  // The last time the connection was writeable
  uint64_t last_write;

  // The operation currently being processed
  uint8_t op;

  // Connection flags
  int flags;

  // Splice fd_in
  int in_fd;

  // Splice fd_out
  int out_fd;

  void *recv_conn;
  void *send_conn;

  struct iovec *ios;
  struct iovec *rec;
  uint16_t nios;

  struct msghdr *msg;
  uint16_t zc_notifs;

  uint16_t head_size;
} conn_t;

typedef struct MPool {
  // The allocated pool of blocks
  void *bpool;

  // The allocated pool of connections
  conn_t *cpool;

  // The size of the pool in pages
  uint32_t npages;

  // The size of the pool in blocks
  uint32_t nblocks;

  // The locations of each page in the pool
  void **blocks;

  // The availability of each block
  uint64_t *freebs;

  // The locations of each conn in the pool
  conn_t **conns;

  // The availability of each conn
  uint64_t *freecs;

  // Clean up callback function
  void (*callback)(conn_t *conn);

  // The page size used
  uint32_t pagesize;

  // Socket read timeout
  uint32_t rtimeout;

  // Socket write timeout
  uint32_t wtimeout;
} MPool;

extern int pipe_sz;
extern int pipe_in, pipe_out, nullfd;
extern FILE *logfd;
extern struct io_uring ring;
extern MPool pool;
extern conn_t *current_recv;
extern conn_t *current_send;

/*
 * Prepare and submit a recv uring op
 */
static inline int urecv(conn_t *conn, void *buffer, size_t buff_size, int flags) {
  if (!conn || conn->fd == -1)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (flags == MSG_PEEK) ? PEEK : RECV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;

  io_uring_prep_recv(sqe, conn->fd, buffer, buff_size, flags);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a multi-shot accept uring op
 */
static inline int umaccept(int listenfd) {
  if (listenfd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = ACCEPT;
  io_uring_prep_multishot_accept(sqe, listenfd, NULL, NULL, SOCK_NONBLOCK);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a splice uring op
 */
static inline int usplice(conn_t *conn, int fd_in, int64_t off_in, int fd_out, int64_t off_out, size_t len) {
  if (!len || !conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = (__u64)conn;
  io_uring_prep_splice(sqe, fd_in, off_in, fd_out, off_out, len, 0);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a writev uring op
 */
static inline int uwritev(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = WRITEV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  io_uring_prep_writev(sqe, conn->fd, &conn->ios[iov_index], nios, -1);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a send uring op
 */
static inline int usend(conn_t *conn, char *res_buff, size_t buff_size, bool zc) {
  if (!conn || conn->fd <= 0 || buff_size == 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (zc) ? SENDZC : SEND;
  conn->data_left = buff_size;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  if (zc)
    io_uring_prep_send_zc(sqe, conn->fd, res_buff, buff_size, 0, 0);
  else
    io_uring_prep_send(sqe, conn->fd, res_buff, buff_size, 0);
  return io_uring_submit(&ring);
}

static inline int ufrecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = FRECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;

  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, rec->iov_len);
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int urecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = RECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int usendmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  bool zc = (conn->data_left > ZC_RES) ? true : false;
  conn->op = (zc) ? SENDMSGZC : SENDMSG;

  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  if (zc) {
    io_uring_prep_sendmsg_zc(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
    conn->zc_notifs++;
  } else {
    io_uring_prep_sendmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  }
  return io_uring_submit(&ring);
}

/*
 * Create and initialize a server socket
 */
static inline int tcp_listen(uint16_t port) {
  int enable;
  int listenfd;
  if ((listenfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    return -1;

  int flags = fcntl(listenfd, F_GETFL, 0);
  fcntl(listenfd, F_SETFL, flags | O_NONBLOCK);
  struct sockaddr_in servaddr;
  memset(&servaddr, 0, sizeof(servaddr));
  servaddr.sin_family = AF_INET;
  servaddr.sin_addr.s_addr = INADDR_ANY;
  servaddr.sin_port = htons(port);

  enable = 1;
  if (setsockopt(listenfd, SOL_SOCKET, SO_REUSEPORT, &enable, sizeof(enable)) < 0)
    return -1;

  if (bind(listenfd, (struct sockaddr *)&servaddr, sizeof(servaddr)) < 0)
    return -1;

  if (listen(listenfd, SOMAXCONN) < 0)
    return -1;

  return listenfd;
}

/*
 * Calculate the difference between two pointers
 */
static inline uintptr_t ptr_diff(uintptr_t p1, uintptr_t p2) { return (uintptr_t)(p1 > p2) ? (p1 - p2) : (p2 - p1); }

static inline size_t get_nroutes(Route *routes) {
  Route *route;
  for (size_t i = 0;; i++) {
    route = &routes[i];
    if (!route->path && !route->handler && !route->method)
      return i;
  }
}

static inline long get_content_length(char *src, char *end) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return -1;
    key = line;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, "Content-Length") != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;

    *line_end = '\0';
    long res = atol(value);
    *line_end = '\r';

    return res;
  }
  return -1;
}

static inline bool have_header(char *src, char *end, const char *header_key, const char *header_value) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    key = line;
    while (*key == ' ')
      key++;
    while (*header_key == ' ')
      header_key++;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return false;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, header_key) != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;
    while (*header_value == ' ')
      header_value++;

    *line_end = '\0';
    bool res = (strcasecmp(value, header_value) == 0);
    *line_end = '\r';

    return res;
  }

  return false;
}

static inline const char *method_str(Method method) {
  switch (method) {
  case GET:
    return "GET";
    break;
  case HEAD:
    return "HEAD";
    break;
  case POST:
    return "POST";
    break;
  case PUT:
    return "PUT";
    break;
  case DELETE:
    return "DELETE";
    break;
  case CONNECT:
    return "CONNECT";
    break;
  case OPTIONS:
    return "OPTIONS";
    break;
  case TRACE:
    return "TRACE";
    break;
  case PATCH:
    return "PATCH";
    break;
  default:
    return NULL;
  }
}

static inline uint8_t method_len(Method method) {
  switch (method) {
  case GET:
    return 3;
    break;
  case HEAD:
    return 4;
    break;
  case POST:
    return 4;
    break;
  case PUT:
    return 3;
    break;
  case DELETE:
    return 6;
    break;
  case CONNECT:
    return 7;
    break;
  case OPTIONS:
    return 7;
    break;
  case TRACE:
    return 5;
    break;
  case PATCH:
    return 5;
    break;
  default:
    return 0;
  }
}

static inline size_t round_to_blocks(size_t size) {
  size_t nblocks = BYTES_TO_BLOCKS(size);
  nblocks = CEIL_BLOCKS(nblocks);
  return nblocks;
}

/*
 * Count the digits in unsigned 64-bit int
 */
static inline int countd(uint64_t num) {
  if (num < 10ULL)
    return 1;
  if (num < 100ULL)
    return 2;
  if (num < 1000ULL)
    return 3;
  if (num < 10000ULL)
    return 4;
  if (num < 100000ULL)
    return 5;
  if (num < 1000000ULL)
    return 6;
  if (num < 10000000ULL)
    return 7;
  if (num < 100000000ULL)
    return 8;
  if (num < 1000000000ULL)
    return 9;
  if (num < 10000000000ULL)
    return 10;
  if (num < 100000000000ULL)
    return 11;
  if (num < 1000000000000ULL)
    return 12;
  if (num < 10000000000000ULL)
    return 13;
  if (num < 100000000000000ULL)
    return 14;
  if (num < 1000000000000000ULL)
    return 15;
  if (num < 10000000000000000ULL)
    return 16;
  if (num < 100000000000000000ULL)
    return 17;
  if (num < 1000000000000000000ULL)
    return 18;
  if (num < 10000000000000000000ULL)
    return 19;
  return 20;
}

/*
 * Get the time elabsed in ms
 */
static inline uint64_t get_time() {
  struct timespec ts;
  clock_gettime(CLOCK_MONOTONIC, &ts);
  return (uint64_t)(ts.tv_sec) * 1000 + (ts.tv_nsec / 1000000);
}

static inline FILE *log_init(const char *path) {
  FILE *res = fopen(path, "a+");
  setvbuf(res, NULL, _IONBF, 0);
  return res;
}

static inline int16_t pollevs(int connfd) {
  struct pollfd pfd;
  pfd.fd = connfd;
  pfd.events = POLLIN | POLLOUT | POLLERR;
  int res = poll(&pfd, 1, 0);
  if (res < 0)
    return POLLERR;
  return pfd.revents;
}

// FIXME This needs to be updated
static inline conn_t *MP_use_once(size_t nblocks, int fd) {

  void *mem = malloc(sizeof(conn_t) + 8 + (IOVEC_NBLOCKS * MP_BLOCK));
  struct conn_t *conn = (conn_t *)mem;
  memset(conn, 0, sizeof(conn_t));
  conn->ios = mem + sizeof(conn_t) + 8;

  if (nblocks > 0) {
    struct iovec *iov = &conn->ios[conn->nios++];
    mem = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (mem == MAP_FAILED)
      return NULL;
    iov->iov_base = mem;
    iov->iov_len = ALIGN_TO_PAGESIZE(nblocks * MP_BLOCK);
  }

  conn->flags |= CF_IN_HEAP;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;

  return conn;
}

static inline int find_freec() {
  uint64_t *word;
  size_t map_size = (sizeof(uint64_t) * 8);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    word = &pool.freecs[i / map_size];

    if (*word == 0) { // All used
      i += (map_size - 1);
      continue;
    }

    i += __builtin_ctzll(*word);
    MARK_BIT_USED(*word, i);
    return i;
  }

  return -1;
}

static inline int MP_init(size_t npages) {
  if (!npages)
    return -1;

  /*** Setup ***/
  pool.npages = npages;
  pool.pagesize = sysconf(_SC_PAGESIZE);

  /*** Pool ***/
  pool.bpool = mmap(NULL, pool.npages * pool.pagesize, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  if (pool.bpool == MAP_FAILED)
    return -1;
  pool.nblocks = (pool.npages * pool.pagesize) / MP_BLOCK;

  /*** Blocks ***/
  pool.blocks = malloc(sizeof(void *) * pool.nblocks);
  if (!pool.blocks)
    return -1;
  for (size_t i = 0; i < pool.nblocks; i++)
    pool.blocks[i] = pool.bpool + (i * MP_BLOCK);

  /*** Freebs ***/
  // if (posix_memalign((void **)&pool.freebs, 64, bitmap_size * sizeof(uint64_t)) < 0)
  size_t bitmap_size = (pool.nblocks + 63) / 64;
  pool.freebs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freebs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freebs[i] = UINT64_MAX;

  /*** Cpool ***/
  pool.cpool = (conn_t *)malloc(sizeof(conn_t) * MAX_CONNS);
  if (!pool.cpool)
    return -1;

  /*** Conns ***/
  pool.conns = (conn_t **)malloc(sizeof(conn_t *) * MAX_CONNS);
  if (!pool.conns)
    return -1;
  size_t conn_size = sizeof(conn_t);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    pool.conns[i] = (conn_t *)((char *)pool.cpool + (i * conn_size));
    pool.conns[i]->fd = -1;
    pool.conns[i]->in_fd = -1;
    pool.conns[i]->out_fd = -1;
  }

  /*** Freecs ***/
  bitmap_size = (MAX_CONNS + 63) / 64;
  pool.freecs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freecs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freecs[i] = UINT64_MAX;

  return 0;
}

static inline int MP_use_blks(size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t max_start = pool.nblocks - nblocks;
  size_t full_chunks = (nblocks / 64) * 64;

  for (size_t i = 0, c = 0; i <= max_start; i++, c++) {
    bool free = true;

    for (size_t j = 0; j < full_chunks; j += 64) {
      size_t word_index = (i + j) / 64;
      if (pool.freebs[word_index] != UINT64_MAX) {
        free = false;
        i += 63;
        break;
      }
    }

    for (size_t j = full_chunks; j < nblocks; j++) {
      size_t bit_index = i + j;
      size_t word_index = bit_index / 64;
      size_t bit_in_word = bit_index % 64;

      if (!BIT_IS_FREE(pool.freebs[word_index], bit_in_word)) {
        free = false;
        i += j;
        break;
      }
    }

    if (free) {
      for (size_t j = 0; j < full_chunks; j += 64) {
        size_t word_index = (i + j) / 64;
        pool.freebs[word_index] = 0;
      }

      for (size_t j = full_chunks; j < nblocks; j++) {
        size_t bit_index = i + j;
        size_t word_index = bit_index / 64;
        size_t bit_in_word = bit_index % 64;

        MARK_BIT_USED(pool.freebs[word_index], bit_in_word);
      }

      return i;
    }
  }

  return -1;
}

static inline int MP_free_blks(size_t bindex, size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t full_chunks = (nblocks / 64) * 64;
  for (size_t i = 0; i < full_chunks; i += 64) {
    size_t word_index = (bindex + i) / 64;
    pool.freebs[word_index] = UINT64_MAX;
  }

  for (size_t i = full_chunks; i < nblocks; i++) {
    size_t bit_index = bindex + i;
    size_t word_index = bit_index / 64;
    size_t bit_in_word = bit_index % 64;

    MARK_BIT_FREE(pool.freebs[word_index], bit_in_word);
  }

  memset(pool.blocks[bindex], 0, nblocks * MP_BLOCK);
  return 0;
}

static inline conn_t *MP_use(size_t nblocks, int fd, bool once) {
  if (fd <= 0)
    return NULL;
  if (once)
    return MP_use_once(nblocks, fd);

  int cindex = find_freec();
  if (cindex < 0) {
    LOG("Err: cindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  conn_t *conn = pool.conns[cindex];

  int ios_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (ios_bindex < 0) {
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }

  struct iovec *ios = pool.blocks[ios_bindex];
  conn->ios = ios;

  int rec_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (rec_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct iovec *rec = pool.blocks[rec_bindex];
  conn->rec = rec;

  int msg_bindex = MP_use_blks(MSG_NBLOCKS);
  if (msg_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct msghdr *msg = pool.blocks[msg_bindex];
  conn->msg = msg;

  if (nblocks > 0) {
    int bindex = MP_use_blks(nblocks);
    if (bindex < 0) {
      MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
      MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
      MP_free_blks(msg_bindex, IOVEC_NBLOCKS);
      MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
      LOG("Err: bindex < 0; will use MP_use_once\n");
      return MP_use_once(nblocks, fd);
    }

    size_t iov_index = conn->nios++;
    struct iovec *iov = &conn->ios[iov_index];
    struct iovec *rec = &conn->rec[iov_index];
    iov->iov_base = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
  }

  conn->msg->msg_iov = conn->ios;
  conn->msg->msg_iovlen = conn->nios;
  conn->cindex = cindex;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;
  return conn;
}

static inline void MP_shed(conn_t *conn, size_t iov_index, size_t nios) {
  struct iovec *iov, *rec;
  size_t bindex, nblocks, index;

  for (size_t i = 0; i < nios; i++) {
    index = iov_index + i;
    iov = &conn->ios[index];
    rec = &conn->rec[index];
    if (!rec || !rec->iov_base)
      continue;
    if (!IN_POOL(rec->iov_base)) {
      munmap(rec->iov_base, rec->iov_len / pool.pagesize);
    } else {
      bindex = ptr_diff((uintptr_t)rec->iov_base, (uintptr_t)pool.bpool) / MP_BLOCK;
      nblocks = rec->iov_len / MP_BLOCK;
      MP_free_blks(bindex, nblocks);
    }
    memset(iov, 0, sizeof(struct iovec));
    memset(rec, 0, sizeof(struct iovec));
    conn->nios--;
  }
}

static inline int MP_expand(conn_t *conn, size_t nblocks, bool once) {
  void *bptr;
  int iov_index, bindex;
  struct iovec *iov, *rec;

  iov_index = conn->nios++;
  iov = &conn->ios[iov_index];
  rec = &conn->rec[iov_index];

  if (nblocks == 0)
    return iov_index;

  if (once) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_base = bptr;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
    return iov_index;
  }

  bindex = MP_use_blks(nblocks);
  if (bindex < 0) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_len = iov->iov_len;
  } else {
    bptr = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_len = iov->iov_len;
  }

  iov->iov_base = bptr;
  rec->iov_base = iov->iov_base;
  return iov_index;
}

static inline int MP_free(conn_t *conn) {
  if (!conn)
    return -1;
  size_t bindex, nblocks;
  uint64_t *word;

  MP_shed(conn, 0, conn->nios);
  if (conn->flags & CF_IN_HEAP) {
    if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
      close(conn->fd);
    free(conn);
    return 0;
  }

  word = &pool.freecs[conn->cindex / 64];
  if (conn->cindex > MAX_CONNS)
    return -1;
  else if (BIT_IS_FREE(*word, conn->cindex))
    return 0;

  bindex = ptr_diff((uintptr_t)conn->ios, (uintptr_t)pool.bpool) / MP_BLOCK;
  nblocks = IOVEC_NBLOCKS;
  MP_free_blks(bindex, nblocks);

  bindex = ptr_diff((uintptr_t)conn->rec, (uintptr_t)pool.bpool) / MP_BLOCK;
  MP_free_blks(bindex, nblocks);

  if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
    close(conn->fd);

  MARK_BIT_FREE(*word, conn->cindex);
  memset(conn, 0, sizeof(conn_t));
  conn->fd = -1;
  conn->in_fd = -1;
  conn->out_fd = -1;
  return 0;
}

static inline void MP_clear(conn_t *conn) {
  conn_t *recv_conn = conn->recv_conn;
  conn_t *send_conn = conn->send_conn;
  if (recv_conn)
    MP_free(recv_conn);
  if (send_conn)
    MP_free(send_conn);
}

static inline void MP_exit(MPool *pool) {
  munmap(pool->bpool, pool->npages);
  free(pool->cpool);
  free(pool->blocks);
  free(pool->conns);
  free(pool->freebs);
  free(pool->freecs);
}

static inline void MP_timeout() {
  conn_t *conn;
  int16_t res;
  uint64_t now;
  size_t windex = 0;
  uint64_t *word = &pool.freecs[0];
  for (size_t i = 0; i < MAX_CONNS; i++) {
    if ((i / 64) < windex)
      word = &pool.freecs[++windex];

    if (*word == UINTMAX_MAX) {
      i = (i / 64) * 64 + 64;
      continue;
    }

    conn = pool.conns[i];
    if (!conn || conn->fd == -1)
      continue;

    res = pollevs(conn->fd);

    now = get_time();
    if (res & POLLERR) {
      MP_clear(conn);
      continue;
    }
    if (res & POLLIN) {
      if (pool.rtimeout > 0 && (now - conn->last_read) >= pool.rtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (res & POLLOUT) {
      if (pool.wtimeout > 0 && (now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (!(res & POLLIN || res & POLLOUT)) {
      if ((pool.rtimeout > 0 && now - conn->last_read) >= pool.rtimeout
          || (pool.wtimeout > 0 && now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
  }
}

/*
 * Calculate the length of a status string
 */
static inline size_t status_len(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return 8;
  case STATUSSWITCHINGPROTOCOLS:
    return 19;
  case STATUSPROCESSING:
    return 10;
  case STATUSEARLYHINTS:
    return 11;
  case STATUSOK:
    return 2;
  case STATUSCREATED:
    return 7;
  case STATUSACCEPTED:
    return 8;
  case STATUSNONAUTHORITATIVE:
    return 29;
  case STATUSNOCONTENT:
    return 10;
  case STATUSRESETCONTENT:
    return 13;
  case STATUSPARTIALCONTENT:
    return 15;
  case STATUSMULTISTATUS:
    return 12;
  case STATUSALREADYREPORTED:
    return 16;
  case STATUSIMUSED:
    return 7;
  case STATUSMULTIPLECHOICES:
    return 16;
  case STATUSMOVEDPERMANENTLY:
    return 17;
  case STATUSFOUND:
    return 5;
  case STATUSSEEOTHER:
    return 9;
  case STATUSNOTMODIFIED:
    return 12;
  case STATUSUSEPROXY:
    return 9;
  case STATUSTEMPORARYREDIRECT:
    return 18;
  case STATUSPERMANENTREDIRECT:
    return 18;
  case STATUSBADREQUEST:
    return 11;
  case STATUSUNAUTHORIZED:
    return 12;
  case STATUSPAYMENTREQUIRED:
    return 16;
  case STATUSFORBIDDEN:
    return 9;
  case STATUSNOTFOUND:
    return 9;
  case STATUSMETHODNOTALLOWED:
    return 18;
  case STATUSNOTACCEPTABLE:
    return 14;
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return 29;
  case STATUSREQUESTTIMEOUT:
    return 15;
  case STATUSCONFLICT:
    return 8;
  case STATUSGONE:
    return 4;
  case STATUSLENGTHREQUIRED:
    return 15;
  case STATUSPRECONDITIONFAILED:
    return 19;
  case CONTENTTOOLARGE:
    return 17;
  case STATUSURITOOLONG:
    return 12;
  case STATUSUNSUPPORTEDMEDIATYPE:
    return 22;
  case STATUSRANGENOTSATISFIABLE:
    return 21;
  case STATUSEXPECTATIONFAILED:
    return 18;
  case STATUSMISDIRECTEDREQUEST:
    return 19;
  case STATUSUNPROCESSABLECONTENT:
    return 21;
  case STATUSLOCKED:
    return 6;
  case STATUSFAILEDDEPENDENCY:
    return 17;
  case STATUSTOOEARLY:
    return 9;
  case STATUSUPGRADEREQUIRED:
    return 16;
  case STATUSPRECONDITIONREQUIRED:
    return 21;
  case STATUSTOOMANYREQUESTS:
    return 17;
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return 31;
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return 29;
  case STATUSInternalServerError:
    return 21;
  case STATUSNOTIMPLEMENTED:
    return 15;
  case STATUSBADGATEWAY:
    return 11;
  case STATUSSERVICEUNAVAILABLE:
    return 19;
  case STATUSGATEWAYTIMEOUT:
    return 15;
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return 26;
  case STATUSVARIANTALSONEGOTIATES:
    return 23;
  case STATUSINSUFFICIENTSTORAGE:
    return 20;
  case STATUSLOOPDETECTED:
    return 13;
  case STATUSNOTEXTENDED:
    return 12;
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return 31;
  default:
    return 0;
  }
}

/*
 * Return the status code string as string literal
 */
static inline char *status_str(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return "Continue";
  case STATUSSWITCHINGPROTOCOLS:
    return "Switching Protocols";
  case STATUSPROCESSING:
    return "Processing";
  case STATUSEARLYHINTS:
    return "Early Hints";
  case STATUSOK:
    return "OK";
  case STATUSCREATED:
    return "Created";
  case STATUSACCEPTED:
    return "Accepted";
  case STATUSNONAUTHORITATIVE:
    return "Non-Authoritative Information";
  case STATUSNOCONTENT:
    return "No Content";
  case STATUSRESETCONTENT:
    return "Reset Content";
  case STATUSPARTIALCONTENT:
    return "Partial Content";
  case STATUSMULTISTATUS:
    return "Multi-Status";
  case STATUSALREADYREPORTED:
    return "Already Reported";
  case STATUSIMUSED:
    return "Im Used";
  case STATUSMULTIPLECHOICES:
    return "Multiple Choices";
  case STATUSMOVEDPERMANENTLY:
    return "Moved Permanently";
  case STATUSFOUND:
    return "Found";
  case STATUSSEEOTHER:
    return "See Other";
  case STATUSNOTMODIFIED:
    return "Not Modified";
  case STATUSUSEPROXY:
    return "Use Proxy";
  case STATUSTEMPORARYREDIRECT:
    return "Temporary Redirect";
  case STATUSPERMANENTREDIRECT:
    return "Permanent Redirect";
  case STATUSBADREQUEST:
    return "Bad Request";
  case STATUSUNAUTHORIZED:
    return "Unauthorized";
  case STATUSPAYMENTREQUIRED:
    return "Payment Required";
  case STATUSFORBIDDEN:
    return "Forbidden";
  case STATUSNOTFOUND:
    return "Not Found";
  case STATUSMETHODNOTALLOWED:
    return "Method Not Allowed";
  case STATUSNOTACCEPTABLE:
    return "Not Acceptable";
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return "Proxy Authentication Required";
  case STATUSREQUESTTIMEOUT:
    return "Request Timeout";
  case STATUSCONFLICT:
    return "Conflict";
  case STATUSGONE:
    return "Gone";
  case STATUSLENGTHREQUIRED:
    return "Length Required";
  case STATUSPRECONDITIONFAILED:
    return "Precondition Failed";
  case CONTENTTOOLARGE:
    return "Content Too Large";
  case STATUSURITOOLONG:
    return "URI Too Long";
  case STATUSUNSUPPORTEDMEDIATYPE:
    return "Unsupported Media Type";
  case STATUSRANGENOTSATISFIABLE:
    return "Range Not Satisfiable";
  case STATUSEXPECTATIONFAILED:
    return "Expectation Failed";
  case STATUSMISDIRECTEDREQUEST:
    return "Misdirected Request";
  case STATUSUNPROCESSABLECONTENT:
    return "Unprocessable Content";
  case STATUSLOCKED:
    return "Locked";
  case STATUSFAILEDDEPENDENCY:
    return "Failed Dependency";
  case STATUSTOOEARLY:
    return "Too Early";
  case STATUSUPGRADEREQUIRED:
    return "Upgrade Required";
  case STATUSPRECONDITIONREQUIRED:
    return "Precondition Required";
  case STATUSTOOMANYREQUESTS:
    return "Too Many Requests";
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return "Request Header Fields Too Large";
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return "Unavailable For Legal Reasons";
  case STATUSInternalServerError:
    return "Internal Server Error";
  case STATUSNOTIMPLEMENTED:
    return "Not Implemented";
  case STATUSBADGATEWAY:
    return "Bad Gateway";
  case STATUSSERVICEUNAVAILABLE:
    return "Service Unavailable";
  case STATUSGATEWAYTIMEOUT:
    return "Gateway Timeout";
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return "HTTP Version Not Supported";
  case STATUSVARIANTALSONEGOTIATES:
    return "Variant Also Negotiates";
  case STATUSINSUFFICIENTSTORAGE:
    return "Insufficient Storage";
  case STATUSLOOPDETECTED:
    return "Loop Detected";
  case STATUSNOTEXTENDED:
    return "Not Extended";
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return "Network Authentication Required";
  default:
    return 0;
  }
}

/*
 * Return true if routes match
 */
static inline bool route_equ(Route *route, Request *req) {
  return route->method == req->method && strncmp(route->path, req->path, strlen(route->path)) == 0;
}

/*
 * Return the matching route index on success. -1 on failure
 */
static inline int match_route(Server *serv, Request *req) {
  for (size_t i = 0; i < serv->_nroutes; i++) {
    Route route = serv->routes[i];
    if (!req->path || !route.path)
      continue;
    if (route_equ(&route, req))
      return i;
    else if (req->method == HEAD && route.method == GET && strcmp(route.path, req->path) == 0)
      return i;
  }
  return -1;
}

/*
 * Return true if the response should contain the Content-Length header
 */
static inline bool should_have_content_length(Request *req, ResWriter *res) {
  return (req->method != CONNECT              // CONNECT request
          && res->status != STATUSNOCONTENT   // 204 response
          && res->status != STATUSNOTMODIFIED // 304 response
          && res->status >= 200);             // 1xx response
}

/*
 * Format http response from the ResWriter.
 * Return response size on success, 0 on failure.
 */
static inline size_t fmt_res(Request *req, ResWriter *res, char *buffer, size_t buffer_size) {
  if (!res || !buffer || buffer_size == 0)
    return 0;

  size_t res_len, total = 0;
  char *dst = buffer;
  size_t maxlen = buffer_size;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t body_length = res->len;

  res_len = snprintf(dst, maxlen, "HTTP/1.1 %d %s", (int)res->status, status_str(res->status));
  total += res_len;
  dst += res_len;
  maxlen -= res_len;

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    res_len = snprintf(dst, maxlen, "\r\n%s: %s", header->key, header->value);
    total += res_len;
    dst += res_len;
    maxlen -= res_len;
  }

  if (have_content_length) {
    res_len = snprintf(dst, maxlen, "\r\nContent-Length: %lu", body_length);
    total += res_len, dst += res_len, maxlen -= res_len;
  }

  memcpy(dst, "\r\n\r\n", 4);
  total += 4, dst += 4, maxlen -= 4;

  return total;
}

static inline size_t res_len(Request *req, ResWriter *res) {
  if (!req || !res)
    return 0;

  if (!res->status)
    res->status = STATUSOK;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t result = 0;
  result += STRLEN("HTTP/1.1 ");     // HTTP version
  result += 4;                       // Status code + space
  result += status_len(res->status); // Status name

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    result += 2;                       // "\r\n"
    result += strlen(header->key) + 2; // Header key + ':' + space
    result += strlen(header->value);   // header value
  }

  if (have_content_length) {
    result += 2;                          // "\r\n"
    result += STRLEN("Content-Length: "); // Header key
    result += countd(res->len);           // Header value
  }

  result += 4; // "\r\n\r\n"

  return result;
}

static inline int send_empty_res(Status status) {
  size_t res_len = STRLEN("HTTP/1.1 ")        // HTTP version
                   + countd((uint64_t)status) // status code
                   + 1                        // space
                   + (int)status_len(status)  // status string
                   + 4;                       // \r\n\r\n

  conn_t *conn = current_send;
  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, res_len);
  if (snprintf((char *)rec->iov_base, res_len + 1, "HTTP/1.1 %d %s\r\n\r\n", (int)status, status_str(status))
      != (int)res_len)
    return -1;

  return usendmsg(conn, 0, 1);
}

static inline ssize_t read_socket(int sockfd, size_t len) {
  if (len == 0 || sockfd <= 0)
    return 0;
  char buff[1024 * 8];
  return read(sockfd, buff, 1024 * 8);
}

static inline int read_method(Method *method, void *src) {
  if (memcmp(src, "GET", 3) == 0)
    *method = GET;
  else if (memcmp(src, "POST", 4) == 0)
    *method = POST;
  else if (memcmp(src, "HEAD", 4) == 0)
    *method = HEAD;
  else if (memcmp(src, "PUT", 3) == 0)
    *method = PUT;
  else if (memcmp(src, "DELETE", 6) == 0)
    *method = DELETE;
  else if (memcmp(src, "CONNECT", 7) == 0)
    *method = CONNECT;
  else if (memcmp(src, "OPTIONS", 7) == 0)
    *method = OPTIONS;
  else if (memcmp(src, "TRACE", 5) == 0)
    *method = TRACE;
  else if (memcmp(src, "PATCH", 5) == 0)
    *method = PATCH;
  else
    return -1;

  return 0;
}

static inline int sendmsg_res(Request *req, ResWriter *res) {
  conn_t *conn;
  size_t head_size, res_size;
  struct iovec *iov;

  conn = current_send;
  iov = &conn->ios[0];
  head_size = res_len(req, res);
  if (head_size == 0)
    return -1;

  conn->data_left += head_size;
  res_size = fmt_res(req, res, iov->iov_base, (head_size + 1));
  if (res_size != head_size)
    return -1;
  iov->iov_len = res_size;

  return usendmsg(conn, 0, conn->nios);
}

static inline int read_req(Request *req, char *req_buffer) {
  if (!req_buffer)
    return -1;
  /*** Method ***/
  char *sep = strchr(req_buffer, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }
  *sep = '\0';
  if (read_method(&req->method, req_buffer) < 0)
    return -1;

  /*** Path ***/
  char *fullpath = sep + 1;
  sep = strchr(fullpath, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }

  *sep = '\0';
  req->path = fullpath;
  /*** Params ***/
  char *paramStart = strchr(fullpath, '?');
  if (paramStart) {
    *paramStart++ = '\0';
    int params_count = 0;
    params_count = HK_parse_params(paramStart, req->params, MAX_URL_PARAMETERS);
    if (params_count > 0)
      req->params_count = params_count;
    else
      req->params_count = 0;
  } else {
    req->params = NULL;
    req->params_count = 0;
  }

  /*** Headers ***/
  char *headStart = strstr(sep + 1, "\r\n");
  char *headEnd = strstr(sep + 1, "\r\n\r\n");
  if (!headStart) {
    LOG("read_req: !headStart\n");
    return -1;
  };

  memset(headStart, 0, 2);
  headStart += 2;
  memset(headEnd, 0, 4);
  headEnd += 4;

  int headers_count = HK_parse_headers(headStart, req->headers, MAX_REQ_HEADERS);
  if (headers_count <= 0)
    return -1;
  req->headers_count = headers_count;

  /*** Host ***/
  int index = HK_get_header(req, "Host");
  if (index < 0)
    return -1;
  char *host = req->headers[index].value;
  req->hostname = host;

  /*** Port ***/
  char *colon = strchr(host, ':');
  if (colon) {
    *colon++ = '\0';
    req->port = atoi(colon);
  } else {
    req->port = PORT;
  }
  return 0;
}
static inline int process_req(Server *serv, conn_t *conn) {
  if (!conn || conn->fd == -1)
    return -1;

  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;
  if (read_req(&req, conn->ios[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    LOG("Err: route_index == -1\n");
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;
  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  sendmsg_res(&req, &res);

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int new_conn(int connfd) {
  if (connfd <= 0)
    return -1;

  current_recv = MP_use(KB * 2, connfd, false);
  current_send = MP_use(KB * 2, connfd, false);

  current_recv->recv_conn = current_recv;
  current_recv->send_conn = current_send;

  current_send->send_conn = current_send;
  current_send->recv_conn = current_recv;

  conn_t *conn = current_recv;
  if (ufrecvmsg(conn, 0, 1) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

static inline int resubmit_sendmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return usendmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int resubmir_recvmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    // FIXME the len should be increased
    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return urecvmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int handle_sendmsg_complete(conn_t *conn) {
  struct iovec *iov, *rec;

  MP_shed(conn, 1, conn->nios - 1);
  iov = &conn->ios[0];
  rec = &conn->rec[0];
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;

  return ufrecvmsg(conn->recv_conn, 0, 1);
}

static inline int handle_sendmsg(conn_t *conn, int res, bool zc) {
  if (!conn || conn->fd == -1)
    return -1;

  conn->data_left -= res;
  if (conn->data_left > 0)
    return resubmit_sendmsg(conn, res);

  if (zc)
    return 0;

  return handle_sendmsg_complete(conn);
}

static inline int handle_insplice(conn_t *conn) {
  conn->op = OUTSPLICE;
  return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
}
static inline int handle_outsplice(conn_t *conn, int res) {
  conn->data_left -= res;
  if (conn->data_left > 0) {
    conn->op = INSPLICE;
    return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
  }

  conn_t *recv_conn = conn->recv_conn;
  struct iovec *iov = &recv_conn->ios[0];
  memset(iov->iov_base, 0, iov->iov_len);
  if (urecv(recv_conn, iov->iov_base, iov->iov_len, MSG_PEEK) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

/*
static inline int handle_recv(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  void *bptr = conn->ios[0].iov_base;
  void *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  void *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  return process_req(serv, conn);
}
*/
static inline int find_route(Server *serv, char *bptr) {
  Request req = {0};
  if (read_method(&req.method, bptr) < 0) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  };
  char *space = strchr(bptr, ' ');
  req.path = (space + 1);
  space = strchr(req.path, ' ');
  *space = '\0';
  int route_index = match_route(serv, &req);
  *space = ' ';
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }
  return route_index;
}

static inline int run_handler(Server *serv, conn_t *conn, bool uses_body) {
  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;

  if (read_req(&req, conn->rec[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  if (uses_body) {
    int h_index = HK_get_header(&req, "Content-Length");
    long body_size = atol(req.headers[h_index].value);
    if (body_size >= 0) {
      req.body.ptr = conn->rec[1].iov_base;
      req.body.size = body_size;
    } else {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    }
  }

  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  if (sendmsg_res(&req, &res) < 0)
    return -1;

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int handle_frecvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  char *bptr = (char *)conn->ios[0].iov_base;
  char *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  char *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  size_t head_size = (headEnd + 4) - bptr;
  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  int route_index = find_route(serv, bptr);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  bool uses_body = serv->routes[route_index].uses_body;
  long body_size = get_content_length(headstart + 2, headEnd + 4);
  if (body_size == -1) {
    if (uses_body) {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    } else {
      body_size = 0;
    }
  }

  conn->head_size = head_size;
  if (!uses_body) {
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  if (res == (int)(head_size + body_size)) {
    size_t iov_index = MP_expand(conn, round_to_blocks(body_size), false);
    memcpy(conn->rec[iov_index].iov_base, headEnd + 4, body_size);
    conn->ios[iov_index].iov_len = body_size;
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  conn->data_left = body_size - (res - head_size);
  bool once = ((size_t)body_size > (size_t)((pool.nblocks * MP_BLOCK) / 10));
  size_t iov_index = MP_expand(conn, round_to_blocks(body_size), once);
  memcpy(conn->rec[iov_index].iov_base, headEnd + 4, (res - head_size));
  conn->ios[iov_index].iov_base += (res - head_size);

  return urecvmsg(conn, iov_index, 1);
}

static inline int handle_recvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  if (conn->data_left > 0) {
    conn->data_left -= res;
    if (conn->data_left == 0) {
      conn->flags &= CF_HANDLER_READY;
      return run_handler(serv, conn, true);
    }

    conn->flags &= ~CF_HANDLER_READY;
    conn->ios[1].iov_base += res;
    return urecvmsg(conn, 1, 1);
  }

  conn->flags &= CF_HANDLER_READY;
  return run_handler(serv, conn, true);
}

static inline int serv_init(Server *serv) {
#if DEBUG
  logfd = log_init("log.txt");
  if (!logfd) {
    printf("log_init failed");
    return -1;
  }
#endif
  serv->_nroutes = get_nroutes(serv->routes);

  int pipefd[2];
  if (pipe(pipefd) < 0)
    return -1;
  pipe_in = pipefd[0];
  pipe_out = pipefd[1];
  nullfd = open("/dev/null", O_WRONLY);
  pipe_sz = fcntl(pipefd[0], F_GETPIPE_SZ);
  if (pipe_sz < 0)
    return -1;

  pool.rtimeout = serv->rtimeout;
  pool.wtimeout = serv->wtimeout;
  if (MP_init(MAX_CONNS * 8) < 0)
    return -1;
  LOG("pool initialized\n");

  if (io_uring_queue_init(MAX_CONNS, &ring, 0) < 0)
    return -1;
  LOG("uring initialized\n");

  int listenfd;
  if ((listenfd = tcp_listen(serv->port)) < 0)
    return -1;
  LOG("socket initialized\n");

  return umaccept(listenfd);
}

static inline int serv_listen(Server *serv) {
  // uint64_t last_check = get_time();
  while (true) {
    // uint64_t now = get_time();
    // if ((now - last_check) >= 200) {
    //   last_check = now;
    //   LOG("CM: CM_check ran\n");
    //   MP_timeout();
    // }

    LOG("SQ ready: %u, CQ ready: %u\n", io_uring_sq_ready(&ring), io_uring_cq_ready(&ring));
    struct io_uring_cqe *cqe;
    if (io_uring_wait_cqe(&ring, &cqe) < 0)
      continue;

    int res = cqe->res;
    LOG("res = %d\n", res);
    conn_t *conn = NULL;
    if (cqe->user_data > 100) {
      conn = (conn_t *)cqe->user_data;
      current_recv = (conn_t *)conn->recv_conn;
      current_send = (conn_t *)conn->send_conn;
    }

    if (res > 0) {
      if (cqe->user_data == ACCEPT) {
        LOG("new conn created\n");
        new_conn(res);
      } else if (conn && conn->fd != -1) {
        LOG("conn[%d]: conn.fd = %d; conn.op = %d\n", conn->cindex, conn->fd, conn->op);
        switch (conn->op) {
        case FRECVMSG:
          if (handle_frecvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case RECVMSG:
          if (handle_recvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case SENDMSG:
        case SENDMSGZC:
          // conn->last_write = get_time();
          bool zc = (conn->op == SENDMSGZC);
          if (handle_sendmsg(conn, res, zc) < 0)
            MP_clear(conn);
          break;
        case INSPLICE:
          if (handle_insplice(conn) < 0)
            MP_clear(conn);
          break;
        case OUTSPLICE:
          if (handle_outsplice(conn, res) < 0)
            MP_clear(conn);
          break;
        }
      }
    } else if (res == 0) {
      if (conn && conn->fd != -1) {
        switch (conn->op) {
        case SENDMSGZC:
          conn->zc_notifs--;
          if (conn->zc_notifs == 0 && handle_sendmsg_complete(conn) < 0)
            MP_clear(conn);
          break;
        case RECV:
          MP_clear(conn);
          break;
        }
      }
    } else {
      if (conn && conn->fd != -1) {
        if (res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR) {
          LOG("conn && conn->fd != -1 && res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR\n");
          MP_clear(conn);
        } else {
          LOG("res == -EAGAIN || res == -EWOULDBLOCK || res == -EINTR\n");
          conn = conn->recv_conn;
          struct iovec *iov = &conn->ios[0];
          memset(iov->iov_base, 0, iov->iov_len);
          if (urecv(conn, iov->iov_base, iov->iov_len, 0) < 0)
            MP_clear(conn);
        }
      }
    }

    LOG("uring operation seen\n");
    io_uring_cqe_seen(&ring, cqe);
  }

  io_uring_queue_exit(&ring);
  MP_exit(&pool);
  return 0;
}

/*** Helper ***/
static inline int _HK_write(void *data, size_t size) {
  size_t nblocks;
  int iov_index;
  conn_t *conn;
  struct iovec *iov;
  bool once;

  conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  nblocks = round_to_blocks(size);
  iov_index = MP_expand(conn, nblocks, once);
  iov = &conn->ios[iov_index];

  memcpy(iov->iov_base, data, size);
  iov->iov_len = size;
  conn->data_left += size;

  return 0;
}
static inline int _HK_write_body(Request *req, size_t offset, size_t size) {
  if (size > req->body.size || offset > req->body.size)
    return -1;

  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  int iov_index = MP_expand(conn, 0, false);
  struct iovec *iov = &conn->ios[iov_index];
  struct iovec *rec = &conn->rec[iov_index];
  rec->iov_base = req->body.ptr + offset;
  rec->iov_len = size;
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;
  conn->data_left += rec->iov_len;
  return 0;
}
/*
static inline int _HK_mem(size_t size, HKMem *mem) {
  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  bool once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  size_t nblocks = round_to_blocks(size);
  int iov_index = MP_expand(conn, nblocks, once);
  struct iovec *iov = &conn->ios[iov_index];
  mem->ptr = iov->iov_base;
  mem->size = iov->iov_len;
  mem->_iov_index = iov_index;
  mem->_flags = (IN_POOL(iov->iov_base)) ? CF_IN_POOL : CF_IN_HEAP;
  return 0;
}

static inline void _HK_send(HKMem *mem, size_t size) {
  conn_t *conn = current_send;
  struct iovec *iov = &conn->ios[mem->_iov_index];
  iov->iov_len = size;
  conn->data_left += size;
}
  */
#endif#define _GNU_SOURCE
#ifndef UTILS_H
#define UTILS_H

#include "hunk.h"
#include <arpa/inet.h>
#include <fcntl.h>
#include <liburing.h>
#include <netdb.h>
#include <signal.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/poll.h>
#include <sys/prctl.h>
#include <sys/socket.h>
#include <sys/sysinfo.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

#define MP_BLOCK  4
#define MAX_CONNS 4096
#define KB        1024
#define NIOS      32

#define IN_POOL(ptr)                 ((void *)ptr >= pool.bpool && (void *)ptr <= (pool.bpool + (pool.npages * pool.pagesize)))
#define ALIGN_TO_PAGESIZE(buff_size) (((buff_size) + (pool.pagesize - 1)) & ~(pool.pagesize - 1))
#define BYTES_TO_BLOCKS(buff_size)   (((buff_size) + (MP_BLOCK - 1)) / MP_BLOCK)
#define CEIL_BLOCKS(nblocks)         ((nblocks + 63) & ~63)
#define CEIL_PAGES(size)             (((size) + ((pool.pagesize) - 1)) & ~((pool.pagesize) - 1))

#define BIT_IS_FREE(word, bit)   (((word) >> (bit)) & 1)
#define MARK_BIT_USED(word, bit) ((word) &= ~(1ULL << (bit)))
#define MARK_BIT_FREE(word, bit) ((word) |= (1ULL << (bit)))
#define FIND_FREE_BIT(word)      ((uint64_t)(word) & -(uint64_t)(word))
#define STRLEN(s)                (sizeof(s) - 1)

#define IOVEC_NBLOCKS (BYTES_TO_BLOCKS(NIOS * sizeof(struct iovec)))
#define MSG_NBLOCKS   (BYTES_TO_BLOCKS(sizeof(struct msghdr)))
#define ZC_RES        KB *KB

#define DEBUG 0
#if DEBUG
#define LOG(...) fprintf(logfd, __VA_ARGS__)
#else
#define LOG(...) ((void)0)
#endif

typedef enum UOP {
  WRITEV = IORING_OP_WRITEV,
  SENDMSG = IORING_OP_SENDMSG,
  RECVMSG = IORING_OP_RECVMSG,
  ACCEPT = IORING_OP_ACCEPT,
  SEND = IORING_OP_SEND,
  RECV = IORING_OP_RECV,
  SENDZC = IORING_OP_SEND_ZC,
  SENDMSGZC = IORING_OP_SENDMSG_ZC,
  PEEK = 50,
  FRECVMSG,
  INSPLICE,
  OUTSPLICE
} UOP;

typedef enum CFS {
  CF_IN_POOL = (1 << 0),       // Connection is in the pool
  CF_IN_HEAP = (1 << 1),       // Connection is in the heap
  CF_SKIP_SOCK = (1 << 2),     // Don't close the socket
  CF_USE_ONCE = (1 << 3),      // Destroy after using
  CF_HANDLER_READY = (1 << 4), // Ready to call the handler
} CFS;

typedef struct conn_t {
  // Socket file descriptor
  int fd;

  // Amount of data left in the current operation
  uint64_t data_left;

  // The index of the connection struct
  uint32_t cindex;

  // The last time the connection was readable
  uint64_t last_read;

  // The last time the connection was writeable
  uint64_t last_write;

  // The operation currently being processed
  uint8_t op;

  // Connection flags
  int flags;

  // Splice fd_in
  int in_fd;

  // Splice fd_out
  int out_fd;

  void *recv_conn;
  void *send_conn;

  struct iovec *ios;
  struct iovec *rec;
  uint16_t nios;

  struct msghdr *msg;
  uint16_t zc_notifs;

  uint16_t head_size;
} conn_t;

typedef struct MPool {
  // The allocated pool of blocks
  void *bpool;

  // The allocated pool of connections
  conn_t *cpool;

  // The size of the pool in pages
  uint32_t npages;

  // The size of the pool in blocks
  uint32_t nblocks;

  // The locations of each page in the pool
  void **blocks;

  // The availability of each block
  uint64_t *freebs;

  // The locations of each conn in the pool
  conn_t **conns;

  // The availability of each conn
  uint64_t *freecs;

  // Clean up callback function
  void (*callback)(conn_t *conn);

  // The page size used
  uint32_t pagesize;

  // Socket read timeout
  uint32_t rtimeout;

  // Socket write timeout
  uint32_t wtimeout;
} MPool;

extern int pipe_sz;
extern int pipe_in, pipe_out, nullfd;
extern FILE *logfd;
extern struct io_uring ring;
extern MPool pool;
extern conn_t *current_recv;
extern conn_t *current_send;

/*
 * Prepare and submit a recv uring op
 */
static inline int urecv(conn_t *conn, void *buffer, size_t buff_size, int flags) {
  if (!conn || conn->fd == -1)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (flags == MSG_PEEK) ? PEEK : RECV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;

  io_uring_prep_recv(sqe, conn->fd, buffer, buff_size, flags);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a multi-shot accept uring op
 */
static inline int umaccept(int listenfd) {
  if (listenfd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = ACCEPT;
  io_uring_prep_multishot_accept(sqe, listenfd, NULL, NULL, SOCK_NONBLOCK);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a splice uring op
 */
static inline int usplice(conn_t *conn, int fd_in, int64_t off_in, int fd_out, int64_t off_out, size_t len) {
  if (!len || !conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = (__u64)conn;
  io_uring_prep_splice(sqe, fd_in, off_in, fd_out, off_out, len, 0);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a writev uring op
 */
static inline int uwritev(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = WRITEV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  io_uring_prep_writev(sqe, conn->fd, &conn->ios[iov_index], nios, -1);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a send uring op
 */
static inline int usend(conn_t *conn, char *res_buff, size_t buff_size, bool zc) {
  if (!conn || conn->fd <= 0 || buff_size == 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (zc) ? SENDZC : SEND;
  conn->data_left = buff_size;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  if (zc)
    io_uring_prep_send_zc(sqe, conn->fd, res_buff, buff_size, 0, 0);
  else
    io_uring_prep_send(sqe, conn->fd, res_buff, buff_size, 0);
  return io_uring_submit(&ring);
}

static inline int ufrecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = FRECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;

  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, rec->iov_len);
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int urecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = RECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int usendmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  bool zc = (conn->data_left > ZC_RES) ? true : false;
  conn->op = (zc) ? SENDMSGZC : SENDMSG;

  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  if (zc) {
    io_uring_prep_sendmsg_zc(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
    conn->zc_notifs++;
  } else {
    io_uring_prep_sendmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  }
  return io_uring_submit(&ring);
}

/*
 * Create and initialize a server socket
 */
static inline int tcp_listen(uint16_t port) {
  int enable;
  int listenfd;
  if ((listenfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    return -1;

  int flags = fcntl(listenfd, F_GETFL, 0);
  fcntl(listenfd, F_SETFL, flags | O_NONBLOCK);
  struct sockaddr_in servaddr;
  memset(&servaddr, 0, sizeof(servaddr));
  servaddr.sin_family = AF_INET;
  servaddr.sin_addr.s_addr = INADDR_ANY;
  servaddr.sin_port = htons(port);

  enable = 1;
  if (setsockopt(listenfd, SOL_SOCKET, SO_REUSEPORT, &enable, sizeof(enable)) < 0)
    return -1;

  if (bind(listenfd, (struct sockaddr *)&servaddr, sizeof(servaddr)) < 0)
    return -1;

  if (listen(listenfd, SOMAXCONN) < 0)
    return -1;

  return listenfd;
}

/*
 * Calculate the difference between two pointers
 */
static inline uintptr_t ptr_diff(uintptr_t p1, uintptr_t p2) { return (uintptr_t)(p1 > p2) ? (p1 - p2) : (p2 - p1); }

static inline size_t get_nroutes(Route *routes) {
  Route *route;
  for (size_t i = 0;; i++) {
    route = &routes[i];
    if (!route->path && !route->handler && !route->method)
      return i;
  }
}

static inline long get_content_length(char *src, char *end) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return -1;
    key = line;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, "Content-Length") != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;

    *line_end = '\0';
    long res = atol(value);
    *line_end = '\r';

    return res;
  }
  return -1;
}

static inline bool have_header(char *src, char *end, const char *header_key, const char *header_value) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    key = line;
    while (*key == ' ')
      key++;
    while (*header_key == ' ')
      header_key++;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return false;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, header_key) != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;
    while (*header_value == ' ')
      header_value++;

    *line_end = '\0';
    bool res = (strcasecmp(value, header_value) == 0);
    *line_end = '\r';

    return res;
  }

  return false;
}

static inline const char *method_str(Method method) {
  switch (method) {
  case GET:
    return "GET";
    break;
  case HEAD:
    return "HEAD";
    break;
  case POST:
    return "POST";
    break;
  case PUT:
    return "PUT";
    break;
  case DELETE:
    return "DELETE";
    break;
  case CONNECT:
    return "CONNECT";
    break;
  case OPTIONS:
    return "OPTIONS";
    break;
  case TRACE:
    return "TRACE";
    break;
  case PATCH:
    return "PATCH";
    break;
  default:
    return NULL;
  }
}

static inline uint8_t method_len(Method method) {
  switch (method) {
  case GET:
    return 3;
    break;
  case HEAD:
    return 4;
    break;
  case POST:
    return 4;
    break;
  case PUT:
    return 3;
    break;
  case DELETE:
    return 6;
    break;
  case CONNECT:
    return 7;
    break;
  case OPTIONS:
    return 7;
    break;
  case TRACE:
    return 5;
    break;
  case PATCH:
    return 5;
    break;
  default:
    return 0;
  }
}

static inline size_t round_to_blocks(size_t size) {
  size_t nblocks = BYTES_TO_BLOCKS(size);
  nblocks = CEIL_BLOCKS(nblocks);
  return nblocks;
}

/*
 * Count the digits in unsigned 64-bit int
 */
static inline int countd(uint64_t num) {
  if (num < 10ULL)
    return 1;
  if (num < 100ULL)
    return 2;
  if (num < 1000ULL)
    return 3;
  if (num < 10000ULL)
    return 4;
  if (num < 100000ULL)
    return 5;
  if (num < 1000000ULL)
    return 6;
  if (num < 10000000ULL)
    return 7;
  if (num < 100000000ULL)
    return 8;
  if (num < 1000000000ULL)
    return 9;
  if (num < 10000000000ULL)
    return 10;
  if (num < 100000000000ULL)
    return 11;
  if (num < 1000000000000ULL)
    return 12;
  if (num < 10000000000000ULL)
    return 13;
  if (num < 100000000000000ULL)
    return 14;
  if (num < 1000000000000000ULL)
    return 15;
  if (num < 10000000000000000ULL)
    return 16;
  if (num < 100000000000000000ULL)
    return 17;
  if (num < 1000000000000000000ULL)
    return 18;
  if (num < 10000000000000000000ULL)
    return 19;
  return 20;
}

/*
 * Get the time elabsed in ms
 */
static inline uint64_t get_time() {
  struct timespec ts;
  clock_gettime(CLOCK_MONOTONIC, &ts);
  return (uint64_t)(ts.tv_sec) * 1000 + (ts.tv_nsec / 1000000);
}

static inline FILE *log_init(const char *path) {
  FILE *res = fopen(path, "a+");
  setvbuf(res, NULL, _IONBF, 0);
  return res;
}

static inline int16_t pollevs(int connfd) {
  struct pollfd pfd;
  pfd.fd = connfd;
  pfd.events = POLLIN | POLLOUT | POLLERR;
  int res = poll(&pfd, 1, 0);
  if (res < 0)
    return POLLERR;
  return pfd.revents;
}

// FIXME This needs to be updated
static inline conn_t *MP_use_once(size_t nblocks, int fd) {

  void *mem = malloc(sizeof(conn_t) + 8 + (IOVEC_NBLOCKS * MP_BLOCK));
  struct conn_t *conn = (conn_t *)mem;
  memset(conn, 0, sizeof(conn_t));
  conn->ios = mem + sizeof(conn_t) + 8;

  if (nblocks > 0) {
    struct iovec *iov = &conn->ios[conn->nios++];
    mem = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (mem == MAP_FAILED)
      return NULL;
    iov->iov_base = mem;
    iov->iov_len = ALIGN_TO_PAGESIZE(nblocks * MP_BLOCK);
  }

  conn->flags |= CF_IN_HEAP;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;

  return conn;
}

static inline int find_freec() {
  uint64_t *word;
  size_t map_size = (sizeof(uint64_t) * 8);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    word = &pool.freecs[i / map_size];

    if (*word == 0) { // All used
      i += (map_size - 1);
      continue;
    }

    i += __builtin_ctzll(*word);
    MARK_BIT_USED(*word, i);
    return i;
  }

  return -1;
}

static inline int MP_init(size_t npages) {
  if (!npages)
    return -1;

  /*** Setup ***/
  pool.npages = npages;
  pool.pagesize = sysconf(_SC_PAGESIZE);

  /*** Pool ***/
  pool.bpool = mmap(NULL, pool.npages * pool.pagesize, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  if (pool.bpool == MAP_FAILED)
    return -1;
  pool.nblocks = (pool.npages * pool.pagesize) / MP_BLOCK;

  /*** Blocks ***/
  pool.blocks = malloc(sizeof(void *) * pool.nblocks);
  if (!pool.blocks)
    return -1;
  for (size_t i = 0; i < pool.nblocks; i++)
    pool.blocks[i] = pool.bpool + (i * MP_BLOCK);

  /*** Freebs ***/
  // if (posix_memalign((void **)&pool.freebs, 64, bitmap_size * sizeof(uint64_t)) < 0)
  size_t bitmap_size = (pool.nblocks + 63) / 64;
  pool.freebs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freebs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freebs[i] = UINT64_MAX;

  /*** Cpool ***/
  pool.cpool = (conn_t *)malloc(sizeof(conn_t) * MAX_CONNS);
  if (!pool.cpool)
    return -1;

  /*** Conns ***/
  pool.conns = (conn_t **)malloc(sizeof(conn_t *) * MAX_CONNS);
  if (!pool.conns)
    return -1;
  size_t conn_size = sizeof(conn_t);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    pool.conns[i] = (conn_t *)((char *)pool.cpool + (i * conn_size));
    pool.conns[i]->fd = -1;
    pool.conns[i]->in_fd = -1;
    pool.conns[i]->out_fd = -1;
  }

  /*** Freecs ***/
  bitmap_size = (MAX_CONNS + 63) / 64;
  pool.freecs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freecs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freecs[i] = UINT64_MAX;

  return 0;
}

static inline int MP_use_blks(size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t max_start = pool.nblocks - nblocks;
  size_t full_chunks = (nblocks / 64) * 64;

  for (size_t i = 0, c = 0; i <= max_start; i++, c++) {
    bool free = true;

    for (size_t j = 0; j < full_chunks; j += 64) {
      size_t word_index = (i + j) / 64;
      if (pool.freebs[word_index] != UINT64_MAX) {
        free = false;
        i += 63;
        break;
      }
    }

    for (size_t j = full_chunks; j < nblocks; j++) {
      size_t bit_index = i + j;
      size_t word_index = bit_index / 64;
      size_t bit_in_word = bit_index % 64;

      if (!BIT_IS_FREE(pool.freebs[word_index], bit_in_word)) {
        free = false;
        i += j;
        break;
      }
    }

    if (free) {
      for (size_t j = 0; j < full_chunks; j += 64) {
        size_t word_index = (i + j) / 64;
        pool.freebs[word_index] = 0;
      }

      for (size_t j = full_chunks; j < nblocks; j++) {
        size_t bit_index = i + j;
        size_t word_index = bit_index / 64;
        size_t bit_in_word = bit_index % 64;

        MARK_BIT_USED(pool.freebs[word_index], bit_in_word);
      }

      return i;
    }
  }

  return -1;
}

static inline int MP_free_blks(size_t bindex, size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t full_chunks = (nblocks / 64) * 64;
  for (size_t i = 0; i < full_chunks; i += 64) {
    size_t word_index = (bindex + i) / 64;
    pool.freebs[word_index] = UINT64_MAX;
  }

  for (size_t i = full_chunks; i < nblocks; i++) {
    size_t bit_index = bindex + i;
    size_t word_index = bit_index / 64;
    size_t bit_in_word = bit_index % 64;

    MARK_BIT_FREE(pool.freebs[word_index], bit_in_word);
  }

  memset(pool.blocks[bindex], 0, nblocks * MP_BLOCK);
  return 0;
}

static inline conn_t *MP_use(size_t nblocks, int fd, bool once) {
  if (fd <= 0)
    return NULL;
  if (once)
    return MP_use_once(nblocks, fd);

  int cindex = find_freec();
  if (cindex < 0) {
    LOG("Err: cindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  conn_t *conn = pool.conns[cindex];

  int ios_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (ios_bindex < 0) {
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }

  struct iovec *ios = pool.blocks[ios_bindex];
  conn->ios = ios;

  int rec_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (rec_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct iovec *rec = pool.blocks[rec_bindex];
  conn->rec = rec;

  int msg_bindex = MP_use_blks(MSG_NBLOCKS);
  if (msg_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct msghdr *msg = pool.blocks[msg_bindex];
  conn->msg = msg;

  if (nblocks > 0) {
    int bindex = MP_use_blks(nblocks);
    if (bindex < 0) {
      MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
      MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
      MP_free_blks(msg_bindex, IOVEC_NBLOCKS);
      MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
      LOG("Err: bindex < 0; will use MP_use_once\n");
      return MP_use_once(nblocks, fd);
    }

    size_t iov_index = conn->nios++;
    struct iovec *iov = &conn->ios[iov_index];
    struct iovec *rec = &conn->rec[iov_index];
    iov->iov_base = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
  }

  conn->msg->msg_iov = conn->ios;
  conn->msg->msg_iovlen = conn->nios;
  conn->cindex = cindex;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;
  return conn;
}

static inline void MP_shed(conn_t *conn, size_t iov_index, size_t nios) {
  struct iovec *iov, *rec;
  size_t bindex, nblocks, index;

  for (size_t i = 0; i < nios; i++) {
    index = iov_index + i;
    iov = &conn->ios[index];
    rec = &conn->rec[index];
    if (!rec || !rec->iov_base)
      continue;
    if (!IN_POOL(rec->iov_base)) {
      munmap(rec->iov_base, rec->iov_len / pool.pagesize);
    } else {
      bindex = ptr_diff((uintptr_t)rec->iov_base, (uintptr_t)pool.bpool) / MP_BLOCK;
      nblocks = rec->iov_len / MP_BLOCK;
      MP_free_blks(bindex, nblocks);
    }
    memset(iov, 0, sizeof(struct iovec));
    memset(rec, 0, sizeof(struct iovec));
    conn->nios--;
  }
}

static inline int MP_expand(conn_t *conn, size_t nblocks, bool once) {
  void *bptr;
  int iov_index, bindex;
  struct iovec *iov, *rec;

  iov_index = conn->nios++;
  iov = &conn->ios[iov_index];
  rec = &conn->rec[iov_index];

  if (nblocks == 0)
    return iov_index;

  if (once) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_base = bptr;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
    return iov_index;
  }

  bindex = MP_use_blks(nblocks);
  if (bindex < 0) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_len = iov->iov_len;
  } else {
    bptr = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_len = iov->iov_len;
  }

  iov->iov_base = bptr;
  rec->iov_base = iov->iov_base;
  return iov_index;
}

static inline int MP_free(conn_t *conn) {
  if (!conn)
    return -1;
  size_t bindex, nblocks;
  uint64_t *word;

  MP_shed(conn, 0, conn->nios);
  if (conn->flags & CF_IN_HEAP) {
    if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
      close(conn->fd);
    free(conn);
    return 0;
  }

  word = &pool.freecs[conn->cindex / 64];
  if (conn->cindex > MAX_CONNS)
    return -1;
  else if (BIT_IS_FREE(*word, conn->cindex))
    return 0;

  bindex = ptr_diff((uintptr_t)conn->ios, (uintptr_t)pool.bpool) / MP_BLOCK;
  nblocks = IOVEC_NBLOCKS;
  MP_free_blks(bindex, nblocks);

  bindex = ptr_diff((uintptr_t)conn->rec, (uintptr_t)pool.bpool) / MP_BLOCK;
  MP_free_blks(bindex, nblocks);

  if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
    close(conn->fd);

  MARK_BIT_FREE(*word, conn->cindex);
  memset(conn, 0, sizeof(conn_t));
  conn->fd = -1;
  conn->in_fd = -1;
  conn->out_fd = -1;
  return 0;
}

static inline void MP_clear(conn_t *conn) {
  conn_t *recv_conn = conn->recv_conn;
  conn_t *send_conn = conn->send_conn;
  if (recv_conn)
    MP_free(recv_conn);
  if (send_conn)
    MP_free(send_conn);
}

static inline void MP_exit(MPool *pool) {
  munmap(pool->bpool, pool->npages);
  free(pool->cpool);
  free(pool->blocks);
  free(pool->conns);
  free(pool->freebs);
  free(pool->freecs);
}

static inline void MP_timeout() {
  conn_t *conn;
  int16_t res;
  uint64_t now;
  size_t windex = 0;
  uint64_t *word = &pool.freecs[0];
  for (size_t i = 0; i < MAX_CONNS; i++) {
    if ((i / 64) < windex)
      word = &pool.freecs[++windex];

    if (*word == UINTMAX_MAX) {
      i = (i / 64) * 64 + 64;
      continue;
    }

    conn = pool.conns[i];
    if (!conn || conn->fd == -1)
      continue;

    res = pollevs(conn->fd);

    now = get_time();
    if (res & POLLERR) {
      MP_clear(conn);
      continue;
    }
    if (res & POLLIN) {
      if (pool.rtimeout > 0 && (now - conn->last_read) >= pool.rtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (res & POLLOUT) {
      if (pool.wtimeout > 0 && (now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (!(res & POLLIN || res & POLLOUT)) {
      if ((pool.rtimeout > 0 && now - conn->last_read) >= pool.rtimeout
          || (pool.wtimeout > 0 && now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
  }
}

/*
 * Calculate the length of a status string
 */
static inline size_t status_len(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return 8;
  case STATUSSWITCHINGPROTOCOLS:
    return 19;
  case STATUSPROCESSING:
    return 10;
  case STATUSEARLYHINTS:
    return 11;
  case STATUSOK:
    return 2;
  case STATUSCREATED:
    return 7;
  case STATUSACCEPTED:
    return 8;
  case STATUSNONAUTHORITATIVE:
    return 29;
  case STATUSNOCONTENT:
    return 10;
  case STATUSRESETCONTENT:
    return 13;
  case STATUSPARTIALCONTENT:
    return 15;
  case STATUSMULTISTATUS:
    return 12;
  case STATUSALREADYREPORTED:
    return 16;
  case STATUSIMUSED:
    return 7;
  case STATUSMULTIPLECHOICES:
    return 16;
  case STATUSMOVEDPERMANENTLY:
    return 17;
  case STATUSFOUND:
    return 5;
  case STATUSSEEOTHER:
    return 9;
  case STATUSNOTMODIFIED:
    return 12;
  case STATUSUSEPROXY:
    return 9;
  case STATUSTEMPORARYREDIRECT:
    return 18;
  case STATUSPERMANENTREDIRECT:
    return 18;
  case STATUSBADREQUEST:
    return 11;
  case STATUSUNAUTHORIZED:
    return 12;
  case STATUSPAYMENTREQUIRED:
    return 16;
  case STATUSFORBIDDEN:
    return 9;
  case STATUSNOTFOUND:
    return 9;
  case STATUSMETHODNOTALLOWED:
    return 18;
  case STATUSNOTACCEPTABLE:
    return 14;
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return 29;
  case STATUSREQUESTTIMEOUT:
    return 15;
  case STATUSCONFLICT:
    return 8;
  case STATUSGONE:
    return 4;
  case STATUSLENGTHREQUIRED:
    return 15;
  case STATUSPRECONDITIONFAILED:
    return 19;
  case CONTENTTOOLARGE:
    return 17;
  case STATUSURITOOLONG:
    return 12;
  case STATUSUNSUPPORTEDMEDIATYPE:
    return 22;
  case STATUSRANGENOTSATISFIABLE:
    return 21;
  case STATUSEXPECTATIONFAILED:
    return 18;
  case STATUSMISDIRECTEDREQUEST:
    return 19;
  case STATUSUNPROCESSABLECONTENT:
    return 21;
  case STATUSLOCKED:
    return 6;
  case STATUSFAILEDDEPENDENCY:
    return 17;
  case STATUSTOOEARLY:
    return 9;
  case STATUSUPGRADEREQUIRED:
    return 16;
  case STATUSPRECONDITIONREQUIRED:
    return 21;
  case STATUSTOOMANYREQUESTS:
    return 17;
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return 31;
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return 29;
  case STATUSInternalServerError:
    return 21;
  case STATUSNOTIMPLEMENTED:
    return 15;
  case STATUSBADGATEWAY:
    return 11;
  case STATUSSERVICEUNAVAILABLE:
    return 19;
  case STATUSGATEWAYTIMEOUT:
    return 15;
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return 26;
  case STATUSVARIANTALSONEGOTIATES:
    return 23;
  case STATUSINSUFFICIENTSTORAGE:
    return 20;
  case STATUSLOOPDETECTED:
    return 13;
  case STATUSNOTEXTENDED:
    return 12;
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return 31;
  default:
    return 0;
  }
}

/*
 * Return the status code string as string literal
 */
static inline char *status_str(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return "Continue";
  case STATUSSWITCHINGPROTOCOLS:
    return "Switching Protocols";
  case STATUSPROCESSING:
    return "Processing";
  case STATUSEARLYHINTS:
    return "Early Hints";
  case STATUSOK:
    return "OK";
  case STATUSCREATED:
    return "Created";
  case STATUSACCEPTED:
    return "Accepted";
  case STATUSNONAUTHORITATIVE:
    return "Non-Authoritative Information";
  case STATUSNOCONTENT:
    return "No Content";
  case STATUSRESETCONTENT:
    return "Reset Content";
  case STATUSPARTIALCONTENT:
    return "Partial Content";
  case STATUSMULTISTATUS:
    return "Multi-Status";
  case STATUSALREADYREPORTED:
    return "Already Reported";
  case STATUSIMUSED:
    return "Im Used";
  case STATUSMULTIPLECHOICES:
    return "Multiple Choices";
  case STATUSMOVEDPERMANENTLY:
    return "Moved Permanently";
  case STATUSFOUND:
    return "Found";
  case STATUSSEEOTHER:
    return "See Other";
  case STATUSNOTMODIFIED:
    return "Not Modified";
  case STATUSUSEPROXY:
    return "Use Proxy";
  case STATUSTEMPORARYREDIRECT:
    return "Temporary Redirect";
  case STATUSPERMANENTREDIRECT:
    return "Permanent Redirect";
  case STATUSBADREQUEST:
    return "Bad Request";
  case STATUSUNAUTHORIZED:
    return "Unauthorized";
  case STATUSPAYMENTREQUIRED:
    return "Payment Required";
  case STATUSFORBIDDEN:
    return "Forbidden";
  case STATUSNOTFOUND:
    return "Not Found";
  case STATUSMETHODNOTALLOWED:
    return "Method Not Allowed";
  case STATUSNOTACCEPTABLE:
    return "Not Acceptable";
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return "Proxy Authentication Required";
  case STATUSREQUESTTIMEOUT:
    return "Request Timeout";
  case STATUSCONFLICT:
    return "Conflict";
  case STATUSGONE:
    return "Gone";
  case STATUSLENGTHREQUIRED:
    return "Length Required";
  case STATUSPRECONDITIONFAILED:
    return "Precondition Failed";
  case CONTENTTOOLARGE:
    return "Content Too Large";
  case STATUSURITOOLONG:
    return "URI Too Long";
  case STATUSUNSUPPORTEDMEDIATYPE:
    return "Unsupported Media Type";
  case STATUSRANGENOTSATISFIABLE:
    return "Range Not Satisfiable";
  case STATUSEXPECTATIONFAILED:
    return "Expectation Failed";
  case STATUSMISDIRECTEDREQUEST:
    return "Misdirected Request";
  case STATUSUNPROCESSABLECONTENT:
    return "Unprocessable Content";
  case STATUSLOCKED:
    return "Locked";
  case STATUSFAILEDDEPENDENCY:
    return "Failed Dependency";
  case STATUSTOOEARLY:
    return "Too Early";
  case STATUSUPGRADEREQUIRED:
    return "Upgrade Required";
  case STATUSPRECONDITIONREQUIRED:
    return "Precondition Required";
  case STATUSTOOMANYREQUESTS:
    return "Too Many Requests";
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return "Request Header Fields Too Large";
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return "Unavailable For Legal Reasons";
  case STATUSInternalServerError:
    return "Internal Server Error";
  case STATUSNOTIMPLEMENTED:
    return "Not Implemented";
  case STATUSBADGATEWAY:
    return "Bad Gateway";
  case STATUSSERVICEUNAVAILABLE:
    return "Service Unavailable";
  case STATUSGATEWAYTIMEOUT:
    return "Gateway Timeout";
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return "HTTP Version Not Supported";
  case STATUSVARIANTALSONEGOTIATES:
    return "Variant Also Negotiates";
  case STATUSINSUFFICIENTSTORAGE:
    return "Insufficient Storage";
  case STATUSLOOPDETECTED:
    return "Loop Detected";
  case STATUSNOTEXTENDED:
    return "Not Extended";
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return "Network Authentication Required";
  default:
    return 0;
  }
}

/*
 * Return true if routes match
 */
static inline bool route_equ(Route *route, Request *req) {
  return route->method == req->method && strncmp(route->path, req->path, strlen(route->path)) == 0;
}

/*
 * Return the matching route index on success. -1 on failure
 */
static inline int match_route(Server *serv, Request *req) {
  for (size_t i = 0; i < serv->_nroutes; i++) {
    Route route = serv->routes[i];
    if (!req->path || !route.path)
      continue;
    if (route_equ(&route, req))
      return i;
    else if (req->method == HEAD && route.method == GET && strcmp(route.path, req->path) == 0)
      return i;
  }
  return -1;
}

/*
 * Return true if the response should contain the Content-Length header
 */
static inline bool should_have_content_length(Request *req, ResWriter *res) {
  return (req->method != CONNECT              // CONNECT request
          && res->status != STATUSNOCONTENT   // 204 response
          && res->status != STATUSNOTMODIFIED // 304 response
          && res->status >= 200);             // 1xx response
}

/*
 * Format http response from the ResWriter.
 * Return response size on success, 0 on failure.
 */
static inline size_t fmt_res(Request *req, ResWriter *res, char *buffer, size_t buffer_size) {
  if (!res || !buffer || buffer_size == 0)
    return 0;

  size_t res_len, total = 0;
  char *dst = buffer;
  size_t maxlen = buffer_size;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t body_length = res->len;

  res_len = snprintf(dst, maxlen, "HTTP/1.1 %d %s", (int)res->status, status_str(res->status));
  total += res_len;
  dst += res_len;
  maxlen -= res_len;

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    res_len = snprintf(dst, maxlen, "\r\n%s: %s", header->key, header->value);
    total += res_len;
    dst += res_len;
    maxlen -= res_len;
  }

  if (have_content_length) {
    res_len = snprintf(dst, maxlen, "\r\nContent-Length: %lu", body_length);
    total += res_len, dst += res_len, maxlen -= res_len;
  }

  memcpy(dst, "\r\n\r\n", 4);
  total += 4, dst += 4, maxlen -= 4;

  return total;
}

static inline size_t res_len(Request *req, ResWriter *res) {
  if (!req || !res)
    return 0;

  if (!res->status)
    res->status = STATUSOK;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t result = 0;
  result += STRLEN("HTTP/1.1 ");     // HTTP version
  result += 4;                       // Status code + space
  result += status_len(res->status); // Status name

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    result += 2;                       // "\r\n"
    result += strlen(header->key) + 2; // Header key + ':' + space
    result += strlen(header->value);   // header value
  }

  if (have_content_length) {
    result += 2;                          // "\r\n"
    result += STRLEN("Content-Length: "); // Header key
    result += countd(res->len);           // Header value
  }

  result += 4; // "\r\n\r\n"

  return result;
}

static inline int send_empty_res(Status status) {
  size_t res_len = STRLEN("HTTP/1.1 ")        // HTTP version
                   + countd((uint64_t)status) // status code
                   + 1                        // space
                   + (int)status_len(status)  // status string
                   + 4;                       // \r\n\r\n

  conn_t *conn = current_send;
  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, res_len);
  if (snprintf((char *)rec->iov_base, res_len + 1, "HTTP/1.1 %d %s\r\n\r\n", (int)status, status_str(status))
      != (int)res_len)
    return -1;

  return usendmsg(conn, 0, 1);
}

static inline ssize_t read_socket(int sockfd, size_t len) {
  if (len == 0 || sockfd <= 0)
    return 0;
  char buff[1024 * 8];
  return read(sockfd, buff, 1024 * 8);
}

static inline int read_method(Method *method, void *src) {
  if (memcmp(src, "GET", 3) == 0)
    *method = GET;
  else if (memcmp(src, "POST", 4) == 0)
    *method = POST;
  else if (memcmp(src, "HEAD", 4) == 0)
    *method = HEAD;
  else if (memcmp(src, "PUT", 3) == 0)
    *method = PUT;
  else if (memcmp(src, "DELETE", 6) == 0)
    *method = DELETE;
  else if (memcmp(src, "CONNECT", 7) == 0)
    *method = CONNECT;
  else if (memcmp(src, "OPTIONS", 7) == 0)
    *method = OPTIONS;
  else if (memcmp(src, "TRACE", 5) == 0)
    *method = TRACE;
  else if (memcmp(src, "PATCH", 5) == 0)
    *method = PATCH;
  else
    return -1;

  return 0;
}

static inline int sendmsg_res(Request *req, ResWriter *res) {
  conn_t *conn;
  size_t head_size, res_size;
  struct iovec *iov;

  conn = current_send;
  iov = &conn->ios[0];
  head_size = res_len(req, res);
  if (head_size == 0)
    return -1;

  conn->data_left += head_size;
  res_size = fmt_res(req, res, iov->iov_base, (head_size + 1));
  if (res_size != head_size)
    return -1;
  iov->iov_len = res_size;

  return usendmsg(conn, 0, conn->nios);
}

static inline int read_req(Request *req, char *req_buffer) {
  if (!req_buffer)
    return -1;
  /*** Method ***/
  char *sep = strchr(req_buffer, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }
  *sep = '\0';
  if (read_method(&req->method, req_buffer) < 0)
    return -1;

  /*** Path ***/
  char *fullpath = sep + 1;
  sep = strchr(fullpath, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }

  *sep = '\0';
  req->path = fullpath;
  /*** Params ***/
  char *paramStart = strchr(fullpath, '?');
  if (paramStart) {
    *paramStart++ = '\0';
    int params_count = 0;
    params_count = HK_parse_params(paramStart, req->params, MAX_URL_PARAMETERS);
    if (params_count > 0)
      req->params_count = params_count;
    else
      req->params_count = 0;
  } else {
    req->params = NULL;
    req->params_count = 0;
  }

  /*** Headers ***/
  char *headStart = strstr(sep + 1, "\r\n");
  char *headEnd = strstr(sep + 1, "\r\n\r\n");
  if (!headStart) {
    LOG("read_req: !headStart\n");
    return -1;
  };

  memset(headStart, 0, 2);
  headStart += 2;
  memset(headEnd, 0, 4);
  headEnd += 4;

  int headers_count = HK_parse_headers(headStart, req->headers, MAX_REQ_HEADERS);
  if (headers_count <= 0)
    return -1;
  req->headers_count = headers_count;

  /*** Host ***/
  int index = HK_get_header(req, "Host");
  if (index < 0)
    return -1;
  char *host = req->headers[index].value;
  req->hostname = host;

  /*** Port ***/
  char *colon = strchr(host, ':');
  if (colon) {
    *colon++ = '\0';
    req->port = atoi(colon);
  } else {
    req->port = PORT;
  }
  return 0;
}
static inline int process_req(Server *serv, conn_t *conn) {
  if (!conn || conn->fd == -1)
    return -1;

  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;
  if (read_req(&req, conn->ios[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    LOG("Err: route_index == -1\n");
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;
  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  sendmsg_res(&req, &res);

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int new_conn(int connfd) {
  if (connfd <= 0)
    return -1;

  current_recv = MP_use(KB * 2, connfd, false);
  current_send = MP_use(KB * 2, connfd, false);

  current_recv->recv_conn = current_recv;
  current_recv->send_conn = current_send;

  current_send->send_conn = current_send;
  current_send->recv_conn = current_recv;

  conn_t *conn = current_recv;
  if (ufrecvmsg(conn, 0, 1) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

static inline int resubmit_sendmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return usendmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int resubmir_recvmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    // FIXME the len should be increased
    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return urecvmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int handle_sendmsg_complete(conn_t *conn) {
  struct iovec *iov, *rec;

  MP_shed(conn, 1, conn->nios - 1);
  iov = &conn->ios[0];
  rec = &conn->rec[0];
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;

  return ufrecvmsg(conn->recv_conn, 0, 1);
}

static inline int handle_sendmsg(conn_t *conn, int res, bool zc) {
  if (!conn || conn->fd == -1)
    return -1;

  conn->data_left -= res;
  if (conn->data_left > 0)
    return resubmit_sendmsg(conn, res);

  if (zc)
    return 0;

  return handle_sendmsg_complete(conn);
}

static inline int handle_insplice(conn_t *conn) {
  conn->op = OUTSPLICE;
  return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
}
static inline int handle_outsplice(conn_t *conn, int res) {
  conn->data_left -= res;
  if (conn->data_left > 0) {
    conn->op = INSPLICE;
    return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
  }

  conn_t *recv_conn = conn->recv_conn;
  struct iovec *iov = &recv_conn->ios[0];
  memset(iov->iov_base, 0, iov->iov_len);
  if (urecv(recv_conn, iov->iov_base, iov->iov_len, MSG_PEEK) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

/*
static inline int handle_recv(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  void *bptr = conn->ios[0].iov_base;
  void *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  void *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  return process_req(serv, conn);
}
*/
static inline int find_route(Server *serv, char *bptr) {
  Request req = {0};
  if (read_method(&req.method, bptr) < 0) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  };
  char *space = strchr(bptr, ' ');
  req.path = (space + 1);
  space = strchr(req.path, ' ');
  *space = '\0';
  int route_index = match_route(serv, &req);
  *space = ' ';
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }
  return route_index;
}

static inline int run_handler(Server *serv, conn_t *conn, bool uses_body) {
  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;

  if (read_req(&req, conn->rec[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  if (uses_body) {
    int h_index = HK_get_header(&req, "Content-Length");
    long body_size = atol(req.headers[h_index].value);
    if (body_size >= 0) {
      req.body.ptr = conn->rec[1].iov_base;
      req.body.size = body_size;
    } else {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    }
  }

  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  if (sendmsg_res(&req, &res) < 0)
    return -1;

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int handle_frecvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  char *bptr = (char *)conn->ios[0].iov_base;
  char *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  char *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  size_t head_size = (headEnd + 4) - bptr;
  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  int route_index = find_route(serv, bptr);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  bool uses_body = serv->routes[route_index].uses_body;
  long body_size = get_content_length(headstart + 2, headEnd + 4);
  if (body_size == -1) {
    if (uses_body) {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    } else {
      body_size = 0;
    }
  }

  conn->head_size = head_size;
  if (!uses_body) {
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  if (res == (int)(head_size + body_size)) {
    size_t iov_index = MP_expand(conn, round_to_blocks(body_size), false);
    memcpy(conn->rec[iov_index].iov_base, headEnd + 4, body_size);
    conn->ios[iov_index].iov_len = body_size;
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  conn->data_left = body_size - (res - head_size);
  bool once = ((size_t)body_size > (size_t)((pool.nblocks * MP_BLOCK) / 10));
  size_t iov_index = MP_expand(conn, round_to_blocks(body_size), once);
  memcpy(conn->rec[iov_index].iov_base, headEnd + 4, (res - head_size));
  conn->ios[iov_index].iov_base += (res - head_size);

  return urecvmsg(conn, iov_index, 1);
}

static inline int handle_recvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  if (conn->data_left > 0) {
    conn->data_left -= res;
    if (conn->data_left == 0) {
      conn->flags &= CF_HANDLER_READY;
      return run_handler(serv, conn, true);
    }

    conn->flags &= ~CF_HANDLER_READY;
    conn->ios[1].iov_base += res;
    return urecvmsg(conn, 1, 1);
  }

  conn->flags &= CF_HANDLER_READY;
  return run_handler(serv, conn, true);
}

static inline int serv_init(Server *serv) {
#if DEBUG
  logfd = log_init("log.txt");
  if (!logfd) {
    printf("log_init failed");
    return -1;
  }
#endif
  serv->_nroutes = get_nroutes(serv->routes);

  int pipefd[2];
  if (pipe(pipefd) < 0)
    return -1;
  pipe_in = pipefd[0];
  pipe_out = pipefd[1];
  nullfd = open("/dev/null", O_WRONLY);
  pipe_sz = fcntl(pipefd[0], F_GETPIPE_SZ);
  if (pipe_sz < 0)
    return -1;

  pool.rtimeout = serv->rtimeout;
  pool.wtimeout = serv->wtimeout;
  if (MP_init(MAX_CONNS * 8) < 0)
    return -1;
  LOG("pool initialized\n");

  if (io_uring_queue_init(MAX_CONNS, &ring, 0) < 0)
    return -1;
  LOG("uring initialized\n");

  int listenfd;
  if ((listenfd = tcp_listen(serv->port)) < 0)
    return -1;
  LOG("socket initialized\n");

  return umaccept(listenfd);
}

static inline int serv_listen(Server *serv) {
  // uint64_t last_check = get_time();
  while (true) {
    // uint64_t now = get_time();
    // if ((now - last_check) >= 200) {
    //   last_check = now;
    //   LOG("CM: CM_check ran\n");
    //   MP_timeout();
    // }

    LOG("SQ ready: %u, CQ ready: %u\n", io_uring_sq_ready(&ring), io_uring_cq_ready(&ring));
    struct io_uring_cqe *cqe;
    if (io_uring_wait_cqe(&ring, &cqe) < 0)
      continue;

    int res = cqe->res;
    LOG("res = %d\n", res);
    conn_t *conn = NULL;
    if (cqe->user_data > 100) {
      conn = (conn_t *)cqe->user_data;
      current_recv = (conn_t *)conn->recv_conn;
      current_send = (conn_t *)conn->send_conn;
    }

    if (res > 0) {
      if (cqe->user_data == ACCEPT) {
        LOG("new conn created\n");
        new_conn(res);
      } else if (conn && conn->fd != -1) {
        LOG("conn[%d]: conn.fd = %d; conn.op = %d\n", conn->cindex, conn->fd, conn->op);
        switch (conn->op) {
        case FRECVMSG:
          if (handle_frecvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case RECVMSG:
          if (handle_recvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case SENDMSG:
        case SENDMSGZC:
          // conn->last_write = get_time();
          bool zc = (conn->op == SENDMSGZC);
          if (handle_sendmsg(conn, res, zc) < 0)
            MP_clear(conn);
          break;
        case INSPLICE:
          if (handle_insplice(conn) < 0)
            MP_clear(conn);
          break;
        case OUTSPLICE:
          if (handle_outsplice(conn, res) < 0)
            MP_clear(conn);
          break;
        }
      }
    } else if (res == 0) {
      if (conn && conn->fd != -1) {
        switch (conn->op) {
        case SENDMSGZC:
          conn->zc_notifs--;
          if (conn->zc_notifs == 0 && handle_sendmsg_complete(conn) < 0)
            MP_clear(conn);
          break;
        case RECV:
          MP_clear(conn);
          break;
        }
      }
    } else {
      if (conn && conn->fd != -1) {
        if (res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR) {
          LOG("conn && conn->fd != -1 && res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR\n");
          MP_clear(conn);
        } else {
          LOG("res == -EAGAIN || res == -EWOULDBLOCK || res == -EINTR\n");
          conn = conn->recv_conn;
          struct iovec *iov = &conn->ios[0];
          memset(iov->iov_base, 0, iov->iov_len);
          if (urecv(conn, iov->iov_base, iov->iov_len, 0) < 0)
            MP_clear(conn);
        }
      }
    }

    LOG("uring operation seen\n");
    io_uring_cqe_seen(&ring, cqe);
  }

  io_uring_queue_exit(&ring);
  MP_exit(&pool);
  return 0;
}

/*** Helper ***/
static inline int _HK_write(void *data, size_t size) {
  size_t nblocks;
  int iov_index;
  conn_t *conn;
  struct iovec *iov;
  bool once;

  conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  nblocks = round_to_blocks(size);
  iov_index = MP_expand(conn, nblocks, once);
  iov = &conn->ios[iov_index];

  memcpy(iov->iov_base, data, size);
  iov->iov_len = size;
  conn->data_left += size;

  return 0;
}
static inline int _HK_write_body(Request *req, size_t offset, size_t size) {
  if (size > req->body.size || offset > req->body.size)
    return -1;

  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  int iov_index = MP_expand(conn, 0, false);
  struct iovec *iov = &conn->ios[iov_index];
  struct iovec *rec = &conn->rec[iov_index];
  rec->iov_base = req->body.ptr + offset;
  rec->iov_len = size;
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;
  conn->data_left += rec->iov_len;
  return 0;
}
/*
static inline int _HK_mem(size_t size, HKMem *mem) {
  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  bool once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  size_t nblocks = round_to_blocks(size);
  int iov_index = MP_expand(conn, nblocks, once);
  struct iovec *iov = &conn->ios[iov_index];
  mem->ptr = iov->iov_base;
  mem->size = iov->iov_len;
  mem->_iov_index = iov_index;
  mem->_flags = (IN_POOL(iov->iov_base)) ? CF_IN_POOL : CF_IN_HEAP;
  return 0;
}

static inline void _HK_send(HKMem *mem, size_t size) {
  conn_t *conn = current_send;
  struct iovec *iov = &conn->ios[mem->_iov_index];
  iov->iov_len = size;
  conn->data_left += size;
}
  */
#endif#define _GNU_SOURCE
#ifndef UTILS_H
#define UTILS_H

#include "hunk.h"
#include <arpa/inet.h>
#include <fcntl.h>
#include <liburing.h>
#include <netdb.h>
#include <signal.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/poll.h>
#include <sys/prctl.h>
#include <sys/socket.h>
#include <sys/sysinfo.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

#define MP_BLOCK  4
#define MAX_CONNS 4096
#define KB        1024
#define NIOS      32

#define IN_POOL(ptr)                 ((void *)ptr >= pool.bpool && (void *)ptr <= (pool.bpool + (pool.npages * pool.pagesize)))
#define ALIGN_TO_PAGESIZE(buff_size) (((buff_size) + (pool.pagesize - 1)) & ~(pool.pagesize - 1))
#define BYTES_TO_BLOCKS(buff_size)   (((buff_size) + (MP_BLOCK - 1)) / MP_BLOCK)
#define CEIL_BLOCKS(nblocks)         ((nblocks + 63) & ~63)
#define CEIL_PAGES(size)             (((size) + ((pool.pagesize) - 1)) & ~((pool.pagesize) - 1))

#define BIT_IS_FREE(word, bit)   (((word) >> (bit)) & 1)
#define MARK_BIT_USED(word, bit) ((word) &= ~(1ULL << (bit)))
#define MARK_BIT_FREE(word, bit) ((word) |= (1ULL << (bit)))
#define FIND_FREE_BIT(word)      ((uint64_t)(word) & -(uint64_t)(word))
#define STRLEN(s)                (sizeof(s) - 1)

#define IOVEC_NBLOCKS (BYTES_TO_BLOCKS(NIOS * sizeof(struct iovec)))
#define MSG_NBLOCKS   (BYTES_TO_BLOCKS(sizeof(struct msghdr)))
#define ZC_RES        KB *KB

#define DEBUG 0
#if DEBUG
#define LOG(...) fprintf(logfd, __VA_ARGS__)
#else
#define LOG(...) ((void)0)
#endif

typedef enum UOP {
  WRITEV = IORING_OP_WRITEV,
  SENDMSG = IORING_OP_SENDMSG,
  RECVMSG = IORING_OP_RECVMSG,
  ACCEPT = IORING_OP_ACCEPT,
  SEND = IORING_OP_SEND,
  RECV = IORING_OP_RECV,
  SENDZC = IORING_OP_SEND_ZC,
  SENDMSGZC = IORING_OP_SENDMSG_ZC,
  PEEK = 50,
  FRECVMSG,
  INSPLICE,
  OUTSPLICE
} UOP;

typedef enum CFS {
  CF_IN_POOL = (1 << 0),       // Connection is in the pool
  CF_IN_HEAP = (1 << 1),       // Connection is in the heap
  CF_SKIP_SOCK = (1 << 2),     // Don't close the socket
  CF_USE_ONCE = (1 << 3),      // Destroy after using
  CF_HANDLER_READY = (1 << 4), // Ready to call the handler
} CFS;

typedef struct conn_t {
  // Socket file descriptor
  int fd;

  // Amount of data left in the current operation
  uint64_t data_left;

  // The index of the connection struct
  uint32_t cindex;

  // The last time the connection was readable
  uint64_t last_read;

  // The last time the connection was writeable
  uint64_t last_write;

  // The operation currently being processed
  uint8_t op;

  // Connection flags
  int flags;

  // Splice fd_in
  int in_fd;

  // Splice fd_out
  int out_fd;

  void *recv_conn;
  void *send_conn;

  struct iovec *ios;
  struct iovec *rec;
  uint16_t nios;

  struct msghdr *msg;
  uint16_t zc_notifs;

  uint16_t head_size;
} conn_t;

typedef struct MPool {
  // The allocated pool of blocks
  void *bpool;

  // The allocated pool of connections
  conn_t *cpool;

  // The size of the pool in pages
  uint32_t npages;

  // The size of the pool in blocks
  uint32_t nblocks;

  // The locations of each page in the pool
  void **blocks;

  // The availability of each block
  uint64_t *freebs;

  // The locations of each conn in the pool
  conn_t **conns;

  // The availability of each conn
  uint64_t *freecs;

  // Clean up callback function
  void (*callback)(conn_t *conn);

  // The page size used
  uint32_t pagesize;

  // Socket read timeout
  uint32_t rtimeout;

  // Socket write timeout
  uint32_t wtimeout;
} MPool;

extern int pipe_sz;
extern int pipe_in, pipe_out, nullfd;
extern FILE *logfd;
extern struct io_uring ring;
extern MPool pool;
extern conn_t *current_recv;
extern conn_t *current_send;

/*
 * Prepare and submit a recv uring op
 */
static inline int urecv(conn_t *conn, void *buffer, size_t buff_size, int flags) {
  if (!conn || conn->fd == -1)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (flags == MSG_PEEK) ? PEEK : RECV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;

  io_uring_prep_recv(sqe, conn->fd, buffer, buff_size, flags);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a multi-shot accept uring op
 */
static inline int umaccept(int listenfd) {
  if (listenfd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = ACCEPT;
  io_uring_prep_multishot_accept(sqe, listenfd, NULL, NULL, SOCK_NONBLOCK);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a splice uring op
 */
static inline int usplice(conn_t *conn, int fd_in, int64_t off_in, int fd_out, int64_t off_out, size_t len) {
  if (!len || !conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = (__u64)conn;
  io_uring_prep_splice(sqe, fd_in, off_in, fd_out, off_out, len, 0);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a writev uring op
 */
static inline int uwritev(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = WRITEV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  io_uring_prep_writev(sqe, conn->fd, &conn->ios[iov_index], nios, -1);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a send uring op
 */
static inline int usend(conn_t *conn, char *res_buff, size_t buff_size, bool zc) {
  if (!conn || conn->fd <= 0 || buff_size == 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (zc) ? SENDZC : SEND;
  conn->data_left = buff_size;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  if (zc)
    io_uring_prep_send_zc(sqe, conn->fd, res_buff, buff_size, 0, 0);
  else
    io_uring_prep_send(sqe, conn->fd, res_buff, buff_size, 0);
  return io_uring_submit(&ring);
}

static inline int ufrecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = FRECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;

  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, rec->iov_len);
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int urecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = RECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int usendmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  bool zc = (conn->data_left > ZC_RES) ? true : false;
  conn->op = (zc) ? SENDMSGZC : SENDMSG;

  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  if (zc) {
    io_uring_prep_sendmsg_zc(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
    conn->zc_notifs++;
  } else {
    io_uring_prep_sendmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  }
  return io_uring_submit(&ring);
}

/*
 * Create and initialize a server socket
 */
static inline int tcp_listen(uint16_t port) {
  int enable;
  int listenfd;
  if ((listenfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    return -1;

  int flags = fcntl(listenfd, F_GETFL, 0);
  fcntl(listenfd, F_SETFL, flags | O_NONBLOCK);
  struct sockaddr_in servaddr;
  memset(&servaddr, 0, sizeof(servaddr));
  servaddr.sin_family = AF_INET;
  servaddr.sin_addr.s_addr = INADDR_ANY;
  servaddr.sin_port = htons(port);

  enable = 1;
  if (setsockopt(listenfd, SOL_SOCKET, SO_REUSEPORT, &enable, sizeof(enable)) < 0)
    return -1;

  if (bind(listenfd, (struct sockaddr *)&servaddr, sizeof(servaddr)) < 0)
    return -1;

  if (listen(listenfd, SOMAXCONN) < 0)
    return -1;

  return listenfd;
}

/*
 * Calculate the difference between two pointers
 */
static inline uintptr_t ptr_diff(uintptr_t p1, uintptr_t p2) { return (uintptr_t)(p1 > p2) ? (p1 - p2) : (p2 - p1); }

static inline size_t get_nroutes(Route *routes) {
  Route *route;
  for (size_t i = 0;; i++) {
    route = &routes[i];
    if (!route->path && !route->handler && !route->method)
      return i;
  }
}

static inline long get_content_length(char *src, char *end) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return -1;
    key = line;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, "Content-Length") != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;

    *line_end = '\0';
    long res = atol(value);
    *line_end = '\r';

    return res;
  }
  return -1;
}

static inline bool have_header(char *src, char *end, const char *header_key, const char *header_value) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    key = line;
    while (*key == ' ')
      key++;
    while (*header_key == ' ')
      header_key++;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return false;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, header_key) != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;
    while (*header_value == ' ')
      header_value++;

    *line_end = '\0';
    bool res = (strcasecmp(value, header_value) == 0);
    *line_end = '\r';

    return res;
  }

  return false;
}

static inline const char *method_str(Method method) {
  switch (method) {
  case GET:
    return "GET";
    break;
  case HEAD:
    return "HEAD";
    break;
  case POST:
    return "POST";
    break;
  case PUT:
    return "PUT";
    break;
  case DELETE:
    return "DELETE";
    break;
  case CONNECT:
    return "CONNECT";
    break;
  case OPTIONS:
    return "OPTIONS";
    break;
  case TRACE:
    return "TRACE";
    break;
  case PATCH:
    return "PATCH";
    break;
  default:
    return NULL;
  }
}

static inline uint8_t method_len(Method method) {
  switch (method) {
  case GET:
    return 3;
    break;
  case HEAD:
    return 4;
    break;
  case POST:
    return 4;
    break;
  case PUT:
    return 3;
    break;
  case DELETE:
    return 6;
    break;
  case CONNECT:
    return 7;
    break;
  case OPTIONS:
    return 7;
    break;
  case TRACE:
    return 5;
    break;
  case PATCH:
    return 5;
    break;
  default:
    return 0;
  }
}

static inline size_t round_to_blocks(size_t size) {
  size_t nblocks = BYTES_TO_BLOCKS(size);
  nblocks = CEIL_BLOCKS(nblocks);
  return nblocks;
}

/*
 * Count the digits in unsigned 64-bit int
 */
static inline int countd(uint64_t num) {
  if (num < 10ULL)
    return 1;
  if (num < 100ULL)
    return 2;
  if (num < 1000ULL)
    return 3;
  if (num < 10000ULL)
    return 4;
  if (num < 100000ULL)
    return 5;
  if (num < 1000000ULL)
    return 6;
  if (num < 10000000ULL)
    return 7;
  if (num < 100000000ULL)
    return 8;
  if (num < 1000000000ULL)
    return 9;
  if (num < 10000000000ULL)
    return 10;
  if (num < 100000000000ULL)
    return 11;
  if (num < 1000000000000ULL)
    return 12;
  if (num < 10000000000000ULL)
    return 13;
  if (num < 100000000000000ULL)
    return 14;
  if (num < 1000000000000000ULL)
    return 15;
  if (num < 10000000000000000ULL)
    return 16;
  if (num < 100000000000000000ULL)
    return 17;
  if (num < 1000000000000000000ULL)
    return 18;
  if (num < 10000000000000000000ULL)
    return 19;
  return 20;
}

/*
 * Get the time elabsed in ms
 */
static inline uint64_t get_time() {
  struct timespec ts;
  clock_gettime(CLOCK_MONOTONIC, &ts);
  return (uint64_t)(ts.tv_sec) * 1000 + (ts.tv_nsec / 1000000);
}

static inline FILE *log_init(const char *path) {
  FILE *res = fopen(path, "a+");
  setvbuf(res, NULL, _IONBF, 0);
  return res;
}

static inline int16_t pollevs(int connfd) {
  struct pollfd pfd;
  pfd.fd = connfd;
  pfd.events = POLLIN | POLLOUT | POLLERR;
  int res = poll(&pfd, 1, 0);
  if (res < 0)
    return POLLERR;
  return pfd.revents;
}

// FIXME This needs to be updated
static inline conn_t *MP_use_once(size_t nblocks, int fd) {

  void *mem = malloc(sizeof(conn_t) + 8 + (IOVEC_NBLOCKS * MP_BLOCK));
  struct conn_t *conn = (conn_t *)mem;
  memset(conn, 0, sizeof(conn_t));
  conn->ios = mem + sizeof(conn_t) + 8;

  if (nblocks > 0) {
    struct iovec *iov = &conn->ios[conn->nios++];
    mem = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (mem == MAP_FAILED)
      return NULL;
    iov->iov_base = mem;
    iov->iov_len = ALIGN_TO_PAGESIZE(nblocks * MP_BLOCK);
  }

  conn->flags |= CF_IN_HEAP;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;

  return conn;
}

static inline int find_freec() {
  uint64_t *word;
  size_t map_size = (sizeof(uint64_t) * 8);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    word = &pool.freecs[i / map_size];

    if (*word == 0) { // All used
      i += (map_size - 1);
      continue;
    }

    i += __builtin_ctzll(*word);
    MARK_BIT_USED(*word, i);
    return i;
  }

  return -1;
}

static inline int MP_init(size_t npages) {
  if (!npages)
    return -1;

  /*** Setup ***/
  pool.npages = npages;
  pool.pagesize = sysconf(_SC_PAGESIZE);

  /*** Pool ***/
  pool.bpool = mmap(NULL, pool.npages * pool.pagesize, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  if (pool.bpool == MAP_FAILED)
    return -1;
  pool.nblocks = (pool.npages * pool.pagesize) / MP_BLOCK;

  /*** Blocks ***/
  pool.blocks = malloc(sizeof(void *) * pool.nblocks);
  if (!pool.blocks)
    return -1;
  for (size_t i = 0; i < pool.nblocks; i++)
    pool.blocks[i] = pool.bpool + (i * MP_BLOCK);

  /*** Freebs ***/
  // if (posix_memalign((void **)&pool.freebs, 64, bitmap_size * sizeof(uint64_t)) < 0)
  size_t bitmap_size = (pool.nblocks + 63) / 64;
  pool.freebs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freebs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freebs[i] = UINT64_MAX;

  /*** Cpool ***/
  pool.cpool = (conn_t *)malloc(sizeof(conn_t) * MAX_CONNS);
  if (!pool.cpool)
    return -1;

  /*** Conns ***/
  pool.conns = (conn_t **)malloc(sizeof(conn_t *) * MAX_CONNS);
  if (!pool.conns)
    return -1;
  size_t conn_size = sizeof(conn_t);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    pool.conns[i] = (conn_t *)((char *)pool.cpool + (i * conn_size));
    pool.conns[i]->fd = -1;
    pool.conns[i]->in_fd = -1;
    pool.conns[i]->out_fd = -1;
  }

  /*** Freecs ***/
  bitmap_size = (MAX_CONNS + 63) / 64;
  pool.freecs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freecs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freecs[i] = UINT64_MAX;

  return 0;
}

static inline int MP_use_blks(size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t max_start = pool.nblocks - nblocks;
  size_t full_chunks = (nblocks / 64) * 64;

  for (size_t i = 0, c = 0; i <= max_start; i++, c++) {
    bool free = true;

    for (size_t j = 0; j < full_chunks; j += 64) {
      size_t word_index = (i + j) / 64;
      if (pool.freebs[word_index] != UINT64_MAX) {
        free = false;
        i += 63;
        break;
      }
    }

    for (size_t j = full_chunks; j < nblocks; j++) {
      size_t bit_index = i + j;
      size_t word_index = bit_index / 64;
      size_t bit_in_word = bit_index % 64;

      if (!BIT_IS_FREE(pool.freebs[word_index], bit_in_word)) {
        free = false;
        i += j;
        break;
      }
    }

    if (free) {
      for (size_t j = 0; j < full_chunks; j += 64) {
        size_t word_index = (i + j) / 64;
        pool.freebs[word_index] = 0;
      }

      for (size_t j = full_chunks; j < nblocks; j++) {
        size_t bit_index = i + j;
        size_t word_index = bit_index / 64;
        size_t bit_in_word = bit_index % 64;

        MARK_BIT_USED(pool.freebs[word_index], bit_in_word);
      }

      return i;
    }
  }

  return -1;
}

static inline int MP_free_blks(size_t bindex, size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t full_chunks = (nblocks / 64) * 64;
  for (size_t i = 0; i < full_chunks; i += 64) {
    size_t word_index = (bindex + i) / 64;
    pool.freebs[word_index] = UINT64_MAX;
  }

  for (size_t i = full_chunks; i < nblocks; i++) {
    size_t bit_index = bindex + i;
    size_t word_index = bit_index / 64;
    size_t bit_in_word = bit_index % 64;

    MARK_BIT_FREE(pool.freebs[word_index], bit_in_word);
  }

  memset(pool.blocks[bindex], 0, nblocks * MP_BLOCK);
  return 0;
}

static inline conn_t *MP_use(size_t nblocks, int fd, bool once) {
  if (fd <= 0)
    return NULL;
  if (once)
    return MP_use_once(nblocks, fd);

  int cindex = find_freec();
  if (cindex < 0) {
    LOG("Err: cindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  conn_t *conn = pool.conns[cindex];

  int ios_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (ios_bindex < 0) {
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }

  struct iovec *ios = pool.blocks[ios_bindex];
  conn->ios = ios;

  int rec_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (rec_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct iovec *rec = pool.blocks[rec_bindex];
  conn->rec = rec;

  int msg_bindex = MP_use_blks(MSG_NBLOCKS);
  if (msg_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct msghdr *msg = pool.blocks[msg_bindex];
  conn->msg = msg;

  if (nblocks > 0) {
    int bindex = MP_use_blks(nblocks);
    if (bindex < 0) {
      MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
      MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
      MP_free_blks(msg_bindex, IOVEC_NBLOCKS);
      MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
      LOG("Err: bindex < 0; will use MP_use_once\n");
      return MP_use_once(nblocks, fd);
    }

    size_t iov_index = conn->nios++;
    struct iovec *iov = &conn->ios[iov_index];
    struct iovec *rec = &conn->rec[iov_index];
    iov->iov_base = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
  }

  conn->msg->msg_iov = conn->ios;
  conn->msg->msg_iovlen = conn->nios;
  conn->cindex = cindex;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;
  return conn;
}

static inline void MP_shed(conn_t *conn, size_t iov_index, size_t nios) {
  struct iovec *iov, *rec;
  size_t bindex, nblocks, index;

  for (size_t i = 0; i < nios; i++) {
    index = iov_index + i;
    iov = &conn->ios[index];
    rec = &conn->rec[index];
    if (!rec || !rec->iov_base)
      continue;
    if (!IN_POOL(rec->iov_base)) {
      munmap(rec->iov_base, rec->iov_len / pool.pagesize);
    } else {
      bindex = ptr_diff((uintptr_t)rec->iov_base, (uintptr_t)pool.bpool) / MP_BLOCK;
      nblocks = rec->iov_len / MP_BLOCK;
      MP_free_blks(bindex, nblocks);
    }
    memset(iov, 0, sizeof(struct iovec));
    memset(rec, 0, sizeof(struct iovec));
    conn->nios--;
  }
}

static inline int MP_expand(conn_t *conn, size_t nblocks, bool once) {
  void *bptr;
  int iov_index, bindex;
  struct iovec *iov, *rec;

  iov_index = conn->nios++;
  iov = &conn->ios[iov_index];
  rec = &conn->rec[iov_index];

  if (nblocks == 0)
    return iov_index;

  if (once) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_base = bptr;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
    return iov_index;
  }

  bindex = MP_use_blks(nblocks);
  if (bindex < 0) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_len = iov->iov_len;
  } else {
    bptr = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_len = iov->iov_len;
  }

  iov->iov_base = bptr;
  rec->iov_base = iov->iov_base;
  return iov_index;
}

static inline int MP_free(conn_t *conn) {
  if (!conn)
    return -1;
  size_t bindex, nblocks;
  uint64_t *word;

  MP_shed(conn, 0, conn->nios);
  if (conn->flags & CF_IN_HEAP) {
    if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
      close(conn->fd);
    free(conn);
    return 0;
  }

  word = &pool.freecs[conn->cindex / 64];
  if (conn->cindex > MAX_CONNS)
    return -1;
  else if (BIT_IS_FREE(*word, conn->cindex))
    return 0;

  bindex = ptr_diff((uintptr_t)conn->ios, (uintptr_t)pool.bpool) / MP_BLOCK;
  nblocks = IOVEC_NBLOCKS;
  MP_free_blks(bindex, nblocks);

  bindex = ptr_diff((uintptr_t)conn->rec, (uintptr_t)pool.bpool) / MP_BLOCK;
  MP_free_blks(bindex, nblocks);

  if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
    close(conn->fd);

  MARK_BIT_FREE(*word, conn->cindex);
  memset(conn, 0, sizeof(conn_t));
  conn->fd = -1;
  conn->in_fd = -1;
  conn->out_fd = -1;
  return 0;
}

static inline void MP_clear(conn_t *conn) {
  conn_t *recv_conn = conn->recv_conn;
  conn_t *send_conn = conn->send_conn;
  if (recv_conn)
    MP_free(recv_conn);
  if (send_conn)
    MP_free(send_conn);
}

static inline void MP_exit(MPool *pool) {
  munmap(pool->bpool, pool->npages);
  free(pool->cpool);
  free(pool->blocks);
  free(pool->conns);
  free(pool->freebs);
  free(pool->freecs);
}

static inline void MP_timeout() {
  conn_t *conn;
  int16_t res;
  uint64_t now;
  size_t windex = 0;
  uint64_t *word = &pool.freecs[0];
  for (size_t i = 0; i < MAX_CONNS; i++) {
    if ((i / 64) < windex)
      word = &pool.freecs[++windex];

    if (*word == UINTMAX_MAX) {
      i = (i / 64) * 64 + 64;
      continue;
    }

    conn = pool.conns[i];
    if (!conn || conn->fd == -1)
      continue;

    res = pollevs(conn->fd);

    now = get_time();
    if (res & POLLERR) {
      MP_clear(conn);
      continue;
    }
    if (res & POLLIN) {
      if (pool.rtimeout > 0 && (now - conn->last_read) >= pool.rtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (res & POLLOUT) {
      if (pool.wtimeout > 0 && (now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (!(res & POLLIN || res & POLLOUT)) {
      if ((pool.rtimeout > 0 && now - conn->last_read) >= pool.rtimeout
          || (pool.wtimeout > 0 && now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
  }
}

/*
 * Calculate the length of a status string
 */
static inline size_t status_len(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return 8;
  case STATUSSWITCHINGPROTOCOLS:
    return 19;
  case STATUSPROCESSING:
    return 10;
  case STATUSEARLYHINTS:
    return 11;
  case STATUSOK:
    return 2;
  case STATUSCREATED:
    return 7;
  case STATUSACCEPTED:
    return 8;
  case STATUSNONAUTHORITATIVE:
    return 29;
  case STATUSNOCONTENT:
    return 10;
  case STATUSRESETCONTENT:
    return 13;
  case STATUSPARTIALCONTENT:
    return 15;
  case STATUSMULTISTATUS:
    return 12;
  case STATUSALREADYREPORTED:
    return 16;
  case STATUSIMUSED:
    return 7;
  case STATUSMULTIPLECHOICES:
    return 16;
  case STATUSMOVEDPERMANENTLY:
    return 17;
  case STATUSFOUND:
    return 5;
  case STATUSSEEOTHER:
    return 9;
  case STATUSNOTMODIFIED:
    return 12;
  case STATUSUSEPROXY:
    return 9;
  case STATUSTEMPORARYREDIRECT:
    return 18;
  case STATUSPERMANENTREDIRECT:
    return 18;
  case STATUSBADREQUEST:
    return 11;
  case STATUSUNAUTHORIZED:
    return 12;
  case STATUSPAYMENTREQUIRED:
    return 16;
  case STATUSFORBIDDEN:
    return 9;
  case STATUSNOTFOUND:
    return 9;
  case STATUSMETHODNOTALLOWED:
    return 18;
  case STATUSNOTACCEPTABLE:
    return 14;
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return 29;
  case STATUSREQUESTTIMEOUT:
    return 15;
  case STATUSCONFLICT:
    return 8;
  case STATUSGONE:
    return 4;
  case STATUSLENGTHREQUIRED:
    return 15;
  case STATUSPRECONDITIONFAILED:
    return 19;
  case CONTENTTOOLARGE:
    return 17;
  case STATUSURITOOLONG:
    return 12;
  case STATUSUNSUPPORTEDMEDIATYPE:
    return 22;
  case STATUSRANGENOTSATISFIABLE:
    return 21;
  case STATUSEXPECTATIONFAILED:
    return 18;
  case STATUSMISDIRECTEDREQUEST:
    return 19;
  case STATUSUNPROCESSABLECONTENT:
    return 21;
  case STATUSLOCKED:
    return 6;
  case STATUSFAILEDDEPENDENCY:
    return 17;
  case STATUSTOOEARLY:
    return 9;
  case STATUSUPGRADEREQUIRED:
    return 16;
  case STATUSPRECONDITIONREQUIRED:
    return 21;
  case STATUSTOOMANYREQUESTS:
    return 17;
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return 31;
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return 29;
  case STATUSInternalServerError:
    return 21;
  case STATUSNOTIMPLEMENTED:
    return 15;
  case STATUSBADGATEWAY:
    return 11;
  case STATUSSERVICEUNAVAILABLE:
    return 19;
  case STATUSGATEWAYTIMEOUT:
    return 15;
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return 26;
  case STATUSVARIANTALSONEGOTIATES:
    return 23;
  case STATUSINSUFFICIENTSTORAGE:
    return 20;
  case STATUSLOOPDETECTED:
    return 13;
  case STATUSNOTEXTENDED:
    return 12;
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return 31;
  default:
    return 0;
  }
}

/*
 * Return the status code string as string literal
 */
static inline char *status_str(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return "Continue";
  case STATUSSWITCHINGPROTOCOLS:
    return "Switching Protocols";
  case STATUSPROCESSING:
    return "Processing";
  case STATUSEARLYHINTS:
    return "Early Hints";
  case STATUSOK:
    return "OK";
  case STATUSCREATED:
    return "Created";
  case STATUSACCEPTED:
    return "Accepted";
  case STATUSNONAUTHORITATIVE:
    return "Non-Authoritative Information";
  case STATUSNOCONTENT:
    return "No Content";
  case STATUSRESETCONTENT:
    return "Reset Content";
  case STATUSPARTIALCONTENT:
    return "Partial Content";
  case STATUSMULTISTATUS:
    return "Multi-Status";
  case STATUSALREADYREPORTED:
    return "Already Reported";
  case STATUSIMUSED:
    return "Im Used";
  case STATUSMULTIPLECHOICES:
    return "Multiple Choices";
  case STATUSMOVEDPERMANENTLY:
    return "Moved Permanently";
  case STATUSFOUND:
    return "Found";
  case STATUSSEEOTHER:
    return "See Other";
  case STATUSNOTMODIFIED:
    return "Not Modified";
  case STATUSUSEPROXY:
    return "Use Proxy";
  case STATUSTEMPORARYREDIRECT:
    return "Temporary Redirect";
  case STATUSPERMANENTREDIRECT:
    return "Permanent Redirect";
  case STATUSBADREQUEST:
    return "Bad Request";
  case STATUSUNAUTHORIZED:
    return "Unauthorized";
  case STATUSPAYMENTREQUIRED:
    return "Payment Required";
  case STATUSFORBIDDEN:
    return "Forbidden";
  case STATUSNOTFOUND:
    return "Not Found";
  case STATUSMETHODNOTALLOWED:
    return "Method Not Allowed";
  case STATUSNOTACCEPTABLE:
    return "Not Acceptable";
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return "Proxy Authentication Required";
  case STATUSREQUESTTIMEOUT:
    return "Request Timeout";
  case STATUSCONFLICT:
    return "Conflict";
  case STATUSGONE:
    return "Gone";
  case STATUSLENGTHREQUIRED:
    return "Length Required";
  case STATUSPRECONDITIONFAILED:
    return "Precondition Failed";
  case CONTENTTOOLARGE:
    return "Content Too Large";
  case STATUSURITOOLONG:
    return "URI Too Long";
  case STATUSUNSUPPORTEDMEDIATYPE:
    return "Unsupported Media Type";
  case STATUSRANGENOTSATISFIABLE:
    return "Range Not Satisfiable";
  case STATUSEXPECTATIONFAILED:
    return "Expectation Failed";
  case STATUSMISDIRECTEDREQUEST:
    return "Misdirected Request";
  case STATUSUNPROCESSABLECONTENT:
    return "Unprocessable Content";
  case STATUSLOCKED:
    return "Locked";
  case STATUSFAILEDDEPENDENCY:
    return "Failed Dependency";
  case STATUSTOOEARLY:
    return "Too Early";
  case STATUSUPGRADEREQUIRED:
    return "Upgrade Required";
  case STATUSPRECONDITIONREQUIRED:
    return "Precondition Required";
  case STATUSTOOMANYREQUESTS:
    return "Too Many Requests";
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return "Request Header Fields Too Large";
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return "Unavailable For Legal Reasons";
  case STATUSInternalServerError:
    return "Internal Server Error";
  case STATUSNOTIMPLEMENTED:
    return "Not Implemented";
  case STATUSBADGATEWAY:
    return "Bad Gateway";
  case STATUSSERVICEUNAVAILABLE:
    return "Service Unavailable";
  case STATUSGATEWAYTIMEOUT:
    return "Gateway Timeout";
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return "HTTP Version Not Supported";
  case STATUSVARIANTALSONEGOTIATES:
    return "Variant Also Negotiates";
  case STATUSINSUFFICIENTSTORAGE:
    return "Insufficient Storage";
  case STATUSLOOPDETECTED:
    return "Loop Detected";
  case STATUSNOTEXTENDED:
    return "Not Extended";
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return "Network Authentication Required";
  default:
    return 0;
  }
}

/*
 * Return true if routes match
 */
static inline bool route_equ(Route *route, Request *req) {
  return route->method == req->method && strncmp(route->path, req->path, strlen(route->path)) == 0;
}

/*
 * Return the matching route index on success. -1 on failure
 */
static inline int match_route(Server *serv, Request *req) {
  for (size_t i = 0; i < serv->_nroutes; i++) {
    Route route = serv->routes[i];
    if (!req->path || !route.path)
      continue;
    if (route_equ(&route, req))
      return i;
    else if (req->method == HEAD && route.method == GET && strcmp(route.path, req->path) == 0)
      return i;
  }
  return -1;
}

/*
 * Return true if the response should contain the Content-Length header
 */
static inline bool should_have_content_length(Request *req, ResWriter *res) {
  return (req->method != CONNECT              // CONNECT request
          && res->status != STATUSNOCONTENT   // 204 response
          && res->status != STATUSNOTMODIFIED // 304 response
          && res->status >= 200);             // 1xx response
}

/*
 * Format http response from the ResWriter.
 * Return response size on success, 0 on failure.
 */
static inline size_t fmt_res(Request *req, ResWriter *res, char *buffer, size_t buffer_size) {
  if (!res || !buffer || buffer_size == 0)
    return 0;

  size_t res_len, total = 0;
  char *dst = buffer;
  size_t maxlen = buffer_size;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t body_length = res->len;

  res_len = snprintf(dst, maxlen, "HTTP/1.1 %d %s", (int)res->status, status_str(res->status));
  total += res_len;
  dst += res_len;
  maxlen -= res_len;

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    res_len = snprintf(dst, maxlen, "\r\n%s: %s", header->key, header->value);
    total += res_len;
    dst += res_len;
    maxlen -= res_len;
  }

  if (have_content_length) {
    res_len = snprintf(dst, maxlen, "\r\nContent-Length: %lu", body_length);
    total += res_len, dst += res_len, maxlen -= res_len;
  }

  memcpy(dst, "\r\n\r\n", 4);
  total += 4, dst += 4, maxlen -= 4;

  return total;
}

static inline size_t res_len(Request *req, ResWriter *res) {
  if (!req || !res)
    return 0;

  if (!res->status)
    res->status = STATUSOK;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t result = 0;
  result += STRLEN("HTTP/1.1 ");     // HTTP version
  result += 4;                       // Status code + space
  result += status_len(res->status); // Status name

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    result += 2;                       // "\r\n"
    result += strlen(header->key) + 2; // Header key + ':' + space
    result += strlen(header->value);   // header value
  }

  if (have_content_length) {
    result += 2;                          // "\r\n"
    result += STRLEN("Content-Length: "); // Header key
    result += countd(res->len);           // Header value
  }

  result += 4; // "\r\n\r\n"

  return result;
}

static inline int send_empty_res(Status status) {
  size_t res_len = STRLEN("HTTP/1.1 ")        // HTTP version
                   + countd((uint64_t)status) // status code
                   + 1                        // space
                   + (int)status_len(status)  // status string
                   + 4;                       // \r\n\r\n

  conn_t *conn = current_send;
  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, res_len);
  if (snprintf((char *)rec->iov_base, res_len + 1, "HTTP/1.1 %d %s\r\n\r\n", (int)status, status_str(status))
      != (int)res_len)
    return -1;

  return usendmsg(conn, 0, 1);
}

static inline ssize_t read_socket(int sockfd, size_t len) {
  if (len == 0 || sockfd <= 0)
    return 0;
  char buff[1024 * 8];
  return read(sockfd, buff, 1024 * 8);
}

static inline int read_method(Method *method, void *src) {
  if (memcmp(src, "GET", 3) == 0)
    *method = GET;
  else if (memcmp(src, "POST", 4) == 0)
    *method = POST;
  else if (memcmp(src, "HEAD", 4) == 0)
    *method = HEAD;
  else if (memcmp(src, "PUT", 3) == 0)
    *method = PUT;
  else if (memcmp(src, "DELETE", 6) == 0)
    *method = DELETE;
  else if (memcmp(src, "CONNECT", 7) == 0)
    *method = CONNECT;
  else if (memcmp(src, "OPTIONS", 7) == 0)
    *method = OPTIONS;
  else if (memcmp(src, "TRACE", 5) == 0)
    *method = TRACE;
  else if (memcmp(src, "PATCH", 5) == 0)
    *method = PATCH;
  else
    return -1;

  return 0;
}

static inline int sendmsg_res(Request *req, ResWriter *res) {
  conn_t *conn;
  size_t head_size, res_size;
  struct iovec *iov;

  conn = current_send;
  iov = &conn->ios[0];
  head_size = res_len(req, res);
  if (head_size == 0)
    return -1;

  conn->data_left += head_size;
  res_size = fmt_res(req, res, iov->iov_base, (head_size + 1));
  if (res_size != head_size)
    return -1;
  iov->iov_len = res_size;

  return usendmsg(conn, 0, conn->nios);
}

static inline int read_req(Request *req, char *req_buffer) {
  if (!req_buffer)
    return -1;
  /*** Method ***/
  char *sep = strchr(req_buffer, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }
  *sep = '\0';
  if (read_method(&req->method, req_buffer) < 0)
    return -1;

  /*** Path ***/
  char *fullpath = sep + 1;
  sep = strchr(fullpath, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }

  *sep = '\0';
  req->path = fullpath;
  /*** Params ***/
  char *paramStart = strchr(fullpath, '?');
  if (paramStart) {
    *paramStart++ = '\0';
    int params_count = 0;
    params_count = HK_parse_params(paramStart, req->params, MAX_URL_PARAMETERS);
    if (params_count > 0)
      req->params_count = params_count;
    else
      req->params_count = 0;
  } else {
    req->params = NULL;
    req->params_count = 0;
  }

  /*** Headers ***/
  char *headStart = strstr(sep + 1, "\r\n");
  char *headEnd = strstr(sep + 1, "\r\n\r\n");
  if (!headStart) {
    LOG("read_req: !headStart\n");
    return -1;
  };

  memset(headStart, 0, 2);
  headStart += 2;
  memset(headEnd, 0, 4);
  headEnd += 4;

  int headers_count = HK_parse_headers(headStart, req->headers, MAX_REQ_HEADERS);
  if (headers_count <= 0)
    return -1;
  req->headers_count = headers_count;

  /*** Host ***/
  int index = HK_get_header(req, "Host");
  if (index < 0)
    return -1;
  char *host = req->headers[index].value;
  req->hostname = host;

  /*** Port ***/
  char *colon = strchr(host, ':');
  if (colon) {
    *colon++ = '\0';
    req->port = atoi(colon);
  } else {
    req->port = PORT;
  }
  return 0;
}
static inline int process_req(Server *serv, conn_t *conn) {
  if (!conn || conn->fd == -1)
    return -1;

  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;
  if (read_req(&req, conn->ios[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    LOG("Err: route_index == -1\n");
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;
  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  sendmsg_res(&req, &res);

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int new_conn(int connfd) {
  if (connfd <= 0)
    return -1;

  current_recv = MP_use(KB * 2, connfd, false);
  current_send = MP_use(KB * 2, connfd, false);

  current_recv->recv_conn = current_recv;
  current_recv->send_conn = current_send;

  current_send->send_conn = current_send;
  current_send->recv_conn = current_recv;

  conn_t *conn = current_recv;
  if (ufrecvmsg(conn, 0, 1) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

static inline int resubmit_sendmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return usendmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int resubmir_recvmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    // FIXME the len should be increased
    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return urecvmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int handle_sendmsg_complete(conn_t *conn) {
  struct iovec *iov, *rec;

  MP_shed(conn, 1, conn->nios - 1);
  iov = &conn->ios[0];
  rec = &conn->rec[0];
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;

  return ufrecvmsg(conn->recv_conn, 0, 1);
}

static inline int handle_sendmsg(conn_t *conn, int res, bool zc) {
  if (!conn || conn->fd == -1)
    return -1;

  conn->data_left -= res;
  if (conn->data_left > 0)
    return resubmit_sendmsg(conn, res);

  if (zc)
    return 0;

  return handle_sendmsg_complete(conn);
}

static inline int handle_insplice(conn_t *conn) {
  conn->op = OUTSPLICE;
  return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
}
static inline int handle_outsplice(conn_t *conn, int res) {
  conn->data_left -= res;
  if (conn->data_left > 0) {
    conn->op = INSPLICE;
    return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
  }

  conn_t *recv_conn = conn->recv_conn;
  struct iovec *iov = &recv_conn->ios[0];
  memset(iov->iov_base, 0, iov->iov_len);
  if (urecv(recv_conn, iov->iov_base, iov->iov_len, MSG_PEEK) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

/*
static inline int handle_recv(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  void *bptr = conn->ios[0].iov_base;
  void *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  void *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  return process_req(serv, conn);
}
*/
static inline int find_route(Server *serv, char *bptr) {
  Request req = {0};
  if (read_method(&req.method, bptr) < 0) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  };
  char *space = strchr(bptr, ' ');
  req.path = (space + 1);
  space = strchr(req.path, ' ');
  *space = '\0';
  int route_index = match_route(serv, &req);
  *space = ' ';
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }
  return route_index;
}

static inline int run_handler(Server *serv, conn_t *conn, bool uses_body) {
  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;

  if (read_req(&req, conn->rec[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  if (uses_body) {
    int h_index = HK_get_header(&req, "Content-Length");
    long body_size = atol(req.headers[h_index].value);
    if (body_size >= 0) {
      req.body.ptr = conn->rec[1].iov_base;
      req.body.size = body_size;
    } else {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    }
  }

  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  if (sendmsg_res(&req, &res) < 0)
    return -1;

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int handle_frecvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  char *bptr = (char *)conn->ios[0].iov_base;
  char *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  char *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  size_t head_size = (headEnd + 4) - bptr;
  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  int route_index = find_route(serv, bptr);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  bool uses_body = serv->routes[route_index].uses_body;
  long body_size = get_content_length(headstart + 2, headEnd + 4);
  if (body_size == -1) {
    if (uses_body) {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    } else {
      body_size = 0;
    }
  }

  conn->head_size = head_size;
  if (!uses_body) {
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  if (res == (int)(head_size + body_size)) {
    size_t iov_index = MP_expand(conn, round_to_blocks(body_size), false);
    memcpy(conn->rec[iov_index].iov_base, headEnd + 4, body_size);
    conn->ios[iov_index].iov_len = body_size;
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  conn->data_left = body_size - (res - head_size);
  bool once = ((size_t)body_size > (size_t)((pool.nblocks * MP_BLOCK) / 10));
  size_t iov_index = MP_expand(conn, round_to_blocks(body_size), once);
  memcpy(conn->rec[iov_index].iov_base, headEnd + 4, (res - head_size));
  conn->ios[iov_index].iov_base += (res - head_size);

  return urecvmsg(conn, iov_index, 1);
}

static inline int handle_recvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  if (conn->data_left > 0) {
    conn->data_left -= res;
    if (conn->data_left == 0) {
      conn->flags &= CF_HANDLER_READY;
      return run_handler(serv, conn, true);
    }

    conn->flags &= ~CF_HANDLER_READY;
    conn->ios[1].iov_base += res;
    return urecvmsg(conn, 1, 1);
  }

  conn->flags &= CF_HANDLER_READY;
  return run_handler(serv, conn, true);
}

static inline int serv_init(Server *serv) {
#if DEBUG
  logfd = log_init("log.txt");
  if (!logfd) {
    printf("log_init failed");
    return -1;
  }
#endif
  serv->_nroutes = get_nroutes(serv->routes);

  int pipefd[2];
  if (pipe(pipefd) < 0)
    return -1;
  pipe_in = pipefd[0];
  pipe_out = pipefd[1];
  nullfd = open("/dev/null", O_WRONLY);
  pipe_sz = fcntl(pipefd[0], F_GETPIPE_SZ);
  if (pipe_sz < 0)
    return -1;

  pool.rtimeout = serv->rtimeout;
  pool.wtimeout = serv->wtimeout;
  if (MP_init(MAX_CONNS * 8) < 0)
    return -1;
  LOG("pool initialized\n");

  if (io_uring_queue_init(MAX_CONNS, &ring, 0) < 0)
    return -1;
  LOG("uring initialized\n");

  int listenfd;
  if ((listenfd = tcp_listen(serv->port)) < 0)
    return -1;
  LOG("socket initialized\n");

  return umaccept(listenfd);
}

static inline int serv_listen(Server *serv) {
  // uint64_t last_check = get_time();
  while (true) {
    // uint64_t now = get_time();
    // if ((now - last_check) >= 200) {
    //   last_check = now;
    //   LOG("CM: CM_check ran\n");
    //   MP_timeout();
    // }

    LOG("SQ ready: %u, CQ ready: %u\n", io_uring_sq_ready(&ring), io_uring_cq_ready(&ring));
    struct io_uring_cqe *cqe;
    if (io_uring_wait_cqe(&ring, &cqe) < 0)
      continue;

    int res = cqe->res;
    LOG("res = %d\n", res);
    conn_t *conn = NULL;
    if (cqe->user_data > 100) {
      conn = (conn_t *)cqe->user_data;
      current_recv = (conn_t *)conn->recv_conn;
      current_send = (conn_t *)conn->send_conn;
    }

    if (res > 0) {
      if (cqe->user_data == ACCEPT) {
        LOG("new conn created\n");
        new_conn(res);
      } else if (conn && conn->fd != -1) {
        LOG("conn[%d]: conn.fd = %d; conn.op = %d\n", conn->cindex, conn->fd, conn->op);
        switch (conn->op) {
        case FRECVMSG:
          if (handle_frecvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case RECVMSG:
          if (handle_recvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case SENDMSG:
        case SENDMSGZC:
          // conn->last_write = get_time();
          bool zc = (conn->op == SENDMSGZC);
          if (handle_sendmsg(conn, res, zc) < 0)
            MP_clear(conn);
          break;
        case INSPLICE:
          if (handle_insplice(conn) < 0)
            MP_clear(conn);
          break;
        case OUTSPLICE:
          if (handle_outsplice(conn, res) < 0)
            MP_clear(conn);
          break;
        }
      }
    } else if (res == 0) {
      if (conn && conn->fd != -1) {
        switch (conn->op) {
        case SENDMSGZC:
          conn->zc_notifs--;
          if (conn->zc_notifs == 0 && handle_sendmsg_complete(conn) < 0)
            MP_clear(conn);
          break;
        case RECV:
          MP_clear(conn);
          break;
        }
      }
    } else {
      if (conn && conn->fd != -1) {
        if (res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR) {
          LOG("conn && conn->fd != -1 && res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR\n");
          MP_clear(conn);
        } else {
          LOG("res == -EAGAIN || res == -EWOULDBLOCK || res == -EINTR\n");
          conn = conn->recv_conn;
          struct iovec *iov = &conn->ios[0];
          memset(iov->iov_base, 0, iov->iov_len);
          if (urecv(conn, iov->iov_base, iov->iov_len, 0) < 0)
            MP_clear(conn);
        }
      }
    }

    LOG("uring operation seen\n");
    io_uring_cqe_seen(&ring, cqe);
  }

  io_uring_queue_exit(&ring);
  MP_exit(&pool);
  return 0;
}

/*** Helper ***/
static inline int _HK_write(void *data, size_t size) {
  size_t nblocks;
  int iov_index;
  conn_t *conn;
  struct iovec *iov;
  bool once;

  conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  nblocks = round_to_blocks(size);
  iov_index = MP_expand(conn, nblocks, once);
  iov = &conn->ios[iov_index];

  memcpy(iov->iov_base, data, size);
  iov->iov_len = size;
  conn->data_left += size;

  return 0;
}
static inline int _HK_write_body(Request *req, size_t offset, size_t size) {
  if (size > req->body.size || offset > req->body.size)
    return -1;

  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  int iov_index = MP_expand(conn, 0, false);
  struct iovec *iov = &conn->ios[iov_index];
  struct iovec *rec = &conn->rec[iov_index];
  rec->iov_base = req->body.ptr + offset;
  rec->iov_len = size;
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;
  conn->data_left += rec->iov_len;
  return 0;
}
/*
static inline int _HK_mem(size_t size, HKMem *mem) {
  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  bool once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  size_t nblocks = round_to_blocks(size);
  int iov_index = MP_expand(conn, nblocks, once);
  struct iovec *iov = &conn->ios[iov_index];
  mem->ptr = iov->iov_base;
  mem->size = iov->iov_len;
  mem->_iov_index = iov_index;
  mem->_flags = (IN_POOL(iov->iov_base)) ? CF_IN_POOL : CF_IN_HEAP;
  return 0;
}

static inline void _HK_send(HKMem *mem, size_t size) {
  conn_t *conn = current_send;
  struct iovec *iov = &conn->ios[mem->_iov_index];
  iov->iov_len = size;
  conn->data_left += size;
}
  */
#endif#define _GNU_SOURCE
#ifndef UTILS_H
#define UTILS_H

#include "hunk.h"
#include <arpa/inet.h>
#include <fcntl.h>
#include <liburing.h>
#include <netdb.h>
#include <signal.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/poll.h>
#include <sys/prctl.h>
#include <sys/socket.h>
#include <sys/sysinfo.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

#define MP_BLOCK  4
#define MAX_CONNS 4096
#define KB        1024
#define NIOS      32

#define IN_POOL(ptr)                 ((void *)ptr >= pool.bpool && (void *)ptr <= (pool.bpool + (pool.npages * pool.pagesize)))
#define ALIGN_TO_PAGESIZE(buff_size) (((buff_size) + (pool.pagesize - 1)) & ~(pool.pagesize - 1))
#define BYTES_TO_BLOCKS(buff_size)   (((buff_size) + (MP_BLOCK - 1)) / MP_BLOCK)
#define CEIL_BLOCKS(nblocks)         ((nblocks + 63) & ~63)
#define CEIL_PAGES(size)             (((size) + ((pool.pagesize) - 1)) & ~((pool.pagesize) - 1))

#define BIT_IS_FREE(word, bit)   (((word) >> (bit)) & 1)
#define MARK_BIT_USED(word, bit) ((word) &= ~(1ULL << (bit)))
#define MARK_BIT_FREE(word, bit) ((word) |= (1ULL << (bit)))
#define FIND_FREE_BIT(word)      ((uint64_t)(word) & -(uint64_t)(word))
#define STRLEN(s)                (sizeof(s) - 1)

#define IOVEC_NBLOCKS (BYTES_TO_BLOCKS(NIOS * sizeof(struct iovec)))
#define MSG_NBLOCKS   (BYTES_TO_BLOCKS(sizeof(struct msghdr)))
#define ZC_RES        KB *KB

#define DEBUG 0
#if DEBUG
#define LOG(...) fprintf(logfd, __VA_ARGS__)
#else
#define LOG(...) ((void)0)
#endif

typedef enum UOP {
  WRITEV = IORING_OP_WRITEV,
  SENDMSG = IORING_OP_SENDMSG,
  RECVMSG = IORING_OP_RECVMSG,
  ACCEPT = IORING_OP_ACCEPT,
  SEND = IORING_OP_SEND,
  RECV = IORING_OP_RECV,
  SENDZC = IORING_OP_SEND_ZC,
  SENDMSGZC = IORING_OP_SENDMSG_ZC,
  PEEK = 50,
  FRECVMSG,
  INSPLICE,
  OUTSPLICE
} UOP;

typedef enum CFS {
  CF_IN_POOL = (1 << 0),       // Connection is in the pool
  CF_IN_HEAP = (1 << 1),       // Connection is in the heap
  CF_SKIP_SOCK = (1 << 2),     // Don't close the socket
  CF_USE_ONCE = (1 << 3),      // Destroy after using
  CF_HANDLER_READY = (1 << 4), // Ready to call the handler
} CFS;

typedef struct conn_t {
  // Socket file descriptor
  int fd;

  // Amount of data left in the current operation
  uint64_t data_left;

  // The index of the connection struct
  uint32_t cindex;

  // The last time the connection was readable
  uint64_t last_read;

  // The last time the connection was writeable
  uint64_t last_write;

  // The operation currently being processed
  uint8_t op;

  // Connection flags
  int flags;

  // Splice fd_in
  int in_fd;

  // Splice fd_out
  int out_fd;

  void *recv_conn;
  void *send_conn;

  struct iovec *ios;
  struct iovec *rec;
  uint16_t nios;

  struct msghdr *msg;
  uint16_t zc_notifs;

  uint16_t head_size;
} conn_t;

typedef struct MPool {
  // The allocated pool of blocks
  void *bpool;

  // The allocated pool of connections
  conn_t *cpool;

  // The size of the pool in pages
  uint32_t npages;

  // The size of the pool in blocks
  uint32_t nblocks;

  // The locations of each page in the pool
  void **blocks;

  // The availability of each block
  uint64_t *freebs;

  // The locations of each conn in the pool
  conn_t **conns;

  // The availability of each conn
  uint64_t *freecs;

  // Clean up callback function
  void (*callback)(conn_t *conn);

  // The page size used
  uint32_t pagesize;

  // Socket read timeout
  uint32_t rtimeout;

  // Socket write timeout
  uint32_t wtimeout;
} MPool;

extern int pipe_sz;
extern int pipe_in, pipe_out, nullfd;
extern FILE *logfd;
extern struct io_uring ring;
extern MPool pool;
extern conn_t *current_recv;
extern conn_t *current_send;

/*
 * Prepare and submit a recv uring op
 */
static inline int urecv(conn_t *conn, void *buffer, size_t buff_size, int flags) {
  if (!conn || conn->fd == -1)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (flags == MSG_PEEK) ? PEEK : RECV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;

  io_uring_prep_recv(sqe, conn->fd, buffer, buff_size, flags);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a multi-shot accept uring op
 */
static inline int umaccept(int listenfd) {
  if (listenfd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = ACCEPT;
  io_uring_prep_multishot_accept(sqe, listenfd, NULL, NULL, SOCK_NONBLOCK);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a splice uring op
 */
static inline int usplice(conn_t *conn, int fd_in, int64_t off_in, int fd_out, int64_t off_out, size_t len) {
  if (!len || !conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = (__u64)conn;
  io_uring_prep_splice(sqe, fd_in, off_in, fd_out, off_out, len, 0);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a writev uring op
 */
static inline int uwritev(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = WRITEV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  io_uring_prep_writev(sqe, conn->fd, &conn->ios[iov_index], nios, -1);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a send uring op
 */
static inline int usend(conn_t *conn, char *res_buff, size_t buff_size, bool zc) {
  if (!conn || conn->fd <= 0 || buff_size == 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (zc) ? SENDZC : SEND;
  conn->data_left = buff_size;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  if (zc)
    io_uring_prep_send_zc(sqe, conn->fd, res_buff, buff_size, 0, 0);
  else
    io_uring_prep_send(sqe, conn->fd, res_buff, buff_size, 0);
  return io_uring_submit(&ring);
}

static inline int ufrecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = FRECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;

  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, rec->iov_len);
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int urecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = RECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int usendmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  bool zc = (conn->data_left > ZC_RES) ? true : false;
  conn->op = (zc) ? SENDMSGZC : SENDMSG;

  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  if (zc) {
    io_uring_prep_sendmsg_zc(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
    conn->zc_notifs++;
  } else {
    io_uring_prep_sendmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  }
  return io_uring_submit(&ring);
}

/*
 * Create and initialize a server socket
 */
static inline int tcp_listen(uint16_t port) {
  int enable;
  int listenfd;
  if ((listenfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    return -1;

  int flags = fcntl(listenfd, F_GETFL, 0);
  fcntl(listenfd, F_SETFL, flags | O_NONBLOCK);
  struct sockaddr_in servaddr;
  memset(&servaddr, 0, sizeof(servaddr));
  servaddr.sin_family = AF_INET;
  servaddr.sin_addr.s_addr = INADDR_ANY;
  servaddr.sin_port = htons(port);

  enable = 1;
  if (setsockopt(listenfd, SOL_SOCKET, SO_REUSEPORT, &enable, sizeof(enable)) < 0)
    return -1;

  if (bind(listenfd, (struct sockaddr *)&servaddr, sizeof(servaddr)) < 0)
    return -1;

  if (listen(listenfd, SOMAXCONN) < 0)
    return -1;

  return listenfd;
}

/*
 * Calculate the difference between two pointers
 */
static inline uintptr_t ptr_diff(uintptr_t p1, uintptr_t p2) { return (uintptr_t)(p1 > p2) ? (p1 - p2) : (p2 - p1); }

static inline size_t get_nroutes(Route *routes) {
  Route *route;
  for (size_t i = 0;; i++) {
    route = &routes[i];
    if (!route->path && !route->handler && !route->method)
      return i;
  }
}

static inline long get_content_length(char *src, char *end) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return -1;
    key = line;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, "Content-Length") != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;

    *line_end = '\0';
    long res = atol(value);
    *line_end = '\r';

    return res;
  }
  return -1;
}

static inline bool have_header(char *src, char *end, const char *header_key, const char *header_value) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    key = line;
    while (*key == ' ')
      key++;
    while (*header_key == ' ')
      header_key++;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return false;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, header_key) != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;
    while (*header_value == ' ')
      header_value++;

    *line_end = '\0';
    bool res = (strcasecmp(value, header_value) == 0);
    *line_end = '\r';

    return res;
  }

  return false;
}

static inline const char *method_str(Method method) {
  switch (method) {
  case GET:
    return "GET";
    break;
  case HEAD:
    return "HEAD";
    break;
  case POST:
    return "POST";
    break;
  case PUT:
    return "PUT";
    break;
  case DELETE:
    return "DELETE";
    break;
  case CONNECT:
    return "CONNECT";
    break;
  case OPTIONS:
    return "OPTIONS";
    break;
  case TRACE:
    return "TRACE";
    break;
  case PATCH:
    return "PATCH";
    break;
  default:
    return NULL;
  }
}

static inline uint8_t method_len(Method method) {
  switch (method) {
  case GET:
    return 3;
    break;
  case HEAD:
    return 4;
    break;
  case POST:
    return 4;
    break;
  case PUT:
    return 3;
    break;
  case DELETE:
    return 6;
    break;
  case CONNECT:
    return 7;
    break;
  case OPTIONS:
    return 7;
    break;
  case TRACE:
    return 5;
    break;
  case PATCH:
    return 5;
    break;
  default:
    return 0;
  }
}

static inline size_t round_to_blocks(size_t size) {
  size_t nblocks = BYTES_TO_BLOCKS(size);
  nblocks = CEIL_BLOCKS(nblocks);
  return nblocks;
}

/*
 * Count the digits in unsigned 64-bit int
 */
static inline int countd(uint64_t num) {
  if (num < 10ULL)
    return 1;
  if (num < 100ULL)
    return 2;
  if (num < 1000ULL)
    return 3;
  if (num < 10000ULL)
    return 4;
  if (num < 100000ULL)
    return 5;
  if (num < 1000000ULL)
    return 6;
  if (num < 10000000ULL)
    return 7;
  if (num < 100000000ULL)
    return 8;
  if (num < 1000000000ULL)
    return 9;
  if (num < 10000000000ULL)
    return 10;
  if (num < 100000000000ULL)
    return 11;
  if (num < 1000000000000ULL)
    return 12;
  if (num < 10000000000000ULL)
    return 13;
  if (num < 100000000000000ULL)
    return 14;
  if (num < 1000000000000000ULL)
    return 15;
  if (num < 10000000000000000ULL)
    return 16;
  if (num < 100000000000000000ULL)
    return 17;
  if (num < 1000000000000000000ULL)
    return 18;
  if (num < 10000000000000000000ULL)
    return 19;
  return 20;
}

/*
 * Get the time elabsed in ms
 */
static inline uint64_t get_time() {
  struct timespec ts;
  clock_gettime(CLOCK_MONOTONIC, &ts);
  return (uint64_t)(ts.tv_sec) * 1000 + (ts.tv_nsec / 1000000);
}

static inline FILE *log_init(const char *path) {
  FILE *res = fopen(path, "a+");
  setvbuf(res, NULL, _IONBF, 0);
  return res;
}

static inline int16_t pollevs(int connfd) {
  struct pollfd pfd;
  pfd.fd = connfd;
  pfd.events = POLLIN | POLLOUT | POLLERR;
  int res = poll(&pfd, 1, 0);
  if (res < 0)
    return POLLERR;
  return pfd.revents;
}

// FIXME This needs to be updated
static inline conn_t *MP_use_once(size_t nblocks, int fd) {

  void *mem = malloc(sizeof(conn_t) + 8 + (IOVEC_NBLOCKS * MP_BLOCK));
  struct conn_t *conn = (conn_t *)mem;
  memset(conn, 0, sizeof(conn_t));
  conn->ios = mem + sizeof(conn_t) + 8;

  if (nblocks > 0) {
    struct iovec *iov = &conn->ios[conn->nios++];
    mem = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (mem == MAP_FAILED)
      return NULL;
    iov->iov_base = mem;
    iov->iov_len = ALIGN_TO_PAGESIZE(nblocks * MP_BLOCK);
  }

  conn->flags |= CF_IN_HEAP;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;

  return conn;
}

static inline int find_freec() {
  uint64_t *word;
  size_t map_size = (sizeof(uint64_t) * 8);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    word = &pool.freecs[i / map_size];

    if (*word == 0) { // All used
      i += (map_size - 1);
      continue;
    }

    i += __builtin_ctzll(*word);
    MARK_BIT_USED(*word, i);
    return i;
  }

  return -1;
}

static inline int MP_init(size_t npages) {
  if (!npages)
    return -1;

  /*** Setup ***/
  pool.npages = npages;
  pool.pagesize = sysconf(_SC_PAGESIZE);

  /*** Pool ***/
  pool.bpool = mmap(NULL, pool.npages * pool.pagesize, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  if (pool.bpool == MAP_FAILED)
    return -1;
  pool.nblocks = (pool.npages * pool.pagesize) / MP_BLOCK;

  /*** Blocks ***/
  pool.blocks = malloc(sizeof(void *) * pool.nblocks);
  if (!pool.blocks)
    return -1;
  for (size_t i = 0; i < pool.nblocks; i++)
    pool.blocks[i] = pool.bpool + (i * MP_BLOCK);

  /*** Freebs ***/
  // if (posix_memalign((void **)&pool.freebs, 64, bitmap_size * sizeof(uint64_t)) < 0)
  size_t bitmap_size = (pool.nblocks + 63) / 64;
  pool.freebs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freebs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freebs[i] = UINT64_MAX;

  /*** Cpool ***/
  pool.cpool = (conn_t *)malloc(sizeof(conn_t) * MAX_CONNS);
  if (!pool.cpool)
    return -1;

  /*** Conns ***/
  pool.conns = (conn_t **)malloc(sizeof(conn_t *) * MAX_CONNS);
  if (!pool.conns)
    return -1;
  size_t conn_size = sizeof(conn_t);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    pool.conns[i] = (conn_t *)((char *)pool.cpool + (i * conn_size));
    pool.conns[i]->fd = -1;
    pool.conns[i]->in_fd = -1;
    pool.conns[i]->out_fd = -1;
  }

  /*** Freecs ***/
  bitmap_size = (MAX_CONNS + 63) / 64;
  pool.freecs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freecs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freecs[i] = UINT64_MAX;

  return 0;
}

static inline int MP_use_blks(size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t max_start = pool.nblocks - nblocks;
  size_t full_chunks = (nblocks / 64) * 64;

  for (size_t i = 0, c = 0; i <= max_start; i++, c++) {
    bool free = true;

    for (size_t j = 0; j < full_chunks; j += 64) {
      size_t word_index = (i + j) / 64;
      if (pool.freebs[word_index] != UINT64_MAX) {
        free = false;
        i += 63;
        break;
      }
    }

    for (size_t j = full_chunks; j < nblocks; j++) {
      size_t bit_index = i + j;
      size_t word_index = bit_index / 64;
      size_t bit_in_word = bit_index % 64;

      if (!BIT_IS_FREE(pool.freebs[word_index], bit_in_word)) {
        free = false;
        i += j;
        break;
      }
    }

    if (free) {
      for (size_t j = 0; j < full_chunks; j += 64) {
        size_t word_index = (i + j) / 64;
        pool.freebs[word_index] = 0;
      }

      for (size_t j = full_chunks; j < nblocks; j++) {
        size_t bit_index = i + j;
        size_t word_index = bit_index / 64;
        size_t bit_in_word = bit_index % 64;

        MARK_BIT_USED(pool.freebs[word_index], bit_in_word);
      }

      return i;
    }
  }

  return -1;
}

static inline int MP_free_blks(size_t bindex, size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t full_chunks = (nblocks / 64) * 64;
  for (size_t i = 0; i < full_chunks; i += 64) {
    size_t word_index = (bindex + i) / 64;
    pool.freebs[word_index] = UINT64_MAX;
  }

  for (size_t i = full_chunks; i < nblocks; i++) {
    size_t bit_index = bindex + i;
    size_t word_index = bit_index / 64;
    size_t bit_in_word = bit_index % 64;

    MARK_BIT_FREE(pool.freebs[word_index], bit_in_word);
  }

  memset(pool.blocks[bindex], 0, nblocks * MP_BLOCK);
  return 0;
}

static inline conn_t *MP_use(size_t nblocks, int fd, bool once) {
  if (fd <= 0)
    return NULL;
  if (once)
    return MP_use_once(nblocks, fd);

  int cindex = find_freec();
  if (cindex < 0) {
    LOG("Err: cindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  conn_t *conn = pool.conns[cindex];

  int ios_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (ios_bindex < 0) {
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }

  struct iovec *ios = pool.blocks[ios_bindex];
  conn->ios = ios;

  int rec_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (rec_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct iovec *rec = pool.blocks[rec_bindex];
  conn->rec = rec;

  int msg_bindex = MP_use_blks(MSG_NBLOCKS);
  if (msg_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct msghdr *msg = pool.blocks[msg_bindex];
  conn->msg = msg;

  if (nblocks > 0) {
    int bindex = MP_use_blks(nblocks);
    if (bindex < 0) {
      MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
      MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
      MP_free_blks(msg_bindex, IOVEC_NBLOCKS);
      MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
      LOG("Err: bindex < 0; will use MP_use_once\n");
      return MP_use_once(nblocks, fd);
    }

    size_t iov_index = conn->nios++;
    struct iovec *iov = &conn->ios[iov_index];
    struct iovec *rec = &conn->rec[iov_index];
    iov->iov_base = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
  }

  conn->msg->msg_iov = conn->ios;
  conn->msg->msg_iovlen = conn->nios;
  conn->cindex = cindex;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;
  return conn;
}

static inline void MP_shed(conn_t *conn, size_t iov_index, size_t nios) {
  struct iovec *iov, *rec;
  size_t bindex, nblocks, index;

  for (size_t i = 0; i < nios; i++) {
    index = iov_index + i;
    iov = &conn->ios[index];
    rec = &conn->rec[index];
    if (!rec || !rec->iov_base)
      continue;
    if (!IN_POOL(rec->iov_base)) {
      munmap(rec->iov_base, rec->iov_len / pool.pagesize);
    } else {
      bindex = ptr_diff((uintptr_t)rec->iov_base, (uintptr_t)pool.bpool) / MP_BLOCK;
      nblocks = rec->iov_len / MP_BLOCK;
      MP_free_blks(bindex, nblocks);
    }
    memset(iov, 0, sizeof(struct iovec));
    memset(rec, 0, sizeof(struct iovec));
    conn->nios--;
  }
}

static inline int MP_expand(conn_t *conn, size_t nblocks, bool once) {
  void *bptr;
  int iov_index, bindex;
  struct iovec *iov, *rec;

  iov_index = conn->nios++;
  iov = &conn->ios[iov_index];
  rec = &conn->rec[iov_index];

  if (nblocks == 0)
    return iov_index;

  if (once) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_base = bptr;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
    return iov_index;
  }

  bindex = MP_use_blks(nblocks);
  if (bindex < 0) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_len = iov->iov_len;
  } else {
    bptr = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_len = iov->iov_len;
  }

  iov->iov_base = bptr;
  rec->iov_base = iov->iov_base;
  return iov_index;
}

static inline int MP_free(conn_t *conn) {
  if (!conn)
    return -1;
  size_t bindex, nblocks;
  uint64_t *word;

  MP_shed(conn, 0, conn->nios);
  if (conn->flags & CF_IN_HEAP) {
    if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
      close(conn->fd);
    free(conn);
    return 0;
  }

  word = &pool.freecs[conn->cindex / 64];
  if (conn->cindex > MAX_CONNS)
    return -1;
  else if (BIT_IS_FREE(*word, conn->cindex))
    return 0;

  bindex = ptr_diff((uintptr_t)conn->ios, (uintptr_t)pool.bpool) / MP_BLOCK;
  nblocks = IOVEC_NBLOCKS;
  MP_free_blks(bindex, nblocks);

  bindex = ptr_diff((uintptr_t)conn->rec, (uintptr_t)pool.bpool) / MP_BLOCK;
  MP_free_blks(bindex, nblocks);

  if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
    close(conn->fd);

  MARK_BIT_FREE(*word, conn->cindex);
  memset(conn, 0, sizeof(conn_t));
  conn->fd = -1;
  conn->in_fd = -1;
  conn->out_fd = -1;
  return 0;
}

static inline void MP_clear(conn_t *conn) {
  conn_t *recv_conn = conn->recv_conn;
  conn_t *send_conn = conn->send_conn;
  if (recv_conn)
    MP_free(recv_conn);
  if (send_conn)
    MP_free(send_conn);
}

static inline void MP_exit(MPool *pool) {
  munmap(pool->bpool, pool->npages);
  free(pool->cpool);
  free(pool->blocks);
  free(pool->conns);
  free(pool->freebs);
  free(pool->freecs);
}

static inline void MP_timeout() {
  conn_t *conn;
  int16_t res;
  uint64_t now;
  size_t windex = 0;
  uint64_t *word = &pool.freecs[0];
  for (size_t i = 0; i < MAX_CONNS; i++) {
    if ((i / 64) < windex)
      word = &pool.freecs[++windex];

    if (*word == UINTMAX_MAX) {
      i = (i / 64) * 64 + 64;
      continue;
    }

    conn = pool.conns[i];
    if (!conn || conn->fd == -1)
      continue;

    res = pollevs(conn->fd);

    now = get_time();
    if (res & POLLERR) {
      MP_clear(conn);
      continue;
    }
    if (res & POLLIN) {
      if (pool.rtimeout > 0 && (now - conn->last_read) >= pool.rtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (res & POLLOUT) {
      if (pool.wtimeout > 0 && (now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (!(res & POLLIN || res & POLLOUT)) {
      if ((pool.rtimeout > 0 && now - conn->last_read) >= pool.rtimeout
          || (pool.wtimeout > 0 && now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
  }
}

/*
 * Calculate the length of a status string
 */
static inline size_t status_len(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return 8;
  case STATUSSWITCHINGPROTOCOLS:
    return 19;
  case STATUSPROCESSING:
    return 10;
  case STATUSEARLYHINTS:
    return 11;
  case STATUSOK:
    return 2;
  case STATUSCREATED:
    return 7;
  case STATUSACCEPTED:
    return 8;
  case STATUSNONAUTHORITATIVE:
    return 29;
  case STATUSNOCONTENT:
    return 10;
  case STATUSRESETCONTENT:
    return 13;
  case STATUSPARTIALCONTENT:
    return 15;
  case STATUSMULTISTATUS:
    return 12;
  case STATUSALREADYREPORTED:
    return 16;
  case STATUSIMUSED:
    return 7;
  case STATUSMULTIPLECHOICES:
    return 16;
  case STATUSMOVEDPERMANENTLY:
    return 17;
  case STATUSFOUND:
    return 5;
  case STATUSSEEOTHER:
    return 9;
  case STATUSNOTMODIFIED:
    return 12;
  case STATUSUSEPROXY:
    return 9;
  case STATUSTEMPORARYREDIRECT:
    return 18;
  case STATUSPERMANENTREDIRECT:
    return 18;
  case STATUSBADREQUEST:
    return 11;
  case STATUSUNAUTHORIZED:
    return 12;
  case STATUSPAYMENTREQUIRED:
    return 16;
  case STATUSFORBIDDEN:
    return 9;
  case STATUSNOTFOUND:
    return 9;
  case STATUSMETHODNOTALLOWED:
    return 18;
  case STATUSNOTACCEPTABLE:
    return 14;
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return 29;
  case STATUSREQUESTTIMEOUT:
    return 15;
  case STATUSCONFLICT:
    return 8;
  case STATUSGONE:
    return 4;
  case STATUSLENGTHREQUIRED:
    return 15;
  case STATUSPRECONDITIONFAILED:
    return 19;
  case CONTENTTOOLARGE:
    return 17;
  case STATUSURITOOLONG:
    return 12;
  case STATUSUNSUPPORTEDMEDIATYPE:
    return 22;
  case STATUSRANGENOTSATISFIABLE:
    return 21;
  case STATUSEXPECTATIONFAILED:
    return 18;
  case STATUSMISDIRECTEDREQUEST:
    return 19;
  case STATUSUNPROCESSABLECONTENT:
    return 21;
  case STATUSLOCKED:
    return 6;
  case STATUSFAILEDDEPENDENCY:
    return 17;
  case STATUSTOOEARLY:
    return 9;
  case STATUSUPGRADEREQUIRED:
    return 16;
  case STATUSPRECONDITIONREQUIRED:
    return 21;
  case STATUSTOOMANYREQUESTS:
    return 17;
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return 31;
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return 29;
  case STATUSInternalServerError:
    return 21;
  case STATUSNOTIMPLEMENTED:
    return 15;
  case STATUSBADGATEWAY:
    return 11;
  case STATUSSERVICEUNAVAILABLE:
    return 19;
  case STATUSGATEWAYTIMEOUT:
    return 15;
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return 26;
  case STATUSVARIANTALSONEGOTIATES:
    return 23;
  case STATUSINSUFFICIENTSTORAGE:
    return 20;
  case STATUSLOOPDETECTED:
    return 13;
  case STATUSNOTEXTENDED:
    return 12;
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return 31;
  default:
    return 0;
  }
}

/*
 * Return the status code string as string literal
 */
static inline char *status_str(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return "Continue";
  case STATUSSWITCHINGPROTOCOLS:
    return "Switching Protocols";
  case STATUSPROCESSING:
    return "Processing";
  case STATUSEARLYHINTS:
    return "Early Hints";
  case STATUSOK:
    return "OK";
  case STATUSCREATED:
    return "Created";
  case STATUSACCEPTED:
    return "Accepted";
  case STATUSNONAUTHORITATIVE:
    return "Non-Authoritative Information";
  case STATUSNOCONTENT:
    return "No Content";
  case STATUSRESETCONTENT:
    return "Reset Content";
  case STATUSPARTIALCONTENT:
    return "Partial Content";
  case STATUSMULTISTATUS:
    return "Multi-Status";
  case STATUSALREADYREPORTED:
    return "Already Reported";
  case STATUSIMUSED:
    return "Im Used";
  case STATUSMULTIPLECHOICES:
    return "Multiple Choices";
  case STATUSMOVEDPERMANENTLY:
    return "Moved Permanently";
  case STATUSFOUND:
    return "Found";
  case STATUSSEEOTHER:
    return "See Other";
  case STATUSNOTMODIFIED:
    return "Not Modified";
  case STATUSUSEPROXY:
    return "Use Proxy";
  case STATUSTEMPORARYREDIRECT:
    return "Temporary Redirect";
  case STATUSPERMANENTREDIRECT:
    return "Permanent Redirect";
  case STATUSBADREQUEST:
    return "Bad Request";
  case STATUSUNAUTHORIZED:
    return "Unauthorized";
  case STATUSPAYMENTREQUIRED:
    return "Payment Required";
  case STATUSFORBIDDEN:
    return "Forbidden";
  case STATUSNOTFOUND:
    return "Not Found";
  case STATUSMETHODNOTALLOWED:
    return "Method Not Allowed";
  case STATUSNOTACCEPTABLE:
    return "Not Acceptable";
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return "Proxy Authentication Required";
  case STATUSREQUESTTIMEOUT:
    return "Request Timeout";
  case STATUSCONFLICT:
    return "Conflict";
  case STATUSGONE:
    return "Gone";
  case STATUSLENGTHREQUIRED:
    return "Length Required";
  case STATUSPRECONDITIONFAILED:
    return "Precondition Failed";
  case CONTENTTOOLARGE:
    return "Content Too Large";
  case STATUSURITOOLONG:
    return "URI Too Long";
  case STATUSUNSUPPORTEDMEDIATYPE:
    return "Unsupported Media Type";
  case STATUSRANGENOTSATISFIABLE:
    return "Range Not Satisfiable";
  case STATUSEXPECTATIONFAILED:
    return "Expectation Failed";
  case STATUSMISDIRECTEDREQUEST:
    return "Misdirected Request";
  case STATUSUNPROCESSABLECONTENT:
    return "Unprocessable Content";
  case STATUSLOCKED:
    return "Locked";
  case STATUSFAILEDDEPENDENCY:
    return "Failed Dependency";
  case STATUSTOOEARLY:
    return "Too Early";
  case STATUSUPGRADEREQUIRED:
    return "Upgrade Required";
  case STATUSPRECONDITIONREQUIRED:
    return "Precondition Required";
  case STATUSTOOMANYREQUESTS:
    return "Too Many Requests";
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return "Request Header Fields Too Large";
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return "Unavailable For Legal Reasons";
  case STATUSInternalServerError:
    return "Internal Server Error";
  case STATUSNOTIMPLEMENTED:
    return "Not Implemented";
  case STATUSBADGATEWAY:
    return "Bad Gateway";
  case STATUSSERVICEUNAVAILABLE:
    return "Service Unavailable";
  case STATUSGATEWAYTIMEOUT:
    return "Gateway Timeout";
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return "HTTP Version Not Supported";
  case STATUSVARIANTALSONEGOTIATES:
    return "Variant Also Negotiates";
  case STATUSINSUFFICIENTSTORAGE:
    return "Insufficient Storage";
  case STATUSLOOPDETECTED:
    return "Loop Detected";
  case STATUSNOTEXTENDED:
    return "Not Extended";
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return "Network Authentication Required";
  default:
    return 0;
  }
}

/*
 * Return true if routes match
 */
static inline bool route_equ(Route *route, Request *req) {
  return route->method == req->method && strncmp(route->path, req->path, strlen(route->path)) == 0;
}

/*
 * Return the matching route index on success. -1 on failure
 */
static inline int match_route(Server *serv, Request *req) {
  for (size_t i = 0; i < serv->_nroutes; i++) {
    Route route = serv->routes[i];
    if (!req->path || !route.path)
      continue;
    if (route_equ(&route, req))
      return i;
    else if (req->method == HEAD && route.method == GET && strcmp(route.path, req->path) == 0)
      return i;
  }
  return -1;
}

/*
 * Return true if the response should contain the Content-Length header
 */
static inline bool should_have_content_length(Request *req, ResWriter *res) {
  return (req->method != CONNECT              // CONNECT request
          && res->status != STATUSNOCONTENT   // 204 response
          && res->status != STATUSNOTMODIFIED // 304 response
          && res->status >= 200);             // 1xx response
}

/*
 * Format http response from the ResWriter.
 * Return response size on success, 0 on failure.
 */
static inline size_t fmt_res(Request *req, ResWriter *res, char *buffer, size_t buffer_size) {
  if (!res || !buffer || buffer_size == 0)
    return 0;

  size_t res_len, total = 0;
  char *dst = buffer;
  size_t maxlen = buffer_size;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t body_length = res->len;

  res_len = snprintf(dst, maxlen, "HTTP/1.1 %d %s", (int)res->status, status_str(res->status));
  total += res_len;
  dst += res_len;
  maxlen -= res_len;

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    res_len = snprintf(dst, maxlen, "\r\n%s: %s", header->key, header->value);
    total += res_len;
    dst += res_len;
    maxlen -= res_len;
  }

  if (have_content_length) {
    res_len = snprintf(dst, maxlen, "\r\nContent-Length: %lu", body_length);
    total += res_len, dst += res_len, maxlen -= res_len;
  }

  memcpy(dst, "\r\n\r\n", 4);
  total += 4, dst += 4, maxlen -= 4;

  return total;
}

static inline size_t res_len(Request *req, ResWriter *res) {
  if (!req || !res)
    return 0;

  if (!res->status)
    res->status = STATUSOK;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t result = 0;
  result += STRLEN("HTTP/1.1 ");     // HTTP version
  result += 4;                       // Status code + space
  result += status_len(res->status); // Status name

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    result += 2;                       // "\r\n"
    result += strlen(header->key) + 2; // Header key + ':' + space
    result += strlen(header->value);   // header value
  }

  if (have_content_length) {
    result += 2;                          // "\r\n"
    result += STRLEN("Content-Length: "); // Header key
    result += countd(res->len);           // Header value
  }

  result += 4; // "\r\n\r\n"

  return result;
}

static inline int send_empty_res(Status status) {
  size_t res_len = STRLEN("HTTP/1.1 ")        // HTTP version
                   + countd((uint64_t)status) // status code
                   + 1                        // space
                   + (int)status_len(status)  // status string
                   + 4;                       // \r\n\r\n

  conn_t *conn = current_send;
  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, res_len);
  if (snprintf((char *)rec->iov_base, res_len + 1, "HTTP/1.1 %d %s\r\n\r\n", (int)status, status_str(status))
      != (int)res_len)
    return -1;

  return usendmsg(conn, 0, 1);
}

static inline ssize_t read_socket(int sockfd, size_t len) {
  if (len == 0 || sockfd <= 0)
    return 0;
  char buff[1024 * 8];
  return read(sockfd, buff, 1024 * 8);
}

static inline int read_method(Method *method, void *src) {
  if (memcmp(src, "GET", 3) == 0)
    *method = GET;
  else if (memcmp(src, "POST", 4) == 0)
    *method = POST;
  else if (memcmp(src, "HEAD", 4) == 0)
    *method = HEAD;
  else if (memcmp(src, "PUT", 3) == 0)
    *method = PUT;
  else if (memcmp(src, "DELETE", 6) == 0)
    *method = DELETE;
  else if (memcmp(src, "CONNECT", 7) == 0)
    *method = CONNECT;
  else if (memcmp(src, "OPTIONS", 7) == 0)
    *method = OPTIONS;
  else if (memcmp(src, "TRACE", 5) == 0)
    *method = TRACE;
  else if (memcmp(src, "PATCH", 5) == 0)
    *method = PATCH;
  else
    return -1;

  return 0;
}

static inline int sendmsg_res(Request *req, ResWriter *res) {
  conn_t *conn;
  size_t head_size, res_size;
  struct iovec *iov;

  conn = current_send;
  iov = &conn->ios[0];
  head_size = res_len(req, res);
  if (head_size == 0)
    return -1;

  conn->data_left += head_size;
  res_size = fmt_res(req, res, iov->iov_base, (head_size + 1));
  if (res_size != head_size)
    return -1;
  iov->iov_len = res_size;

  return usendmsg(conn, 0, conn->nios);
}

static inline int read_req(Request *req, char *req_buffer) {
  if (!req_buffer)
    return -1;
  /*** Method ***/
  char *sep = strchr(req_buffer, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }
  *sep = '\0';
  if (read_method(&req->method, req_buffer) < 0)
    return -1;

  /*** Path ***/
  char *fullpath = sep + 1;
  sep = strchr(fullpath, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }

  *sep = '\0';
  req->path = fullpath;
  /*** Params ***/
  char *paramStart = strchr(fullpath, '?');
  if (paramStart) {
    *paramStart++ = '\0';
    int params_count = 0;
    params_count = HK_parse_params(paramStart, req->params, MAX_URL_PARAMETERS);
    if (params_count > 0)
      req->params_count = params_count;
    else
      req->params_count = 0;
  } else {
    req->params = NULL;
    req->params_count = 0;
  }

  /*** Headers ***/
  char *headStart = strstr(sep + 1, "\r\n");
  char *headEnd = strstr(sep + 1, "\r\n\r\n");
  if (!headStart) {
    LOG("read_req: !headStart\n");
    return -1;
  };

  memset(headStart, 0, 2);
  headStart += 2;
  memset(headEnd, 0, 4);
  headEnd += 4;

  int headers_count = HK_parse_headers(headStart, req->headers, MAX_REQ_HEADERS);
  if (headers_count <= 0)
    return -1;
  req->headers_count = headers_count;

  /*** Host ***/
  int index = HK_get_header(req, "Host");
  if (index < 0)
    return -1;
  char *host = req->headers[index].value;
  req->hostname = host;

  /*** Port ***/
  char *colon = strchr(host, ':');
  if (colon) {
    *colon++ = '\0';
    req->port = atoi(colon);
  } else {
    req->port = PORT;
  }
  return 0;
}
static inline int process_req(Server *serv, conn_t *conn) {
  if (!conn || conn->fd == -1)
    return -1;

  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;
  if (read_req(&req, conn->ios[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    LOG("Err: route_index == -1\n");
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;
  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  sendmsg_res(&req, &res);

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int new_conn(int connfd) {
  if (connfd <= 0)
    return -1;

  current_recv = MP_use(KB * 2, connfd, false);
  current_send = MP_use(KB * 2, connfd, false);

  current_recv->recv_conn = current_recv;
  current_recv->send_conn = current_send;

  current_send->send_conn = current_send;
  current_send->recv_conn = current_recv;

  conn_t *conn = current_recv;
  if (ufrecvmsg(conn, 0, 1) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

static inline int resubmit_sendmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return usendmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int resubmir_recvmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    // FIXME the len should be increased
    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return urecvmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int handle_sendmsg_complete(conn_t *conn) {
  struct iovec *iov, *rec;

  MP_shed(conn, 1, conn->nios - 1);
  iov = &conn->ios[0];
  rec = &conn->rec[0];
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;

  return ufrecvmsg(conn->recv_conn, 0, 1);
}

static inline int handle_sendmsg(conn_t *conn, int res, bool zc) {
  if (!conn || conn->fd == -1)
    return -1;

  conn->data_left -= res;
  if (conn->data_left > 0)
    return resubmit_sendmsg(conn, res);

  if (zc)
    return 0;

  return handle_sendmsg_complete(conn);
}

static inline int handle_insplice(conn_t *conn) {
  conn->op = OUTSPLICE;
  return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
}
static inline int handle_outsplice(conn_t *conn, int res) {
  conn->data_left -= res;
  if (conn->data_left > 0) {
    conn->op = INSPLICE;
    return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
  }

  conn_t *recv_conn = conn->recv_conn;
  struct iovec *iov = &recv_conn->ios[0];
  memset(iov->iov_base, 0, iov->iov_len);
  if (urecv(recv_conn, iov->iov_base, iov->iov_len, MSG_PEEK) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

/*
static inline int handle_recv(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  void *bptr = conn->ios[0].iov_base;
  void *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  void *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  return process_req(serv, conn);
}
*/
static inline int find_route(Server *serv, char *bptr) {
  Request req = {0};
  if (read_method(&req.method, bptr) < 0) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  };
  char *space = strchr(bptr, ' ');
  req.path = (space + 1);
  space = strchr(req.path, ' ');
  *space = '\0';
  int route_index = match_route(serv, &req);
  *space = ' ';
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }
  return route_index;
}

static inline int run_handler(Server *serv, conn_t *conn, bool uses_body) {
  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;

  if (read_req(&req, conn->rec[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  if (uses_body) {
    int h_index = HK_get_header(&req, "Content-Length");
    long body_size = atol(req.headers[h_index].value);
    if (body_size >= 0) {
      req.body.ptr = conn->rec[1].iov_base;
      req.body.size = body_size;
    } else {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    }
  }

  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  if (sendmsg_res(&req, &res) < 0)
    return -1;

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int handle_frecvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  char *bptr = (char *)conn->ios[0].iov_base;
  char *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  char *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  size_t head_size = (headEnd + 4) - bptr;
  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  int route_index = find_route(serv, bptr);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  bool uses_body = serv->routes[route_index].uses_body;
  long body_size = get_content_length(headstart + 2, headEnd + 4);
  if (body_size == -1) {
    if (uses_body) {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    } else {
      body_size = 0;
    }
  }

  conn->head_size = head_size;
  if (!uses_body) {
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  if (res == (int)(head_size + body_size)) {
    size_t iov_index = MP_expand(conn, round_to_blocks(body_size), false);
    memcpy(conn->rec[iov_index].iov_base, headEnd + 4, body_size);
    conn->ios[iov_index].iov_len = body_size;
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  conn->data_left = body_size - (res - head_size);
  bool once = ((size_t)body_size > (size_t)((pool.nblocks * MP_BLOCK) / 10));
  size_t iov_index = MP_expand(conn, round_to_blocks(body_size), once);
  memcpy(conn->rec[iov_index].iov_base, headEnd + 4, (res - head_size));
  conn->ios[iov_index].iov_base += (res - head_size);

  return urecvmsg(conn, iov_index, 1);
}

static inline int handle_recvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  if (conn->data_left > 0) {
    conn->data_left -= res;
    if (conn->data_left == 0) {
      conn->flags &= CF_HANDLER_READY;
      return run_handler(serv, conn, true);
    }

    conn->flags &= ~CF_HANDLER_READY;
    conn->ios[1].iov_base += res;
    return urecvmsg(conn, 1, 1);
  }

  conn->flags &= CF_HANDLER_READY;
  return run_handler(serv, conn, true);
}

static inline int serv_init(Server *serv) {
#if DEBUG
  logfd = log_init("log.txt");
  if (!logfd) {
    printf("log_init failed");
    return -1;
  }
#endif
  serv->_nroutes = get_nroutes(serv->routes);

  int pipefd[2];
  if (pipe(pipefd) < 0)
    return -1;
  pipe_in = pipefd[0];
  pipe_out = pipefd[1];
  nullfd = open("/dev/null", O_WRONLY);
  pipe_sz = fcntl(pipefd[0], F_GETPIPE_SZ);
  if (pipe_sz < 0)
    return -1;

  pool.rtimeout = serv->rtimeout;
  pool.wtimeout = serv->wtimeout;
  if (MP_init(MAX_CONNS * 8) < 0)
    return -1;
  LOG("pool initialized\n");

  if (io_uring_queue_init(MAX_CONNS, &ring, 0) < 0)
    return -1;
  LOG("uring initialized\n");

  int listenfd;
  if ((listenfd = tcp_listen(serv->port)) < 0)
    return -1;
  LOG("socket initialized\n");

  return umaccept(listenfd);
}

static inline int serv_listen(Server *serv) {
  // uint64_t last_check = get_time();
  while (true) {
    // uint64_t now = get_time();
    // if ((now - last_check) >= 200) {
    //   last_check = now;
    //   LOG("CM: CM_check ran\n");
    //   MP_timeout();
    // }

    LOG("SQ ready: %u, CQ ready: %u\n", io_uring_sq_ready(&ring), io_uring_cq_ready(&ring));
    struct io_uring_cqe *cqe;
    if (io_uring_wait_cqe(&ring, &cqe) < 0)
      continue;

    int res = cqe->res;
    LOG("res = %d\n", res);
    conn_t *conn = NULL;
    if (cqe->user_data > 100) {
      conn = (conn_t *)cqe->user_data;
      current_recv = (conn_t *)conn->recv_conn;
      current_send = (conn_t *)conn->send_conn;
    }

    if (res > 0) {
      if (cqe->user_data == ACCEPT) {
        LOG("new conn created\n");
        new_conn(res);
      } else if (conn && conn->fd != -1) {
        LOG("conn[%d]: conn.fd = %d; conn.op = %d\n", conn->cindex, conn->fd, conn->op);
        switch (conn->op) {
        case FRECVMSG:
          if (handle_frecvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case RECVMSG:
          if (handle_recvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case SENDMSG:
        case SENDMSGZC:
          // conn->last_write = get_time();
          bool zc = (conn->op == SENDMSGZC);
          if (handle_sendmsg(conn, res, zc) < 0)
            MP_clear(conn);
          break;
        case INSPLICE:
          if (handle_insplice(conn) < 0)
            MP_clear(conn);
          break;
        case OUTSPLICE:
          if (handle_outsplice(conn, res) < 0)
            MP_clear(conn);
          break;
        }
      }
    } else if (res == 0) {
      if (conn && conn->fd != -1) {
        switch (conn->op) {
        case SENDMSGZC:
          conn->zc_notifs--;
          if (conn->zc_notifs == 0 && handle_sendmsg_complete(conn) < 0)
            MP_clear(conn);
          break;
        case RECV:
          MP_clear(conn);
          break;
        }
      }
    } else {
      if (conn && conn->fd != -1) {
        if (res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR) {
          LOG("conn && conn->fd != -1 && res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR\n");
          MP_clear(conn);
        } else {
          LOG("res == -EAGAIN || res == -EWOULDBLOCK || res == -EINTR\n");
          conn = conn->recv_conn;
          struct iovec *iov = &conn->ios[0];
          memset(iov->iov_base, 0, iov->iov_len);
          if (urecv(conn, iov->iov_base, iov->iov_len, 0) < 0)
            MP_clear(conn);
        }
      }
    }

    LOG("uring operation seen\n");
    io_uring_cqe_seen(&ring, cqe);
  }

  io_uring_queue_exit(&ring);
  MP_exit(&pool);
  return 0;
}

/*** Helper ***/
static inline int _HK_write(void *data, size_t size) {
  size_t nblocks;
  int iov_index;
  conn_t *conn;
  struct iovec *iov;
  bool once;

  conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  nblocks = round_to_blocks(size);
  iov_index = MP_expand(conn, nblocks, once);
  iov = &conn->ios[iov_index];

  memcpy(iov->iov_base, data, size);
  iov->iov_len = size;
  conn->data_left += size;

  return 0;
}
static inline int _HK_write_body(Request *req, size_t offset, size_t size) {
  if (size > req->body.size || offset > req->body.size)
    return -1;

  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  int iov_index = MP_expand(conn, 0, false);
  struct iovec *iov = &conn->ios[iov_index];
  struct iovec *rec = &conn->rec[iov_index];
  rec->iov_base = req->body.ptr + offset;
  rec->iov_len = size;
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;
  conn->data_left += rec->iov_len;
  return 0;
}
/*
static inline int _HK_mem(size_t size, HKMem *mem) {
  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  bool once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  size_t nblocks = round_to_blocks(size);
  int iov_index = MP_expand(conn, nblocks, once);
  struct iovec *iov = &conn->ios[iov_index];
  mem->ptr = iov->iov_base;
  mem->size = iov->iov_len;
  mem->_iov_index = iov_index;
  mem->_flags = (IN_POOL(iov->iov_base)) ? CF_IN_POOL : CF_IN_HEAP;
  return 0;
}

static inline void _HK_send(HKMem *mem, size_t size) {
  conn_t *conn = current_send;
  struct iovec *iov = &conn->ios[mem->_iov_index];
  iov->iov_len = size;
  conn->data_left += size;
}
  */
#endif#define _GNU_SOURCE
#ifndef UTILS_H
#define UTILS_H

#include "hunk.h"
#include <arpa/inet.h>
#include <fcntl.h>
#include <liburing.h>
#include <netdb.h>
#include <signal.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/poll.h>
#include <sys/prctl.h>
#include <sys/socket.h>
#include <sys/sysinfo.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

#define MP_BLOCK  4
#define MAX_CONNS 4096
#define KB        1024
#define NIOS      32

#define IN_POOL(ptr)                 ((void *)ptr >= pool.bpool && (void *)ptr <= (pool.bpool + (pool.npages * pool.pagesize)))
#define ALIGN_TO_PAGESIZE(buff_size) (((buff_size) + (pool.pagesize - 1)) & ~(pool.pagesize - 1))
#define BYTES_TO_BLOCKS(buff_size)   (((buff_size) + (MP_BLOCK - 1)) / MP_BLOCK)
#define CEIL_BLOCKS(nblocks)         ((nblocks + 63) & ~63)
#define CEIL_PAGES(size)             (((size) + ((pool.pagesize) - 1)) & ~((pool.pagesize) - 1))

#define BIT_IS_FREE(word, bit)   (((word) >> (bit)) & 1)
#define MARK_BIT_USED(word, bit) ((word) &= ~(1ULL << (bit)))
#define MARK_BIT_FREE(word, bit) ((word) |= (1ULL << (bit)))
#define FIND_FREE_BIT(word)      ((uint64_t)(word) & -(uint64_t)(word))
#define STRLEN(s)                (sizeof(s) - 1)

#define IOVEC_NBLOCKS (BYTES_TO_BLOCKS(NIOS * sizeof(struct iovec)))
#define MSG_NBLOCKS   (BYTES_TO_BLOCKS(sizeof(struct msghdr)))
#define ZC_RES        KB *KB

#define DEBUG 0
#if DEBUG
#define LOG(...) fprintf(logfd, __VA_ARGS__)
#else
#define LOG(...) ((void)0)
#endif

typedef enum UOP {
  WRITEV = IORING_OP_WRITEV,
  SENDMSG = IORING_OP_SENDMSG,
  RECVMSG = IORING_OP_RECVMSG,
  ACCEPT = IORING_OP_ACCEPT,
  SEND = IORING_OP_SEND,
  RECV = IORING_OP_RECV,
  SENDZC = IORING_OP_SEND_ZC,
  SENDMSGZC = IORING_OP_SENDMSG_ZC,
  PEEK = 50,
  FRECVMSG,
  INSPLICE,
  OUTSPLICE
} UOP;

typedef enum CFS {
  CF_IN_POOL = (1 << 0),       // Connection is in the pool
  CF_IN_HEAP = (1 << 1),       // Connection is in the heap
  CF_SKIP_SOCK = (1 << 2),     // Don't close the socket
  CF_USE_ONCE = (1 << 3),      // Destroy after using
  CF_HANDLER_READY = (1 << 4), // Ready to call the handler
} CFS;

typedef struct conn_t {
  // Socket file descriptor
  int fd;

  // Amount of data left in the current operation
  uint64_t data_left;

  // The index of the connection struct
  uint32_t cindex;

  // The last time the connection was readable
  uint64_t last_read;

  // The last time the connection was writeable
  uint64_t last_write;

  // The operation currently being processed
  uint8_t op;

  // Connection flags
  int flags;

  // Splice fd_in
  int in_fd;

  // Splice fd_out
  int out_fd;

  void *recv_conn;
  void *send_conn;

  struct iovec *ios;
  struct iovec *rec;
  uint16_t nios;

  struct msghdr *msg;
  uint16_t zc_notifs;

  uint16_t head_size;
} conn_t;

typedef struct MPool {
  // The allocated pool of blocks
  void *bpool;

  // The allocated pool of connections
  conn_t *cpool;

  // The size of the pool in pages
  uint32_t npages;

  // The size of the pool in blocks
  uint32_t nblocks;

  // The locations of each page in the pool
  void **blocks;

  // The availability of each block
  uint64_t *freebs;

  // The locations of each conn in the pool
  conn_t **conns;

  // The availability of each conn
  uint64_t *freecs;

  // Clean up callback function
  void (*callback)(conn_t *conn);

  // The page size used
  uint32_t pagesize;

  // Socket read timeout
  uint32_t rtimeout;

  // Socket write timeout
  uint32_t wtimeout;
} MPool;

extern int pipe_sz;
extern int pipe_in, pipe_out, nullfd;
extern FILE *logfd;
extern struct io_uring ring;
extern MPool pool;
extern conn_t *current_recv;
extern conn_t *current_send;

/*
 * Prepare and submit a recv uring op
 */
static inline int urecv(conn_t *conn, void *buffer, size_t buff_size, int flags) {
  if (!conn || conn->fd == -1)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (flags == MSG_PEEK) ? PEEK : RECV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;

  io_uring_prep_recv(sqe, conn->fd, buffer, buff_size, flags);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a multi-shot accept uring op
 */
static inline int umaccept(int listenfd) {
  if (listenfd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = ACCEPT;
  io_uring_prep_multishot_accept(sqe, listenfd, NULL, NULL, SOCK_NONBLOCK);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a splice uring op
 */
static inline int usplice(conn_t *conn, int fd_in, int64_t off_in, int fd_out, int64_t off_out, size_t len) {
  if (!len || !conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = (__u64)conn;
  io_uring_prep_splice(sqe, fd_in, off_in, fd_out, off_out, len, 0);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a writev uring op
 */
static inline int uwritev(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = WRITEV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  io_uring_prep_writev(sqe, conn->fd, &conn->ios[iov_index], nios, -1);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a send uring op
 */
static inline int usend(conn_t *conn, char *res_buff, size_t buff_size, bool zc) {
  if (!conn || conn->fd <= 0 || buff_size == 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (zc) ? SENDZC : SEND;
  conn->data_left = buff_size;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  if (zc)
    io_uring_prep_send_zc(sqe, conn->fd, res_buff, buff_size, 0, 0);
  else
    io_uring_prep_send(sqe, conn->fd, res_buff, buff_size, 0);
  return io_uring_submit(&ring);
}

static inline int ufrecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = FRECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;

  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, rec->iov_len);
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int urecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = RECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int usendmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  bool zc = (conn->data_left > ZC_RES) ? true : false;
  conn->op = (zc) ? SENDMSGZC : SENDMSG;

  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  if (zc) {
    io_uring_prep_sendmsg_zc(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
    conn->zc_notifs++;
  } else {
    io_uring_prep_sendmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  }
  return io_uring_submit(&ring);
}

/*
 * Create and initialize a server socket
 */
static inline int tcp_listen(uint16_t port) {
  int enable;
  int listenfd;
  if ((listenfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    return -1;

  int flags = fcntl(listenfd, F_GETFL, 0);
  fcntl(listenfd, F_SETFL, flags | O_NONBLOCK);
  struct sockaddr_in servaddr;
  memset(&servaddr, 0, sizeof(servaddr));
  servaddr.sin_family = AF_INET;
  servaddr.sin_addr.s_addr = INADDR_ANY;
  servaddr.sin_port = htons(port);

  enable = 1;
  if (setsockopt(listenfd, SOL_SOCKET, SO_REUSEPORT, &enable, sizeof(enable)) < 0)
    return -1;

  if (bind(listenfd, (struct sockaddr *)&servaddr, sizeof(servaddr)) < 0)
    return -1;

  if (listen(listenfd, SOMAXCONN) < 0)
    return -1;

  return listenfd;
}

/*
 * Calculate the difference between two pointers
 */
static inline uintptr_t ptr_diff(uintptr_t p1, uintptr_t p2) { return (uintptr_t)(p1 > p2) ? (p1 - p2) : (p2 - p1); }

static inline size_t get_nroutes(Route *routes) {
  Route *route;
  for (size_t i = 0;; i++) {
    route = &routes[i];
    if (!route->path && !route->handler && !route->method)
      return i;
  }
}

static inline long get_content_length(char *src, char *end) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return -1;
    key = line;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, "Content-Length") != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;

    *line_end = '\0';
    long res = atol(value);
    *line_end = '\r';

    return res;
  }
  return -1;
}

static inline bool have_header(char *src, char *end, const char *header_key, const char *header_value) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    key = line;
    while (*key == ' ')
      key++;
    while (*header_key == ' ')
      header_key++;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return false;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, header_key) != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;
    while (*header_value == ' ')
      header_value++;

    *line_end = '\0';
    bool res = (strcasecmp(value, header_value) == 0);
    *line_end = '\r';

    return res;
  }

  return false;
}

static inline const char *method_str(Method method) {
  switch (method) {
  case GET:
    return "GET";
    break;
  case HEAD:
    return "HEAD";
    break;
  case POST:
    return "POST";
    break;
  case PUT:
    return "PUT";
    break;
  case DELETE:
    return "DELETE";
    break;
  case CONNECT:
    return "CONNECT";
    break;
  case OPTIONS:
    return "OPTIONS";
    break;
  case TRACE:
    return "TRACE";
    break;
  case PATCH:
    return "PATCH";
    break;
  default:
    return NULL;
  }
}

static inline uint8_t method_len(Method method) {
  switch (method) {
  case GET:
    return 3;
    break;
  case HEAD:
    return 4;
    break;
  case POST:
    return 4;
    break;
  case PUT:
    return 3;
    break;
  case DELETE:
    return 6;
    break;
  case CONNECT:
    return 7;
    break;
  case OPTIONS:
    return 7;
    break;
  case TRACE:
    return 5;
    break;
  case PATCH:
    return 5;
    break;
  default:
    return 0;
  }
}

static inline size_t round_to_blocks(size_t size) {
  size_t nblocks = BYTES_TO_BLOCKS(size);
  nblocks = CEIL_BLOCKS(nblocks);
  return nblocks;
}

/*
 * Count the digits in unsigned 64-bit int
 */
static inline int countd(uint64_t num) {
  if (num < 10ULL)
    return 1;
  if (num < 100ULL)
    return 2;
  if (num < 1000ULL)
    return 3;
  if (num < 10000ULL)
    return 4;
  if (num < 100000ULL)
    return 5;
  if (num < 1000000ULL)
    return 6;
  if (num < 10000000ULL)
    return 7;
  if (num < 100000000ULL)
    return 8;
  if (num < 1000000000ULL)
    return 9;
  if (num < 10000000000ULL)
    return 10;
  if (num < 100000000000ULL)
    return 11;
  if (num < 1000000000000ULL)
    return 12;
  if (num < 10000000000000ULL)
    return 13;
  if (num < 100000000000000ULL)
    return 14;
  if (num < 1000000000000000ULL)
    return 15;
  if (num < 10000000000000000ULL)
    return 16;
  if (num < 100000000000000000ULL)
    return 17;
  if (num < 1000000000000000000ULL)
    return 18;
  if (num < 10000000000000000000ULL)
    return 19;
  return 20;
}

/*
 * Get the time elabsed in ms
 */
static inline uint64_t get_time() {
  struct timespec ts;
  clock_gettime(CLOCK_MONOTONIC, &ts);
  return (uint64_t)(ts.tv_sec) * 1000 + (ts.tv_nsec / 1000000);
}

static inline FILE *log_init(const char *path) {
  FILE *res = fopen(path, "a+");
  setvbuf(res, NULL, _IONBF, 0);
  return res;
}

static inline int16_t pollevs(int connfd) {
  struct pollfd pfd;
  pfd.fd = connfd;
  pfd.events = POLLIN | POLLOUT | POLLERR;
  int res = poll(&pfd, 1, 0);
  if (res < 0)
    return POLLERR;
  return pfd.revents;
}

// FIXME This needs to be updated
static inline conn_t *MP_use_once(size_t nblocks, int fd) {

  void *mem = malloc(sizeof(conn_t) + 8 + (IOVEC_NBLOCKS * MP_BLOCK));
  struct conn_t *conn = (conn_t *)mem;
  memset(conn, 0, sizeof(conn_t));
  conn->ios = mem + sizeof(conn_t) + 8;

  if (nblocks > 0) {
    struct iovec *iov = &conn->ios[conn->nios++];
    mem = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (mem == MAP_FAILED)
      return NULL;
    iov->iov_base = mem;
    iov->iov_len = ALIGN_TO_PAGESIZE(nblocks * MP_BLOCK);
  }

  conn->flags |= CF_IN_HEAP;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;

  return conn;
}

static inline int find_freec() {
  uint64_t *word;
  size_t map_size = (sizeof(uint64_t) * 8);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    word = &pool.freecs[i / map_size];

    if (*word == 0) { // All used
      i += (map_size - 1);
      continue;
    }

    i += __builtin_ctzll(*word);
    MARK_BIT_USED(*word, i);
    return i;
  }

  return -1;
}

static inline int MP_init(size_t npages) {
  if (!npages)
    return -1;

  /*** Setup ***/
  pool.npages = npages;
  pool.pagesize = sysconf(_SC_PAGESIZE);

  /*** Pool ***/
  pool.bpool = mmap(NULL, pool.npages * pool.pagesize, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  if (pool.bpool == MAP_FAILED)
    return -1;
  pool.nblocks = (pool.npages * pool.pagesize) / MP_BLOCK;

  /*** Blocks ***/
  pool.blocks = malloc(sizeof(void *) * pool.nblocks);
  if (!pool.blocks)
    return -1;
  for (size_t i = 0; i < pool.nblocks; i++)
    pool.blocks[i] = pool.bpool + (i * MP_BLOCK);

  /*** Freebs ***/
  // if (posix_memalign((void **)&pool.freebs, 64, bitmap_size * sizeof(uint64_t)) < 0)
  size_t bitmap_size = (pool.nblocks + 63) / 64;
  pool.freebs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freebs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freebs[i] = UINT64_MAX;

  /*** Cpool ***/
  pool.cpool = (conn_t *)malloc(sizeof(conn_t) * MAX_CONNS);
  if (!pool.cpool)
    return -1;

  /*** Conns ***/
  pool.conns = (conn_t **)malloc(sizeof(conn_t *) * MAX_CONNS);
  if (!pool.conns)
    return -1;
  size_t conn_size = sizeof(conn_t);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    pool.conns[i] = (conn_t *)((char *)pool.cpool + (i * conn_size));
    pool.conns[i]->fd = -1;
    pool.conns[i]->in_fd = -1;
    pool.conns[i]->out_fd = -1;
  }

  /*** Freecs ***/
  bitmap_size = (MAX_CONNS + 63) / 64;
  pool.freecs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freecs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freecs[i] = UINT64_MAX;

  return 0;
}

static inline int MP_use_blks(size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t max_start = pool.nblocks - nblocks;
  size_t full_chunks = (nblocks / 64) * 64;

  for (size_t i = 0, c = 0; i <= max_start; i++, c++) {
    bool free = true;

    for (size_t j = 0; j < full_chunks; j += 64) {
      size_t word_index = (i + j) / 64;
      if (pool.freebs[word_index] != UINT64_MAX) {
        free = false;
        i += 63;
        break;
      }
    }

    for (size_t j = full_chunks; j < nblocks; j++) {
      size_t bit_index = i + j;
      size_t word_index = bit_index / 64;
      size_t bit_in_word = bit_index % 64;

      if (!BIT_IS_FREE(pool.freebs[word_index], bit_in_word)) {
        free = false;
        i += j;
        break;
      }
    }

    if (free) {
      for (size_t j = 0; j < full_chunks; j += 64) {
        size_t word_index = (i + j) / 64;
        pool.freebs[word_index] = 0;
      }

      for (size_t j = full_chunks; j < nblocks; j++) {
        size_t bit_index = i + j;
        size_t word_index = bit_index / 64;
        size_t bit_in_word = bit_index % 64;

        MARK_BIT_USED(pool.freebs[word_index], bit_in_word);
      }

      return i;
    }
  }

  return -1;
}

static inline int MP_free_blks(size_t bindex, size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t full_chunks = (nblocks / 64) * 64;
  for (size_t i = 0; i < full_chunks; i += 64) {
    size_t word_index = (bindex + i) / 64;
    pool.freebs[word_index] = UINT64_MAX;
  }

  for (size_t i = full_chunks; i < nblocks; i++) {
    size_t bit_index = bindex + i;
    size_t word_index = bit_index / 64;
    size_t bit_in_word = bit_index % 64;

    MARK_BIT_FREE(pool.freebs[word_index], bit_in_word);
  }

  memset(pool.blocks[bindex], 0, nblocks * MP_BLOCK);
  return 0;
}

static inline conn_t *MP_use(size_t nblocks, int fd, bool once) {
  if (fd <= 0)
    return NULL;
  if (once)
    return MP_use_once(nblocks, fd);

  int cindex = find_freec();
  if (cindex < 0) {
    LOG("Err: cindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  conn_t *conn = pool.conns[cindex];

  int ios_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (ios_bindex < 0) {
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }

  struct iovec *ios = pool.blocks[ios_bindex];
  conn->ios = ios;

  int rec_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (rec_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct iovec *rec = pool.blocks[rec_bindex];
  conn->rec = rec;

  int msg_bindex = MP_use_blks(MSG_NBLOCKS);
  if (msg_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct msghdr *msg = pool.blocks[msg_bindex];
  conn->msg = msg;

  if (nblocks > 0) {
    int bindex = MP_use_blks(nblocks);
    if (bindex < 0) {
      MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
      MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
      MP_free_blks(msg_bindex, IOVEC_NBLOCKS);
      MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
      LOG("Err: bindex < 0; will use MP_use_once\n");
      return MP_use_once(nblocks, fd);
    }

    size_t iov_index = conn->nios++;
    struct iovec *iov = &conn->ios[iov_index];
    struct iovec *rec = &conn->rec[iov_index];
    iov->iov_base = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
  }

  conn->msg->msg_iov = conn->ios;
  conn->msg->msg_iovlen = conn->nios;
  conn->cindex = cindex;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;
  return conn;
}

static inline void MP_shed(conn_t *conn, size_t iov_index, size_t nios) {
  struct iovec *iov, *rec;
  size_t bindex, nblocks, index;

  for (size_t i = 0; i < nios; i++) {
    index = iov_index + i;
    iov = &conn->ios[index];
    rec = &conn->rec[index];
    if (!rec || !rec->iov_base)
      continue;
    if (!IN_POOL(rec->iov_base)) {
      munmap(rec->iov_base, rec->iov_len / pool.pagesize);
    } else {
      bindex = ptr_diff((uintptr_t)rec->iov_base, (uintptr_t)pool.bpool) / MP_BLOCK;
      nblocks = rec->iov_len / MP_BLOCK;
      MP_free_blks(bindex, nblocks);
    }
    memset(iov, 0, sizeof(struct iovec));
    memset(rec, 0, sizeof(struct iovec));
    conn->nios--;
  }
}

static inline int MP_expand(conn_t *conn, size_t nblocks, bool once) {
  void *bptr;
  int iov_index, bindex;
  struct iovec *iov, *rec;

  iov_index = conn->nios++;
  iov = &conn->ios[iov_index];
  rec = &conn->rec[iov_index];

  if (nblocks == 0)
    return iov_index;

  if (once) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_base = bptr;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
    return iov_index;
  }

  bindex = MP_use_blks(nblocks);
  if (bindex < 0) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_len = iov->iov_len;
  } else {
    bptr = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_len = iov->iov_len;
  }

  iov->iov_base = bptr;
  rec->iov_base = iov->iov_base;
  return iov_index;
}

static inline int MP_free(conn_t *conn) {
  if (!conn)
    return -1;
  size_t bindex, nblocks;
  uint64_t *word;

  MP_shed(conn, 0, conn->nios);
  if (conn->flags & CF_IN_HEAP) {
    if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
      close(conn->fd);
    free(conn);
    return 0;
  }

  word = &pool.freecs[conn->cindex / 64];
  if (conn->cindex > MAX_CONNS)
    return -1;
  else if (BIT_IS_FREE(*word, conn->cindex))
    return 0;

  bindex = ptr_diff((uintptr_t)conn->ios, (uintptr_t)pool.bpool) / MP_BLOCK;
  nblocks = IOVEC_NBLOCKS;
  MP_free_blks(bindex, nblocks);

  bindex = ptr_diff((uintptr_t)conn->rec, (uintptr_t)pool.bpool) / MP_BLOCK;
  MP_free_blks(bindex, nblocks);

  if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
    close(conn->fd);

  MARK_BIT_FREE(*word, conn->cindex);
  memset(conn, 0, sizeof(conn_t));
  conn->fd = -1;
  conn->in_fd = -1;
  conn->out_fd = -1;
  return 0;
}

static inline void MP_clear(conn_t *conn) {
  conn_t *recv_conn = conn->recv_conn;
  conn_t *send_conn = conn->send_conn;
  if (recv_conn)
    MP_free(recv_conn);
  if (send_conn)
    MP_free(send_conn);
}

static inline void MP_exit(MPool *pool) {
  munmap(pool->bpool, pool->npages);
  free(pool->cpool);
  free(pool->blocks);
  free(pool->conns);
  free(pool->freebs);
  free(pool->freecs);
}

static inline void MP_timeout() {
  conn_t *conn;
  int16_t res;
  uint64_t now;
  size_t windex = 0;
  uint64_t *word = &pool.freecs[0];
  for (size_t i = 0; i < MAX_CONNS; i++) {
    if ((i / 64) < windex)
      word = &pool.freecs[++windex];

    if (*word == UINTMAX_MAX) {
      i = (i / 64) * 64 + 64;
      continue;
    }

    conn = pool.conns[i];
    if (!conn || conn->fd == -1)
      continue;

    res = pollevs(conn->fd);

    now = get_time();
    if (res & POLLERR) {
      MP_clear(conn);
      continue;
    }
    if (res & POLLIN) {
      if (pool.rtimeout > 0 && (now - conn->last_read) >= pool.rtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (res & POLLOUT) {
      if (pool.wtimeout > 0 && (now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (!(res & POLLIN || res & POLLOUT)) {
      if ((pool.rtimeout > 0 && now - conn->last_read) >= pool.rtimeout
          || (pool.wtimeout > 0 && now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
  }
}

/*
 * Calculate the length of a status string
 */
static inline size_t status_len(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return 8;
  case STATUSSWITCHINGPROTOCOLS:
    return 19;
  case STATUSPROCESSING:
    return 10;
  case STATUSEARLYHINTS:
    return 11;
  case STATUSOK:
    return 2;
  case STATUSCREATED:
    return 7;
  case STATUSACCEPTED:
    return 8;
  case STATUSNONAUTHORITATIVE:
    return 29;
  case STATUSNOCONTENT:
    return 10;
  case STATUSRESETCONTENT:
    return 13;
  case STATUSPARTIALCONTENT:
    return 15;
  case STATUSMULTISTATUS:
    return 12;
  case STATUSALREADYREPORTED:
    return 16;
  case STATUSIMUSED:
    return 7;
  case STATUSMULTIPLECHOICES:
    return 16;
  case STATUSMOVEDPERMANENTLY:
    return 17;
  case STATUSFOUND:
    return 5;
  case STATUSSEEOTHER:
    return 9;
  case STATUSNOTMODIFIED:
    return 12;
  case STATUSUSEPROXY:
    return 9;
  case STATUSTEMPORARYREDIRECT:
    return 18;
  case STATUSPERMANENTREDIRECT:
    return 18;
  case STATUSBADREQUEST:
    return 11;
  case STATUSUNAUTHORIZED:
    return 12;
  case STATUSPAYMENTREQUIRED:
    return 16;
  case STATUSFORBIDDEN:
    return 9;
  case STATUSNOTFOUND:
    return 9;
  case STATUSMETHODNOTALLOWED:
    return 18;
  case STATUSNOTACCEPTABLE:
    return 14;
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return 29;
  case STATUSREQUESTTIMEOUT:
    return 15;
  case STATUSCONFLICT:
    return 8;
  case STATUSGONE:
    return 4;
  case STATUSLENGTHREQUIRED:
    return 15;
  case STATUSPRECONDITIONFAILED:
    return 19;
  case CONTENTTOOLARGE:
    return 17;
  case STATUSURITOOLONG:
    return 12;
  case STATUSUNSUPPORTEDMEDIATYPE:
    return 22;
  case STATUSRANGENOTSATISFIABLE:
    return 21;
  case STATUSEXPECTATIONFAILED:
    return 18;
  case STATUSMISDIRECTEDREQUEST:
    return 19;
  case STATUSUNPROCESSABLECONTENT:
    return 21;
  case STATUSLOCKED:
    return 6;
  case STATUSFAILEDDEPENDENCY:
    return 17;
  case STATUSTOOEARLY:
    return 9;
  case STATUSUPGRADEREQUIRED:
    return 16;
  case STATUSPRECONDITIONREQUIRED:
    return 21;
  case STATUSTOOMANYREQUESTS:
    return 17;
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return 31;
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return 29;
  case STATUSInternalServerError:
    return 21;
  case STATUSNOTIMPLEMENTED:
    return 15;
  case STATUSBADGATEWAY:
    return 11;
  case STATUSSERVICEUNAVAILABLE:
    return 19;
  case STATUSGATEWAYTIMEOUT:
    return 15;
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return 26;
  case STATUSVARIANTALSONEGOTIATES:
    return 23;
  case STATUSINSUFFICIENTSTORAGE:
    return 20;
  case STATUSLOOPDETECTED:
    return 13;
  case STATUSNOTEXTENDED:
    return 12;
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return 31;
  default:
    return 0;
  }
}

/*
 * Return the status code string as string literal
 */
static inline char *status_str(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return "Continue";
  case STATUSSWITCHINGPROTOCOLS:
    return "Switching Protocols";
  case STATUSPROCESSING:
    return "Processing";
  case STATUSEARLYHINTS:
    return "Early Hints";
  case STATUSOK:
    return "OK";
  case STATUSCREATED:
    return "Created";
  case STATUSACCEPTED:
    return "Accepted";
  case STATUSNONAUTHORITATIVE:
    return "Non-Authoritative Information";
  case STATUSNOCONTENT:
    return "No Content";
  case STATUSRESETCONTENT:
    return "Reset Content";
  case STATUSPARTIALCONTENT:
    return "Partial Content";
  case STATUSMULTISTATUS:
    return "Multi-Status";
  case STATUSALREADYREPORTED:
    return "Already Reported";
  case STATUSIMUSED:
    return "Im Used";
  case STATUSMULTIPLECHOICES:
    return "Multiple Choices";
  case STATUSMOVEDPERMANENTLY:
    return "Moved Permanently";
  case STATUSFOUND:
    return "Found";
  case STATUSSEEOTHER:
    return "See Other";
  case STATUSNOTMODIFIED:
    return "Not Modified";
  case STATUSUSEPROXY:
    return "Use Proxy";
  case STATUSTEMPORARYREDIRECT:
    return "Temporary Redirect";
  case STATUSPERMANENTREDIRECT:
    return "Permanent Redirect";
  case STATUSBADREQUEST:
    return "Bad Request";
  case STATUSUNAUTHORIZED:
    return "Unauthorized";
  case STATUSPAYMENTREQUIRED:
    return "Payment Required";
  case STATUSFORBIDDEN:
    return "Forbidden";
  case STATUSNOTFOUND:
    return "Not Found";
  case STATUSMETHODNOTALLOWED:
    return "Method Not Allowed";
  case STATUSNOTACCEPTABLE:
    return "Not Acceptable";
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return "Proxy Authentication Required";
  case STATUSREQUESTTIMEOUT:
    return "Request Timeout";
  case STATUSCONFLICT:
    return "Conflict";
  case STATUSGONE:
    return "Gone";
  case STATUSLENGTHREQUIRED:
    return "Length Required";
  case STATUSPRECONDITIONFAILED:
    return "Precondition Failed";
  case CONTENTTOOLARGE:
    return "Content Too Large";
  case STATUSURITOOLONG:
    return "URI Too Long";
  case STATUSUNSUPPORTEDMEDIATYPE:
    return "Unsupported Media Type";
  case STATUSRANGENOTSATISFIABLE:
    return "Range Not Satisfiable";
  case STATUSEXPECTATIONFAILED:
    return "Expectation Failed";
  case STATUSMISDIRECTEDREQUEST:
    return "Misdirected Request";
  case STATUSUNPROCESSABLECONTENT:
    return "Unprocessable Content";
  case STATUSLOCKED:
    return "Locked";
  case STATUSFAILEDDEPENDENCY:
    return "Failed Dependency";
  case STATUSTOOEARLY:
    return "Too Early";
  case STATUSUPGRADEREQUIRED:
    return "Upgrade Required";
  case STATUSPRECONDITIONREQUIRED:
    return "Precondition Required";
  case STATUSTOOMANYREQUESTS:
    return "Too Many Requests";
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return "Request Header Fields Too Large";
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return "Unavailable For Legal Reasons";
  case STATUSInternalServerError:
    return "Internal Server Error";
  case STATUSNOTIMPLEMENTED:
    return "Not Implemented";
  case STATUSBADGATEWAY:
    return "Bad Gateway";
  case STATUSSERVICEUNAVAILABLE:
    return "Service Unavailable";
  case STATUSGATEWAYTIMEOUT:
    return "Gateway Timeout";
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return "HTTP Version Not Supported";
  case STATUSVARIANTALSONEGOTIATES:
    return "Variant Also Negotiates";
  case STATUSINSUFFICIENTSTORAGE:
    return "Insufficient Storage";
  case STATUSLOOPDETECTED:
    return "Loop Detected";
  case STATUSNOTEXTENDED:
    return "Not Extended";
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return "Network Authentication Required";
  default:
    return 0;
  }
}

/*
 * Return true if routes match
 */
static inline bool route_equ(Route *route, Request *req) {
  return route->method == req->method && strncmp(route->path, req->path, strlen(route->path)) == 0;
}

/*
 * Return the matching route index on success. -1 on failure
 */
static inline int match_route(Server *serv, Request *req) {
  for (size_t i = 0; i < serv->_nroutes; i++) {
    Route route = serv->routes[i];
    if (!req->path || !route.path)
      continue;
    if (route_equ(&route, req))
      return i;
    else if (req->method == HEAD && route.method == GET && strcmp(route.path, req->path) == 0)
      return i;
  }
  return -1;
}

/*
 * Return true if the response should contain the Content-Length header
 */
static inline bool should_have_content_length(Request *req, ResWriter *res) {
  return (req->method != CONNECT              // CONNECT request
          && res->status != STATUSNOCONTENT   // 204 response
          && res->status != STATUSNOTMODIFIED // 304 response
          && res->status >= 200);             // 1xx response
}

/*
 * Format http response from the ResWriter.
 * Return response size on success, 0 on failure.
 */
static inline size_t fmt_res(Request *req, ResWriter *res, char *buffer, size_t buffer_size) {
  if (!res || !buffer || buffer_size == 0)
    return 0;

  size_t res_len, total = 0;
  char *dst = buffer;
  size_t maxlen = buffer_size;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t body_length = res->len;

  res_len = snprintf(dst, maxlen, "HTTP/1.1 %d %s", (int)res->status, status_str(res->status));
  total += res_len;
  dst += res_len;
  maxlen -= res_len;

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    res_len = snprintf(dst, maxlen, "\r\n%s: %s", header->key, header->value);
    total += res_len;
    dst += res_len;
    maxlen -= res_len;
  }

  if (have_content_length) {
    res_len = snprintf(dst, maxlen, "\r\nContent-Length: %lu", body_length);
    total += res_len, dst += res_len, maxlen -= res_len;
  }

  memcpy(dst, "\r\n\r\n", 4);
  total += 4, dst += 4, maxlen -= 4;

  return total;
}

static inline size_t res_len(Request *req, ResWriter *res) {
  if (!req || !res)
    return 0;

  if (!res->status)
    res->status = STATUSOK;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t result = 0;
  result += STRLEN("HTTP/1.1 ");     // HTTP version
  result += 4;                       // Status code + space
  result += status_len(res->status); // Status name

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    result += 2;                       // "\r\n"
    result += strlen(header->key) + 2; // Header key + ':' + space
    result += strlen(header->value);   // header value
  }

  if (have_content_length) {
    result += 2;                          // "\r\n"
    result += STRLEN("Content-Length: "); // Header key
    result += countd(res->len);           // Header value
  }

  result += 4; // "\r\n\r\n"

  return result;
}

static inline int send_empty_res(Status status) {
  size_t res_len = STRLEN("HTTP/1.1 ")        // HTTP version
                   + countd((uint64_t)status) // status code
                   + 1                        // space
                   + (int)status_len(status)  // status string
                   + 4;                       // \r\n\r\n

  conn_t *conn = current_send;
  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, res_len);
  if (snprintf((char *)rec->iov_base, res_len + 1, "HTTP/1.1 %d %s\r\n\r\n", (int)status, status_str(status))
      != (int)res_len)
    return -1;

  return usendmsg(conn, 0, 1);
}

static inline ssize_t read_socket(int sockfd, size_t len) {
  if (len == 0 || sockfd <= 0)
    return 0;
  char buff[1024 * 8];
  return read(sockfd, buff, 1024 * 8);
}

static inline int read_method(Method *method, void *src) {
  if (memcmp(src, "GET", 3) == 0)
    *method = GET;
  else if (memcmp(src, "POST", 4) == 0)
    *method = POST;
  else if (memcmp(src, "HEAD", 4) == 0)
    *method = HEAD;
  else if (memcmp(src, "PUT", 3) == 0)
    *method = PUT;
  else if (memcmp(src, "DELETE", 6) == 0)
    *method = DELETE;
  else if (memcmp(src, "CONNECT", 7) == 0)
    *method = CONNECT;
  else if (memcmp(src, "OPTIONS", 7) == 0)
    *method = OPTIONS;
  else if (memcmp(src, "TRACE", 5) == 0)
    *method = TRACE;
  else if (memcmp(src, "PATCH", 5) == 0)
    *method = PATCH;
  else
    return -1;

  return 0;
}

static inline int sendmsg_res(Request *req, ResWriter *res) {
  conn_t *conn;
  size_t head_size, res_size;
  struct iovec *iov;

  conn = current_send;
  iov = &conn->ios[0];
  head_size = res_len(req, res);
  if (head_size == 0)
    return -1;

  conn->data_left += head_size;
  res_size = fmt_res(req, res, iov->iov_base, (head_size + 1));
  if (res_size != head_size)
    return -1;
  iov->iov_len = res_size;

  return usendmsg(conn, 0, conn->nios);
}

static inline int read_req(Request *req, char *req_buffer) {
  if (!req_buffer)
    return -1;
  /*** Method ***/
  char *sep = strchr(req_buffer, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }
  *sep = '\0';
  if (read_method(&req->method, req_buffer) < 0)
    return -1;

  /*** Path ***/
  char *fullpath = sep + 1;
  sep = strchr(fullpath, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }

  *sep = '\0';
  req->path = fullpath;
  /*** Params ***/
  char *paramStart = strchr(fullpath, '?');
  if (paramStart) {
    *paramStart++ = '\0';
    int params_count = 0;
    params_count = HK_parse_params(paramStart, req->params, MAX_URL_PARAMETERS);
    if (params_count > 0)
      req->params_count = params_count;
    else
      req->params_count = 0;
  } else {
    req->params = NULL;
    req->params_count = 0;
  }

  /*** Headers ***/
  char *headStart = strstr(sep + 1, "\r\n");
  char *headEnd = strstr(sep + 1, "\r\n\r\n");
  if (!headStart) {
    LOG("read_req: !headStart\n");
    return -1;
  };

  memset(headStart, 0, 2);
  headStart += 2;
  memset(headEnd, 0, 4);
  headEnd += 4;

  int headers_count = HK_parse_headers(headStart, req->headers, MAX_REQ_HEADERS);
  if (headers_count <= 0)
    return -1;
  req->headers_count = headers_count;

  /*** Host ***/
  int index = HK_get_header(req, "Host");
  if (index < 0)
    return -1;
  char *host = req->headers[index].value;
  req->hostname = host;

  /*** Port ***/
  char *colon = strchr(host, ':');
  if (colon) {
    *colon++ = '\0';
    req->port = atoi(colon);
  } else {
    req->port = PORT;
  }
  return 0;
}
static inline int process_req(Server *serv, conn_t *conn) {
  if (!conn || conn->fd == -1)
    return -1;

  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;
  if (read_req(&req, conn->ios[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    LOG("Err: route_index == -1\n");
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;
  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  sendmsg_res(&req, &res);

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int new_conn(int connfd) {
  if (connfd <= 0)
    return -1;

  current_recv = MP_use(KB * 2, connfd, false);
  current_send = MP_use(KB * 2, connfd, false);

  current_recv->recv_conn = current_recv;
  current_recv->send_conn = current_send;

  current_send->send_conn = current_send;
  current_send->recv_conn = current_recv;

  conn_t *conn = current_recv;
  if (ufrecvmsg(conn, 0, 1) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

static inline int resubmit_sendmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return usendmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int resubmir_recvmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    // FIXME the len should be increased
    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return urecvmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int handle_sendmsg_complete(conn_t *conn) {
  struct iovec *iov, *rec;

  MP_shed(conn, 1, conn->nios - 1);
  iov = &conn->ios[0];
  rec = &conn->rec[0];
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;

  return ufrecvmsg(conn->recv_conn, 0, 1);
}

static inline int handle_sendmsg(conn_t *conn, int res, bool zc) {
  if (!conn || conn->fd == -1)
    return -1;

  conn->data_left -= res;
  if (conn->data_left > 0)
    return resubmit_sendmsg(conn, res);

  if (zc)
    return 0;

  return handle_sendmsg_complete(conn);
}

static inline int handle_insplice(conn_t *conn) {
  conn->op = OUTSPLICE;
  return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
}
static inline int handle_outsplice(conn_t *conn, int res) {
  conn->data_left -= res;
  if (conn->data_left > 0) {
    conn->op = INSPLICE;
    return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
  }

  conn_t *recv_conn = conn->recv_conn;
  struct iovec *iov = &recv_conn->ios[0];
  memset(iov->iov_base, 0, iov->iov_len);
  if (urecv(recv_conn, iov->iov_base, iov->iov_len, MSG_PEEK) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

/*
static inline int handle_recv(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  void *bptr = conn->ios[0].iov_base;
  void *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  void *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  return process_req(serv, conn);
}
*/
static inline int find_route(Server *serv, char *bptr) {
  Request req = {0};
  if (read_method(&req.method, bptr) < 0) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  };
  char *space = strchr(bptr, ' ');
  req.path = (space + 1);
  space = strchr(req.path, ' ');
  *space = '\0';
  int route_index = match_route(serv, &req);
  *space = ' ';
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }
  return route_index;
}

static inline int run_handler(Server *serv, conn_t *conn, bool uses_body) {
  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;

  if (read_req(&req, conn->rec[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  if (uses_body) {
    int h_index = HK_get_header(&req, "Content-Length");
    long body_size = atol(req.headers[h_index].value);
    if (body_size >= 0) {
      req.body.ptr = conn->rec[1].iov_base;
      req.body.size = body_size;
    } else {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    }
  }

  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  if (sendmsg_res(&req, &res) < 0)
    return -1;

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int handle_frecvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  char *bptr = (char *)conn->ios[0].iov_base;
  char *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  char *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  size_t head_size = (headEnd + 4) - bptr;
  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  int route_index = find_route(serv, bptr);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  bool uses_body = serv->routes[route_index].uses_body;
  long body_size = get_content_length(headstart + 2, headEnd + 4);
  if (body_size == -1) {
    if (uses_body) {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    } else {
      body_size = 0;
    }
  }

  conn->head_size = head_size;
  if (!uses_body) {
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  if (res == (int)(head_size + body_size)) {
    size_t iov_index = MP_expand(conn, round_to_blocks(body_size), false);
    memcpy(conn->rec[iov_index].iov_base, headEnd + 4, body_size);
    conn->ios[iov_index].iov_len = body_size;
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  conn->data_left = body_size - (res - head_size);
  bool once = ((size_t)body_size > (size_t)((pool.nblocks * MP_BLOCK) / 10));
  size_t iov_index = MP_expand(conn, round_to_blocks(body_size), once);
  memcpy(conn->rec[iov_index].iov_base, headEnd + 4, (res - head_size));
  conn->ios[iov_index].iov_base += (res - head_size);

  return urecvmsg(conn, iov_index, 1);
}

static inline int handle_recvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  if (conn->data_left > 0) {
    conn->data_left -= res;
    if (conn->data_left == 0) {
      conn->flags &= CF_HANDLER_READY;
      return run_handler(serv, conn, true);
    }

    conn->flags &= ~CF_HANDLER_READY;
    conn->ios[1].iov_base += res;
    return urecvmsg(conn, 1, 1);
  }

  conn->flags &= CF_HANDLER_READY;
  return run_handler(serv, conn, true);
}

static inline int serv_init(Server *serv) {
#if DEBUG
  logfd = log_init("log.txt");
  if (!logfd) {
    printf("log_init failed");
    return -1;
  }
#endif
  serv->_nroutes = get_nroutes(serv->routes);

  int pipefd[2];
  if (pipe(pipefd) < 0)
    return -1;
  pipe_in = pipefd[0];
  pipe_out = pipefd[1];
  nullfd = open("/dev/null", O_WRONLY);
  pipe_sz = fcntl(pipefd[0], F_GETPIPE_SZ);
  if (pipe_sz < 0)
    return -1;

  pool.rtimeout = serv->rtimeout;
  pool.wtimeout = serv->wtimeout;
  if (MP_init(MAX_CONNS * 8) < 0)
    return -1;
  LOG("pool initialized\n");

  if (io_uring_queue_init(MAX_CONNS, &ring, 0) < 0)
    return -1;
  LOG("uring initialized\n");

  int listenfd;
  if ((listenfd = tcp_listen(serv->port)) < 0)
    return -1;
  LOG("socket initialized\n");

  return umaccept(listenfd);
}

static inline int serv_listen(Server *serv) {
  // uint64_t last_check = get_time();
  while (true) {
    // uint64_t now = get_time();
    // if ((now - last_check) >= 200) {
    //   last_check = now;
    //   LOG("CM: CM_check ran\n");
    //   MP_timeout();
    // }

    LOG("SQ ready: %u, CQ ready: %u\n", io_uring_sq_ready(&ring), io_uring_cq_ready(&ring));
    struct io_uring_cqe *cqe;
    if (io_uring_wait_cqe(&ring, &cqe) < 0)
      continue;

    int res = cqe->res;
    LOG("res = %d\n", res);
    conn_t *conn = NULL;
    if (cqe->user_data > 100) {
      conn = (conn_t *)cqe->user_data;
      current_recv = (conn_t *)conn->recv_conn;
      current_send = (conn_t *)conn->send_conn;
    }

    if (res > 0) {
      if (cqe->user_data == ACCEPT) {
        LOG("new conn created\n");
        new_conn(res);
      } else if (conn && conn->fd != -1) {
        LOG("conn[%d]: conn.fd = %d; conn.op = %d\n", conn->cindex, conn->fd, conn->op);
        switch (conn->op) {
        case FRECVMSG:
          if (handle_frecvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case RECVMSG:
          if (handle_recvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case SENDMSG:
        case SENDMSGZC:
          // conn->last_write = get_time();
          bool zc = (conn->op == SENDMSGZC);
          if (handle_sendmsg(conn, res, zc) < 0)
            MP_clear(conn);
          break;
        case INSPLICE:
          if (handle_insplice(conn) < 0)
            MP_clear(conn);
          break;
        case OUTSPLICE:
          if (handle_outsplice(conn, res) < 0)
            MP_clear(conn);
          break;
        }
      }
    } else if (res == 0) {
      if (conn && conn->fd != -1) {
        switch (conn->op) {
        case SENDMSGZC:
          conn->zc_notifs--;
          if (conn->zc_notifs == 0 && handle_sendmsg_complete(conn) < 0)
            MP_clear(conn);
          break;
        case RECV:
          MP_clear(conn);
          break;
        }
      }
    } else {
      if (conn && conn->fd != -1) {
        if (res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR) {
          LOG("conn && conn->fd != -1 && res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR\n");
          MP_clear(conn);
        } else {
          LOG("res == -EAGAIN || res == -EWOULDBLOCK || res == -EINTR\n");
          conn = conn->recv_conn;
          struct iovec *iov = &conn->ios[0];
          memset(iov->iov_base, 0, iov->iov_len);
          if (urecv(conn, iov->iov_base, iov->iov_len, 0) < 0)
            MP_clear(conn);
        }
      }
    }

    LOG("uring operation seen\n");
    io_uring_cqe_seen(&ring, cqe);
  }

  io_uring_queue_exit(&ring);
  MP_exit(&pool);
  return 0;
}

/*** Helper ***/
static inline int _HK_write(void *data, size_t size) {
  size_t nblocks;
  int iov_index;
  conn_t *conn;
  struct iovec *iov;
  bool once;

  conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  nblocks = round_to_blocks(size);
  iov_index = MP_expand(conn, nblocks, once);
  iov = &conn->ios[iov_index];

  memcpy(iov->iov_base, data, size);
  iov->iov_len = size;
  conn->data_left += size;

  return 0;
}
static inline int _HK_write_body(Request *req, size_t offset, size_t size) {
  if (size > req->body.size || offset > req->body.size)
    return -1;

  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  int iov_index = MP_expand(conn, 0, false);
  struct iovec *iov = &conn->ios[iov_index];
  struct iovec *rec = &conn->rec[iov_index];
  rec->iov_base = req->body.ptr + offset;
  rec->iov_len = size;
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;
  conn->data_left += rec->iov_len;
  return 0;
}
/*
static inline int _HK_mem(size_t size, HKMem *mem) {
  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  bool once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  size_t nblocks = round_to_blocks(size);
  int iov_index = MP_expand(conn, nblocks, once);
  struct iovec *iov = &conn->ios[iov_index];
  mem->ptr = iov->iov_base;
  mem->size = iov->iov_len;
  mem->_iov_index = iov_index;
  mem->_flags = (IN_POOL(iov->iov_base)) ? CF_IN_POOL : CF_IN_HEAP;
  return 0;
}

static inline void _HK_send(HKMem *mem, size_t size) {
  conn_t *conn = current_send;
  struct iovec *iov = &conn->ios[mem->_iov_index];
  iov->iov_len = size;
  conn->data_left += size;
}
  */
#endif#define _GNU_SOURCE
#ifndef UTILS_H
#define UTILS_H

#include "hunk.h"
#include <arpa/inet.h>
#include <fcntl.h>
#include <liburing.h>
#include <netdb.h>
#include <signal.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/poll.h>
#include <sys/prctl.h>
#include <sys/socket.h>
#include <sys/sysinfo.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

#define MP_BLOCK  4
#define MAX_CONNS 4096
#define KB        1024
#define NIOS      32

#define IN_POOL(ptr)                 ((void *)ptr >= pool.bpool && (void *)ptr <= (pool.bpool + (pool.npages * pool.pagesize)))
#define ALIGN_TO_PAGESIZE(buff_size) (((buff_size) + (pool.pagesize - 1)) & ~(pool.pagesize - 1))
#define BYTES_TO_BLOCKS(buff_size)   (((buff_size) + (MP_BLOCK - 1)) / MP_BLOCK)
#define CEIL_BLOCKS(nblocks)         ((nblocks + 63) & ~63)
#define CEIL_PAGES(size)             (((size) + ((pool.pagesize) - 1)) & ~((pool.pagesize) - 1))

#define BIT_IS_FREE(word, bit)   (((word) >> (bit)) & 1)
#define MARK_BIT_USED(word, bit) ((word) &= ~(1ULL << (bit)))
#define MARK_BIT_FREE(word, bit) ((word) |= (1ULL << (bit)))
#define FIND_FREE_BIT(word)      ((uint64_t)(word) & -(uint64_t)(word))
#define STRLEN(s)                (sizeof(s) - 1)

#define IOVEC_NBLOCKS (BYTES_TO_BLOCKS(NIOS * sizeof(struct iovec)))
#define MSG_NBLOCKS   (BYTES_TO_BLOCKS(sizeof(struct msghdr)))
#define ZC_RES        KB *KB

#define DEBUG 0
#if DEBUG
#define LOG(...) fprintf(logfd, __VA_ARGS__)
#else
#define LOG(...) ((void)0)
#endif

typedef enum UOP {
  WRITEV = IORING_OP_WRITEV,
  SENDMSG = IORING_OP_SENDMSG,
  RECVMSG = IORING_OP_RECVMSG,
  ACCEPT = IORING_OP_ACCEPT,
  SEND = IORING_OP_SEND,
  RECV = IORING_OP_RECV,
  SENDZC = IORING_OP_SEND_ZC,
  SENDMSGZC = IORING_OP_SENDMSG_ZC,
  PEEK = 50,
  FRECVMSG,
  INSPLICE,
  OUTSPLICE
} UOP;

typedef enum CFS {
  CF_IN_POOL = (1 << 0),       // Connection is in the pool
  CF_IN_HEAP = (1 << 1),       // Connection is in the heap
  CF_SKIP_SOCK = (1 << 2),     // Don't close the socket
  CF_USE_ONCE = (1 << 3),      // Destroy after using
  CF_HANDLER_READY = (1 << 4), // Ready to call the handler
} CFS;

typedef struct conn_t {
  // Socket file descriptor
  int fd;

  // Amount of data left in the current operation
  uint64_t data_left;

  // The index of the connection struct
  uint32_t cindex;

  // The last time the connection was readable
  uint64_t last_read;

  // The last time the connection was writeable
  uint64_t last_write;

  // The operation currently being processed
  uint8_t op;

  // Connection flags
  int flags;

  // Splice fd_in
  int in_fd;

  // Splice fd_out
  int out_fd;

  void *recv_conn;
  void *send_conn;

  struct iovec *ios;
  struct iovec *rec;
  uint16_t nios;

  struct msghdr *msg;
  uint16_t zc_notifs;

  uint16_t head_size;
} conn_t;

typedef struct MPool {
  // The allocated pool of blocks
  void *bpool;

  // The allocated pool of connections
  conn_t *cpool;

  // The size of the pool in pages
  uint32_t npages;

  // The size of the pool in blocks
  uint32_t nblocks;

  // The locations of each page in the pool
  void **blocks;

  // The availability of each block
  uint64_t *freebs;

  // The locations of each conn in the pool
  conn_t **conns;

  // The availability of each conn
  uint64_t *freecs;

  // Clean up callback function
  void (*callback)(conn_t *conn);

  // The page size used
  uint32_t pagesize;

  // Socket read timeout
  uint32_t rtimeout;

  // Socket write timeout
  uint32_t wtimeout;
} MPool;

extern int pipe_sz;
extern int pipe_in, pipe_out, nullfd;
extern FILE *logfd;
extern struct io_uring ring;
extern MPool pool;
extern conn_t *current_recv;
extern conn_t *current_send;

/*
 * Prepare and submit a recv uring op
 */
static inline int urecv(conn_t *conn, void *buffer, size_t buff_size, int flags) {
  if (!conn || conn->fd == -1)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (flags == MSG_PEEK) ? PEEK : RECV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;

  io_uring_prep_recv(sqe, conn->fd, buffer, buff_size, flags);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a multi-shot accept uring op
 */
static inline int umaccept(int listenfd) {
  if (listenfd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = ACCEPT;
  io_uring_prep_multishot_accept(sqe, listenfd, NULL, NULL, SOCK_NONBLOCK);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a splice uring op
 */
static inline int usplice(conn_t *conn, int fd_in, int64_t off_in, int fd_out, int64_t off_out, size_t len) {
  if (!len || !conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = (__u64)conn;
  io_uring_prep_splice(sqe, fd_in, off_in, fd_out, off_out, len, 0);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a writev uring op
 */
static inline int uwritev(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = WRITEV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  io_uring_prep_writev(sqe, conn->fd, &conn->ios[iov_index], nios, -1);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a send uring op
 */
static inline int usend(conn_t *conn, char *res_buff, size_t buff_size, bool zc) {
  if (!conn || conn->fd <= 0 || buff_size == 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (zc) ? SENDZC : SEND;
  conn->data_left = buff_size;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  if (zc)
    io_uring_prep_send_zc(sqe, conn->fd, res_buff, buff_size, 0, 0);
  else
    io_uring_prep_send(sqe, conn->fd, res_buff, buff_size, 0);
  return io_uring_submit(&ring);
}

static inline int ufrecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = FRECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;

  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, rec->iov_len);
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int urecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = RECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int usendmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  bool zc = (conn->data_left > ZC_RES) ? true : false;
  conn->op = (zc) ? SENDMSGZC : SENDMSG;

  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  if (zc) {
    io_uring_prep_sendmsg_zc(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
    conn->zc_notifs++;
  } else {
    io_uring_prep_sendmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  }
  return io_uring_submit(&ring);
}

/*
 * Create and initialize a server socket
 */
static inline int tcp_listen(uint16_t port) {
  int enable;
  int listenfd;
  if ((listenfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    return -1;

  int flags = fcntl(listenfd, F_GETFL, 0);
  fcntl(listenfd, F_SETFL, flags | O_NONBLOCK);
  struct sockaddr_in servaddr;
  memset(&servaddr, 0, sizeof(servaddr));
  servaddr.sin_family = AF_INET;
  servaddr.sin_addr.s_addr = INADDR_ANY;
  servaddr.sin_port = htons(port);

  enable = 1;
  if (setsockopt(listenfd, SOL_SOCKET, SO_REUSEPORT, &enable, sizeof(enable)) < 0)
    return -1;

  if (bind(listenfd, (struct sockaddr *)&servaddr, sizeof(servaddr)) < 0)
    return -1;

  if (listen(listenfd, SOMAXCONN) < 0)
    return -1;

  return listenfd;
}

/*
 * Calculate the difference between two pointers
 */
static inline uintptr_t ptr_diff(uintptr_t p1, uintptr_t p2) { return (uintptr_t)(p1 > p2) ? (p1 - p2) : (p2 - p1); }

static inline size_t get_nroutes(Route *routes) {
  Route *route;
  for (size_t i = 0;; i++) {
    route = &routes[i];
    if (!route->path && !route->handler && !route->method)
      return i;
  }
}

static inline long get_content_length(char *src, char *end) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return -1;
    key = line;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, "Content-Length") != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;

    *line_end = '\0';
    long res = atol(value);
    *line_end = '\r';

    return res;
  }
  return -1;
}

static inline bool have_header(char *src, char *end, const char *header_key, const char *header_value) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    key = line;
    while (*key == ' ')
      key++;
    while (*header_key == ' ')
      header_key++;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return false;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, header_key) != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;
    while (*header_value == ' ')
      header_value++;

    *line_end = '\0';
    bool res = (strcasecmp(value, header_value) == 0);
    *line_end = '\r';

    return res;
  }

  return false;
}

static inline const char *method_str(Method method) {
  switch (method) {
  case GET:
    return "GET";
    break;
  case HEAD:
    return "HEAD";
    break;
  case POST:
    return "POST";
    break;
  case PUT:
    return "PUT";
    break;
  case DELETE:
    return "DELETE";
    break;
  case CONNECT:
    return "CONNECT";
    break;
  case OPTIONS:
    return "OPTIONS";
    break;
  case TRACE:
    return "TRACE";
    break;
  case PATCH:
    return "PATCH";
    break;
  default:
    return NULL;
  }
}

static inline uint8_t method_len(Method method) {
  switch (method) {
  case GET:
    return 3;
    break;
  case HEAD:
    return 4;
    break;
  case POST:
    return 4;
    break;
  case PUT:
    return 3;
    break;
  case DELETE:
    return 6;
    break;
  case CONNECT:
    return 7;
    break;
  case OPTIONS:
    return 7;
    break;
  case TRACE:
    return 5;
    break;
  case PATCH:
    return 5;
    break;
  default:
    return 0;
  }
}

static inline size_t round_to_blocks(size_t size) {
  size_t nblocks = BYTES_TO_BLOCKS(size);
  nblocks = CEIL_BLOCKS(nblocks);
  return nblocks;
}

/*
 * Count the digits in unsigned 64-bit int
 */
static inline int countd(uint64_t num) {
  if (num < 10ULL)
    return 1;
  if (num < 100ULL)
    return 2;
  if (num < 1000ULL)
    return 3;
  if (num < 10000ULL)
    return 4;
  if (num < 100000ULL)
    return 5;
  if (num < 1000000ULL)
    return 6;
  if (num < 10000000ULL)
    return 7;
  if (num < 100000000ULL)
    return 8;
  if (num < 1000000000ULL)
    return 9;
  if (num < 10000000000ULL)
    return 10;
  if (num < 100000000000ULL)
    return 11;
  if (num < 1000000000000ULL)
    return 12;
  if (num < 10000000000000ULL)
    return 13;
  if (num < 100000000000000ULL)
    return 14;
  if (num < 1000000000000000ULL)
    return 15;
  if (num < 10000000000000000ULL)
    return 16;
  if (num < 100000000000000000ULL)
    return 17;
  if (num < 1000000000000000000ULL)
    return 18;
  if (num < 10000000000000000000ULL)
    return 19;
  return 20;
}

/*
 * Get the time elabsed in ms
 */
static inline uint64_t get_time() {
  struct timespec ts;
  clock_gettime(CLOCK_MONOTONIC, &ts);
  return (uint64_t)(ts.tv_sec) * 1000 + (ts.tv_nsec / 1000000);
}

static inline FILE *log_init(const char *path) {
  FILE *res = fopen(path, "a+");
  setvbuf(res, NULL, _IONBF, 0);
  return res;
}

static inline int16_t pollevs(int connfd) {
  struct pollfd pfd;
  pfd.fd = connfd;
  pfd.events = POLLIN | POLLOUT | POLLERR;
  int res = poll(&pfd, 1, 0);
  if (res < 0)
    return POLLERR;
  return pfd.revents;
}

// FIXME This needs to be updated
static inline conn_t *MP_use_once(size_t nblocks, int fd) {

  void *mem = malloc(sizeof(conn_t) + 8 + (IOVEC_NBLOCKS * MP_BLOCK));
  struct conn_t *conn = (conn_t *)mem;
  memset(conn, 0, sizeof(conn_t));
  conn->ios = mem + sizeof(conn_t) + 8;

  if (nblocks > 0) {
    struct iovec *iov = &conn->ios[conn->nios++];
    mem = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (mem == MAP_FAILED)
      return NULL;
    iov->iov_base = mem;
    iov->iov_len = ALIGN_TO_PAGESIZE(nblocks * MP_BLOCK);
  }

  conn->flags |= CF_IN_HEAP;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;

  return conn;
}

static inline int find_freec() {
  uint64_t *word;
  size_t map_size = (sizeof(uint64_t) * 8);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    word = &pool.freecs[i / map_size];

    if (*word == 0) { // All used
      i += (map_size - 1);
      continue;
    }

    i += __builtin_ctzll(*word);
    MARK_BIT_USED(*word, i);
    return i;
  }

  return -1;
}

static inline int MP_init(size_t npages) {
  if (!npages)
    return -1;

  /*** Setup ***/
  pool.npages = npages;
  pool.pagesize = sysconf(_SC_PAGESIZE);

  /*** Pool ***/
  pool.bpool = mmap(NULL, pool.npages * pool.pagesize, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  if (pool.bpool == MAP_FAILED)
    return -1;
  pool.nblocks = (pool.npages * pool.pagesize) / MP_BLOCK;

  /*** Blocks ***/
  pool.blocks = malloc(sizeof(void *) * pool.nblocks);
  if (!pool.blocks)
    return -1;
  for (size_t i = 0; i < pool.nblocks; i++)
    pool.blocks[i] = pool.bpool + (i * MP_BLOCK);

  /*** Freebs ***/
  // if (posix_memalign((void **)&pool.freebs, 64, bitmap_size * sizeof(uint64_t)) < 0)
  size_t bitmap_size = (pool.nblocks + 63) / 64;
  pool.freebs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freebs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freebs[i] = UINT64_MAX;

  /*** Cpool ***/
  pool.cpool = (conn_t *)malloc(sizeof(conn_t) * MAX_CONNS);
  if (!pool.cpool)
    return -1;

  /*** Conns ***/
  pool.conns = (conn_t **)malloc(sizeof(conn_t *) * MAX_CONNS);
  if (!pool.conns)
    return -1;
  size_t conn_size = sizeof(conn_t);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    pool.conns[i] = (conn_t *)((char *)pool.cpool + (i * conn_size));
    pool.conns[i]->fd = -1;
    pool.conns[i]->in_fd = -1;
    pool.conns[i]->out_fd = -1;
  }

  /*** Freecs ***/
  bitmap_size = (MAX_CONNS + 63) / 64;
  pool.freecs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freecs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freecs[i] = UINT64_MAX;

  return 0;
}

static inline int MP_use_blks(size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t max_start = pool.nblocks - nblocks;
  size_t full_chunks = (nblocks / 64) * 64;

  for (size_t i = 0, c = 0; i <= max_start; i++, c++) {
    bool free = true;

    for (size_t j = 0; j < full_chunks; j += 64) {
      size_t word_index = (i + j) / 64;
      if (pool.freebs[word_index] != UINT64_MAX) {
        free = false;
        i += 63;
        break;
      }
    }

    for (size_t j = full_chunks; j < nblocks; j++) {
      size_t bit_index = i + j;
      size_t word_index = bit_index / 64;
      size_t bit_in_word = bit_index % 64;

      if (!BIT_IS_FREE(pool.freebs[word_index], bit_in_word)) {
        free = false;
        i += j;
        break;
      }
    }

    if (free) {
      for (size_t j = 0; j < full_chunks; j += 64) {
        size_t word_index = (i + j) / 64;
        pool.freebs[word_index] = 0;
      }

      for (size_t j = full_chunks; j < nblocks; j++) {
        size_t bit_index = i + j;
        size_t word_index = bit_index / 64;
        size_t bit_in_word = bit_index % 64;

        MARK_BIT_USED(pool.freebs[word_index], bit_in_word);
      }

      return i;
    }
  }

  return -1;
}

static inline int MP_free_blks(size_t bindex, size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t full_chunks = (nblocks / 64) * 64;
  for (size_t i = 0; i < full_chunks; i += 64) {
    size_t word_index = (bindex + i) / 64;
    pool.freebs[word_index] = UINT64_MAX;
  }

  for (size_t i = full_chunks; i < nblocks; i++) {
    size_t bit_index = bindex + i;
    size_t word_index = bit_index / 64;
    size_t bit_in_word = bit_index % 64;

    MARK_BIT_FREE(pool.freebs[word_index], bit_in_word);
  }

  memset(pool.blocks[bindex], 0, nblocks * MP_BLOCK);
  return 0;
}

static inline conn_t *MP_use(size_t nblocks, int fd, bool once) {
  if (fd <= 0)
    return NULL;
  if (once)
    return MP_use_once(nblocks, fd);

  int cindex = find_freec();
  if (cindex < 0) {
    LOG("Err: cindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  conn_t *conn = pool.conns[cindex];

  int ios_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (ios_bindex < 0) {
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }

  struct iovec *ios = pool.blocks[ios_bindex];
  conn->ios = ios;

  int rec_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (rec_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct iovec *rec = pool.blocks[rec_bindex];
  conn->rec = rec;

  int msg_bindex = MP_use_blks(MSG_NBLOCKS);
  if (msg_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct msghdr *msg = pool.blocks[msg_bindex];
  conn->msg = msg;

  if (nblocks > 0) {
    int bindex = MP_use_blks(nblocks);
    if (bindex < 0) {
      MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
      MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
      MP_free_blks(msg_bindex, IOVEC_NBLOCKS);
      MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
      LOG("Err: bindex < 0; will use MP_use_once\n");
      return MP_use_once(nblocks, fd);
    }

    size_t iov_index = conn->nios++;
    struct iovec *iov = &conn->ios[iov_index];
    struct iovec *rec = &conn->rec[iov_index];
    iov->iov_base = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
  }

  conn->msg->msg_iov = conn->ios;
  conn->msg->msg_iovlen = conn->nios;
  conn->cindex = cindex;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;
  return conn;
}

static inline void MP_shed(conn_t *conn, size_t iov_index, size_t nios) {
  struct iovec *iov, *rec;
  size_t bindex, nblocks, index;

  for (size_t i = 0; i < nios; i++) {
    index = iov_index + i;
    iov = &conn->ios[index];
    rec = &conn->rec[index];
    if (!rec || !rec->iov_base)
      continue;
    if (!IN_POOL(rec->iov_base)) {
      munmap(rec->iov_base, rec->iov_len / pool.pagesize);
    } else {
      bindex = ptr_diff((uintptr_t)rec->iov_base, (uintptr_t)pool.bpool) / MP_BLOCK;
      nblocks = rec->iov_len / MP_BLOCK;
      MP_free_blks(bindex, nblocks);
    }
    memset(iov, 0, sizeof(struct iovec));
    memset(rec, 0, sizeof(struct iovec));
    conn->nios--;
  }
}

static inline int MP_expand(conn_t *conn, size_t nblocks, bool once) {
  void *bptr;
  int iov_index, bindex;
  struct iovec *iov, *rec;

  iov_index = conn->nios++;
  iov = &conn->ios[iov_index];
  rec = &conn->rec[iov_index];

  if (nblocks == 0)
    return iov_index;

  if (once) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_base = bptr;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
    return iov_index;
  }

  bindex = MP_use_blks(nblocks);
  if (bindex < 0) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_len = iov->iov_len;
  } else {
    bptr = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_len = iov->iov_len;
  }

  iov->iov_base = bptr;
  rec->iov_base = iov->iov_base;
  return iov_index;
}

static inline int MP_free(conn_t *conn) {
  if (!conn)
    return -1;
  size_t bindex, nblocks;
  uint64_t *word;

  MP_shed(conn, 0, conn->nios);
  if (conn->flags & CF_IN_HEAP) {
    if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
      close(conn->fd);
    free(conn);
    return 0;
  }

  word = &pool.freecs[conn->cindex / 64];
  if (conn->cindex > MAX_CONNS)
    return -1;
  else if (BIT_IS_FREE(*word, conn->cindex))
    return 0;

  bindex = ptr_diff((uintptr_t)conn->ios, (uintptr_t)pool.bpool) / MP_BLOCK;
  nblocks = IOVEC_NBLOCKS;
  MP_free_blks(bindex, nblocks);

  bindex = ptr_diff((uintptr_t)conn->rec, (uintptr_t)pool.bpool) / MP_BLOCK;
  MP_free_blks(bindex, nblocks);

  if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
    close(conn->fd);

  MARK_BIT_FREE(*word, conn->cindex);
  memset(conn, 0, sizeof(conn_t));
  conn->fd = -1;
  conn->in_fd = -1;
  conn->out_fd = -1;
  return 0;
}

static inline void MP_clear(conn_t *conn) {
  conn_t *recv_conn = conn->recv_conn;
  conn_t *send_conn = conn->send_conn;
  if (recv_conn)
    MP_free(recv_conn);
  if (send_conn)
    MP_free(send_conn);
}

static inline void MP_exit(MPool *pool) {
  munmap(pool->bpool, pool->npages);
  free(pool->cpool);
  free(pool->blocks);
  free(pool->conns);
  free(pool->freebs);
  free(pool->freecs);
}

static inline void MP_timeout() {
  conn_t *conn;
  int16_t res;
  uint64_t now;
  size_t windex = 0;
  uint64_t *word = &pool.freecs[0];
  for (size_t i = 0; i < MAX_CONNS; i++) {
    if ((i / 64) < windex)
      word = &pool.freecs[++windex];

    if (*word == UINTMAX_MAX) {
      i = (i / 64) * 64 + 64;
      continue;
    }

    conn = pool.conns[i];
    if (!conn || conn->fd == -1)
      continue;

    res = pollevs(conn->fd);

    now = get_time();
    if (res & POLLERR) {
      MP_clear(conn);
      continue;
    }
    if (res & POLLIN) {
      if (pool.rtimeout > 0 && (now - conn->last_read) >= pool.rtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (res & POLLOUT) {
      if (pool.wtimeout > 0 && (now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (!(res & POLLIN || res & POLLOUT)) {
      if ((pool.rtimeout > 0 && now - conn->last_read) >= pool.rtimeout
          || (pool.wtimeout > 0 && now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
  }
}

/*
 * Calculate the length of a status string
 */
static inline size_t status_len(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return 8;
  case STATUSSWITCHINGPROTOCOLS:
    return 19;
  case STATUSPROCESSING:
    return 10;
  case STATUSEARLYHINTS:
    return 11;
  case STATUSOK:
    return 2;
  case STATUSCREATED:
    return 7;
  case STATUSACCEPTED:
    return 8;
  case STATUSNONAUTHORITATIVE:
    return 29;
  case STATUSNOCONTENT:
    return 10;
  case STATUSRESETCONTENT:
    return 13;
  case STATUSPARTIALCONTENT:
    return 15;
  case STATUSMULTISTATUS:
    return 12;
  case STATUSALREADYREPORTED:
    return 16;
  case STATUSIMUSED:
    return 7;
  case STATUSMULTIPLECHOICES:
    return 16;
  case STATUSMOVEDPERMANENTLY:
    return 17;
  case STATUSFOUND:
    return 5;
  case STATUSSEEOTHER:
    return 9;
  case STATUSNOTMODIFIED:
    return 12;
  case STATUSUSEPROXY:
    return 9;
  case STATUSTEMPORARYREDIRECT:
    return 18;
  case STATUSPERMANENTREDIRECT:
    return 18;
  case STATUSBADREQUEST:
    return 11;
  case STATUSUNAUTHORIZED:
    return 12;
  case STATUSPAYMENTREQUIRED:
    return 16;
  case STATUSFORBIDDEN:
    return 9;
  case STATUSNOTFOUND:
    return 9;
  case STATUSMETHODNOTALLOWED:
    return 18;
  case STATUSNOTACCEPTABLE:
    return 14;
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return 29;
  case STATUSREQUESTTIMEOUT:
    return 15;
  case STATUSCONFLICT:
    return 8;
  case STATUSGONE:
    return 4;
  case STATUSLENGTHREQUIRED:
    return 15;
  case STATUSPRECONDITIONFAILED:
    return 19;
  case CONTENTTOOLARGE:
    return 17;
  case STATUSURITOOLONG:
    return 12;
  case STATUSUNSUPPORTEDMEDIATYPE:
    return 22;
  case STATUSRANGENOTSATISFIABLE:
    return 21;
  case STATUSEXPECTATIONFAILED:
    return 18;
  case STATUSMISDIRECTEDREQUEST:
    return 19;
  case STATUSUNPROCESSABLECONTENT:
    return 21;
  case STATUSLOCKED:
    return 6;
  case STATUSFAILEDDEPENDENCY:
    return 17;
  case STATUSTOOEARLY:
    return 9;
  case STATUSUPGRADEREQUIRED:
    return 16;
  case STATUSPRECONDITIONREQUIRED:
    return 21;
  case STATUSTOOMANYREQUESTS:
    return 17;
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return 31;
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return 29;
  case STATUSInternalServerError:
    return 21;
  case STATUSNOTIMPLEMENTED:
    return 15;
  case STATUSBADGATEWAY:
    return 11;
  case STATUSSERVICEUNAVAILABLE:
    return 19;
  case STATUSGATEWAYTIMEOUT:
    return 15;
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return 26;
  case STATUSVARIANTALSONEGOTIATES:
    return 23;
  case STATUSINSUFFICIENTSTORAGE:
    return 20;
  case STATUSLOOPDETECTED:
    return 13;
  case STATUSNOTEXTENDED:
    return 12;
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return 31;
  default:
    return 0;
  }
}

/*
 * Return the status code string as string literal
 */
static inline char *status_str(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return "Continue";
  case STATUSSWITCHINGPROTOCOLS:
    return "Switching Protocols";
  case STATUSPROCESSING:
    return "Processing";
  case STATUSEARLYHINTS:
    return "Early Hints";
  case STATUSOK:
    return "OK";
  case STATUSCREATED:
    return "Created";
  case STATUSACCEPTED:
    return "Accepted";
  case STATUSNONAUTHORITATIVE:
    return "Non-Authoritative Information";
  case STATUSNOCONTENT:
    return "No Content";
  case STATUSRESETCONTENT:
    return "Reset Content";
  case STATUSPARTIALCONTENT:
    return "Partial Content";
  case STATUSMULTISTATUS:
    return "Multi-Status";
  case STATUSALREADYREPORTED:
    return "Already Reported";
  case STATUSIMUSED:
    return "Im Used";
  case STATUSMULTIPLECHOICES:
    return "Multiple Choices";
  case STATUSMOVEDPERMANENTLY:
    return "Moved Permanently";
  case STATUSFOUND:
    return "Found";
  case STATUSSEEOTHER:
    return "See Other";
  case STATUSNOTMODIFIED:
    return "Not Modified";
  case STATUSUSEPROXY:
    return "Use Proxy";
  case STATUSTEMPORARYREDIRECT:
    return "Temporary Redirect";
  case STATUSPERMANENTREDIRECT:
    return "Permanent Redirect";
  case STATUSBADREQUEST:
    return "Bad Request";
  case STATUSUNAUTHORIZED:
    return "Unauthorized";
  case STATUSPAYMENTREQUIRED:
    return "Payment Required";
  case STATUSFORBIDDEN:
    return "Forbidden";
  case STATUSNOTFOUND:
    return "Not Found";
  case STATUSMETHODNOTALLOWED:
    return "Method Not Allowed";
  case STATUSNOTACCEPTABLE:
    return "Not Acceptable";
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return "Proxy Authentication Required";
  case STATUSREQUESTTIMEOUT:
    return "Request Timeout";
  case STATUSCONFLICT:
    return "Conflict";
  case STATUSGONE:
    return "Gone";
  case STATUSLENGTHREQUIRED:
    return "Length Required";
  case STATUSPRECONDITIONFAILED:
    return "Precondition Failed";
  case CONTENTTOOLARGE:
    return "Content Too Large";
  case STATUSURITOOLONG:
    return "URI Too Long";
  case STATUSUNSUPPORTEDMEDIATYPE:
    return "Unsupported Media Type";
  case STATUSRANGENOTSATISFIABLE:
    return "Range Not Satisfiable";
  case STATUSEXPECTATIONFAILED:
    return "Expectation Failed";
  case STATUSMISDIRECTEDREQUEST:
    return "Misdirected Request";
  case STATUSUNPROCESSABLECONTENT:
    return "Unprocessable Content";
  case STATUSLOCKED:
    return "Locked";
  case STATUSFAILEDDEPENDENCY:
    return "Failed Dependency";
  case STATUSTOOEARLY:
    return "Too Early";
  case STATUSUPGRADEREQUIRED:
    return "Upgrade Required";
  case STATUSPRECONDITIONREQUIRED:
    return "Precondition Required";
  case STATUSTOOMANYREQUESTS:
    return "Too Many Requests";
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return "Request Header Fields Too Large";
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return "Unavailable For Legal Reasons";
  case STATUSInternalServerError:
    return "Internal Server Error";
  case STATUSNOTIMPLEMENTED:
    return "Not Implemented";
  case STATUSBADGATEWAY:
    return "Bad Gateway";
  case STATUSSERVICEUNAVAILABLE:
    return "Service Unavailable";
  case STATUSGATEWAYTIMEOUT:
    return "Gateway Timeout";
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return "HTTP Version Not Supported";
  case STATUSVARIANTALSONEGOTIATES:
    return "Variant Also Negotiates";
  case STATUSINSUFFICIENTSTORAGE:
    return "Insufficient Storage";
  case STATUSLOOPDETECTED:
    return "Loop Detected";
  case STATUSNOTEXTENDED:
    return "Not Extended";
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return "Network Authentication Required";
  default:
    return 0;
  }
}

/*
 * Return true if routes match
 */
static inline bool route_equ(Route *route, Request *req) {
  return route->method == req->method && strncmp(route->path, req->path, strlen(route->path)) == 0;
}

/*
 * Return the matching route index on success. -1 on failure
 */
static inline int match_route(Server *serv, Request *req) {
  for (size_t i = 0; i < serv->_nroutes; i++) {
    Route route = serv->routes[i];
    if (!req->path || !route.path)
      continue;
    if (route_equ(&route, req))
      return i;
    else if (req->method == HEAD && route.method == GET && strcmp(route.path, req->path) == 0)
      return i;
  }
  return -1;
}

/*
 * Return true if the response should contain the Content-Length header
 */
static inline bool should_have_content_length(Request *req, ResWriter *res) {
  return (req->method != CONNECT              // CONNECT request
          && res->status != STATUSNOCONTENT   // 204 response
          && res->status != STATUSNOTMODIFIED // 304 response
          && res->status >= 200);             // 1xx response
}

/*
 * Format http response from the ResWriter.
 * Return response size on success, 0 on failure.
 */
static inline size_t fmt_res(Request *req, ResWriter *res, char *buffer, size_t buffer_size) {
  if (!res || !buffer || buffer_size == 0)
    return 0;

  size_t res_len, total = 0;
  char *dst = buffer;
  size_t maxlen = buffer_size;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t body_length = res->len;

  res_len = snprintf(dst, maxlen, "HTTP/1.1 %d %s", (int)res->status, status_str(res->status));
  total += res_len;
  dst += res_len;
  maxlen -= res_len;

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    res_len = snprintf(dst, maxlen, "\r\n%s: %s", header->key, header->value);
    total += res_len;
    dst += res_len;
    maxlen -= res_len;
  }

  if (have_content_length) {
    res_len = snprintf(dst, maxlen, "\r\nContent-Length: %lu", body_length);
    total += res_len, dst += res_len, maxlen -= res_len;
  }

  memcpy(dst, "\r\n\r\n", 4);
  total += 4, dst += 4, maxlen -= 4;

  return total;
}

static inline size_t res_len(Request *req, ResWriter *res) {
  if (!req || !res)
    return 0;

  if (!res->status)
    res->status = STATUSOK;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t result = 0;
  result += STRLEN("HTTP/1.1 ");     // HTTP version
  result += 4;                       // Status code + space
  result += status_len(res->status); // Status name

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    result += 2;                       // "\r\n"
    result += strlen(header->key) + 2; // Header key + ':' + space
    result += strlen(header->value);   // header value
  }

  if (have_content_length) {
    result += 2;                          // "\r\n"
    result += STRLEN("Content-Length: "); // Header key
    result += countd(res->len);           // Header value
  }

  result += 4; // "\r\n\r\n"

  return result;
}

static inline int send_empty_res(Status status) {
  size_t res_len = STRLEN("HTTP/1.1 ")        // HTTP version
                   + countd((uint64_t)status) // status code
                   + 1                        // space
                   + (int)status_len(status)  // status string
                   + 4;                       // \r\n\r\n

  conn_t *conn = current_send;
  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, res_len);
  if (snprintf((char *)rec->iov_base, res_len + 1, "HTTP/1.1 %d %s\r\n\r\n", (int)status, status_str(status))
      != (int)res_len)
    return -1;

  return usendmsg(conn, 0, 1);
}

static inline ssize_t read_socket(int sockfd, size_t len) {
  if (len == 0 || sockfd <= 0)
    return 0;
  char buff[1024 * 8];
  return read(sockfd, buff, 1024 * 8);
}

static inline int read_method(Method *method, void *src) {
  if (memcmp(src, "GET", 3) == 0)
    *method = GET;
  else if (memcmp(src, "POST", 4) == 0)
    *method = POST;
  else if (memcmp(src, "HEAD", 4) == 0)
    *method = HEAD;
  else if (memcmp(src, "PUT", 3) == 0)
    *method = PUT;
  else if (memcmp(src, "DELETE", 6) == 0)
    *method = DELETE;
  else if (memcmp(src, "CONNECT", 7) == 0)
    *method = CONNECT;
  else if (memcmp(src, "OPTIONS", 7) == 0)
    *method = OPTIONS;
  else if (memcmp(src, "TRACE", 5) == 0)
    *method = TRACE;
  else if (memcmp(src, "PATCH", 5) == 0)
    *method = PATCH;
  else
    return -1;

  return 0;
}

static inline int sendmsg_res(Request *req, ResWriter *res) {
  conn_t *conn;
  size_t head_size, res_size;
  struct iovec *iov;

  conn = current_send;
  iov = &conn->ios[0];
  head_size = res_len(req, res);
  if (head_size == 0)
    return -1;

  conn->data_left += head_size;
  res_size = fmt_res(req, res, iov->iov_base, (head_size + 1));
  if (res_size != head_size)
    return -1;
  iov->iov_len = res_size;

  return usendmsg(conn, 0, conn->nios);
}

static inline int read_req(Request *req, char *req_buffer) {
  if (!req_buffer)
    return -1;
  /*** Method ***/
  char *sep = strchr(req_buffer, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }
  *sep = '\0';
  if (read_method(&req->method, req_buffer) < 0)
    return -1;

  /*** Path ***/
  char *fullpath = sep + 1;
  sep = strchr(fullpath, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }

  *sep = '\0';
  req->path = fullpath;
  /*** Params ***/
  char *paramStart = strchr(fullpath, '?');
  if (paramStart) {
    *paramStart++ = '\0';
    int params_count = 0;
    params_count = HK_parse_params(paramStart, req->params, MAX_URL_PARAMETERS);
    if (params_count > 0)
      req->params_count = params_count;
    else
      req->params_count = 0;
  } else {
    req->params = NULL;
    req->params_count = 0;
  }

  /*** Headers ***/
  char *headStart = strstr(sep + 1, "\r\n");
  char *headEnd = strstr(sep + 1, "\r\n\r\n");
  if (!headStart) {
    LOG("read_req: !headStart\n");
    return -1;
  };

  memset(headStart, 0, 2);
  headStart += 2;
  memset(headEnd, 0, 4);
  headEnd += 4;

  int headers_count = HK_parse_headers(headStart, req->headers, MAX_REQ_HEADERS);
  if (headers_count <= 0)
    return -1;
  req->headers_count = headers_count;

  /*** Host ***/
  int index = HK_get_header(req, "Host");
  if (index < 0)
    return -1;
  char *host = req->headers[index].value;
  req->hostname = host;

  /*** Port ***/
  char *colon = strchr(host, ':');
  if (colon) {
    *colon++ = '\0';
    req->port = atoi(colon);
  } else {
    req->port = PORT;
  }
  return 0;
}
static inline int process_req(Server *serv, conn_t *conn) {
  if (!conn || conn->fd == -1)
    return -1;

  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;
  if (read_req(&req, conn->ios[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    LOG("Err: route_index == -1\n");
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;
  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  sendmsg_res(&req, &res);

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int new_conn(int connfd) {
  if (connfd <= 0)
    return -1;

  current_recv = MP_use(KB * 2, connfd, false);
  current_send = MP_use(KB * 2, connfd, false);

  current_recv->recv_conn = current_recv;
  current_recv->send_conn = current_send;

  current_send->send_conn = current_send;
  current_send->recv_conn = current_recv;

  conn_t *conn = current_recv;
  if (ufrecvmsg(conn, 0, 1) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

static inline int resubmit_sendmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return usendmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int resubmir_recvmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    // FIXME the len should be increased
    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return urecvmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int handle_sendmsg_complete(conn_t *conn) {
  struct iovec *iov, *rec;

  MP_shed(conn, 1, conn->nios - 1);
  iov = &conn->ios[0];
  rec = &conn->rec[0];
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;

  return ufrecvmsg(conn->recv_conn, 0, 1);
}

static inline int handle_sendmsg(conn_t *conn, int res, bool zc) {
  if (!conn || conn->fd == -1)
    return -1;

  conn->data_left -= res;
  if (conn->data_left > 0)
    return resubmit_sendmsg(conn, res);

  if (zc)
    return 0;

  return handle_sendmsg_complete(conn);
}

static inline int handle_insplice(conn_t *conn) {
  conn->op = OUTSPLICE;
  return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
}
static inline int handle_outsplice(conn_t *conn, int res) {
  conn->data_left -= res;
  if (conn->data_left > 0) {
    conn->op = INSPLICE;
    return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
  }

  conn_t *recv_conn = conn->recv_conn;
  struct iovec *iov = &recv_conn->ios[0];
  memset(iov->iov_base, 0, iov->iov_len);
  if (urecv(recv_conn, iov->iov_base, iov->iov_len, MSG_PEEK) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

/*
static inline int handle_recv(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  void *bptr = conn->ios[0].iov_base;
  void *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  void *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  return process_req(serv, conn);
}
*/
static inline int find_route(Server *serv, char *bptr) {
  Request req = {0};
  if (read_method(&req.method, bptr) < 0) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  };
  char *space = strchr(bptr, ' ');
  req.path = (space + 1);
  space = strchr(req.path, ' ');
  *space = '\0';
  int route_index = match_route(serv, &req);
  *space = ' ';
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }
  return route_index;
}

static inline int run_handler(Server *serv, conn_t *conn, bool uses_body) {
  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;

  if (read_req(&req, conn->rec[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  if (uses_body) {
    int h_index = HK_get_header(&req, "Content-Length");
    long body_size = atol(req.headers[h_index].value);
    if (body_size >= 0) {
      req.body.ptr = conn->rec[1].iov_base;
      req.body.size = body_size;
    } else {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    }
  }

  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  if (sendmsg_res(&req, &res) < 0)
    return -1;

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int handle_frecvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  char *bptr = (char *)conn->ios[0].iov_base;
  char *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  char *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  size_t head_size = (headEnd + 4) - bptr;
  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  int route_index = find_route(serv, bptr);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  bool uses_body = serv->routes[route_index].uses_body;
  long body_size = get_content_length(headstart + 2, headEnd + 4);
  if (body_size == -1) {
    if (uses_body) {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    } else {
      body_size = 0;
    }
  }

  conn->head_size = head_size;
  if (!uses_body) {
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  if (res == (int)(head_size + body_size)) {
    size_t iov_index = MP_expand(conn, round_to_blocks(body_size), false);
    memcpy(conn->rec[iov_index].iov_base, headEnd + 4, body_size);
    conn->ios[iov_index].iov_len = body_size;
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  conn->data_left = body_size - (res - head_size);
  bool once = ((size_t)body_size > (size_t)((pool.nblocks * MP_BLOCK) / 10));
  size_t iov_index = MP_expand(conn, round_to_blocks(body_size), once);
  memcpy(conn->rec[iov_index].iov_base, headEnd + 4, (res - head_size));
  conn->ios[iov_index].iov_base += (res - head_size);

  return urecvmsg(conn, iov_index, 1);
}

static inline int handle_recvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  if (conn->data_left > 0) {
    conn->data_left -= res;
    if (conn->data_left == 0) {
      conn->flags &= CF_HANDLER_READY;
      return run_handler(serv, conn, true);
    }

    conn->flags &= ~CF_HANDLER_READY;
    conn->ios[1].iov_base += res;
    return urecvmsg(conn, 1, 1);
  }

  conn->flags &= CF_HANDLER_READY;
  return run_handler(serv, conn, true);
}

static inline int serv_init(Server *serv) {
#if DEBUG
  logfd = log_init("log.txt");
  if (!logfd) {
    printf("log_init failed");
    return -1;
  }
#endif
  serv->_nroutes = get_nroutes(serv->routes);

  int pipefd[2];
  if (pipe(pipefd) < 0)
    return -1;
  pipe_in = pipefd[0];
  pipe_out = pipefd[1];
  nullfd = open("/dev/null", O_WRONLY);
  pipe_sz = fcntl(pipefd[0], F_GETPIPE_SZ);
  if (pipe_sz < 0)
    return -1;

  pool.rtimeout = serv->rtimeout;
  pool.wtimeout = serv->wtimeout;
  if (MP_init(MAX_CONNS * 8) < 0)
    return -1;
  LOG("pool initialized\n");

  if (io_uring_queue_init(MAX_CONNS, &ring, 0) < 0)
    return -1;
  LOG("uring initialized\n");

  int listenfd;
  if ((listenfd = tcp_listen(serv->port)) < 0)
    return -1;
  LOG("socket initialized\n");

  return umaccept(listenfd);
}

static inline int serv_listen(Server *serv) {
  // uint64_t last_check = get_time();
  while (true) {
    // uint64_t now = get_time();
    // if ((now - last_check) >= 200) {
    //   last_check = now;
    //   LOG("CM: CM_check ran\n");
    //   MP_timeout();
    // }

    LOG("SQ ready: %u, CQ ready: %u\n", io_uring_sq_ready(&ring), io_uring_cq_ready(&ring));
    struct io_uring_cqe *cqe;
    if (io_uring_wait_cqe(&ring, &cqe) < 0)
      continue;

    int res = cqe->res;
    LOG("res = %d\n", res);
    conn_t *conn = NULL;
    if (cqe->user_data > 100) {
      conn = (conn_t *)cqe->user_data;
      current_recv = (conn_t *)conn->recv_conn;
      current_send = (conn_t *)conn->send_conn;
    }

    if (res > 0) {
      if (cqe->user_data == ACCEPT) {
        LOG("new conn created\n");
        new_conn(res);
      } else if (conn && conn->fd != -1) {
        LOG("conn[%d]: conn.fd = %d; conn.op = %d\n", conn->cindex, conn->fd, conn->op);
        switch (conn->op) {
        case FRECVMSG:
          if (handle_frecvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case RECVMSG:
          if (handle_recvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case SENDMSG:
        case SENDMSGZC:
          // conn->last_write = get_time();
          bool zc = (conn->op == SENDMSGZC);
          if (handle_sendmsg(conn, res, zc) < 0)
            MP_clear(conn);
          break;
        case INSPLICE:
          if (handle_insplice(conn) < 0)
            MP_clear(conn);
          break;
        case OUTSPLICE:
          if (handle_outsplice(conn, res) < 0)
            MP_clear(conn);
          break;
        }
      }
    } else if (res == 0) {
      if (conn && conn->fd != -1) {
        switch (conn->op) {
        case SENDMSGZC:
          conn->zc_notifs--;
          if (conn->zc_notifs == 0 && handle_sendmsg_complete(conn) < 0)
            MP_clear(conn);
          break;
        case RECV:
          MP_clear(conn);
          break;
        }
      }
    } else {
      if (conn && conn->fd != -1) {
        if (res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR) {
          LOG("conn && conn->fd != -1 && res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR\n");
          MP_clear(conn);
        } else {
          LOG("res == -EAGAIN || res == -EWOULDBLOCK || res == -EINTR\n");
          conn = conn->recv_conn;
          struct iovec *iov = &conn->ios[0];
          memset(iov->iov_base, 0, iov->iov_len);
          if (urecv(conn, iov->iov_base, iov->iov_len, 0) < 0)
            MP_clear(conn);
        }
      }
    }

    LOG("uring operation seen\n");
    io_uring_cqe_seen(&ring, cqe);
  }

  io_uring_queue_exit(&ring);
  MP_exit(&pool);
  return 0;
}

/*** Helper ***/
static inline int _HK_write(void *data, size_t size) {
  size_t nblocks;
  int iov_index;
  conn_t *conn;
  struct iovec *iov;
  bool once;

  conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  nblocks = round_to_blocks(size);
  iov_index = MP_expand(conn, nblocks, once);
  iov = &conn->ios[iov_index];

  memcpy(iov->iov_base, data, size);
  iov->iov_len = size;
  conn->data_left += size;

  return 0;
}
static inline int _HK_write_body(Request *req, size_t offset, size_t size) {
  if (size > req->body.size || offset > req->body.size)
    return -1;

  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  int iov_index = MP_expand(conn, 0, false);
  struct iovec *iov = &conn->ios[iov_index];
  struct iovec *rec = &conn->rec[iov_index];
  rec->iov_base = req->body.ptr + offset;
  rec->iov_len = size;
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;
  conn->data_left += rec->iov_len;
  return 0;
}
/*
static inline int _HK_mem(size_t size, HKMem *mem) {
  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  bool once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  size_t nblocks = round_to_blocks(size);
  int iov_index = MP_expand(conn, nblocks, once);
  struct iovec *iov = &conn->ios[iov_index];
  mem->ptr = iov->iov_base;
  mem->size = iov->iov_len;
  mem->_iov_index = iov_index;
  mem->_flags = (IN_POOL(iov->iov_base)) ? CF_IN_POOL : CF_IN_HEAP;
  return 0;
}

static inline void _HK_send(HKMem *mem, size_t size) {
  conn_t *conn = current_send;
  struct iovec *iov = &conn->ios[mem->_iov_index];
  iov->iov_len = size;
  conn->data_left += size;
}
  */
#endif#define _GNU_SOURCE
#ifndef UTILS_H
#define UTILS_H

#include "hunk.h"
#include <arpa/inet.h>
#include <fcntl.h>
#include <liburing.h>
#include <netdb.h>
#include <signal.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/poll.h>
#include <sys/prctl.h>
#include <sys/socket.h>
#include <sys/sysinfo.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

#define MP_BLOCK  4
#define MAX_CONNS 4096
#define KB        1024
#define NIOS      32

#define IN_POOL(ptr)                 ((void *)ptr >= pool.bpool && (void *)ptr <= (pool.bpool + (pool.npages * pool.pagesize)))
#define ALIGN_TO_PAGESIZE(buff_size) (((buff_size) + (pool.pagesize - 1)) & ~(pool.pagesize - 1))
#define BYTES_TO_BLOCKS(buff_size)   (((buff_size) + (MP_BLOCK - 1)) / MP_BLOCK)
#define CEIL_BLOCKS(nblocks)         ((nblocks + 63) & ~63)
#define CEIL_PAGES(size)             (((size) + ((pool.pagesize) - 1)) & ~((pool.pagesize) - 1))

#define BIT_IS_FREE(word, bit)   (((word) >> (bit)) & 1)
#define MARK_BIT_USED(word, bit) ((word) &= ~(1ULL << (bit)))
#define MARK_BIT_FREE(word, bit) ((word) |= (1ULL << (bit)))
#define FIND_FREE_BIT(word)      ((uint64_t)(word) & -(uint64_t)(word))
#define STRLEN(s)                (sizeof(s) - 1)

#define IOVEC_NBLOCKS (BYTES_TO_BLOCKS(NIOS * sizeof(struct iovec)))
#define MSG_NBLOCKS   (BYTES_TO_BLOCKS(sizeof(struct msghdr)))
#define ZC_RES        KB *KB

#define DEBUG 0
#if DEBUG
#define LOG(...) fprintf(logfd, __VA_ARGS__)
#else
#define LOG(...) ((void)0)
#endif

typedef enum UOP {
  WRITEV = IORING_OP_WRITEV,
  SENDMSG = IORING_OP_SENDMSG,
  RECVMSG = IORING_OP_RECVMSG,
  ACCEPT = IORING_OP_ACCEPT,
  SEND = IORING_OP_SEND,
  RECV = IORING_OP_RECV,
  SENDZC = IORING_OP_SEND_ZC,
  SENDMSGZC = IORING_OP_SENDMSG_ZC,
  PEEK = 50,
  FRECVMSG,
  INSPLICE,
  OUTSPLICE
} UOP;

typedef enum CFS {
  CF_IN_POOL = (1 << 0),       // Connection is in the pool
  CF_IN_HEAP = (1 << 1),       // Connection is in the heap
  CF_SKIP_SOCK = (1 << 2),     // Don't close the socket
  CF_USE_ONCE = (1 << 3),      // Destroy after using
  CF_HANDLER_READY = (1 << 4), // Ready to call the handler
} CFS;

typedef struct conn_t {
  // Socket file descriptor
  int fd;

  // Amount of data left in the current operation
  uint64_t data_left;

  // The index of the connection struct
  uint32_t cindex;

  // The last time the connection was readable
  uint64_t last_read;

  // The last time the connection was writeable
  uint64_t last_write;

  // The operation currently being processed
  uint8_t op;

  // Connection flags
  int flags;

  // Splice fd_in
  int in_fd;

  // Splice fd_out
  int out_fd;

  void *recv_conn;
  void *send_conn;

  struct iovec *ios;
  struct iovec *rec;
  uint16_t nios;

  struct msghdr *msg;
  uint16_t zc_notifs;

  uint16_t head_size;
} conn_t;

typedef struct MPool {
  // The allocated pool of blocks
  void *bpool;

  // The allocated pool of connections
  conn_t *cpool;

  // The size of the pool in pages
  uint32_t npages;

  // The size of the pool in blocks
  uint32_t nblocks;

  // The locations of each page in the pool
  void **blocks;

  // The availability of each block
  uint64_t *freebs;

  // The locations of each conn in the pool
  conn_t **conns;

  // The availability of each conn
  uint64_t *freecs;

  // Clean up callback function
  void (*callback)(conn_t *conn);

  // The page size used
  uint32_t pagesize;

  // Socket read timeout
  uint32_t rtimeout;

  // Socket write timeout
  uint32_t wtimeout;
} MPool;

extern int pipe_sz;
extern int pipe_in, pipe_out, nullfd;
extern FILE *logfd;
extern struct io_uring ring;
extern MPool pool;
extern conn_t *current_recv;
extern conn_t *current_send;

/*
 * Prepare and submit a recv uring op
 */
static inline int urecv(conn_t *conn, void *buffer, size_t buff_size, int flags) {
  if (!conn || conn->fd == -1)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (flags == MSG_PEEK) ? PEEK : RECV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;

  io_uring_prep_recv(sqe, conn->fd, buffer, buff_size, flags);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a multi-shot accept uring op
 */
static inline int umaccept(int listenfd) {
  if (listenfd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = ACCEPT;
  io_uring_prep_multishot_accept(sqe, listenfd, NULL, NULL, SOCK_NONBLOCK);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a splice uring op
 */
static inline int usplice(conn_t *conn, int fd_in, int64_t off_in, int fd_out, int64_t off_out, size_t len) {
  if (!len || !conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = (__u64)conn;
  io_uring_prep_splice(sqe, fd_in, off_in, fd_out, off_out, len, 0);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a writev uring op
 */
static inline int uwritev(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = WRITEV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  io_uring_prep_writev(sqe, conn->fd, &conn->ios[iov_index], nios, -1);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a send uring op
 */
static inline int usend(conn_t *conn, char *res_buff, size_t buff_size, bool zc) {
  if (!conn || conn->fd <= 0 || buff_size == 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (zc) ? SENDZC : SEND;
  conn->data_left = buff_size;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  if (zc)
    io_uring_prep_send_zc(sqe, conn->fd, res_buff, buff_size, 0, 0);
  else
    io_uring_prep_send(sqe, conn->fd, res_buff, buff_size, 0);
  return io_uring_submit(&ring);
}

static inline int ufrecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = FRECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;

  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, rec->iov_len);
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int urecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = RECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int usendmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  bool zc = (conn->data_left > ZC_RES) ? true : false;
  conn->op = (zc) ? SENDMSGZC : SENDMSG;

  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  if (zc) {
    io_uring_prep_sendmsg_zc(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
    conn->zc_notifs++;
  } else {
    io_uring_prep_sendmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  }
  return io_uring_submit(&ring);
}

/*
 * Create and initialize a server socket
 */
static inline int tcp_listen(uint16_t port) {
  int enable;
  int listenfd;
  if ((listenfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    return -1;

  int flags = fcntl(listenfd, F_GETFL, 0);
  fcntl(listenfd, F_SETFL, flags | O_NONBLOCK);
  struct sockaddr_in servaddr;
  memset(&servaddr, 0, sizeof(servaddr));
  servaddr.sin_family = AF_INET;
  servaddr.sin_addr.s_addr = INADDR_ANY;
  servaddr.sin_port = htons(port);

  enable = 1;
  if (setsockopt(listenfd, SOL_SOCKET, SO_REUSEPORT, &enable, sizeof(enable)) < 0)
    return -1;

  if (bind(listenfd, (struct sockaddr *)&servaddr, sizeof(servaddr)) < 0)
    return -1;

  if (listen(listenfd, SOMAXCONN) < 0)
    return -1;

  return listenfd;
}

/*
 * Calculate the difference between two pointers
 */
static inline uintptr_t ptr_diff(uintptr_t p1, uintptr_t p2) { return (uintptr_t)(p1 > p2) ? (p1 - p2) : (p2 - p1); }

static inline size_t get_nroutes(Route *routes) {
  Route *route;
  for (size_t i = 0;; i++) {
    route = &routes[i];
    if (!route->path && !route->handler && !route->method)
      return i;
  }
}

static inline long get_content_length(char *src, char *end) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return -1;
    key = line;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, "Content-Length") != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;

    *line_end = '\0';
    long res = atol(value);
    *line_end = '\r';

    return res;
  }
  return -1;
}

static inline bool have_header(char *src, char *end, const char *header_key, const char *header_value) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    key = line;
    while (*key == ' ')
      key++;
    while (*header_key == ' ')
      header_key++;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return false;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, header_key) != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;
    while (*header_value == ' ')
      header_value++;

    *line_end = '\0';
    bool res = (strcasecmp(value, header_value) == 0);
    *line_end = '\r';

    return res;
  }

  return false;
}

static inline const char *method_str(Method method) {
  switch (method) {
  case GET:
    return "GET";
    break;
  case HEAD:
    return "HEAD";
    break;
  case POST:
    return "POST";
    break;
  case PUT:
    return "PUT";
    break;
  case DELETE:
    return "DELETE";
    break;
  case CONNECT:
    return "CONNECT";
    break;
  case OPTIONS:
    return "OPTIONS";
    break;
  case TRACE:
    return "TRACE";
    break;
  case PATCH:
    return "PATCH";
    break;
  default:
    return NULL;
  }
}

static inline uint8_t method_len(Method method) {
  switch (method) {
  case GET:
    return 3;
    break;
  case HEAD:
    return 4;
    break;
  case POST:
    return 4;
    break;
  case PUT:
    return 3;
    break;
  case DELETE:
    return 6;
    break;
  case CONNECT:
    return 7;
    break;
  case OPTIONS:
    return 7;
    break;
  case TRACE:
    return 5;
    break;
  case PATCH:
    return 5;
    break;
  default:
    return 0;
  }
}

static inline size_t round_to_blocks(size_t size) {
  size_t nblocks = BYTES_TO_BLOCKS(size);
  nblocks = CEIL_BLOCKS(nblocks);
  return nblocks;
}

/*
 * Count the digits in unsigned 64-bit int
 */
static inline int countd(uint64_t num) {
  if (num < 10ULL)
    return 1;
  if (num < 100ULL)
    return 2;
  if (num < 1000ULL)
    return 3;
  if (num < 10000ULL)
    return 4;
  if (num < 100000ULL)
    return 5;
  if (num < 1000000ULL)
    return 6;
  if (num < 10000000ULL)
    return 7;
  if (num < 100000000ULL)
    return 8;
  if (num < 1000000000ULL)
    return 9;
  if (num < 10000000000ULL)
    return 10;
  if (num < 100000000000ULL)
    return 11;
  if (num < 1000000000000ULL)
    return 12;
  if (num < 10000000000000ULL)
    return 13;
  if (num < 100000000000000ULL)
    return 14;
  if (num < 1000000000000000ULL)
    return 15;
  if (num < 10000000000000000ULL)
    return 16;
  if (num < 100000000000000000ULL)
    return 17;
  if (num < 1000000000000000000ULL)
    return 18;
  if (num < 10000000000000000000ULL)
    return 19;
  return 20;
}

/*
 * Get the time elabsed in ms
 */
static inline uint64_t get_time() {
  struct timespec ts;
  clock_gettime(CLOCK_MONOTONIC, &ts);
  return (uint64_t)(ts.tv_sec) * 1000 + (ts.tv_nsec / 1000000);
}

static inline FILE *log_init(const char *path) {
  FILE *res = fopen(path, "a+");
  setvbuf(res, NULL, _IONBF, 0);
  return res;
}

static inline int16_t pollevs(int connfd) {
  struct pollfd pfd;
  pfd.fd = connfd;
  pfd.events = POLLIN | POLLOUT | POLLERR;
  int res = poll(&pfd, 1, 0);
  if (res < 0)
    return POLLERR;
  return pfd.revents;
}

// FIXME This needs to be updated
static inline conn_t *MP_use_once(size_t nblocks, int fd) {

  void *mem = malloc(sizeof(conn_t) + 8 + (IOVEC_NBLOCKS * MP_BLOCK));
  struct conn_t *conn = (conn_t *)mem;
  memset(conn, 0, sizeof(conn_t));
  conn->ios = mem + sizeof(conn_t) + 8;

  if (nblocks > 0) {
    struct iovec *iov = &conn->ios[conn->nios++];
    mem = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (mem == MAP_FAILED)
      return NULL;
    iov->iov_base = mem;
    iov->iov_len = ALIGN_TO_PAGESIZE(nblocks * MP_BLOCK);
  }

  conn->flags |= CF_IN_HEAP;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;

  return conn;
}

static inline int find_freec() {
  uint64_t *word;
  size_t map_size = (sizeof(uint64_t) * 8);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    word = &pool.freecs[i / map_size];

    if (*word == 0) { // All used
      i += (map_size - 1);
      continue;
    }

    i += __builtin_ctzll(*word);
    MARK_BIT_USED(*word, i);
    return i;
  }

  return -1;
}

static inline int MP_init(size_t npages) {
  if (!npages)
    return -1;

  /*** Setup ***/
  pool.npages = npages;
  pool.pagesize = sysconf(_SC_PAGESIZE);

  /*** Pool ***/
  pool.bpool = mmap(NULL, pool.npages * pool.pagesize, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  if (pool.bpool == MAP_FAILED)
    return -1;
  pool.nblocks = (pool.npages * pool.pagesize) / MP_BLOCK;

  /*** Blocks ***/
  pool.blocks = malloc(sizeof(void *) * pool.nblocks);
  if (!pool.blocks)
    return -1;
  for (size_t i = 0; i < pool.nblocks; i++)
    pool.blocks[i] = pool.bpool + (i * MP_BLOCK);

  /*** Freebs ***/
  // if (posix_memalign((void **)&pool.freebs, 64, bitmap_size * sizeof(uint64_t)) < 0)
  size_t bitmap_size = (pool.nblocks + 63) / 64;
  pool.freebs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freebs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freebs[i] = UINT64_MAX;

  /*** Cpool ***/
  pool.cpool = (conn_t *)malloc(sizeof(conn_t) * MAX_CONNS);
  if (!pool.cpool)
    return -1;

  /*** Conns ***/
  pool.conns = (conn_t **)malloc(sizeof(conn_t *) * MAX_CONNS);
  if (!pool.conns)
    return -1;
  size_t conn_size = sizeof(conn_t);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    pool.conns[i] = (conn_t *)((char *)pool.cpool + (i * conn_size));
    pool.conns[i]->fd = -1;
    pool.conns[i]->in_fd = -1;
    pool.conns[i]->out_fd = -1;
  }

  /*** Freecs ***/
  bitmap_size = (MAX_CONNS + 63) / 64;
  pool.freecs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freecs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freecs[i] = UINT64_MAX;

  return 0;
}

static inline int MP_use_blks(size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t max_start = pool.nblocks - nblocks;
  size_t full_chunks = (nblocks / 64) * 64;

  for (size_t i = 0, c = 0; i <= max_start; i++, c++) {
    bool free = true;

    for (size_t j = 0; j < full_chunks; j += 64) {
      size_t word_index = (i + j) / 64;
      if (pool.freebs[word_index] != UINT64_MAX) {
        free = false;
        i += 63;
        break;
      }
    }

    for (size_t j = full_chunks; j < nblocks; j++) {
      size_t bit_index = i + j;
      size_t word_index = bit_index / 64;
      size_t bit_in_word = bit_index % 64;

      if (!BIT_IS_FREE(pool.freebs[word_index], bit_in_word)) {
        free = false;
        i += j;
        break;
      }
    }

    if (free) {
      for (size_t j = 0; j < full_chunks; j += 64) {
        size_t word_index = (i + j) / 64;
        pool.freebs[word_index] = 0;
      }

      for (size_t j = full_chunks; j < nblocks; j++) {
        size_t bit_index = i + j;
        size_t word_index = bit_index / 64;
        size_t bit_in_word = bit_index % 64;

        MARK_BIT_USED(pool.freebs[word_index], bit_in_word);
      }

      return i;
    }
  }

  return -1;
}

static inline int MP_free_blks(size_t bindex, size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t full_chunks = (nblocks / 64) * 64;
  for (size_t i = 0; i < full_chunks; i += 64) {
    size_t word_index = (bindex + i) / 64;
    pool.freebs[word_index] = UINT64_MAX;
  }

  for (size_t i = full_chunks; i < nblocks; i++) {
    size_t bit_index = bindex + i;
    size_t word_index = bit_index / 64;
    size_t bit_in_word = bit_index % 64;

    MARK_BIT_FREE(pool.freebs[word_index], bit_in_word);
  }

  memset(pool.blocks[bindex], 0, nblocks * MP_BLOCK);
  return 0;
}

static inline conn_t *MP_use(size_t nblocks, int fd, bool once) {
  if (fd <= 0)
    return NULL;
  if (once)
    return MP_use_once(nblocks, fd);

  int cindex = find_freec();
  if (cindex < 0) {
    LOG("Err: cindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  conn_t *conn = pool.conns[cindex];

  int ios_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (ios_bindex < 0) {
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }

  struct iovec *ios = pool.blocks[ios_bindex];
  conn->ios = ios;

  int rec_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (rec_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct iovec *rec = pool.blocks[rec_bindex];
  conn->rec = rec;

  int msg_bindex = MP_use_blks(MSG_NBLOCKS);
  if (msg_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct msghdr *msg = pool.blocks[msg_bindex];
  conn->msg = msg;

  if (nblocks > 0) {
    int bindex = MP_use_blks(nblocks);
    if (bindex < 0) {
      MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
      MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
      MP_free_blks(msg_bindex, IOVEC_NBLOCKS);
      MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
      LOG("Err: bindex < 0; will use MP_use_once\n");
      return MP_use_once(nblocks, fd);
    }

    size_t iov_index = conn->nios++;
    struct iovec *iov = &conn->ios[iov_index];
    struct iovec *rec = &conn->rec[iov_index];
    iov->iov_base = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
  }

  conn->msg->msg_iov = conn->ios;
  conn->msg->msg_iovlen = conn->nios;
  conn->cindex = cindex;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;
  return conn;
}

static inline void MP_shed(conn_t *conn, size_t iov_index, size_t nios) {
  struct iovec *iov, *rec;
  size_t bindex, nblocks, index;

  for (size_t i = 0; i < nios; i++) {
    index = iov_index + i;
    iov = &conn->ios[index];
    rec = &conn->rec[index];
    if (!rec || !rec->iov_base)
      continue;
    if (!IN_POOL(rec->iov_base)) {
      munmap(rec->iov_base, rec->iov_len / pool.pagesize);
    } else {
      bindex = ptr_diff((uintptr_t)rec->iov_base, (uintptr_t)pool.bpool) / MP_BLOCK;
      nblocks = rec->iov_len / MP_BLOCK;
      MP_free_blks(bindex, nblocks);
    }
    memset(iov, 0, sizeof(struct iovec));
    memset(rec, 0, sizeof(struct iovec));
    conn->nios--;
  }
}

static inline int MP_expand(conn_t *conn, size_t nblocks, bool once) {
  void *bptr;
  int iov_index, bindex;
  struct iovec *iov, *rec;

  iov_index = conn->nios++;
  iov = &conn->ios[iov_index];
  rec = &conn->rec[iov_index];

  if (nblocks == 0)
    return iov_index;

  if (once) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_base = bptr;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
    return iov_index;
  }

  bindex = MP_use_blks(nblocks);
  if (bindex < 0) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_len = iov->iov_len;
  } else {
    bptr = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_len = iov->iov_len;
  }

  iov->iov_base = bptr;
  rec->iov_base = iov->iov_base;
  return iov_index;
}

static inline int MP_free(conn_t *conn) {
  if (!conn)
    return -1;
  size_t bindex, nblocks;
  uint64_t *word;

  MP_shed(conn, 0, conn->nios);
  if (conn->flags & CF_IN_HEAP) {
    if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
      close(conn->fd);
    free(conn);
    return 0;
  }

  word = &pool.freecs[conn->cindex / 64];
  if (conn->cindex > MAX_CONNS)
    return -1;
  else if (BIT_IS_FREE(*word, conn->cindex))
    return 0;

  bindex = ptr_diff((uintptr_t)conn->ios, (uintptr_t)pool.bpool) / MP_BLOCK;
  nblocks = IOVEC_NBLOCKS;
  MP_free_blks(bindex, nblocks);

  bindex = ptr_diff((uintptr_t)conn->rec, (uintptr_t)pool.bpool) / MP_BLOCK;
  MP_free_blks(bindex, nblocks);

  if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
    close(conn->fd);

  MARK_BIT_FREE(*word, conn->cindex);
  memset(conn, 0, sizeof(conn_t));
  conn->fd = -1;
  conn->in_fd = -1;
  conn->out_fd = -1;
  return 0;
}

static inline void MP_clear(conn_t *conn) {
  conn_t *recv_conn = conn->recv_conn;
  conn_t *send_conn = conn->send_conn;
  if (recv_conn)
    MP_free(recv_conn);
  if (send_conn)
    MP_free(send_conn);
}

static inline void MP_exit(MPool *pool) {
  munmap(pool->bpool, pool->npages);
  free(pool->cpool);
  free(pool->blocks);
  free(pool->conns);
  free(pool->freebs);
  free(pool->freecs);
}

static inline void MP_timeout() {
  conn_t *conn;
  int16_t res;
  uint64_t now;
  size_t windex = 0;
  uint64_t *word = &pool.freecs[0];
  for (size_t i = 0; i < MAX_CONNS; i++) {
    if ((i / 64) < windex)
      word = &pool.freecs[++windex];

    if (*word == UINTMAX_MAX) {
      i = (i / 64) * 64 + 64;
      continue;
    }

    conn = pool.conns[i];
    if (!conn || conn->fd == -1)
      continue;

    res = pollevs(conn->fd);

    now = get_time();
    if (res & POLLERR) {
      MP_clear(conn);
      continue;
    }
    if (res & POLLIN) {
      if (pool.rtimeout > 0 && (now - conn->last_read) >= pool.rtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (res & POLLOUT) {
      if (pool.wtimeout > 0 && (now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (!(res & POLLIN || res & POLLOUT)) {
      if ((pool.rtimeout > 0 && now - conn->last_read) >= pool.rtimeout
          || (pool.wtimeout > 0 && now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
  }
}

/*
 * Calculate the length of a status string
 */
static inline size_t status_len(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return 8;
  case STATUSSWITCHINGPROTOCOLS:
    return 19;
  case STATUSPROCESSING:
    return 10;
  case STATUSEARLYHINTS:
    return 11;
  case STATUSOK:
    return 2;
  case STATUSCREATED:
    return 7;
  case STATUSACCEPTED:
    return 8;
  case STATUSNONAUTHORITATIVE:
    return 29;
  case STATUSNOCONTENT:
    return 10;
  case STATUSRESETCONTENT:
    return 13;
  case STATUSPARTIALCONTENT:
    return 15;
  case STATUSMULTISTATUS:
    return 12;
  case STATUSALREADYREPORTED:
    return 16;
  case STATUSIMUSED:
    return 7;
  case STATUSMULTIPLECHOICES:
    return 16;
  case STATUSMOVEDPERMANENTLY:
    return 17;
  case STATUSFOUND:
    return 5;
  case STATUSSEEOTHER:
    return 9;
  case STATUSNOTMODIFIED:
    return 12;
  case STATUSUSEPROXY:
    return 9;
  case STATUSTEMPORARYREDIRECT:
    return 18;
  case STATUSPERMANENTREDIRECT:
    return 18;
  case STATUSBADREQUEST:
    return 11;
  case STATUSUNAUTHORIZED:
    return 12;
  case STATUSPAYMENTREQUIRED:
    return 16;
  case STATUSFORBIDDEN:
    return 9;
  case STATUSNOTFOUND:
    return 9;
  case STATUSMETHODNOTALLOWED:
    return 18;
  case STATUSNOTACCEPTABLE:
    return 14;
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return 29;
  case STATUSREQUESTTIMEOUT:
    return 15;
  case STATUSCONFLICT:
    return 8;
  case STATUSGONE:
    return 4;
  case STATUSLENGTHREQUIRED:
    return 15;
  case STATUSPRECONDITIONFAILED:
    return 19;
  case CONTENTTOOLARGE:
    return 17;
  case STATUSURITOOLONG:
    return 12;
  case STATUSUNSUPPORTEDMEDIATYPE:
    return 22;
  case STATUSRANGENOTSATISFIABLE:
    return 21;
  case STATUSEXPECTATIONFAILED:
    return 18;
  case STATUSMISDIRECTEDREQUEST:
    return 19;
  case STATUSUNPROCESSABLECONTENT:
    return 21;
  case STATUSLOCKED:
    return 6;
  case STATUSFAILEDDEPENDENCY:
    return 17;
  case STATUSTOOEARLY:
    return 9;
  case STATUSUPGRADEREQUIRED:
    return 16;
  case STATUSPRECONDITIONREQUIRED:
    return 21;
  case STATUSTOOMANYREQUESTS:
    return 17;
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return 31;
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return 29;
  case STATUSInternalServerError:
    return 21;
  case STATUSNOTIMPLEMENTED:
    return 15;
  case STATUSBADGATEWAY:
    return 11;
  case STATUSSERVICEUNAVAILABLE:
    return 19;
  case STATUSGATEWAYTIMEOUT:
    return 15;
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return 26;
  case STATUSVARIANTALSONEGOTIATES:
    return 23;
  case STATUSINSUFFICIENTSTORAGE:
    return 20;
  case STATUSLOOPDETECTED:
    return 13;
  case STATUSNOTEXTENDED:
    return 12;
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return 31;
  default:
    return 0;
  }
}

/*
 * Return the status code string as string literal
 */
static inline char *status_str(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return "Continue";
  case STATUSSWITCHINGPROTOCOLS:
    return "Switching Protocols";
  case STATUSPROCESSING:
    return "Processing";
  case STATUSEARLYHINTS:
    return "Early Hints";
  case STATUSOK:
    return "OK";
  case STATUSCREATED:
    return "Created";
  case STATUSACCEPTED:
    return "Accepted";
  case STATUSNONAUTHORITATIVE:
    return "Non-Authoritative Information";
  case STATUSNOCONTENT:
    return "No Content";
  case STATUSRESETCONTENT:
    return "Reset Content";
  case STATUSPARTIALCONTENT:
    return "Partial Content";
  case STATUSMULTISTATUS:
    return "Multi-Status";
  case STATUSALREADYREPORTED:
    return "Already Reported";
  case STATUSIMUSED:
    return "Im Used";
  case STATUSMULTIPLECHOICES:
    return "Multiple Choices";
  case STATUSMOVEDPERMANENTLY:
    return "Moved Permanently";
  case STATUSFOUND:
    return "Found";
  case STATUSSEEOTHER:
    return "See Other";
  case STATUSNOTMODIFIED:
    return "Not Modified";
  case STATUSUSEPROXY:
    return "Use Proxy";
  case STATUSTEMPORARYREDIRECT:
    return "Temporary Redirect";
  case STATUSPERMANENTREDIRECT:
    return "Permanent Redirect";
  case STATUSBADREQUEST:
    return "Bad Request";
  case STATUSUNAUTHORIZED:
    return "Unauthorized";
  case STATUSPAYMENTREQUIRED:
    return "Payment Required";
  case STATUSFORBIDDEN:
    return "Forbidden";
  case STATUSNOTFOUND:
    return "Not Found";
  case STATUSMETHODNOTALLOWED:
    return "Method Not Allowed";
  case STATUSNOTACCEPTABLE:
    return "Not Acceptable";
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return "Proxy Authentication Required";
  case STATUSREQUESTTIMEOUT:
    return "Request Timeout";
  case STATUSCONFLICT:
    return "Conflict";
  case STATUSGONE:
    return "Gone";
  case STATUSLENGTHREQUIRED:
    return "Length Required";
  case STATUSPRECONDITIONFAILED:
    return "Precondition Failed";
  case CONTENTTOOLARGE:
    return "Content Too Large";
  case STATUSURITOOLONG:
    return "URI Too Long";
  case STATUSUNSUPPORTEDMEDIATYPE:
    return "Unsupported Media Type";
  case STATUSRANGENOTSATISFIABLE:
    return "Range Not Satisfiable";
  case STATUSEXPECTATIONFAILED:
    return "Expectation Failed";
  case STATUSMISDIRECTEDREQUEST:
    return "Misdirected Request";
  case STATUSUNPROCESSABLECONTENT:
    return "Unprocessable Content";
  case STATUSLOCKED:
    return "Locked";
  case STATUSFAILEDDEPENDENCY:
    return "Failed Dependency";
  case STATUSTOOEARLY:
    return "Too Early";
  case STATUSUPGRADEREQUIRED:
    return "Upgrade Required";
  case STATUSPRECONDITIONREQUIRED:
    return "Precondition Required";
  case STATUSTOOMANYREQUESTS:
    return "Too Many Requests";
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return "Request Header Fields Too Large";
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return "Unavailable For Legal Reasons";
  case STATUSInternalServerError:
    return "Internal Server Error";
  case STATUSNOTIMPLEMENTED:
    return "Not Implemented";
  case STATUSBADGATEWAY:
    return "Bad Gateway";
  case STATUSSERVICEUNAVAILABLE:
    return "Service Unavailable";
  case STATUSGATEWAYTIMEOUT:
    return "Gateway Timeout";
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return "HTTP Version Not Supported";
  case STATUSVARIANTALSONEGOTIATES:
    return "Variant Also Negotiates";
  case STATUSINSUFFICIENTSTORAGE:
    return "Insufficient Storage";
  case STATUSLOOPDETECTED:
    return "Loop Detected";
  case STATUSNOTEXTENDED:
    return "Not Extended";
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return "Network Authentication Required";
  default:
    return 0;
  }
}

/*
 * Return true if routes match
 */
static inline bool route_equ(Route *route, Request *req) {
  return route->method == req->method && strncmp(route->path, req->path, strlen(route->path)) == 0;
}

/*
 * Return the matching route index on success. -1 on failure
 */
static inline int match_route(Server *serv, Request *req) {
  for (size_t i = 0; i < serv->_nroutes; i++) {
    Route route = serv->routes[i];
    if (!req->path || !route.path)
      continue;
    if (route_equ(&route, req))
      return i;
    else if (req->method == HEAD && route.method == GET && strcmp(route.path, req->path) == 0)
      return i;
  }
  return -1;
}

/*
 * Return true if the response should contain the Content-Length header
 */
static inline bool should_have_content_length(Request *req, ResWriter *res) {
  return (req->method != CONNECT              // CONNECT request
          && res->status != STATUSNOCONTENT   // 204 response
          && res->status != STATUSNOTMODIFIED // 304 response
          && res->status >= 200);             // 1xx response
}

/*
 * Format http response from the ResWriter.
 * Return response size on success, 0 on failure.
 */
static inline size_t fmt_res(Request *req, ResWriter *res, char *buffer, size_t buffer_size) {
  if (!res || !buffer || buffer_size == 0)
    return 0;

  size_t res_len, total = 0;
  char *dst = buffer;
  size_t maxlen = buffer_size;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t body_length = res->len;

  res_len = snprintf(dst, maxlen, "HTTP/1.1 %d %s", (int)res->status, status_str(res->status));
  total += res_len;
  dst += res_len;
  maxlen -= res_len;

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    res_len = snprintf(dst, maxlen, "\r\n%s: %s", header->key, header->value);
    total += res_len;
    dst += res_len;
    maxlen -= res_len;
  }

  if (have_content_length) {
    res_len = snprintf(dst, maxlen, "\r\nContent-Length: %lu", body_length);
    total += res_len, dst += res_len, maxlen -= res_len;
  }

  memcpy(dst, "\r\n\r\n", 4);
  total += 4, dst += 4, maxlen -= 4;

  return total;
}

static inline size_t res_len(Request *req, ResWriter *res) {
  if (!req || !res)
    return 0;

  if (!res->status)
    res->status = STATUSOK;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t result = 0;
  result += STRLEN("HTTP/1.1 ");     // HTTP version
  result += 4;                       // Status code + space
  result += status_len(res->status); // Status name

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    result += 2;                       // "\r\n"
    result += strlen(header->key) + 2; // Header key + ':' + space
    result += strlen(header->value);   // header value
  }

  if (have_content_length) {
    result += 2;                          // "\r\n"
    result += STRLEN("Content-Length: "); // Header key
    result += countd(res->len);           // Header value
  }

  result += 4; // "\r\n\r\n"

  return result;
}

static inline int send_empty_res(Status status) {
  size_t res_len = STRLEN("HTTP/1.1 ")        // HTTP version
                   + countd((uint64_t)status) // status code
                   + 1                        // space
                   + (int)status_len(status)  // status string
                   + 4;                       // \r\n\r\n

  conn_t *conn = current_send;
  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, res_len);
  if (snprintf((char *)rec->iov_base, res_len + 1, "HTTP/1.1 %d %s\r\n\r\n", (int)status, status_str(status))
      != (int)res_len)
    return -1;

  return usendmsg(conn, 0, 1);
}

static inline ssize_t read_socket(int sockfd, size_t len) {
  if (len == 0 || sockfd <= 0)
    return 0;
  char buff[1024 * 8];
  return read(sockfd, buff, 1024 * 8);
}

static inline int read_method(Method *method, void *src) {
  if (memcmp(src, "GET", 3) == 0)
    *method = GET;
  else if (memcmp(src, "POST", 4) == 0)
    *method = POST;
  else if (memcmp(src, "HEAD", 4) == 0)
    *method = HEAD;
  else if (memcmp(src, "PUT", 3) == 0)
    *method = PUT;
  else if (memcmp(src, "DELETE", 6) == 0)
    *method = DELETE;
  else if (memcmp(src, "CONNECT", 7) == 0)
    *method = CONNECT;
  else if (memcmp(src, "OPTIONS", 7) == 0)
    *method = OPTIONS;
  else if (memcmp(src, "TRACE", 5) == 0)
    *method = TRACE;
  else if (memcmp(src, "PATCH", 5) == 0)
    *method = PATCH;
  else
    return -1;

  return 0;
}

static inline int sendmsg_res(Request *req, ResWriter *res) {
  conn_t *conn;
  size_t head_size, res_size;
  struct iovec *iov;

  conn = current_send;
  iov = &conn->ios[0];
  head_size = res_len(req, res);
  if (head_size == 0)
    return -1;

  conn->data_left += head_size;
  res_size = fmt_res(req, res, iov->iov_base, (head_size + 1));
  if (res_size != head_size)
    return -1;
  iov->iov_len = res_size;

  return usendmsg(conn, 0, conn->nios);
}

static inline int read_req(Request *req, char *req_buffer) {
  if (!req_buffer)
    return -1;
  /*** Method ***/
  char *sep = strchr(req_buffer, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }
  *sep = '\0';
  if (read_method(&req->method, req_buffer) < 0)
    return -1;

  /*** Path ***/
  char *fullpath = sep + 1;
  sep = strchr(fullpath, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }

  *sep = '\0';
  req->path = fullpath;
  /*** Params ***/
  char *paramStart = strchr(fullpath, '?');
  if (paramStart) {
    *paramStart++ = '\0';
    int params_count = 0;
    params_count = HK_parse_params(paramStart, req->params, MAX_URL_PARAMETERS);
    if (params_count > 0)
      req->params_count = params_count;
    else
      req->params_count = 0;
  } else {
    req->params = NULL;
    req->params_count = 0;
  }

  /*** Headers ***/
  char *headStart = strstr(sep + 1, "\r\n");
  char *headEnd = strstr(sep + 1, "\r\n\r\n");
  if (!headStart) {
    LOG("read_req: !headStart\n");
    return -1;
  };

  memset(headStart, 0, 2);
  headStart += 2;
  memset(headEnd, 0, 4);
  headEnd += 4;

  int headers_count = HK_parse_headers(headStart, req->headers, MAX_REQ_HEADERS);
  if (headers_count <= 0)
    return -1;
  req->headers_count = headers_count;

  /*** Host ***/
  int index = HK_get_header(req, "Host");
  if (index < 0)
    return -1;
  char *host = req->headers[index].value;
  req->hostname = host;

  /*** Port ***/
  char *colon = strchr(host, ':');
  if (colon) {
    *colon++ = '\0';
    req->port = atoi(colon);
  } else {
    req->port = PORT;
  }
  return 0;
}
static inline int process_req(Server *serv, conn_t *conn) {
  if (!conn || conn->fd == -1)
    return -1;

  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;
  if (read_req(&req, conn->ios[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    LOG("Err: route_index == -1\n");
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;
  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  sendmsg_res(&req, &res);

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int new_conn(int connfd) {
  if (connfd <= 0)
    return -1;

  current_recv = MP_use(KB * 2, connfd, false);
  current_send = MP_use(KB * 2, connfd, false);

  current_recv->recv_conn = current_recv;
  current_recv->send_conn = current_send;

  current_send->send_conn = current_send;
  current_send->recv_conn = current_recv;

  conn_t *conn = current_recv;
  if (ufrecvmsg(conn, 0, 1) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

static inline int resubmit_sendmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return usendmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int resubmir_recvmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    // FIXME the len should be increased
    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return urecvmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int handle_sendmsg_complete(conn_t *conn) {
  struct iovec *iov, *rec;

  MP_shed(conn, 1, conn->nios - 1);
  iov = &conn->ios[0];
  rec = &conn->rec[0];
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;

  return ufrecvmsg(conn->recv_conn, 0, 1);
}

static inline int handle_sendmsg(conn_t *conn, int res, bool zc) {
  if (!conn || conn->fd == -1)
    return -1;

  conn->data_left -= res;
  if (conn->data_left > 0)
    return resubmit_sendmsg(conn, res);

  if (zc)
    return 0;

  return handle_sendmsg_complete(conn);
}

static inline int handle_insplice(conn_t *conn) {
  conn->op = OUTSPLICE;
  return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
}
static inline int handle_outsplice(conn_t *conn, int res) {
  conn->data_left -= res;
  if (conn->data_left > 0) {
    conn->op = INSPLICE;
    return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
  }

  conn_t *recv_conn = conn->recv_conn;
  struct iovec *iov = &recv_conn->ios[0];
  memset(iov->iov_base, 0, iov->iov_len);
  if (urecv(recv_conn, iov->iov_base, iov->iov_len, MSG_PEEK) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

/*
static inline int handle_recv(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  void *bptr = conn->ios[0].iov_base;
  void *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  void *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  return process_req(serv, conn);
}
*/
static inline int find_route(Server *serv, char *bptr) {
  Request req = {0};
  if (read_method(&req.method, bptr) < 0) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  };
  char *space = strchr(bptr, ' ');
  req.path = (space + 1);
  space = strchr(req.path, ' ');
  *space = '\0';
  int route_index = match_route(serv, &req);
  *space = ' ';
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }
  return route_index;
}

static inline int run_handler(Server *serv, conn_t *conn, bool uses_body) {
  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;

  if (read_req(&req, conn->rec[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  if (uses_body) {
    int h_index = HK_get_header(&req, "Content-Length");
    long body_size = atol(req.headers[h_index].value);
    if (body_size >= 0) {
      req.body.ptr = conn->rec[1].iov_base;
      req.body.size = body_size;
    } else {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    }
  }

  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  if (sendmsg_res(&req, &res) < 0)
    return -1;

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int handle_frecvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  char *bptr = (char *)conn->ios[0].iov_base;
  char *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  char *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  size_t head_size = (headEnd + 4) - bptr;
  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  int route_index = find_route(serv, bptr);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  bool uses_body = serv->routes[route_index].uses_body;
  long body_size = get_content_length(headstart + 2, headEnd + 4);
  if (body_size == -1) {
    if (uses_body) {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    } else {
      body_size = 0;
    }
  }

  conn->head_size = head_size;
  if (!uses_body) {
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  if (res == (int)(head_size + body_size)) {
    size_t iov_index = MP_expand(conn, round_to_blocks(body_size), false);
    memcpy(conn->rec[iov_index].iov_base, headEnd + 4, body_size);
    conn->ios[iov_index].iov_len = body_size;
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  conn->data_left = body_size - (res - head_size);
  bool once = ((size_t)body_size > (size_t)((pool.nblocks * MP_BLOCK) / 10));
  size_t iov_index = MP_expand(conn, round_to_blocks(body_size), once);
  memcpy(conn->rec[iov_index].iov_base, headEnd + 4, (res - head_size));
  conn->ios[iov_index].iov_base += (res - head_size);

  return urecvmsg(conn, iov_index, 1);
}

static inline int handle_recvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  if (conn->data_left > 0) {
    conn->data_left -= res;
    if (conn->data_left == 0) {
      conn->flags &= CF_HANDLER_READY;
      return run_handler(serv, conn, true);
    }

    conn->flags &= ~CF_HANDLER_READY;
    conn->ios[1].iov_base += res;
    return urecvmsg(conn, 1, 1);
  }

  conn->flags &= CF_HANDLER_READY;
  return run_handler(serv, conn, true);
}

static inline int serv_init(Server *serv) {
#if DEBUG
  logfd = log_init("log.txt");
  if (!logfd) {
    printf("log_init failed");
    return -1;
  }
#endif
  serv->_nroutes = get_nroutes(serv->routes);

  int pipefd[2];
  if (pipe(pipefd) < 0)
    return -1;
  pipe_in = pipefd[0];
  pipe_out = pipefd[1];
  nullfd = open("/dev/null", O_WRONLY);
  pipe_sz = fcntl(pipefd[0], F_GETPIPE_SZ);
  if (pipe_sz < 0)
    return -1;

  pool.rtimeout = serv->rtimeout;
  pool.wtimeout = serv->wtimeout;
  if (MP_init(MAX_CONNS * 8) < 0)
    return -1;
  LOG("pool initialized\n");

  if (io_uring_queue_init(MAX_CONNS, &ring, 0) < 0)
    return -1;
  LOG("uring initialized\n");

  int listenfd;
  if ((listenfd = tcp_listen(serv->port)) < 0)
    return -1;
  LOG("socket initialized\n");

  return umaccept(listenfd);
}

static inline int serv_listen(Server *serv) {
  // uint64_t last_check = get_time();
  while (true) {
    // uint64_t now = get_time();
    // if ((now - last_check) >= 200) {
    //   last_check = now;
    //   LOG("CM: CM_check ran\n");
    //   MP_timeout();
    // }

    LOG("SQ ready: %u, CQ ready: %u\n", io_uring_sq_ready(&ring), io_uring_cq_ready(&ring));
    struct io_uring_cqe *cqe;
    if (io_uring_wait_cqe(&ring, &cqe) < 0)
      continue;

    int res = cqe->res;
    LOG("res = %d\n", res);
    conn_t *conn = NULL;
    if (cqe->user_data > 100) {
      conn = (conn_t *)cqe->user_data;
      current_recv = (conn_t *)conn->recv_conn;
      current_send = (conn_t *)conn->send_conn;
    }

    if (res > 0) {
      if (cqe->user_data == ACCEPT) {
        LOG("new conn created\n");
        new_conn(res);
      } else if (conn && conn->fd != -1) {
        LOG("conn[%d]: conn.fd = %d; conn.op = %d\n", conn->cindex, conn->fd, conn->op);
        switch (conn->op) {
        case FRECVMSG:
          if (handle_frecvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case RECVMSG:
          if (handle_recvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case SENDMSG:
        case SENDMSGZC:
          // conn->last_write = get_time();
          bool zc = (conn->op == SENDMSGZC);
          if (handle_sendmsg(conn, res, zc) < 0)
            MP_clear(conn);
          break;
        case INSPLICE:
          if (handle_insplice(conn) < 0)
            MP_clear(conn);
          break;
        case OUTSPLICE:
          if (handle_outsplice(conn, res) < 0)
            MP_clear(conn);
          break;
        }
      }
    } else if (res == 0) {
      if (conn && conn->fd != -1) {
        switch (conn->op) {
        case SENDMSGZC:
          conn->zc_notifs--;
          if (conn->zc_notifs == 0 && handle_sendmsg_complete(conn) < 0)
            MP_clear(conn);
          break;
        case RECV:
          MP_clear(conn);
          break;
        }
      }
    } else {
      if (conn && conn->fd != -1) {
        if (res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR) {
          LOG("conn && conn->fd != -1 && res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR\n");
          MP_clear(conn);
        } else {
          LOG("res == -EAGAIN || res == -EWOULDBLOCK || res == -EINTR\n");
          conn = conn->recv_conn;
          struct iovec *iov = &conn->ios[0];
          memset(iov->iov_base, 0, iov->iov_len);
          if (urecv(conn, iov->iov_base, iov->iov_len, 0) < 0)
            MP_clear(conn);
        }
      }
    }

    LOG("uring operation seen\n");
    io_uring_cqe_seen(&ring, cqe);
  }

  io_uring_queue_exit(&ring);
  MP_exit(&pool);
  return 0;
}

/*** Helper ***/
static inline int _HK_write(void *data, size_t size) {
  size_t nblocks;
  int iov_index;
  conn_t *conn;
  struct iovec *iov;
  bool once;

  conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  nblocks = round_to_blocks(size);
  iov_index = MP_expand(conn, nblocks, once);
  iov = &conn->ios[iov_index];

  memcpy(iov->iov_base, data, size);
  iov->iov_len = size;
  conn->data_left += size;

  return 0;
}
static inline int _HK_write_body(Request *req, size_t offset, size_t size) {
  if (size > req->body.size || offset > req->body.size)
    return -1;

  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  int iov_index = MP_expand(conn, 0, false);
  struct iovec *iov = &conn->ios[iov_index];
  struct iovec *rec = &conn->rec[iov_index];
  rec->iov_base = req->body.ptr + offset;
  rec->iov_len = size;
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;
  conn->data_left += rec->iov_len;
  return 0;
}
/*
static inline int _HK_mem(size_t size, HKMem *mem) {
  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  bool once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  size_t nblocks = round_to_blocks(size);
  int iov_index = MP_expand(conn, nblocks, once);
  struct iovec *iov = &conn->ios[iov_index];
  mem->ptr = iov->iov_base;
  mem->size = iov->iov_len;
  mem->_iov_index = iov_index;
  mem->_flags = (IN_POOL(iov->iov_base)) ? CF_IN_POOL : CF_IN_HEAP;
  return 0;
}

static inline void _HK_send(HKMem *mem, size_t size) {
  conn_t *conn = current_send;
  struct iovec *iov = &conn->ios[mem->_iov_index];
  iov->iov_len = size;
  conn->data_left += size;
}
  */
#endif#define _GNU_SOURCE
#ifndef UTILS_H
#define UTILS_H

#include "hunk.h"
#include <arpa/inet.h>
#include <fcntl.h>
#include <liburing.h>
#include <netdb.h>
#include <signal.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/poll.h>
#include <sys/prctl.h>
#include <sys/socket.h>
#include <sys/sysinfo.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

#define MP_BLOCK  4
#define MAX_CONNS 4096
#define KB        1024
#define NIOS      32

#define IN_POOL(ptr)                 ((void *)ptr >= pool.bpool && (void *)ptr <= (pool.bpool + (pool.npages * pool.pagesize)))
#define ALIGN_TO_PAGESIZE(buff_size) (((buff_size) + (pool.pagesize - 1)) & ~(pool.pagesize - 1))
#define BYTES_TO_BLOCKS(buff_size)   (((buff_size) + (MP_BLOCK - 1)) / MP_BLOCK)
#define CEIL_BLOCKS(nblocks)         ((nblocks + 63) & ~63)
#define CEIL_PAGES(size)             (((size) + ((pool.pagesize) - 1)) & ~((pool.pagesize) - 1))

#define BIT_IS_FREE(word, bit)   (((word) >> (bit)) & 1)
#define MARK_BIT_USED(word, bit) ((word) &= ~(1ULL << (bit)))
#define MARK_BIT_FREE(word, bit) ((word) |= (1ULL << (bit)))
#define FIND_FREE_BIT(word)      ((uint64_t)(word) & -(uint64_t)(word))
#define STRLEN(s)                (sizeof(s) - 1)

#define IOVEC_NBLOCKS (BYTES_TO_BLOCKS(NIOS * sizeof(struct iovec)))
#define MSG_NBLOCKS   (BYTES_TO_BLOCKS(sizeof(struct msghdr)))
#define ZC_RES        KB *KB

#define DEBUG 0
#if DEBUG
#define LOG(...) fprintf(logfd, __VA_ARGS__)
#else
#define LOG(...) ((void)0)
#endif

typedef enum UOP {
  WRITEV = IORING_OP_WRITEV,
  SENDMSG = IORING_OP_SENDMSG,
  RECVMSG = IORING_OP_RECVMSG,
  ACCEPT = IORING_OP_ACCEPT,
  SEND = IORING_OP_SEND,
  RECV = IORING_OP_RECV,
  SENDZC = IORING_OP_SEND_ZC,
  SENDMSGZC = IORING_OP_SENDMSG_ZC,
  PEEK = 50,
  FRECVMSG,
  INSPLICE,
  OUTSPLICE
} UOP;

typedef enum CFS {
  CF_IN_POOL = (1 << 0),       // Connection is in the pool
  CF_IN_HEAP = (1 << 1),       // Connection is in the heap
  CF_SKIP_SOCK = (1 << 2),     // Don't close the socket
  CF_USE_ONCE = (1 << 3),      // Destroy after using
  CF_HANDLER_READY = (1 << 4), // Ready to call the handler
} CFS;

typedef struct conn_t {
  // Socket file descriptor
  int fd;

  // Amount of data left in the current operation
  uint64_t data_left;

  // The index of the connection struct
  uint32_t cindex;

  // The last time the connection was readable
  uint64_t last_read;

  // The last time the connection was writeable
  uint64_t last_write;

  // The operation currently being processed
  uint8_t op;

  // Connection flags
  int flags;

  // Splice fd_in
  int in_fd;

  // Splice fd_out
  int out_fd;

  void *recv_conn;
  void *send_conn;

  struct iovec *ios;
  struct iovec *rec;
  uint16_t nios;

  struct msghdr *msg;
  uint16_t zc_notifs;

  uint16_t head_size;
} conn_t;

typedef struct MPool {
  // The allocated pool of blocks
  void *bpool;

  // The allocated pool of connections
  conn_t *cpool;

  // The size of the pool in pages
  uint32_t npages;

  // The size of the pool in blocks
  uint32_t nblocks;

  // The locations of each page in the pool
  void **blocks;

  // The availability of each block
  uint64_t *freebs;

  // The locations of each conn in the pool
  conn_t **conns;

  // The availability of each conn
  uint64_t *freecs;

  // Clean up callback function
  void (*callback)(conn_t *conn);

  // The page size used
  uint32_t pagesize;

  // Socket read timeout
  uint32_t rtimeout;

  // Socket write timeout
  uint32_t wtimeout;
} MPool;

extern int pipe_sz;
extern int pipe_in, pipe_out, nullfd;
extern FILE *logfd;
extern struct io_uring ring;
extern MPool pool;
extern conn_t *current_recv;
extern conn_t *current_send;

/*
 * Prepare and submit a recv uring op
 */
static inline int urecv(conn_t *conn, void *buffer, size_t buff_size, int flags) {
  if (!conn || conn->fd == -1)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (flags == MSG_PEEK) ? PEEK : RECV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;

  io_uring_prep_recv(sqe, conn->fd, buffer, buff_size, flags);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a multi-shot accept uring op
 */
static inline int umaccept(int listenfd) {
  if (listenfd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = ACCEPT;
  io_uring_prep_multishot_accept(sqe, listenfd, NULL, NULL, SOCK_NONBLOCK);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a splice uring op
 */
static inline int usplice(conn_t *conn, int fd_in, int64_t off_in, int fd_out, int64_t off_out, size_t len) {
  if (!len || !conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = (__u64)conn;
  io_uring_prep_splice(sqe, fd_in, off_in, fd_out, off_out, len, 0);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a writev uring op
 */
static inline int uwritev(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = WRITEV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  io_uring_prep_writev(sqe, conn->fd, &conn->ios[iov_index], nios, -1);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a send uring op
 */
static inline int usend(conn_t *conn, char *res_buff, size_t buff_size, bool zc) {
  if (!conn || conn->fd <= 0 || buff_size == 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (zc) ? SENDZC : SEND;
  conn->data_left = buff_size;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  if (zc)
    io_uring_prep_send_zc(sqe, conn->fd, res_buff, buff_size, 0, 0);
  else
    io_uring_prep_send(sqe, conn->fd, res_buff, buff_size, 0);
  return io_uring_submit(&ring);
}

static inline int ufrecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = FRECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;

  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, rec->iov_len);
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int urecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = RECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int usendmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  bool zc = (conn->data_left > ZC_RES) ? true : false;
  conn->op = (zc) ? SENDMSGZC : SENDMSG;

  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  if (zc) {
    io_uring_prep_sendmsg_zc(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
    conn->zc_notifs++;
  } else {
    io_uring_prep_sendmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  }
  return io_uring_submit(&ring);
}

/*
 * Create and initialize a server socket
 */
static inline int tcp_listen(uint16_t port) {
  int enable;
  int listenfd;
  if ((listenfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    return -1;

  int flags = fcntl(listenfd, F_GETFL, 0);
  fcntl(listenfd, F_SETFL, flags | O_NONBLOCK);
  struct sockaddr_in servaddr;
  memset(&servaddr, 0, sizeof(servaddr));
  servaddr.sin_family = AF_INET;
  servaddr.sin_addr.s_addr = INADDR_ANY;
  servaddr.sin_port = htons(port);

  enable = 1;
  if (setsockopt(listenfd, SOL_SOCKET, SO_REUSEPORT, &enable, sizeof(enable)) < 0)
    return -1;

  if (bind(listenfd, (struct sockaddr *)&servaddr, sizeof(servaddr)) < 0)
    return -1;

  if (listen(listenfd, SOMAXCONN) < 0)
    return -1;

  return listenfd;
}

/*
 * Calculate the difference between two pointers
 */
static inline uintptr_t ptr_diff(uintptr_t p1, uintptr_t p2) { return (uintptr_t)(p1 > p2) ? (p1 - p2) : (p2 - p1); }

static inline size_t get_nroutes(Route *routes) {
  Route *route;
  for (size_t i = 0;; i++) {
    route = &routes[i];
    if (!route->path && !route->handler && !route->method)
      return i;
  }
}

static inline long get_content_length(char *src, char *end) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return -1;
    key = line;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, "Content-Length") != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;

    *line_end = '\0';
    long res = atol(value);
    *line_end = '\r';

    return res;
  }
  return -1;
}

static inline bool have_header(char *src, char *end, const char *header_key, const char *header_value) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    key = line;
    while (*key == ' ')
      key++;
    while (*header_key == ' ')
      header_key++;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return false;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, header_key) != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;
    while (*header_value == ' ')
      header_value++;

    *line_end = '\0';
    bool res = (strcasecmp(value, header_value) == 0);
    *line_end = '\r';

    return res;
  }

  return false;
}

static inline const char *method_str(Method method) {
  switch (method) {
  case GET:
    return "GET";
    break;
  case HEAD:
    return "HEAD";
    break;
  case POST:
    return "POST";
    break;
  case PUT:
    return "PUT";
    break;
  case DELETE:
    return "DELETE";
    break;
  case CONNECT:
    return "CONNECT";
    break;
  case OPTIONS:
    return "OPTIONS";
    break;
  case TRACE:
    return "TRACE";
    break;
  case PATCH:
    return "PATCH";
    break;
  default:
    return NULL;
  }
}

static inline uint8_t method_len(Method method) {
  switch (method) {
  case GET:
    return 3;
    break;
  case HEAD:
    return 4;
    break;
  case POST:
    return 4;
    break;
  case PUT:
    return 3;
    break;
  case DELETE:
    return 6;
    break;
  case CONNECT:
    return 7;
    break;
  case OPTIONS:
    return 7;
    break;
  case TRACE:
    return 5;
    break;
  case PATCH:
    return 5;
    break;
  default:
    return 0;
  }
}

static inline size_t round_to_blocks(size_t size) {
  size_t nblocks = BYTES_TO_BLOCKS(size);
  nblocks = CEIL_BLOCKS(nblocks);
  return nblocks;
}

/*
 * Count the digits in unsigned 64-bit int
 */
static inline int countd(uint64_t num) {
  if (num < 10ULL)
    return 1;
  if (num < 100ULL)
    return 2;
  if (num < 1000ULL)
    return 3;
  if (num < 10000ULL)
    return 4;
  if (num < 100000ULL)
    return 5;
  if (num < 1000000ULL)
    return 6;
  if (num < 10000000ULL)
    return 7;
  if (num < 100000000ULL)
    return 8;
  if (num < 1000000000ULL)
    return 9;
  if (num < 10000000000ULL)
    return 10;
  if (num < 100000000000ULL)
    return 11;
  if (num < 1000000000000ULL)
    return 12;
  if (num < 10000000000000ULL)
    return 13;
  if (num < 100000000000000ULL)
    return 14;
  if (num < 1000000000000000ULL)
    return 15;
  if (num < 10000000000000000ULL)
    return 16;
  if (num < 100000000000000000ULL)
    return 17;
  if (num < 1000000000000000000ULL)
    return 18;
  if (num < 10000000000000000000ULL)
    return 19;
  return 20;
}

/*
 * Get the time elabsed in ms
 */
static inline uint64_t get_time() {
  struct timespec ts;
  clock_gettime(CLOCK_MONOTONIC, &ts);
  return (uint64_t)(ts.tv_sec) * 1000 + (ts.tv_nsec / 1000000);
}

static inline FILE *log_init(const char *path) {
  FILE *res = fopen(path, "a+");
  setvbuf(res, NULL, _IONBF, 0);
  return res;
}

static inline int16_t pollevs(int connfd) {
  struct pollfd pfd;
  pfd.fd = connfd;
  pfd.events = POLLIN | POLLOUT | POLLERR;
  int res = poll(&pfd, 1, 0);
  if (res < 0)
    return POLLERR;
  return pfd.revents;
}

// FIXME This needs to be updated
static inline conn_t *MP_use_once(size_t nblocks, int fd) {

  void *mem = malloc(sizeof(conn_t) + 8 + (IOVEC_NBLOCKS * MP_BLOCK));
  struct conn_t *conn = (conn_t *)mem;
  memset(conn, 0, sizeof(conn_t));
  conn->ios = mem + sizeof(conn_t) + 8;

  if (nblocks > 0) {
    struct iovec *iov = &conn->ios[conn->nios++];
    mem = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (mem == MAP_FAILED)
      return NULL;
    iov->iov_base = mem;
    iov->iov_len = ALIGN_TO_PAGESIZE(nblocks * MP_BLOCK);
  }

  conn->flags |= CF_IN_HEAP;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;

  return conn;
}

static inline int find_freec() {
  uint64_t *word;
  size_t map_size = (sizeof(uint64_t) * 8);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    word = &pool.freecs[i / map_size];

    if (*word == 0) { // All used
      i += (map_size - 1);
      continue;
    }

    i += __builtin_ctzll(*word);
    MARK_BIT_USED(*word, i);
    return i;
  }

  return -1;
}

static inline int MP_init(size_t npages) {
  if (!npages)
    return -1;

  /*** Setup ***/
  pool.npages = npages;
  pool.pagesize = sysconf(_SC_PAGESIZE);

  /*** Pool ***/
  pool.bpool = mmap(NULL, pool.npages * pool.pagesize, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  if (pool.bpool == MAP_FAILED)
    return -1;
  pool.nblocks = (pool.npages * pool.pagesize) / MP_BLOCK;

  /*** Blocks ***/
  pool.blocks = malloc(sizeof(void *) * pool.nblocks);
  if (!pool.blocks)
    return -1;
  for (size_t i = 0; i < pool.nblocks; i++)
    pool.blocks[i] = pool.bpool + (i * MP_BLOCK);

  /*** Freebs ***/
  // if (posix_memalign((void **)&pool.freebs, 64, bitmap_size * sizeof(uint64_t)) < 0)
  size_t bitmap_size = (pool.nblocks + 63) / 64;
  pool.freebs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freebs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freebs[i] = UINT64_MAX;

  /*** Cpool ***/
  pool.cpool = (conn_t *)malloc(sizeof(conn_t) * MAX_CONNS);
  if (!pool.cpool)
    return -1;

  /*** Conns ***/
  pool.conns = (conn_t **)malloc(sizeof(conn_t *) * MAX_CONNS);
  if (!pool.conns)
    return -1;
  size_t conn_size = sizeof(conn_t);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    pool.conns[i] = (conn_t *)((char *)pool.cpool + (i * conn_size));
    pool.conns[i]->fd = -1;
    pool.conns[i]->in_fd = -1;
    pool.conns[i]->out_fd = -1;
  }

  /*** Freecs ***/
  bitmap_size = (MAX_CONNS + 63) / 64;
  pool.freecs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freecs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freecs[i] = UINT64_MAX;

  return 0;
}

static inline int MP_use_blks(size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t max_start = pool.nblocks - nblocks;
  size_t full_chunks = (nblocks / 64) * 64;

  for (size_t i = 0, c = 0; i <= max_start; i++, c++) {
    bool free = true;

    for (size_t j = 0; j < full_chunks; j += 64) {
      size_t word_index = (i + j) / 64;
      if (pool.freebs[word_index] != UINT64_MAX) {
        free = false;
        i += 63;
        break;
      }
    }

    for (size_t j = full_chunks; j < nblocks; j++) {
      size_t bit_index = i + j;
      size_t word_index = bit_index / 64;
      size_t bit_in_word = bit_index % 64;

      if (!BIT_IS_FREE(pool.freebs[word_index], bit_in_word)) {
        free = false;
        i += j;
        break;
      }
    }

    if (free) {
      for (size_t j = 0; j < full_chunks; j += 64) {
        size_t word_index = (i + j) / 64;
        pool.freebs[word_index] = 0;
      }

      for (size_t j = full_chunks; j < nblocks; j++) {
        size_t bit_index = i + j;
        size_t word_index = bit_index / 64;
        size_t bit_in_word = bit_index % 64;

        MARK_BIT_USED(pool.freebs[word_index], bit_in_word);
      }

      return i;
    }
  }

  return -1;
}

static inline int MP_free_blks(size_t bindex, size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t full_chunks = (nblocks / 64) * 64;
  for (size_t i = 0; i < full_chunks; i += 64) {
    size_t word_index = (bindex + i) / 64;
    pool.freebs[word_index] = UINT64_MAX;
  }

  for (size_t i = full_chunks; i < nblocks; i++) {
    size_t bit_index = bindex + i;
    size_t word_index = bit_index / 64;
    size_t bit_in_word = bit_index % 64;

    MARK_BIT_FREE(pool.freebs[word_index], bit_in_word);
  }

  memset(pool.blocks[bindex], 0, nblocks * MP_BLOCK);
  return 0;
}

static inline conn_t *MP_use(size_t nblocks, int fd, bool once) {
  if (fd <= 0)
    return NULL;
  if (once)
    return MP_use_once(nblocks, fd);

  int cindex = find_freec();
  if (cindex < 0) {
    LOG("Err: cindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  conn_t *conn = pool.conns[cindex];

  int ios_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (ios_bindex < 0) {
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }

  struct iovec *ios = pool.blocks[ios_bindex];
  conn->ios = ios;

  int rec_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (rec_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct iovec *rec = pool.blocks[rec_bindex];
  conn->rec = rec;

  int msg_bindex = MP_use_blks(MSG_NBLOCKS);
  if (msg_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct msghdr *msg = pool.blocks[msg_bindex];
  conn->msg = msg;

  if (nblocks > 0) {
    int bindex = MP_use_blks(nblocks);
    if (bindex < 0) {
      MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
      MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
      MP_free_blks(msg_bindex, IOVEC_NBLOCKS);
      MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
      LOG("Err: bindex < 0; will use MP_use_once\n");
      return MP_use_once(nblocks, fd);
    }

    size_t iov_index = conn->nios++;
    struct iovec *iov = &conn->ios[iov_index];
    struct iovec *rec = &conn->rec[iov_index];
    iov->iov_base = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
  }

  conn->msg->msg_iov = conn->ios;
  conn->msg->msg_iovlen = conn->nios;
  conn->cindex = cindex;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;
  return conn;
}

static inline void MP_shed(conn_t *conn, size_t iov_index, size_t nios) {
  struct iovec *iov, *rec;
  size_t bindex, nblocks, index;

  for (size_t i = 0; i < nios; i++) {
    index = iov_index + i;
    iov = &conn->ios[index];
    rec = &conn->rec[index];
    if (!rec || !rec->iov_base)
      continue;
    if (!IN_POOL(rec->iov_base)) {
      munmap(rec->iov_base, rec->iov_len / pool.pagesize);
    } else {
      bindex = ptr_diff((uintptr_t)rec->iov_base, (uintptr_t)pool.bpool) / MP_BLOCK;
      nblocks = rec->iov_len / MP_BLOCK;
      MP_free_blks(bindex, nblocks);
    }
    memset(iov, 0, sizeof(struct iovec));
    memset(rec, 0, sizeof(struct iovec));
    conn->nios--;
  }
}

static inline int MP_expand(conn_t *conn, size_t nblocks, bool once) {
  void *bptr;
  int iov_index, bindex;
  struct iovec *iov, *rec;

  iov_index = conn->nios++;
  iov = &conn->ios[iov_index];
  rec = &conn->rec[iov_index];

  if (nblocks == 0)
    return iov_index;

  if (once) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_base = bptr;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
    return iov_index;
  }

  bindex = MP_use_blks(nblocks);
  if (bindex < 0) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_len = iov->iov_len;
  } else {
    bptr = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_len = iov->iov_len;
  }

  iov->iov_base = bptr;
  rec->iov_base = iov->iov_base;
  return iov_index;
}

static inline int MP_free(conn_t *conn) {
  if (!conn)
    return -1;
  size_t bindex, nblocks;
  uint64_t *word;

  MP_shed(conn, 0, conn->nios);
  if (conn->flags & CF_IN_HEAP) {
    if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
      close(conn->fd);
    free(conn);
    return 0;
  }

  word = &pool.freecs[conn->cindex / 64];
  if (conn->cindex > MAX_CONNS)
    return -1;
  else if (BIT_IS_FREE(*word, conn->cindex))
    return 0;

  bindex = ptr_diff((uintptr_t)conn->ios, (uintptr_t)pool.bpool) / MP_BLOCK;
  nblocks = IOVEC_NBLOCKS;
  MP_free_blks(bindex, nblocks);

  bindex = ptr_diff((uintptr_t)conn->rec, (uintptr_t)pool.bpool) / MP_BLOCK;
  MP_free_blks(bindex, nblocks);

  if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
    close(conn->fd);

  MARK_BIT_FREE(*word, conn->cindex);
  memset(conn, 0, sizeof(conn_t));
  conn->fd = -1;
  conn->in_fd = -1;
  conn->out_fd = -1;
  return 0;
}

static inline void MP_clear(conn_t *conn) {
  conn_t *recv_conn = conn->recv_conn;
  conn_t *send_conn = conn->send_conn;
  if (recv_conn)
    MP_free(recv_conn);
  if (send_conn)
    MP_free(send_conn);
}

static inline void MP_exit(MPool *pool) {
  munmap(pool->bpool, pool->npages);
  free(pool->cpool);
  free(pool->blocks);
  free(pool->conns);
  free(pool->freebs);
  free(pool->freecs);
}

static inline void MP_timeout() {
  conn_t *conn;
  int16_t res;
  uint64_t now;
  size_t windex = 0;
  uint64_t *word = &pool.freecs[0];
  for (size_t i = 0; i < MAX_CONNS; i++) {
    if ((i / 64) < windex)
      word = &pool.freecs[++windex];

    if (*word == UINTMAX_MAX) {
      i = (i / 64) * 64 + 64;
      continue;
    }

    conn = pool.conns[i];
    if (!conn || conn->fd == -1)
      continue;

    res = pollevs(conn->fd);

    now = get_time();
    if (res & POLLERR) {
      MP_clear(conn);
      continue;
    }
    if (res & POLLIN) {
      if (pool.rtimeout > 0 && (now - conn->last_read) >= pool.rtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (res & POLLOUT) {
      if (pool.wtimeout > 0 && (now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (!(res & POLLIN || res & POLLOUT)) {
      if ((pool.rtimeout > 0 && now - conn->last_read) >= pool.rtimeout
          || (pool.wtimeout > 0 && now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
  }
}

/*
 * Calculate the length of a status string
 */
static inline size_t status_len(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return 8;
  case STATUSSWITCHINGPROTOCOLS:
    return 19;
  case STATUSPROCESSING:
    return 10;
  case STATUSEARLYHINTS:
    return 11;
  case STATUSOK:
    return 2;
  case STATUSCREATED:
    return 7;
  case STATUSACCEPTED:
    return 8;
  case STATUSNONAUTHORITATIVE:
    return 29;
  case STATUSNOCONTENT:
    return 10;
  case STATUSRESETCONTENT:
    return 13;
  case STATUSPARTIALCONTENT:
    return 15;
  case STATUSMULTISTATUS:
    return 12;
  case STATUSALREADYREPORTED:
    return 16;
  case STATUSIMUSED:
    return 7;
  case STATUSMULTIPLECHOICES:
    return 16;
  case STATUSMOVEDPERMANENTLY:
    return 17;
  case STATUSFOUND:
    return 5;
  case STATUSSEEOTHER:
    return 9;
  case STATUSNOTMODIFIED:
    return 12;
  case STATUSUSEPROXY:
    return 9;
  case STATUSTEMPORARYREDIRECT:
    return 18;
  case STATUSPERMANENTREDIRECT:
    return 18;
  case STATUSBADREQUEST:
    return 11;
  case STATUSUNAUTHORIZED:
    return 12;
  case STATUSPAYMENTREQUIRED:
    return 16;
  case STATUSFORBIDDEN:
    return 9;
  case STATUSNOTFOUND:
    return 9;
  case STATUSMETHODNOTALLOWED:
    return 18;
  case STATUSNOTACCEPTABLE:
    return 14;
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return 29;
  case STATUSREQUESTTIMEOUT:
    return 15;
  case STATUSCONFLICT:
    return 8;
  case STATUSGONE:
    return 4;
  case STATUSLENGTHREQUIRED:
    return 15;
  case STATUSPRECONDITIONFAILED:
    return 19;
  case CONTENTTOOLARGE:
    return 17;
  case STATUSURITOOLONG:
    return 12;
  case STATUSUNSUPPORTEDMEDIATYPE:
    return 22;
  case STATUSRANGENOTSATISFIABLE:
    return 21;
  case STATUSEXPECTATIONFAILED:
    return 18;
  case STATUSMISDIRECTEDREQUEST:
    return 19;
  case STATUSUNPROCESSABLECONTENT:
    return 21;
  case STATUSLOCKED:
    return 6;
  case STATUSFAILEDDEPENDENCY:
    return 17;
  case STATUSTOOEARLY:
    return 9;
  case STATUSUPGRADEREQUIRED:
    return 16;
  case STATUSPRECONDITIONREQUIRED:
    return 21;
  case STATUSTOOMANYREQUESTS:
    return 17;
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return 31;
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return 29;
  case STATUSInternalServerError:
    return 21;
  case STATUSNOTIMPLEMENTED:
    return 15;
  case STATUSBADGATEWAY:
    return 11;
  case STATUSSERVICEUNAVAILABLE:
    return 19;
  case STATUSGATEWAYTIMEOUT:
    return 15;
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return 26;
  case STATUSVARIANTALSONEGOTIATES:
    return 23;
  case STATUSINSUFFICIENTSTORAGE:
    return 20;
  case STATUSLOOPDETECTED:
    return 13;
  case STATUSNOTEXTENDED:
    return 12;
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return 31;
  default:
    return 0;
  }
}

/*
 * Return the status code string as string literal
 */
static inline char *status_str(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return "Continue";
  case STATUSSWITCHINGPROTOCOLS:
    return "Switching Protocols";
  case STATUSPROCESSING:
    return "Processing";
  case STATUSEARLYHINTS:
    return "Early Hints";
  case STATUSOK:
    return "OK";
  case STATUSCREATED:
    return "Created";
  case STATUSACCEPTED:
    return "Accepted";
  case STATUSNONAUTHORITATIVE:
    return "Non-Authoritative Information";
  case STATUSNOCONTENT:
    return "No Content";
  case STATUSRESETCONTENT:
    return "Reset Content";
  case STATUSPARTIALCONTENT:
    return "Partial Content";
  case STATUSMULTISTATUS:
    return "Multi-Status";
  case STATUSALREADYREPORTED:
    return "Already Reported";
  case STATUSIMUSED:
    return "Im Used";
  case STATUSMULTIPLECHOICES:
    return "Multiple Choices";
  case STATUSMOVEDPERMANENTLY:
    return "Moved Permanently";
  case STATUSFOUND:
    return "Found";
  case STATUSSEEOTHER:
    return "See Other";
  case STATUSNOTMODIFIED:
    return "Not Modified";
  case STATUSUSEPROXY:
    return "Use Proxy";
  case STATUSTEMPORARYREDIRECT:
    return "Temporary Redirect";
  case STATUSPERMANENTREDIRECT:
    return "Permanent Redirect";
  case STATUSBADREQUEST:
    return "Bad Request";
  case STATUSUNAUTHORIZED:
    return "Unauthorized";
  case STATUSPAYMENTREQUIRED:
    return "Payment Required";
  case STATUSFORBIDDEN:
    return "Forbidden";
  case STATUSNOTFOUND:
    return "Not Found";
  case STATUSMETHODNOTALLOWED:
    return "Method Not Allowed";
  case STATUSNOTACCEPTABLE:
    return "Not Acceptable";
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return "Proxy Authentication Required";
  case STATUSREQUESTTIMEOUT:
    return "Request Timeout";
  case STATUSCONFLICT:
    return "Conflict";
  case STATUSGONE:
    return "Gone";
  case STATUSLENGTHREQUIRED:
    return "Length Required";
  case STATUSPRECONDITIONFAILED:
    return "Precondition Failed";
  case CONTENTTOOLARGE:
    return "Content Too Large";
  case STATUSURITOOLONG:
    return "URI Too Long";
  case STATUSUNSUPPORTEDMEDIATYPE:
    return "Unsupported Media Type";
  case STATUSRANGENOTSATISFIABLE:
    return "Range Not Satisfiable";
  case STATUSEXPECTATIONFAILED:
    return "Expectation Failed";
  case STATUSMISDIRECTEDREQUEST:
    return "Misdirected Request";
  case STATUSUNPROCESSABLECONTENT:
    return "Unprocessable Content";
  case STATUSLOCKED:
    return "Locked";
  case STATUSFAILEDDEPENDENCY:
    return "Failed Dependency";
  case STATUSTOOEARLY:
    return "Too Early";
  case STATUSUPGRADEREQUIRED:
    return "Upgrade Required";
  case STATUSPRECONDITIONREQUIRED:
    return "Precondition Required";
  case STATUSTOOMANYREQUESTS:
    return "Too Many Requests";
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return "Request Header Fields Too Large";
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return "Unavailable For Legal Reasons";
  case STATUSInternalServerError:
    return "Internal Server Error";
  case STATUSNOTIMPLEMENTED:
    return "Not Implemented";
  case STATUSBADGATEWAY:
    return "Bad Gateway";
  case STATUSSERVICEUNAVAILABLE:
    return "Service Unavailable";
  case STATUSGATEWAYTIMEOUT:
    return "Gateway Timeout";
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return "HTTP Version Not Supported";
  case STATUSVARIANTALSONEGOTIATES:
    return "Variant Also Negotiates";
  case STATUSINSUFFICIENTSTORAGE:
    return "Insufficient Storage";
  case STATUSLOOPDETECTED:
    return "Loop Detected";
  case STATUSNOTEXTENDED:
    return "Not Extended";
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return "Network Authentication Required";
  default:
    return 0;
  }
}

/*
 * Return true if routes match
 */
static inline bool route_equ(Route *route, Request *req) {
  return route->method == req->method && strncmp(route->path, req->path, strlen(route->path)) == 0;
}

/*
 * Return the matching route index on success. -1 on failure
 */
static inline int match_route(Server *serv, Request *req) {
  for (size_t i = 0; i < serv->_nroutes; i++) {
    Route route = serv->routes[i];
    if (!req->path || !route.path)
      continue;
    if (route_equ(&route, req))
      return i;
    else if (req->method == HEAD && route.method == GET && strcmp(route.path, req->path) == 0)
      return i;
  }
  return -1;
}

/*
 * Return true if the response should contain the Content-Length header
 */
static inline bool should_have_content_length(Request *req, ResWriter *res) {
  return (req->method != CONNECT              // CONNECT request
          && res->status != STATUSNOCONTENT   // 204 response
          && res->status != STATUSNOTMODIFIED // 304 response
          && res->status >= 200);             // 1xx response
}

/*
 * Format http response from the ResWriter.
 * Return response size on success, 0 on failure.
 */
static inline size_t fmt_res(Request *req, ResWriter *res, char *buffer, size_t buffer_size) {
  if (!res || !buffer || buffer_size == 0)
    return 0;

  size_t res_len, total = 0;
  char *dst = buffer;
  size_t maxlen = buffer_size;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t body_length = res->len;

  res_len = snprintf(dst, maxlen, "HTTP/1.1 %d %s", (int)res->status, status_str(res->status));
  total += res_len;
  dst += res_len;
  maxlen -= res_len;

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    res_len = snprintf(dst, maxlen, "\r\n%s: %s", header->key, header->value);
    total += res_len;
    dst += res_len;
    maxlen -= res_len;
  }

  if (have_content_length) {
    res_len = snprintf(dst, maxlen, "\r\nContent-Length: %lu", body_length);
    total += res_len, dst += res_len, maxlen -= res_len;
  }

  memcpy(dst, "\r\n\r\n", 4);
  total += 4, dst += 4, maxlen -= 4;

  return total;
}

static inline size_t res_len(Request *req, ResWriter *res) {
  if (!req || !res)
    return 0;

  if (!res->status)
    res->status = STATUSOK;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t result = 0;
  result += STRLEN("HTTP/1.1 ");     // HTTP version
  result += 4;                       // Status code + space
  result += status_len(res->status); // Status name

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    result += 2;                       // "\r\n"
    result += strlen(header->key) + 2; // Header key + ':' + space
    result += strlen(header->value);   // header value
  }

  if (have_content_length) {
    result += 2;                          // "\r\n"
    result += STRLEN("Content-Length: "); // Header key
    result += countd(res->len);           // Header value
  }

  result += 4; // "\r\n\r\n"

  return result;
}

static inline int send_empty_res(Status status) {
  size_t res_len = STRLEN("HTTP/1.1 ")        // HTTP version
                   + countd((uint64_t)status) // status code
                   + 1                        // space
                   + (int)status_len(status)  // status string
                   + 4;                       // \r\n\r\n

  conn_t *conn = current_send;
  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, res_len);
  if (snprintf((char *)rec->iov_base, res_len + 1, "HTTP/1.1 %d %s\r\n\r\n", (int)status, status_str(status))
      != (int)res_len)
    return -1;

  return usendmsg(conn, 0, 1);
}

static inline ssize_t read_socket(int sockfd, size_t len) {
  if (len == 0 || sockfd <= 0)
    return 0;
  char buff[1024 * 8];
  return read(sockfd, buff, 1024 * 8);
}

static inline int read_method(Method *method, void *src) {
  if (memcmp(src, "GET", 3) == 0)
    *method = GET;
  else if (memcmp(src, "POST", 4) == 0)
    *method = POST;
  else if (memcmp(src, "HEAD", 4) == 0)
    *method = HEAD;
  else if (memcmp(src, "PUT", 3) == 0)
    *method = PUT;
  else if (memcmp(src, "DELETE", 6) == 0)
    *method = DELETE;
  else if (memcmp(src, "CONNECT", 7) == 0)
    *method = CONNECT;
  else if (memcmp(src, "OPTIONS", 7) == 0)
    *method = OPTIONS;
  else if (memcmp(src, "TRACE", 5) == 0)
    *method = TRACE;
  else if (memcmp(src, "PATCH", 5) == 0)
    *method = PATCH;
  else
    return -1;

  return 0;
}

static inline int sendmsg_res(Request *req, ResWriter *res) {
  conn_t *conn;
  size_t head_size, res_size;
  struct iovec *iov;

  conn = current_send;
  iov = &conn->ios[0];
  head_size = res_len(req, res);
  if (head_size == 0)
    return -1;

  conn->data_left += head_size;
  res_size = fmt_res(req, res, iov->iov_base, (head_size + 1));
  if (res_size != head_size)
    return -1;
  iov->iov_len = res_size;

  return usendmsg(conn, 0, conn->nios);
}

static inline int read_req(Request *req, char *req_buffer) {
  if (!req_buffer)
    return -1;
  /*** Method ***/
  char *sep = strchr(req_buffer, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }
  *sep = '\0';
  if (read_method(&req->method, req_buffer) < 0)
    return -1;

  /*** Path ***/
  char *fullpath = sep + 1;
  sep = strchr(fullpath, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }

  *sep = '\0';
  req->path = fullpath;
  /*** Params ***/
  char *paramStart = strchr(fullpath, '?');
  if (paramStart) {
    *paramStart++ = '\0';
    int params_count = 0;
    params_count = HK_parse_params(paramStart, req->params, MAX_URL_PARAMETERS);
    if (params_count > 0)
      req->params_count = params_count;
    else
      req->params_count = 0;
  } else {
    req->params = NULL;
    req->params_count = 0;
  }

  /*** Headers ***/
  char *headStart = strstr(sep + 1, "\r\n");
  char *headEnd = strstr(sep + 1, "\r\n\r\n");
  if (!headStart) {
    LOG("read_req: !headStart\n");
    return -1;
  };

  memset(headStart, 0, 2);
  headStart += 2;
  memset(headEnd, 0, 4);
  headEnd += 4;

  int headers_count = HK_parse_headers(headStart, req->headers, MAX_REQ_HEADERS);
  if (headers_count <= 0)
    return -1;
  req->headers_count = headers_count;

  /*** Host ***/
  int index = HK_get_header(req, "Host");
  if (index < 0)
    return -1;
  char *host = req->headers[index].value;
  req->hostname = host;

  /*** Port ***/
  char *colon = strchr(host, ':');
  if (colon) {
    *colon++ = '\0';
    req->port = atoi(colon);
  } else {
    req->port = PORT;
  }
  return 0;
}
static inline int process_req(Server *serv, conn_t *conn) {
  if (!conn || conn->fd == -1)
    return -1;

  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;
  if (read_req(&req, conn->ios[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    LOG("Err: route_index == -1\n");
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;
  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  sendmsg_res(&req, &res);

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int new_conn(int connfd) {
  if (connfd <= 0)
    return -1;

  current_recv = MP_use(KB * 2, connfd, false);
  current_send = MP_use(KB * 2, connfd, false);

  current_recv->recv_conn = current_recv;
  current_recv->send_conn = current_send;

  current_send->send_conn = current_send;
  current_send->recv_conn = current_recv;

  conn_t *conn = current_recv;
  if (ufrecvmsg(conn, 0, 1) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

static inline int resubmit_sendmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return usendmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int resubmir_recvmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    // FIXME the len should be increased
    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return urecvmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int handle_sendmsg_complete(conn_t *conn) {
  struct iovec *iov, *rec;

  MP_shed(conn, 1, conn->nios - 1);
  iov = &conn->ios[0];
  rec = &conn->rec[0];
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;

  return ufrecvmsg(conn->recv_conn, 0, 1);
}

static inline int handle_sendmsg(conn_t *conn, int res, bool zc) {
  if (!conn || conn->fd == -1)
    return -1;

  conn->data_left -= res;
  if (conn->data_left > 0)
    return resubmit_sendmsg(conn, res);

  if (zc)
    return 0;

  return handle_sendmsg_complete(conn);
}

static inline int handle_insplice(conn_t *conn) {
  conn->op = OUTSPLICE;
  return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
}
static inline int handle_outsplice(conn_t *conn, int res) {
  conn->data_left -= res;
  if (conn->data_left > 0) {
    conn->op = INSPLICE;
    return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
  }

  conn_t *recv_conn = conn->recv_conn;
  struct iovec *iov = &recv_conn->ios[0];
  memset(iov->iov_base, 0, iov->iov_len);
  if (urecv(recv_conn, iov->iov_base, iov->iov_len, MSG_PEEK) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

/*
static inline int handle_recv(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  void *bptr = conn->ios[0].iov_base;
  void *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  void *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  return process_req(serv, conn);
}
*/
static inline int find_route(Server *serv, char *bptr) {
  Request req = {0};
  if (read_method(&req.method, bptr) < 0) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  };
  char *space = strchr(bptr, ' ');
  req.path = (space + 1);
  space = strchr(req.path, ' ');
  *space = '\0';
  int route_index = match_route(serv, &req);
  *space = ' ';
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }
  return route_index;
}

static inline int run_handler(Server *serv, conn_t *conn, bool uses_body) {
  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;

  if (read_req(&req, conn->rec[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  if (uses_body) {
    int h_index = HK_get_header(&req, "Content-Length");
    long body_size = atol(req.headers[h_index].value);
    if (body_size >= 0) {
      req.body.ptr = conn->rec[1].iov_base;
      req.body.size = body_size;
    } else {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    }
  }

  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  if (sendmsg_res(&req, &res) < 0)
    return -1;

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int handle_frecvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  char *bptr = (char *)conn->ios[0].iov_base;
  char *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  char *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  size_t head_size = (headEnd + 4) - bptr;
  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  int route_index = find_route(serv, bptr);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  bool uses_body = serv->routes[route_index].uses_body;
  long body_size = get_content_length(headstart + 2, headEnd + 4);
  if (body_size == -1) {
    if (uses_body) {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    } else {
      body_size = 0;
    }
  }

  conn->head_size = head_size;
  if (!uses_body) {
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  if (res == (int)(head_size + body_size)) {
    size_t iov_index = MP_expand(conn, round_to_blocks(body_size), false);
    memcpy(conn->rec[iov_index].iov_base, headEnd + 4, body_size);
    conn->ios[iov_index].iov_len = body_size;
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  conn->data_left = body_size - (res - head_size);
  bool once = ((size_t)body_size > (size_t)((pool.nblocks * MP_BLOCK) / 10));
  size_t iov_index = MP_expand(conn, round_to_blocks(body_size), once);
  memcpy(conn->rec[iov_index].iov_base, headEnd + 4, (res - head_size));
  conn->ios[iov_index].iov_base += (res - head_size);

  return urecvmsg(conn, iov_index, 1);
}

static inline int handle_recvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  if (conn->data_left > 0) {
    conn->data_left -= res;
    if (conn->data_left == 0) {
      conn->flags &= CF_HANDLER_READY;
      return run_handler(serv, conn, true);
    }

    conn->flags &= ~CF_HANDLER_READY;
    conn->ios[1].iov_base += res;
    return urecvmsg(conn, 1, 1);
  }

  conn->flags &= CF_HANDLER_READY;
  return run_handler(serv, conn, true);
}

static inline int serv_init(Server *serv) {
#if DEBUG
  logfd = log_init("log.txt");
  if (!logfd) {
    printf("log_init failed");
    return -1;
  }
#endif
  serv->_nroutes = get_nroutes(serv->routes);

  int pipefd[2];
  if (pipe(pipefd) < 0)
    return -1;
  pipe_in = pipefd[0];
  pipe_out = pipefd[1];
  nullfd = open("/dev/null", O_WRONLY);
  pipe_sz = fcntl(pipefd[0], F_GETPIPE_SZ);
  if (pipe_sz < 0)
    return -1;

  pool.rtimeout = serv->rtimeout;
  pool.wtimeout = serv->wtimeout;
  if (MP_init(MAX_CONNS * 8) < 0)
    return -1;
  LOG("pool initialized\n");

  if (io_uring_queue_init(MAX_CONNS, &ring, 0) < 0)
    return -1;
  LOG("uring initialized\n");

  int listenfd;
  if ((listenfd = tcp_listen(serv->port)) < 0)
    return -1;
  LOG("socket initialized\n");

  return umaccept(listenfd);
}

static inline int serv_listen(Server *serv) {
  // uint64_t last_check = get_time();
  while (true) {
    // uint64_t now = get_time();
    // if ((now - last_check) >= 200) {
    //   last_check = now;
    //   LOG("CM: CM_check ran\n");
    //   MP_timeout();
    // }

    LOG("SQ ready: %u, CQ ready: %u\n", io_uring_sq_ready(&ring), io_uring_cq_ready(&ring));
    struct io_uring_cqe *cqe;
    if (io_uring_wait_cqe(&ring, &cqe) < 0)
      continue;

    int res = cqe->res;
    LOG("res = %d\n", res);
    conn_t *conn = NULL;
    if (cqe->user_data > 100) {
      conn = (conn_t *)cqe->user_data;
      current_recv = (conn_t *)conn->recv_conn;
      current_send = (conn_t *)conn->send_conn;
    }

    if (res > 0) {
      if (cqe->user_data == ACCEPT) {
        LOG("new conn created\n");
        new_conn(res);
      } else if (conn && conn->fd != -1) {
        LOG("conn[%d]: conn.fd = %d; conn.op = %d\n", conn->cindex, conn->fd, conn->op);
        switch (conn->op) {
        case FRECVMSG:
          if (handle_frecvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case RECVMSG:
          if (handle_recvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case SENDMSG:
        case SENDMSGZC:
          // conn->last_write = get_time();
          bool zc = (conn->op == SENDMSGZC);
          if (handle_sendmsg(conn, res, zc) < 0)
            MP_clear(conn);
          break;
        case INSPLICE:
          if (handle_insplice(conn) < 0)
            MP_clear(conn);
          break;
        case OUTSPLICE:
          if (handle_outsplice(conn, res) < 0)
            MP_clear(conn);
          break;
        }
      }
    } else if (res == 0) {
      if (conn && conn->fd != -1) {
        switch (conn->op) {
        case SENDMSGZC:
          conn->zc_notifs--;
          if (conn->zc_notifs == 0 && handle_sendmsg_complete(conn) < 0)
            MP_clear(conn);
          break;
        case RECV:
          MP_clear(conn);
          break;
        }
      }
    } else {
      if (conn && conn->fd != -1) {
        if (res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR) {
          LOG("conn && conn->fd != -1 && res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR\n");
          MP_clear(conn);
        } else {
          LOG("res == -EAGAIN || res == -EWOULDBLOCK || res == -EINTR\n");
          conn = conn->recv_conn;
          struct iovec *iov = &conn->ios[0];
          memset(iov->iov_base, 0, iov->iov_len);
          if (urecv(conn, iov->iov_base, iov->iov_len, 0) < 0)
            MP_clear(conn);
        }
      }
    }

    LOG("uring operation seen\n");
    io_uring_cqe_seen(&ring, cqe);
  }

  io_uring_queue_exit(&ring);
  MP_exit(&pool);
  return 0;
}

/*** Helper ***/
static inline int _HK_write(void *data, size_t size) {
  size_t nblocks;
  int iov_index;
  conn_t *conn;
  struct iovec *iov;
  bool once;

  conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  nblocks = round_to_blocks(size);
  iov_index = MP_expand(conn, nblocks, once);
  iov = &conn->ios[iov_index];

  memcpy(iov->iov_base, data, size);
  iov->iov_len = size;
  conn->data_left += size;

  return 0;
}
static inline int _HK_write_body(Request *req, size_t offset, size_t size) {
  if (size > req->body.size || offset > req->body.size)
    return -1;

  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  int iov_index = MP_expand(conn, 0, false);
  struct iovec *iov = &conn->ios[iov_index];
  struct iovec *rec = &conn->rec[iov_index];
  rec->iov_base = req->body.ptr + offset;
  rec->iov_len = size;
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;
  conn->data_left += rec->iov_len;
  return 0;
}
/*
static inline int _HK_mem(size_t size, HKMem *mem) {
  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  bool once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  size_t nblocks = round_to_blocks(size);
  int iov_index = MP_expand(conn, nblocks, once);
  struct iovec *iov = &conn->ios[iov_index];
  mem->ptr = iov->iov_base;
  mem->size = iov->iov_len;
  mem->_iov_index = iov_index;
  mem->_flags = (IN_POOL(iov->iov_base)) ? CF_IN_POOL : CF_IN_HEAP;
  return 0;
}

static inline void _HK_send(HKMem *mem, size_t size) {
  conn_t *conn = current_send;
  struct iovec *iov = &conn->ios[mem->_iov_index];
  iov->iov_len = size;
  conn->data_left += size;
}
  */
#endif#define _GNU_SOURCE
#ifndef UTILS_H
#define UTILS_H

#include "hunk.h"
#include <arpa/inet.h>
#include <fcntl.h>
#include <liburing.h>
#include <netdb.h>
#include <signal.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/poll.h>
#include <sys/prctl.h>
#include <sys/socket.h>
#include <sys/sysinfo.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

#define MP_BLOCK  4
#define MAX_CONNS 4096
#define KB        1024
#define NIOS      32

#define IN_POOL(ptr)                 ((void *)ptr >= pool.bpool && (void *)ptr <= (pool.bpool + (pool.npages * pool.pagesize)))
#define ALIGN_TO_PAGESIZE(buff_size) (((buff_size) + (pool.pagesize - 1)) & ~(pool.pagesize - 1))
#define BYTES_TO_BLOCKS(buff_size)   (((buff_size) + (MP_BLOCK - 1)) / MP_BLOCK)
#define CEIL_BLOCKS(nblocks)         ((nblocks + 63) & ~63)
#define CEIL_PAGES(size)             (((size) + ((pool.pagesize) - 1)) & ~((pool.pagesize) - 1))

#define BIT_IS_FREE(word, bit)   (((word) >> (bit)) & 1)
#define MARK_BIT_USED(word, bit) ((word) &= ~(1ULL << (bit)))
#define MARK_BIT_FREE(word, bit) ((word) |= (1ULL << (bit)))
#define FIND_FREE_BIT(word)      ((uint64_t)(word) & -(uint64_t)(word))
#define STRLEN(s)                (sizeof(s) - 1)

#define IOVEC_NBLOCKS (BYTES_TO_BLOCKS(NIOS * sizeof(struct iovec)))
#define MSG_NBLOCKS   (BYTES_TO_BLOCKS(sizeof(struct msghdr)))
#define ZC_RES        KB *KB

#define DEBUG 0
#if DEBUG
#define LOG(...) fprintf(logfd, __VA_ARGS__)
#else
#define LOG(...) ((void)0)
#endif

typedef enum UOP {
  WRITEV = IORING_OP_WRITEV,
  SENDMSG = IORING_OP_SENDMSG,
  RECVMSG = IORING_OP_RECVMSG,
  ACCEPT = IORING_OP_ACCEPT,
  SEND = IORING_OP_SEND,
  RECV = IORING_OP_RECV,
  SENDZC = IORING_OP_SEND_ZC,
  SENDMSGZC = IORING_OP_SENDMSG_ZC,
  PEEK = 50,
  FRECVMSG,
  INSPLICE,
  OUTSPLICE
} UOP;

typedef enum CFS {
  CF_IN_POOL = (1 << 0),       // Connection is in the pool
  CF_IN_HEAP = (1 << 1),       // Connection is in the heap
  CF_SKIP_SOCK = (1 << 2),     // Don't close the socket
  CF_USE_ONCE = (1 << 3),      // Destroy after using
  CF_HANDLER_READY = (1 << 4), // Ready to call the handler
} CFS;

typedef struct conn_t {
  // Socket file descriptor
  int fd;

  // Amount of data left in the current operation
  uint64_t data_left;

  // The index of the connection struct
  uint32_t cindex;

  // The last time the connection was readable
  uint64_t last_read;

  // The last time the connection was writeable
  uint64_t last_write;

  // The operation currently being processed
  uint8_t op;

  // Connection flags
  int flags;

  // Splice fd_in
  int in_fd;

  // Splice fd_out
  int out_fd;

  void *recv_conn;
  void *send_conn;

  struct iovec *ios;
  struct iovec *rec;
  uint16_t nios;

  struct msghdr *msg;
  uint16_t zc_notifs;

  uint16_t head_size;
} conn_t;

typedef struct MPool {
  // The allocated pool of blocks
  void *bpool;

  // The allocated pool of connections
  conn_t *cpool;

  // The size of the pool in pages
  uint32_t npages;

  // The size of the pool in blocks
  uint32_t nblocks;

  // The locations of each page in the pool
  void **blocks;

  // The availability of each block
  uint64_t *freebs;

  // The locations of each conn in the pool
  conn_t **conns;

  // The availability of each conn
  uint64_t *freecs;

  // Clean up callback function
  void (*callback)(conn_t *conn);

  // The page size used
  uint32_t pagesize;

  // Socket read timeout
  uint32_t rtimeout;

  // Socket write timeout
  uint32_t wtimeout;
} MPool;

extern int pipe_sz;
extern int pipe_in, pipe_out, nullfd;
extern FILE *logfd;
extern struct io_uring ring;
extern MPool pool;
extern conn_t *current_recv;
extern conn_t *current_send;

/*
 * Prepare and submit a recv uring op
 */
static inline int urecv(conn_t *conn, void *buffer, size_t buff_size, int flags) {
  if (!conn || conn->fd == -1)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (flags == MSG_PEEK) ? PEEK : RECV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;

  io_uring_prep_recv(sqe, conn->fd, buffer, buff_size, flags);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a multi-shot accept uring op
 */
static inline int umaccept(int listenfd) {
  if (listenfd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = ACCEPT;
  io_uring_prep_multishot_accept(sqe, listenfd, NULL, NULL, SOCK_NONBLOCK);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a splice uring op
 */
static inline int usplice(conn_t *conn, int fd_in, int64_t off_in, int fd_out, int64_t off_out, size_t len) {
  if (!len || !conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = (__u64)conn;
  io_uring_prep_splice(sqe, fd_in, off_in, fd_out, off_out, len, 0);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a writev uring op
 */
static inline int uwritev(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = WRITEV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  io_uring_prep_writev(sqe, conn->fd, &conn->ios[iov_index], nios, -1);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a send uring op
 */
static inline int usend(conn_t *conn, char *res_buff, size_t buff_size, bool zc) {
  if (!conn || conn->fd <= 0 || buff_size == 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (zc) ? SENDZC : SEND;
  conn->data_left = buff_size;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  if (zc)
    io_uring_prep_send_zc(sqe, conn->fd, res_buff, buff_size, 0, 0);
  else
    io_uring_prep_send(sqe, conn->fd, res_buff, buff_size, 0);
  return io_uring_submit(&ring);
}

static inline int ufrecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = FRECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;

  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, rec->iov_len);
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int urecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = RECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int usendmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  bool zc = (conn->data_left > ZC_RES) ? true : false;
  conn->op = (zc) ? SENDMSGZC : SENDMSG;

  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  if (zc) {
    io_uring_prep_sendmsg_zc(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
    conn->zc_notifs++;
  } else {
    io_uring_prep_sendmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  }
  return io_uring_submit(&ring);
}

/*
 * Create and initialize a server socket
 */
static inline int tcp_listen(uint16_t port) {
  int enable;
  int listenfd;
  if ((listenfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    return -1;

  int flags = fcntl(listenfd, F_GETFL, 0);
  fcntl(listenfd, F_SETFL, flags | O_NONBLOCK);
  struct sockaddr_in servaddr;
  memset(&servaddr, 0, sizeof(servaddr));
  servaddr.sin_family = AF_INET;
  servaddr.sin_addr.s_addr = INADDR_ANY;
  servaddr.sin_port = htons(port);

  enable = 1;
  if (setsockopt(listenfd, SOL_SOCKET, SO_REUSEPORT, &enable, sizeof(enable)) < 0)
    return -1;

  if (bind(listenfd, (struct sockaddr *)&servaddr, sizeof(servaddr)) < 0)
    return -1;

  if (listen(listenfd, SOMAXCONN) < 0)
    return -1;

  return listenfd;
}

/*
 * Calculate the difference between two pointers
 */
static inline uintptr_t ptr_diff(uintptr_t p1, uintptr_t p2) { return (uintptr_t)(p1 > p2) ? (p1 - p2) : (p2 - p1); }

static inline size_t get_nroutes(Route *routes) {
  Route *route;
  for (size_t i = 0;; i++) {
    route = &routes[i];
    if (!route->path && !route->handler && !route->method)
      return i;
  }
}

static inline long get_content_length(char *src, char *end) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return -1;
    key = line;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, "Content-Length") != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;

    *line_end = '\0';
    long res = atol(value);
    *line_end = '\r';

    return res;
  }
  return -1;
}

static inline bool have_header(char *src, char *end, const char *header_key, const char *header_value) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    key = line;
    while (*key == ' ')
      key++;
    while (*header_key == ' ')
      header_key++;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return false;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, header_key) != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;
    while (*header_value == ' ')
      header_value++;

    *line_end = '\0';
    bool res = (strcasecmp(value, header_value) == 0);
    *line_end = '\r';

    return res;
  }

  return false;
}

static inline const char *method_str(Method method) {
  switch (method) {
  case GET:
    return "GET";
    break;
  case HEAD:
    return "HEAD";
    break;
  case POST:
    return "POST";
    break;
  case PUT:
    return "PUT";
    break;
  case DELETE:
    return "DELETE";
    break;
  case CONNECT:
    return "CONNECT";
    break;
  case OPTIONS:
    return "OPTIONS";
    break;
  case TRACE:
    return "TRACE";
    break;
  case PATCH:
    return "PATCH";
    break;
  default:
    return NULL;
  }
}

static inline uint8_t method_len(Method method) {
  switch (method) {
  case GET:
    return 3;
    break;
  case HEAD:
    return 4;
    break;
  case POST:
    return 4;
    break;
  case PUT:
    return 3;
    break;
  case DELETE:
    return 6;
    break;
  case CONNECT:
    return 7;
    break;
  case OPTIONS:
    return 7;
    break;
  case TRACE:
    return 5;
    break;
  case PATCH:
    return 5;
    break;
  default:
    return 0;
  }
}

static inline size_t round_to_blocks(size_t size) {
  size_t nblocks = BYTES_TO_BLOCKS(size);
  nblocks = CEIL_BLOCKS(nblocks);
  return nblocks;
}

/*
 * Count the digits in unsigned 64-bit int
 */
static inline int countd(uint64_t num) {
  if (num < 10ULL)
    return 1;
  if (num < 100ULL)
    return 2;
  if (num < 1000ULL)
    return 3;
  if (num < 10000ULL)
    return 4;
  if (num < 100000ULL)
    return 5;
  if (num < 1000000ULL)
    return 6;
  if (num < 10000000ULL)
    return 7;
  if (num < 100000000ULL)
    return 8;
  if (num < 1000000000ULL)
    return 9;
  if (num < 10000000000ULL)
    return 10;
  if (num < 100000000000ULL)
    return 11;
  if (num < 1000000000000ULL)
    return 12;
  if (num < 10000000000000ULL)
    return 13;
  if (num < 100000000000000ULL)
    return 14;
  if (num < 1000000000000000ULL)
    return 15;
  if (num < 10000000000000000ULL)
    return 16;
  if (num < 100000000000000000ULL)
    return 17;
  if (num < 1000000000000000000ULL)
    return 18;
  if (num < 10000000000000000000ULL)
    return 19;
  return 20;
}

/*
 * Get the time elabsed in ms
 */
static inline uint64_t get_time() {
  struct timespec ts;
  clock_gettime(CLOCK_MONOTONIC, &ts);
  return (uint64_t)(ts.tv_sec) * 1000 + (ts.tv_nsec / 1000000);
}

static inline FILE *log_init(const char *path) {
  FILE *res = fopen(path, "a+");
  setvbuf(res, NULL, _IONBF, 0);
  return res;
}

static inline int16_t pollevs(int connfd) {
  struct pollfd pfd;
  pfd.fd = connfd;
  pfd.events = POLLIN | POLLOUT | POLLERR;
  int res = poll(&pfd, 1, 0);
  if (res < 0)
    return POLLERR;
  return pfd.revents;
}

// FIXME This needs to be updated
static inline conn_t *MP_use_once(size_t nblocks, int fd) {

  void *mem = malloc(sizeof(conn_t) + 8 + (IOVEC_NBLOCKS * MP_BLOCK));
  struct conn_t *conn = (conn_t *)mem;
  memset(conn, 0, sizeof(conn_t));
  conn->ios = mem + sizeof(conn_t) + 8;

  if (nblocks > 0) {
    struct iovec *iov = &conn->ios[conn->nios++];
    mem = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (mem == MAP_FAILED)
      return NULL;
    iov->iov_base = mem;
    iov->iov_len = ALIGN_TO_PAGESIZE(nblocks * MP_BLOCK);
  }

  conn->flags |= CF_IN_HEAP;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;

  return conn;
}

static inline int find_freec() {
  uint64_t *word;
  size_t map_size = (sizeof(uint64_t) * 8);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    word = &pool.freecs[i / map_size];

    if (*word == 0) { // All used
      i += (map_size - 1);
      continue;
    }

    i += __builtin_ctzll(*word);
    MARK_BIT_USED(*word, i);
    return i;
  }

  return -1;
}

static inline int MP_init(size_t npages) {
  if (!npages)
    return -1;

  /*** Setup ***/
  pool.npages = npages;
  pool.pagesize = sysconf(_SC_PAGESIZE);

  /*** Pool ***/
  pool.bpool = mmap(NULL, pool.npages * pool.pagesize, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  if (pool.bpool == MAP_FAILED)
    return -1;
  pool.nblocks = (pool.npages * pool.pagesize) / MP_BLOCK;

  /*** Blocks ***/
  pool.blocks = malloc(sizeof(void *) * pool.nblocks);
  if (!pool.blocks)
    return -1;
  for (size_t i = 0; i < pool.nblocks; i++)
    pool.blocks[i] = pool.bpool + (i * MP_BLOCK);

  /*** Freebs ***/
  // if (posix_memalign((void **)&pool.freebs, 64, bitmap_size * sizeof(uint64_t)) < 0)
  size_t bitmap_size = (pool.nblocks + 63) / 64;
  pool.freebs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freebs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freebs[i] = UINT64_MAX;

  /*** Cpool ***/
  pool.cpool = (conn_t *)malloc(sizeof(conn_t) * MAX_CONNS);
  if (!pool.cpool)
    return -1;

  /*** Conns ***/
  pool.conns = (conn_t **)malloc(sizeof(conn_t *) * MAX_CONNS);
  if (!pool.conns)
    return -1;
  size_t conn_size = sizeof(conn_t);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    pool.conns[i] = (conn_t *)((char *)pool.cpool + (i * conn_size));
    pool.conns[i]->fd = -1;
    pool.conns[i]->in_fd = -1;
    pool.conns[i]->out_fd = -1;
  }

  /*** Freecs ***/
  bitmap_size = (MAX_CONNS + 63) / 64;
  pool.freecs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freecs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freecs[i] = UINT64_MAX;

  return 0;
}

static inline int MP_use_blks(size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t max_start = pool.nblocks - nblocks;
  size_t full_chunks = (nblocks / 64) * 64;

  for (size_t i = 0, c = 0; i <= max_start; i++, c++) {
    bool free = true;

    for (size_t j = 0; j < full_chunks; j += 64) {
      size_t word_index = (i + j) / 64;
      if (pool.freebs[word_index] != UINT64_MAX) {
        free = false;
        i += 63;
        break;
      }
    }

    for (size_t j = full_chunks; j < nblocks; j++) {
      size_t bit_index = i + j;
      size_t word_index = bit_index / 64;
      size_t bit_in_word = bit_index % 64;

      if (!BIT_IS_FREE(pool.freebs[word_index], bit_in_word)) {
        free = false;
        i += j;
        break;
      }
    }

    if (free) {
      for (size_t j = 0; j < full_chunks; j += 64) {
        size_t word_index = (i + j) / 64;
        pool.freebs[word_index] = 0;
      }

      for (size_t j = full_chunks; j < nblocks; j++) {
        size_t bit_index = i + j;
        size_t word_index = bit_index / 64;
        size_t bit_in_word = bit_index % 64;

        MARK_BIT_USED(pool.freebs[word_index], bit_in_word);
      }

      return i;
    }
  }

  return -1;
}

static inline int MP_free_blks(size_t bindex, size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t full_chunks = (nblocks / 64) * 64;
  for (size_t i = 0; i < full_chunks; i += 64) {
    size_t word_index = (bindex + i) / 64;
    pool.freebs[word_index] = UINT64_MAX;
  }

  for (size_t i = full_chunks; i < nblocks; i++) {
    size_t bit_index = bindex + i;
    size_t word_index = bit_index / 64;
    size_t bit_in_word = bit_index % 64;

    MARK_BIT_FREE(pool.freebs[word_index], bit_in_word);
  }

  memset(pool.blocks[bindex], 0, nblocks * MP_BLOCK);
  return 0;
}

static inline conn_t *MP_use(size_t nblocks, int fd, bool once) {
  if (fd <= 0)
    return NULL;
  if (once)
    return MP_use_once(nblocks, fd);

  int cindex = find_freec();
  if (cindex < 0) {
    LOG("Err: cindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  conn_t *conn = pool.conns[cindex];

  int ios_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (ios_bindex < 0) {
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }

  struct iovec *ios = pool.blocks[ios_bindex];
  conn->ios = ios;

  int rec_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (rec_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct iovec *rec = pool.blocks[rec_bindex];
  conn->rec = rec;

  int msg_bindex = MP_use_blks(MSG_NBLOCKS);
  if (msg_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct msghdr *msg = pool.blocks[msg_bindex];
  conn->msg = msg;

  if (nblocks > 0) {
    int bindex = MP_use_blks(nblocks);
    if (bindex < 0) {
      MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
      MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
      MP_free_blks(msg_bindex, IOVEC_NBLOCKS);
      MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
      LOG("Err: bindex < 0; will use MP_use_once\n");
      return MP_use_once(nblocks, fd);
    }

    size_t iov_index = conn->nios++;
    struct iovec *iov = &conn->ios[iov_index];
    struct iovec *rec = &conn->rec[iov_index];
    iov->iov_base = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
  }

  conn->msg->msg_iov = conn->ios;
  conn->msg->msg_iovlen = conn->nios;
  conn->cindex = cindex;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;
  return conn;
}

static inline void MP_shed(conn_t *conn, size_t iov_index, size_t nios) {
  struct iovec *iov, *rec;
  size_t bindex, nblocks, index;

  for (size_t i = 0; i < nios; i++) {
    index = iov_index + i;
    iov = &conn->ios[index];
    rec = &conn->rec[index];
    if (!rec || !rec->iov_base)
      continue;
    if (!IN_POOL(rec->iov_base)) {
      munmap(rec->iov_base, rec->iov_len / pool.pagesize);
    } else {
      bindex = ptr_diff((uintptr_t)rec->iov_base, (uintptr_t)pool.bpool) / MP_BLOCK;
      nblocks = rec->iov_len / MP_BLOCK;
      MP_free_blks(bindex, nblocks);
    }
    memset(iov, 0, sizeof(struct iovec));
    memset(rec, 0, sizeof(struct iovec));
    conn->nios--;
  }
}

static inline int MP_expand(conn_t *conn, size_t nblocks, bool once) {
  void *bptr;
  int iov_index, bindex;
  struct iovec *iov, *rec;

  iov_index = conn->nios++;
  iov = &conn->ios[iov_index];
  rec = &conn->rec[iov_index];

  if (nblocks == 0)
    return iov_index;

  if (once) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_base = bptr;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
    return iov_index;
  }

  bindex = MP_use_blks(nblocks);
  if (bindex < 0) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_len = iov->iov_len;
  } else {
    bptr = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_len = iov->iov_len;
  }

  iov->iov_base = bptr;
  rec->iov_base = iov->iov_base;
  return iov_index;
}

static inline int MP_free(conn_t *conn) {
  if (!conn)
    return -1;
  size_t bindex, nblocks;
  uint64_t *word;

  MP_shed(conn, 0, conn->nios);
  if (conn->flags & CF_IN_HEAP) {
    if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
      close(conn->fd);
    free(conn);
    return 0;
  }

  word = &pool.freecs[conn->cindex / 64];
  if (conn->cindex > MAX_CONNS)
    return -1;
  else if (BIT_IS_FREE(*word, conn->cindex))
    return 0;

  bindex = ptr_diff((uintptr_t)conn->ios, (uintptr_t)pool.bpool) / MP_BLOCK;
  nblocks = IOVEC_NBLOCKS;
  MP_free_blks(bindex, nblocks);

  bindex = ptr_diff((uintptr_t)conn->rec, (uintptr_t)pool.bpool) / MP_BLOCK;
  MP_free_blks(bindex, nblocks);

  if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
    close(conn->fd);

  MARK_BIT_FREE(*word, conn->cindex);
  memset(conn, 0, sizeof(conn_t));
  conn->fd = -1;
  conn->in_fd = -1;
  conn->out_fd = -1;
  return 0;
}

static inline void MP_clear(conn_t *conn) {
  conn_t *recv_conn = conn->recv_conn;
  conn_t *send_conn = conn->send_conn;
  if (recv_conn)
    MP_free(recv_conn);
  if (send_conn)
    MP_free(send_conn);
}

static inline void MP_exit(MPool *pool) {
  munmap(pool->bpool, pool->npages);
  free(pool->cpool);
  free(pool->blocks);
  free(pool->conns);
  free(pool->freebs);
  free(pool->freecs);
}

static inline void MP_timeout() {
  conn_t *conn;
  int16_t res;
  uint64_t now;
  size_t windex = 0;
  uint64_t *word = &pool.freecs[0];
  for (size_t i = 0; i < MAX_CONNS; i++) {
    if ((i / 64) < windex)
      word = &pool.freecs[++windex];

    if (*word == UINTMAX_MAX) {
      i = (i / 64) * 64 + 64;
      continue;
    }

    conn = pool.conns[i];
    if (!conn || conn->fd == -1)
      continue;

    res = pollevs(conn->fd);

    now = get_time();
    if (res & POLLERR) {
      MP_clear(conn);
      continue;
    }
    if (res & POLLIN) {
      if (pool.rtimeout > 0 && (now - conn->last_read) >= pool.rtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (res & POLLOUT) {
      if (pool.wtimeout > 0 && (now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (!(res & POLLIN || res & POLLOUT)) {
      if ((pool.rtimeout > 0 && now - conn->last_read) >= pool.rtimeout
          || (pool.wtimeout > 0 && now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
  }
}

/*
 * Calculate the length of a status string
 */
static inline size_t status_len(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return 8;
  case STATUSSWITCHINGPROTOCOLS:
    return 19;
  case STATUSPROCESSING:
    return 10;
  case STATUSEARLYHINTS:
    return 11;
  case STATUSOK:
    return 2;
  case STATUSCREATED:
    return 7;
  case STATUSACCEPTED:
    return 8;
  case STATUSNONAUTHORITATIVE:
    return 29;
  case STATUSNOCONTENT:
    return 10;
  case STATUSRESETCONTENT:
    return 13;
  case STATUSPARTIALCONTENT:
    return 15;
  case STATUSMULTISTATUS:
    return 12;
  case STATUSALREADYREPORTED:
    return 16;
  case STATUSIMUSED:
    return 7;
  case STATUSMULTIPLECHOICES:
    return 16;
  case STATUSMOVEDPERMANENTLY:
    return 17;
  case STATUSFOUND:
    return 5;
  case STATUSSEEOTHER:
    return 9;
  case STATUSNOTMODIFIED:
    return 12;
  case STATUSUSEPROXY:
    return 9;
  case STATUSTEMPORARYREDIRECT:
    return 18;
  case STATUSPERMANENTREDIRECT:
    return 18;
  case STATUSBADREQUEST:
    return 11;
  case STATUSUNAUTHORIZED:
    return 12;
  case STATUSPAYMENTREQUIRED:
    return 16;
  case STATUSFORBIDDEN:
    return 9;
  case STATUSNOTFOUND:
    return 9;
  case STATUSMETHODNOTALLOWED:
    return 18;
  case STATUSNOTACCEPTABLE:
    return 14;
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return 29;
  case STATUSREQUESTTIMEOUT:
    return 15;
  case STATUSCONFLICT:
    return 8;
  case STATUSGONE:
    return 4;
  case STATUSLENGTHREQUIRED:
    return 15;
  case STATUSPRECONDITIONFAILED:
    return 19;
  case CONTENTTOOLARGE:
    return 17;
  case STATUSURITOOLONG:
    return 12;
  case STATUSUNSUPPORTEDMEDIATYPE:
    return 22;
  case STATUSRANGENOTSATISFIABLE:
    return 21;
  case STATUSEXPECTATIONFAILED:
    return 18;
  case STATUSMISDIRECTEDREQUEST:
    return 19;
  case STATUSUNPROCESSABLECONTENT:
    return 21;
  case STATUSLOCKED:
    return 6;
  case STATUSFAILEDDEPENDENCY:
    return 17;
  case STATUSTOOEARLY:
    return 9;
  case STATUSUPGRADEREQUIRED:
    return 16;
  case STATUSPRECONDITIONREQUIRED:
    return 21;
  case STATUSTOOMANYREQUESTS:
    return 17;
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return 31;
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return 29;
  case STATUSInternalServerError:
    return 21;
  case STATUSNOTIMPLEMENTED:
    return 15;
  case STATUSBADGATEWAY:
    return 11;
  case STATUSSERVICEUNAVAILABLE:
    return 19;
  case STATUSGATEWAYTIMEOUT:
    return 15;
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return 26;
  case STATUSVARIANTALSONEGOTIATES:
    return 23;
  case STATUSINSUFFICIENTSTORAGE:
    return 20;
  case STATUSLOOPDETECTED:
    return 13;
  case STATUSNOTEXTENDED:
    return 12;
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return 31;
  default:
    return 0;
  }
}

/*
 * Return the status code string as string literal
 */
static inline char *status_str(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return "Continue";
  case STATUSSWITCHINGPROTOCOLS:
    return "Switching Protocols";
  case STATUSPROCESSING:
    return "Processing";
  case STATUSEARLYHINTS:
    return "Early Hints";
  case STATUSOK:
    return "OK";
  case STATUSCREATED:
    return "Created";
  case STATUSACCEPTED:
    return "Accepted";
  case STATUSNONAUTHORITATIVE:
    return "Non-Authoritative Information";
  case STATUSNOCONTENT:
    return "No Content";
  case STATUSRESETCONTENT:
    return "Reset Content";
  case STATUSPARTIALCONTENT:
    return "Partial Content";
  case STATUSMULTISTATUS:
    return "Multi-Status";
  case STATUSALREADYREPORTED:
    return "Already Reported";
  case STATUSIMUSED:
    return "Im Used";
  case STATUSMULTIPLECHOICES:
    return "Multiple Choices";
  case STATUSMOVEDPERMANENTLY:
    return "Moved Permanently";
  case STATUSFOUND:
    return "Found";
  case STATUSSEEOTHER:
    return "See Other";
  case STATUSNOTMODIFIED:
    return "Not Modified";
  case STATUSUSEPROXY:
    return "Use Proxy";
  case STATUSTEMPORARYREDIRECT:
    return "Temporary Redirect";
  case STATUSPERMANENTREDIRECT:
    return "Permanent Redirect";
  case STATUSBADREQUEST:
    return "Bad Request";
  case STATUSUNAUTHORIZED:
    return "Unauthorized";
  case STATUSPAYMENTREQUIRED:
    return "Payment Required";
  case STATUSFORBIDDEN:
    return "Forbidden";
  case STATUSNOTFOUND:
    return "Not Found";
  case STATUSMETHODNOTALLOWED:
    return "Method Not Allowed";
  case STATUSNOTACCEPTABLE:
    return "Not Acceptable";
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return "Proxy Authentication Required";
  case STATUSREQUESTTIMEOUT:
    return "Request Timeout";
  case STATUSCONFLICT:
    return "Conflict";
  case STATUSGONE:
    return "Gone";
  case STATUSLENGTHREQUIRED:
    return "Length Required";
  case STATUSPRECONDITIONFAILED:
    return "Precondition Failed";
  case CONTENTTOOLARGE:
    return "Content Too Large";
  case STATUSURITOOLONG:
    return "URI Too Long";
  case STATUSUNSUPPORTEDMEDIATYPE:
    return "Unsupported Media Type";
  case STATUSRANGENOTSATISFIABLE:
    return "Range Not Satisfiable";
  case STATUSEXPECTATIONFAILED:
    return "Expectation Failed";
  case STATUSMISDIRECTEDREQUEST:
    return "Misdirected Request";
  case STATUSUNPROCESSABLECONTENT:
    return "Unprocessable Content";
  case STATUSLOCKED:
    return "Locked";
  case STATUSFAILEDDEPENDENCY:
    return "Failed Dependency";
  case STATUSTOOEARLY:
    return "Too Early";
  case STATUSUPGRADEREQUIRED:
    return "Upgrade Required";
  case STATUSPRECONDITIONREQUIRED:
    return "Precondition Required";
  case STATUSTOOMANYREQUESTS:
    return "Too Many Requests";
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return "Request Header Fields Too Large";
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return "Unavailable For Legal Reasons";
  case STATUSInternalServerError:
    return "Internal Server Error";
  case STATUSNOTIMPLEMENTED:
    return "Not Implemented";
  case STATUSBADGATEWAY:
    return "Bad Gateway";
  case STATUSSERVICEUNAVAILABLE:
    return "Service Unavailable";
  case STATUSGATEWAYTIMEOUT:
    return "Gateway Timeout";
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return "HTTP Version Not Supported";
  case STATUSVARIANTALSONEGOTIATES:
    return "Variant Also Negotiates";
  case STATUSINSUFFICIENTSTORAGE:
    return "Insufficient Storage";
  case STATUSLOOPDETECTED:
    return "Loop Detected";
  case STATUSNOTEXTENDED:
    return "Not Extended";
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return "Network Authentication Required";
  default:
    return 0;
  }
}

/*
 * Return true if routes match
 */
static inline bool route_equ(Route *route, Request *req) {
  return route->method == req->method && strncmp(route->path, req->path, strlen(route->path)) == 0;
}

/*
 * Return the matching route index on success. -1 on failure
 */
static inline int match_route(Server *serv, Request *req) {
  for (size_t i = 0; i < serv->_nroutes; i++) {
    Route route = serv->routes[i];
    if (!req->path || !route.path)
      continue;
    if (route_equ(&route, req))
      return i;
    else if (req->method == HEAD && route.method == GET && strcmp(route.path, req->path) == 0)
      return i;
  }
  return -1;
}

/*
 * Return true if the response should contain the Content-Length header
 */
static inline bool should_have_content_length(Request *req, ResWriter *res) {
  return (req->method != CONNECT              // CONNECT request
          && res->status != STATUSNOCONTENT   // 204 response
          && res->status != STATUSNOTMODIFIED // 304 response
          && res->status >= 200);             // 1xx response
}

/*
 * Format http response from the ResWriter.
 * Return response size on success, 0 on failure.
 */
static inline size_t fmt_res(Request *req, ResWriter *res, char *buffer, size_t buffer_size) {
  if (!res || !buffer || buffer_size == 0)
    return 0;

  size_t res_len, total = 0;
  char *dst = buffer;
  size_t maxlen = buffer_size;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t body_length = res->len;

  res_len = snprintf(dst, maxlen, "HTTP/1.1 %d %s", (int)res->status, status_str(res->status));
  total += res_len;
  dst += res_len;
  maxlen -= res_len;

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    res_len = snprintf(dst, maxlen, "\r\n%s: %s", header->key, header->value);
    total += res_len;
    dst += res_len;
    maxlen -= res_len;
  }

  if (have_content_length) {
    res_len = snprintf(dst, maxlen, "\r\nContent-Length: %lu", body_length);
    total += res_len, dst += res_len, maxlen -= res_len;
  }

  memcpy(dst, "\r\n\r\n", 4);
  total += 4, dst += 4, maxlen -= 4;

  return total;
}

static inline size_t res_len(Request *req, ResWriter *res) {
  if (!req || !res)
    return 0;

  if (!res->status)
    res->status = STATUSOK;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t result = 0;
  result += STRLEN("HTTP/1.1 ");     // HTTP version
  result += 4;                       // Status code + space
  result += status_len(res->status); // Status name

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    result += 2;                       // "\r\n"
    result += strlen(header->key) + 2; // Header key + ':' + space
    result += strlen(header->value);   // header value
  }

  if (have_content_length) {
    result += 2;                          // "\r\n"
    result += STRLEN("Content-Length: "); // Header key
    result += countd(res->len);           // Header value
  }

  result += 4; // "\r\n\r\n"

  return result;
}

static inline int send_empty_res(Status status) {
  size_t res_len = STRLEN("HTTP/1.1 ")        // HTTP version
                   + countd((uint64_t)status) // status code
                   + 1                        // space
                   + (int)status_len(status)  // status string
                   + 4;                       // \r\n\r\n

  conn_t *conn = current_send;
  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, res_len);
  if (snprintf((char *)rec->iov_base, res_len + 1, "HTTP/1.1 %d %s\r\n\r\n", (int)status, status_str(status))
      != (int)res_len)
    return -1;

  return usendmsg(conn, 0, 1);
}

static inline ssize_t read_socket(int sockfd, size_t len) {
  if (len == 0 || sockfd <= 0)
    return 0;
  char buff[1024 * 8];
  return read(sockfd, buff, 1024 * 8);
}

static inline int read_method(Method *method, void *src) {
  if (memcmp(src, "GET", 3) == 0)
    *method = GET;
  else if (memcmp(src, "POST", 4) == 0)
    *method = POST;
  else if (memcmp(src, "HEAD", 4) == 0)
    *method = HEAD;
  else if (memcmp(src, "PUT", 3) == 0)
    *method = PUT;
  else if (memcmp(src, "DELETE", 6) == 0)
    *method = DELETE;
  else if (memcmp(src, "CONNECT", 7) == 0)
    *method = CONNECT;
  else if (memcmp(src, "OPTIONS", 7) == 0)
    *method = OPTIONS;
  else if (memcmp(src, "TRACE", 5) == 0)
    *method = TRACE;
  else if (memcmp(src, "PATCH", 5) == 0)
    *method = PATCH;
  else
    return -1;

  return 0;
}

static inline int sendmsg_res(Request *req, ResWriter *res) {
  conn_t *conn;
  size_t head_size, res_size;
  struct iovec *iov;

  conn = current_send;
  iov = &conn->ios[0];
  head_size = res_len(req, res);
  if (head_size == 0)
    return -1;

  conn->data_left += head_size;
  res_size = fmt_res(req, res, iov->iov_base, (head_size + 1));
  if (res_size != head_size)
    return -1;
  iov->iov_len = res_size;

  return usendmsg(conn, 0, conn->nios);
}

static inline int read_req(Request *req, char *req_buffer) {
  if (!req_buffer)
    return -1;
  /*** Method ***/
  char *sep = strchr(req_buffer, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }
  *sep = '\0';
  if (read_method(&req->method, req_buffer) < 0)
    return -1;

  /*** Path ***/
  char *fullpath = sep + 1;
  sep = strchr(fullpath, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }

  *sep = '\0';
  req->path = fullpath;
  /*** Params ***/
  char *paramStart = strchr(fullpath, '?');
  if (paramStart) {
    *paramStart++ = '\0';
    int params_count = 0;
    params_count = HK_parse_params(paramStart, req->params, MAX_URL_PARAMETERS);
    if (params_count > 0)
      req->params_count = params_count;
    else
      req->params_count = 0;
  } else {
    req->params = NULL;
    req->params_count = 0;
  }

  /*** Headers ***/
  char *headStart = strstr(sep + 1, "\r\n");
  char *headEnd = strstr(sep + 1, "\r\n\r\n");
  if (!headStart) {
    LOG("read_req: !headStart\n");
    return -1;
  };

  memset(headStart, 0, 2);
  headStart += 2;
  memset(headEnd, 0, 4);
  headEnd += 4;

  int headers_count = HK_parse_headers(headStart, req->headers, MAX_REQ_HEADERS);
  if (headers_count <= 0)
    return -1;
  req->headers_count = headers_count;

  /*** Host ***/
  int index = HK_get_header(req, "Host");
  if (index < 0)
    return -1;
  char *host = req->headers[index].value;
  req->hostname = host;

  /*** Port ***/
  char *colon = strchr(host, ':');
  if (colon) {
    *colon++ = '\0';
    req->port = atoi(colon);
  } else {
    req->port = PORT;
  }
  return 0;
}
static inline int process_req(Server *serv, conn_t *conn) {
  if (!conn || conn->fd == -1)
    return -1;

  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;
  if (read_req(&req, conn->ios[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    LOG("Err: route_index == -1\n");
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;
  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  sendmsg_res(&req, &res);

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int new_conn(int connfd) {
  if (connfd <= 0)
    return -1;

  current_recv = MP_use(KB * 2, connfd, false);
  current_send = MP_use(KB * 2, connfd, false);

  current_recv->recv_conn = current_recv;
  current_recv->send_conn = current_send;

  current_send->send_conn = current_send;
  current_send->recv_conn = current_recv;

  conn_t *conn = current_recv;
  if (ufrecvmsg(conn, 0, 1) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

static inline int resubmit_sendmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return usendmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int resubmir_recvmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    // FIXME the len should be increased
    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return urecvmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int handle_sendmsg_complete(conn_t *conn) {
  struct iovec *iov, *rec;

  MP_shed(conn, 1, conn->nios - 1);
  iov = &conn->ios[0];
  rec = &conn->rec[0];
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;

  return ufrecvmsg(conn->recv_conn, 0, 1);
}

static inline int handle_sendmsg(conn_t *conn, int res, bool zc) {
  if (!conn || conn->fd == -1)
    return -1;

  conn->data_left -= res;
  if (conn->data_left > 0)
    return resubmit_sendmsg(conn, res);

  if (zc)
    return 0;

  return handle_sendmsg_complete(conn);
}

static inline int handle_insplice(conn_t *conn) {
  conn->op = OUTSPLICE;
  return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
}
static inline int handle_outsplice(conn_t *conn, int res) {
  conn->data_left -= res;
  if (conn->data_left > 0) {
    conn->op = INSPLICE;
    return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
  }

  conn_t *recv_conn = conn->recv_conn;
  struct iovec *iov = &recv_conn->ios[0];
  memset(iov->iov_base, 0, iov->iov_len);
  if (urecv(recv_conn, iov->iov_base, iov->iov_len, MSG_PEEK) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

/*
static inline int handle_recv(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  void *bptr = conn->ios[0].iov_base;
  void *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  void *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  return process_req(serv, conn);
}
*/
static inline int find_route(Server *serv, char *bptr) {
  Request req = {0};
  if (read_method(&req.method, bptr) < 0) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  };
  char *space = strchr(bptr, ' ');
  req.path = (space + 1);
  space = strchr(req.path, ' ');
  *space = '\0';
  int route_index = match_route(serv, &req);
  *space = ' ';
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }
  return route_index;
}

static inline int run_handler(Server *serv, conn_t *conn, bool uses_body) {
  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;

  if (read_req(&req, conn->rec[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  if (uses_body) {
    int h_index = HK_get_header(&req, "Content-Length");
    long body_size = atol(req.headers[h_index].value);
    if (body_size >= 0) {
      req.body.ptr = conn->rec[1].iov_base;
      req.body.size = body_size;
    } else {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    }
  }

  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  if (sendmsg_res(&req, &res) < 0)
    return -1;

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int handle_frecvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  char *bptr = (char *)conn->ios[0].iov_base;
  char *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  char *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  size_t head_size = (headEnd + 4) - bptr;
  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  int route_index = find_route(serv, bptr);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  bool uses_body = serv->routes[route_index].uses_body;
  long body_size = get_content_length(headstart + 2, headEnd + 4);
  if (body_size == -1) {
    if (uses_body) {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    } else {
      body_size = 0;
    }
  }

  conn->head_size = head_size;
  if (!uses_body) {
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  if (res == (int)(head_size + body_size)) {
    size_t iov_index = MP_expand(conn, round_to_blocks(body_size), false);
    memcpy(conn->rec[iov_index].iov_base, headEnd + 4, body_size);
    conn->ios[iov_index].iov_len = body_size;
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  conn->data_left = body_size - (res - head_size);
  bool once = ((size_t)body_size > (size_t)((pool.nblocks * MP_BLOCK) / 10));
  size_t iov_index = MP_expand(conn, round_to_blocks(body_size), once);
  memcpy(conn->rec[iov_index].iov_base, headEnd + 4, (res - head_size));
  conn->ios[iov_index].iov_base += (res - head_size);

  return urecvmsg(conn, iov_index, 1);
}

static inline int handle_recvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  if (conn->data_left > 0) {
    conn->data_left -= res;
    if (conn->data_left == 0) {
      conn->flags &= CF_HANDLER_READY;
      return run_handler(serv, conn, true);
    }

    conn->flags &= ~CF_HANDLER_READY;
    conn->ios[1].iov_base += res;
    return urecvmsg(conn, 1, 1);
  }

  conn->flags &= CF_HANDLER_READY;
  return run_handler(serv, conn, true);
}

static inline int serv_init(Server *serv) {
#if DEBUG
  logfd = log_init("log.txt");
  if (!logfd) {
    printf("log_init failed");
    return -1;
  }
#endif
  serv->_nroutes = get_nroutes(serv->routes);

  int pipefd[2];
  if (pipe(pipefd) < 0)
    return -1;
  pipe_in = pipefd[0];
  pipe_out = pipefd[1];
  nullfd = open("/dev/null", O_WRONLY);
  pipe_sz = fcntl(pipefd[0], F_GETPIPE_SZ);
  if (pipe_sz < 0)
    return -1;

  pool.rtimeout = serv->rtimeout;
  pool.wtimeout = serv->wtimeout;
  if (MP_init(MAX_CONNS * 8) < 0)
    return -1;
  LOG("pool initialized\n");

  if (io_uring_queue_init(MAX_CONNS, &ring, 0) < 0)
    return -1;
  LOG("uring initialized\n");

  int listenfd;
  if ((listenfd = tcp_listen(serv->port)) < 0)
    return -1;
  LOG("socket initialized\n");

  return umaccept(listenfd);
}

static inline int serv_listen(Server *serv) {
  // uint64_t last_check = get_time();
  while (true) {
    // uint64_t now = get_time();
    // if ((now - last_check) >= 200) {
    //   last_check = now;
    //   LOG("CM: CM_check ran\n");
    //   MP_timeout();
    // }

    LOG("SQ ready: %u, CQ ready: %u\n", io_uring_sq_ready(&ring), io_uring_cq_ready(&ring));
    struct io_uring_cqe *cqe;
    if (io_uring_wait_cqe(&ring, &cqe) < 0)
      continue;

    int res = cqe->res;
    LOG("res = %d\n", res);
    conn_t *conn = NULL;
    if (cqe->user_data > 100) {
      conn = (conn_t *)cqe->user_data;
      current_recv = (conn_t *)conn->recv_conn;
      current_send = (conn_t *)conn->send_conn;
    }

    if (res > 0) {
      if (cqe->user_data == ACCEPT) {
        LOG("new conn created\n");
        new_conn(res);
      } else if (conn && conn->fd != -1) {
        LOG("conn[%d]: conn.fd = %d; conn.op = %d\n", conn->cindex, conn->fd, conn->op);
        switch (conn->op) {
        case FRECVMSG:
          if (handle_frecvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case RECVMSG:
          if (handle_recvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case SENDMSG:
        case SENDMSGZC:
          // conn->last_write = get_time();
          bool zc = (conn->op == SENDMSGZC);
          if (handle_sendmsg(conn, res, zc) < 0)
            MP_clear(conn);
          break;
        case INSPLICE:
          if (handle_insplice(conn) < 0)
            MP_clear(conn);
          break;
        case OUTSPLICE:
          if (handle_outsplice(conn, res) < 0)
            MP_clear(conn);
          break;
        }
      }
    } else if (res == 0) {
      if (conn && conn->fd != -1) {
        switch (conn->op) {
        case SENDMSGZC:
          conn->zc_notifs--;
          if (conn->zc_notifs == 0 && handle_sendmsg_complete(conn) < 0)
            MP_clear(conn);
          break;
        case RECV:
          MP_clear(conn);
          break;
        }
      }
    } else {
      if (conn && conn->fd != -1) {
        if (res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR) {
          LOG("conn && conn->fd != -1 && res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR\n");
          MP_clear(conn);
        } else {
          LOG("res == -EAGAIN || res == -EWOULDBLOCK || res == -EINTR\n");
          conn = conn->recv_conn;
          struct iovec *iov = &conn->ios[0];
          memset(iov->iov_base, 0, iov->iov_len);
          if (urecv(conn, iov->iov_base, iov->iov_len, 0) < 0)
            MP_clear(conn);
        }
      }
    }

    LOG("uring operation seen\n");
    io_uring_cqe_seen(&ring, cqe);
  }

  io_uring_queue_exit(&ring);
  MP_exit(&pool);
  return 0;
}

/*** Helper ***/
static inline int _HK_write(void *data, size_t size) {
  size_t nblocks;
  int iov_index;
  conn_t *conn;
  struct iovec *iov;
  bool once;

  conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  nblocks = round_to_blocks(size);
  iov_index = MP_expand(conn, nblocks, once);
  iov = &conn->ios[iov_index];

  memcpy(iov->iov_base, data, size);
  iov->iov_len = size;
  conn->data_left += size;

  return 0;
}
static inline int _HK_write_body(Request *req, size_t offset, size_t size) {
  if (size > req->body.size || offset > req->body.size)
    return -1;

  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  int iov_index = MP_expand(conn, 0, false);
  struct iovec *iov = &conn->ios[iov_index];
  struct iovec *rec = &conn->rec[iov_index];
  rec->iov_base = req->body.ptr + offset;
  rec->iov_len = size;
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;
  conn->data_left += rec->iov_len;
  return 0;
}
/*
static inline int _HK_mem(size_t size, HKMem *mem) {
  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  bool once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  size_t nblocks = round_to_blocks(size);
  int iov_index = MP_expand(conn, nblocks, once);
  struct iovec *iov = &conn->ios[iov_index];
  mem->ptr = iov->iov_base;
  mem->size = iov->iov_len;
  mem->_iov_index = iov_index;
  mem->_flags = (IN_POOL(iov->iov_base)) ? CF_IN_POOL : CF_IN_HEAP;
  return 0;
}

static inline void _HK_send(HKMem *mem, size_t size) {
  conn_t *conn = current_send;
  struct iovec *iov = &conn->ios[mem->_iov_index];
  iov->iov_len = size;
  conn->data_left += size;
}
  */
#endif#define _GNU_SOURCE
#ifndef UTILS_H
#define UTILS_H

#include "hunk.h"
#include <arpa/inet.h>
#include <fcntl.h>
#include <liburing.h>
#include <netdb.h>
#include <signal.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/poll.h>
#include <sys/prctl.h>
#include <sys/socket.h>
#include <sys/sysinfo.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

#define MP_BLOCK  4
#define MAX_CONNS 4096
#define KB        1024
#define NIOS      32

#define IN_POOL(ptr)                 ((void *)ptr >= pool.bpool && (void *)ptr <= (pool.bpool + (pool.npages * pool.pagesize)))
#define ALIGN_TO_PAGESIZE(buff_size) (((buff_size) + (pool.pagesize - 1)) & ~(pool.pagesize - 1))
#define BYTES_TO_BLOCKS(buff_size)   (((buff_size) + (MP_BLOCK - 1)) / MP_BLOCK)
#define CEIL_BLOCKS(nblocks)         ((nblocks + 63) & ~63)
#define CEIL_PAGES(size)             (((size) + ((pool.pagesize) - 1)) & ~((pool.pagesize) - 1))

#define BIT_IS_FREE(word, bit)   (((word) >> (bit)) & 1)
#define MARK_BIT_USED(word, bit) ((word) &= ~(1ULL << (bit)))
#define MARK_BIT_FREE(word, bit) ((word) |= (1ULL << (bit)))
#define FIND_FREE_BIT(word)      ((uint64_t)(word) & -(uint64_t)(word))
#define STRLEN(s)                (sizeof(s) - 1)

#define IOVEC_NBLOCKS (BYTES_TO_BLOCKS(NIOS * sizeof(struct iovec)))
#define MSG_NBLOCKS   (BYTES_TO_BLOCKS(sizeof(struct msghdr)))
#define ZC_RES        KB *KB

#define DEBUG 0
#if DEBUG
#define LOG(...) fprintf(logfd, __VA_ARGS__)
#else
#define LOG(...) ((void)0)
#endif

typedef enum UOP {
  WRITEV = IORING_OP_WRITEV,
  SENDMSG = IORING_OP_SENDMSG,
  RECVMSG = IORING_OP_RECVMSG,
  ACCEPT = IORING_OP_ACCEPT,
  SEND = IORING_OP_SEND,
  RECV = IORING_OP_RECV,
  SENDZC = IORING_OP_SEND_ZC,
  SENDMSGZC = IORING_OP_SENDMSG_ZC,
  PEEK = 50,
  FRECVMSG,
  INSPLICE,
  OUTSPLICE
} UOP;

typedef enum CFS {
  CF_IN_POOL = (1 << 0),       // Connection is in the pool
  CF_IN_HEAP = (1 << 1),       // Connection is in the heap
  CF_SKIP_SOCK = (1 << 2),     // Don't close the socket
  CF_USE_ONCE = (1 << 3),      // Destroy after using
  CF_HANDLER_READY = (1 << 4), // Ready to call the handler
} CFS;

typedef struct conn_t {
  // Socket file descriptor
  int fd;

  // Amount of data left in the current operation
  uint64_t data_left;

  // The index of the connection struct
  uint32_t cindex;

  // The last time the connection was readable
  uint64_t last_read;

  // The last time the connection was writeable
  uint64_t last_write;

  // The operation currently being processed
  uint8_t op;

  // Connection flags
  int flags;

  // Splice fd_in
  int in_fd;

  // Splice fd_out
  int out_fd;

  void *recv_conn;
  void *send_conn;

  struct iovec *ios;
  struct iovec *rec;
  uint16_t nios;

  struct msghdr *msg;
  uint16_t zc_notifs;

  uint16_t head_size;
} conn_t;

typedef struct MPool {
  // The allocated pool of blocks
  void *bpool;

  // The allocated pool of connections
  conn_t *cpool;

  // The size of the pool in pages
  uint32_t npages;

  // The size of the pool in blocks
  uint32_t nblocks;

  // The locations of each page in the pool
  void **blocks;

  // The availability of each block
  uint64_t *freebs;

  // The locations of each conn in the pool
  conn_t **conns;

  // The availability of each conn
  uint64_t *freecs;

  // Clean up callback function
  void (*callback)(conn_t *conn);

  // The page size used
  uint32_t pagesize;

  // Socket read timeout
  uint32_t rtimeout;

  // Socket write timeout
  uint32_t wtimeout;
} MPool;

extern int pipe_sz;
extern int pipe_in, pipe_out, nullfd;
extern FILE *logfd;
extern struct io_uring ring;
extern MPool pool;
extern conn_t *current_recv;
extern conn_t *current_send;

/*
 * Prepare and submit a recv uring op
 */
static inline int urecv(conn_t *conn, void *buffer, size_t buff_size, int flags) {
  if (!conn || conn->fd == -1)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (flags == MSG_PEEK) ? PEEK : RECV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;

  io_uring_prep_recv(sqe, conn->fd, buffer, buff_size, flags);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a multi-shot accept uring op
 */
static inline int umaccept(int listenfd) {
  if (listenfd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = ACCEPT;
  io_uring_prep_multishot_accept(sqe, listenfd, NULL, NULL, SOCK_NONBLOCK);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a splice uring op
 */
static inline int usplice(conn_t *conn, int fd_in, int64_t off_in, int fd_out, int64_t off_out, size_t len) {
  if (!len || !conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = (__u64)conn;
  io_uring_prep_splice(sqe, fd_in, off_in, fd_out, off_out, len, 0);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a writev uring op
 */
static inline int uwritev(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = WRITEV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  io_uring_prep_writev(sqe, conn->fd, &conn->ios[iov_index], nios, -1);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a send uring op
 */
static inline int usend(conn_t *conn, char *res_buff, size_t buff_size, bool zc) {
  if (!conn || conn->fd <= 0 || buff_size == 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (zc) ? SENDZC : SEND;
  conn->data_left = buff_size;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  if (zc)
    io_uring_prep_send_zc(sqe, conn->fd, res_buff, buff_size, 0, 0);
  else
    io_uring_prep_send(sqe, conn->fd, res_buff, buff_size, 0);
  return io_uring_submit(&ring);
}

static inline int ufrecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = FRECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;

  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, rec->iov_len);
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int urecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = RECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int usendmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  bool zc = (conn->data_left > ZC_RES) ? true : false;
  conn->op = (zc) ? SENDMSGZC : SENDMSG;

  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  if (zc) {
    io_uring_prep_sendmsg_zc(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
    conn->zc_notifs++;
  } else {
    io_uring_prep_sendmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  }
  return io_uring_submit(&ring);
}

/*
 * Create and initialize a server socket
 */
static inline int tcp_listen(uint16_t port) {
  int enable;
  int listenfd;
  if ((listenfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    return -1;

  int flags = fcntl(listenfd, F_GETFL, 0);
  fcntl(listenfd, F_SETFL, flags | O_NONBLOCK);
  struct sockaddr_in servaddr;
  memset(&servaddr, 0, sizeof(servaddr));
  servaddr.sin_family = AF_INET;
  servaddr.sin_addr.s_addr = INADDR_ANY;
  servaddr.sin_port = htons(port);

  enable = 1;
  if (setsockopt(listenfd, SOL_SOCKET, SO_REUSEPORT, &enable, sizeof(enable)) < 0)
    return -1;

  if (bind(listenfd, (struct sockaddr *)&servaddr, sizeof(servaddr)) < 0)
    return -1;

  if (listen(listenfd, SOMAXCONN) < 0)
    return -1;

  return listenfd;
}

/*
 * Calculate the difference between two pointers
 */
static inline uintptr_t ptr_diff(uintptr_t p1, uintptr_t p2) { return (uintptr_t)(p1 > p2) ? (p1 - p2) : (p2 - p1); }

static inline size_t get_nroutes(Route *routes) {
  Route *route;
  for (size_t i = 0;; i++) {
    route = &routes[i];
    if (!route->path && !route->handler && !route->method)
      return i;
  }
}

static inline long get_content_length(char *src, char *end) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return -1;
    key = line;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, "Content-Length") != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;

    *line_end = '\0';
    long res = atol(value);
    *line_end = '\r';

    return res;
  }
  return -1;
}

static inline bool have_header(char *src, char *end, const char *header_key, const char *header_value) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    key = line;
    while (*key == ' ')
      key++;
    while (*header_key == ' ')
      header_key++;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return false;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, header_key) != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;
    while (*header_value == ' ')
      header_value++;

    *line_end = '\0';
    bool res = (strcasecmp(value, header_value) == 0);
    *line_end = '\r';

    return res;
  }

  return false;
}

static inline const char *method_str(Method method) {
  switch (method) {
  case GET:
    return "GET";
    break;
  case HEAD:
    return "HEAD";
    break;
  case POST:
    return "POST";
    break;
  case PUT:
    return "PUT";
    break;
  case DELETE:
    return "DELETE";
    break;
  case CONNECT:
    return "CONNECT";
    break;
  case OPTIONS:
    return "OPTIONS";
    break;
  case TRACE:
    return "TRACE";
    break;
  case PATCH:
    return "PATCH";
    break;
  default:
    return NULL;
  }
}

static inline uint8_t method_len(Method method) {
  switch (method) {
  case GET:
    return 3;
    break;
  case HEAD:
    return 4;
    break;
  case POST:
    return 4;
    break;
  case PUT:
    return 3;
    break;
  case DELETE:
    return 6;
    break;
  case CONNECT:
    return 7;
    break;
  case OPTIONS:
    return 7;
    break;
  case TRACE:
    return 5;
    break;
  case PATCH:
    return 5;
    break;
  default:
    return 0;
  }
}

static inline size_t round_to_blocks(size_t size) {
  size_t nblocks = BYTES_TO_BLOCKS(size);
  nblocks = CEIL_BLOCKS(nblocks);
  return nblocks;
}

/*
 * Count the digits in unsigned 64-bit int
 */
static inline int countd(uint64_t num) {
  if (num < 10ULL)
    return 1;
  if (num < 100ULL)
    return 2;
  if (num < 1000ULL)
    return 3;
  if (num < 10000ULL)
    return 4;
  if (num < 100000ULL)
    return 5;
  if (num < 1000000ULL)
    return 6;
  if (num < 10000000ULL)
    return 7;
  if (num < 100000000ULL)
    return 8;
  if (num < 1000000000ULL)
    return 9;
  if (num < 10000000000ULL)
    return 10;
  if (num < 100000000000ULL)
    return 11;
  if (num < 1000000000000ULL)
    return 12;
  if (num < 10000000000000ULL)
    return 13;
  if (num < 100000000000000ULL)
    return 14;
  if (num < 1000000000000000ULL)
    return 15;
  if (num < 10000000000000000ULL)
    return 16;
  if (num < 100000000000000000ULL)
    return 17;
  if (num < 1000000000000000000ULL)
    return 18;
  if (num < 10000000000000000000ULL)
    return 19;
  return 20;
}

/*
 * Get the time elabsed in ms
 */
static inline uint64_t get_time() {
  struct timespec ts;
  clock_gettime(CLOCK_MONOTONIC, &ts);
  return (uint64_t)(ts.tv_sec) * 1000 + (ts.tv_nsec / 1000000);
}

static inline FILE *log_init(const char *path) {
  FILE *res = fopen(path, "a+");
  setvbuf(res, NULL, _IONBF, 0);
  return res;
}

static inline int16_t pollevs(int connfd) {
  struct pollfd pfd;
  pfd.fd = connfd;
  pfd.events = POLLIN | POLLOUT | POLLERR;
  int res = poll(&pfd, 1, 0);
  if (res < 0)
    return POLLERR;
  return pfd.revents;
}

// FIXME This needs to be updated
static inline conn_t *MP_use_once(size_t nblocks, int fd) {

  void *mem = malloc(sizeof(conn_t) + 8 + (IOVEC_NBLOCKS * MP_BLOCK));
  struct conn_t *conn = (conn_t *)mem;
  memset(conn, 0, sizeof(conn_t));
  conn->ios = mem + sizeof(conn_t) + 8;

  if (nblocks > 0) {
    struct iovec *iov = &conn->ios[conn->nios++];
    mem = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (mem == MAP_FAILED)
      return NULL;
    iov->iov_base = mem;
    iov->iov_len = ALIGN_TO_PAGESIZE(nblocks * MP_BLOCK);
  }

  conn->flags |= CF_IN_HEAP;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;

  return conn;
}

static inline int find_freec() {
  uint64_t *word;
  size_t map_size = (sizeof(uint64_t) * 8);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    word = &pool.freecs[i / map_size];

    if (*word == 0) { // All used
      i += (map_size - 1);
      continue;
    }

    i += __builtin_ctzll(*word);
    MARK_BIT_USED(*word, i);
    return i;
  }

  return -1;
}

static inline int MP_init(size_t npages) {
  if (!npages)
    return -1;

  /*** Setup ***/
  pool.npages = npages;
  pool.pagesize = sysconf(_SC_PAGESIZE);

  /*** Pool ***/
  pool.bpool = mmap(NULL, pool.npages * pool.pagesize, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  if (pool.bpool == MAP_FAILED)
    return -1;
  pool.nblocks = (pool.npages * pool.pagesize) / MP_BLOCK;

  /*** Blocks ***/
  pool.blocks = malloc(sizeof(void *) * pool.nblocks);
  if (!pool.blocks)
    return -1;
  for (size_t i = 0; i < pool.nblocks; i++)
    pool.blocks[i] = pool.bpool + (i * MP_BLOCK);

  /*** Freebs ***/
  // if (posix_memalign((void **)&pool.freebs, 64, bitmap_size * sizeof(uint64_t)) < 0)
  size_t bitmap_size = (pool.nblocks + 63) / 64;
  pool.freebs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freebs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freebs[i] = UINT64_MAX;

  /*** Cpool ***/
  pool.cpool = (conn_t *)malloc(sizeof(conn_t) * MAX_CONNS);
  if (!pool.cpool)
    return -1;

  /*** Conns ***/
  pool.conns = (conn_t **)malloc(sizeof(conn_t *) * MAX_CONNS);
  if (!pool.conns)
    return -1;
  size_t conn_size = sizeof(conn_t);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    pool.conns[i] = (conn_t *)((char *)pool.cpool + (i * conn_size));
    pool.conns[i]->fd = -1;
    pool.conns[i]->in_fd = -1;
    pool.conns[i]->out_fd = -1;
  }

  /*** Freecs ***/
  bitmap_size = (MAX_CONNS + 63) / 64;
  pool.freecs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freecs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freecs[i] = UINT64_MAX;

  return 0;
}

static inline int MP_use_blks(size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t max_start = pool.nblocks - nblocks;
  size_t full_chunks = (nblocks / 64) * 64;

  for (size_t i = 0, c = 0; i <= max_start; i++, c++) {
    bool free = true;

    for (size_t j = 0; j < full_chunks; j += 64) {
      size_t word_index = (i + j) / 64;
      if (pool.freebs[word_index] != UINT64_MAX) {
        free = false;
        i += 63;
        break;
      }
    }

    for (size_t j = full_chunks; j < nblocks; j++) {
      size_t bit_index = i + j;
      size_t word_index = bit_index / 64;
      size_t bit_in_word = bit_index % 64;

      if (!BIT_IS_FREE(pool.freebs[word_index], bit_in_word)) {
        free = false;
        i += j;
        break;
      }
    }

    if (free) {
      for (size_t j = 0; j < full_chunks; j += 64) {
        size_t word_index = (i + j) / 64;
        pool.freebs[word_index] = 0;
      }

      for (size_t j = full_chunks; j < nblocks; j++) {
        size_t bit_index = i + j;
        size_t word_index = bit_index / 64;
        size_t bit_in_word = bit_index % 64;

        MARK_BIT_USED(pool.freebs[word_index], bit_in_word);
      }

      return i;
    }
  }

  return -1;
}

static inline int MP_free_blks(size_t bindex, size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t full_chunks = (nblocks / 64) * 64;
  for (size_t i = 0; i < full_chunks; i += 64) {
    size_t word_index = (bindex + i) / 64;
    pool.freebs[word_index] = UINT64_MAX;
  }

  for (size_t i = full_chunks; i < nblocks; i++) {
    size_t bit_index = bindex + i;
    size_t word_index = bit_index / 64;
    size_t bit_in_word = bit_index % 64;

    MARK_BIT_FREE(pool.freebs[word_index], bit_in_word);
  }

  memset(pool.blocks[bindex], 0, nblocks * MP_BLOCK);
  return 0;
}

static inline conn_t *MP_use(size_t nblocks, int fd, bool once) {
  if (fd <= 0)
    return NULL;
  if (once)
    return MP_use_once(nblocks, fd);

  int cindex = find_freec();
  if (cindex < 0) {
    LOG("Err: cindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  conn_t *conn = pool.conns[cindex];

  int ios_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (ios_bindex < 0) {
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }

  struct iovec *ios = pool.blocks[ios_bindex];
  conn->ios = ios;

  int rec_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (rec_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct iovec *rec = pool.blocks[rec_bindex];
  conn->rec = rec;

  int msg_bindex = MP_use_blks(MSG_NBLOCKS);
  if (msg_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct msghdr *msg = pool.blocks[msg_bindex];
  conn->msg = msg;

  if (nblocks > 0) {
    int bindex = MP_use_blks(nblocks);
    if (bindex < 0) {
      MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
      MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
      MP_free_blks(msg_bindex, IOVEC_NBLOCKS);
      MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
      LOG("Err: bindex < 0; will use MP_use_once\n");
      return MP_use_once(nblocks, fd);
    }

    size_t iov_index = conn->nios++;
    struct iovec *iov = &conn->ios[iov_index];
    struct iovec *rec = &conn->rec[iov_index];
    iov->iov_base = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
  }

  conn->msg->msg_iov = conn->ios;
  conn->msg->msg_iovlen = conn->nios;
  conn->cindex = cindex;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;
  return conn;
}

static inline void MP_shed(conn_t *conn, size_t iov_index, size_t nios) {
  struct iovec *iov, *rec;
  size_t bindex, nblocks, index;

  for (size_t i = 0; i < nios; i++) {
    index = iov_index + i;
    iov = &conn->ios[index];
    rec = &conn->rec[index];
    if (!rec || !rec->iov_base)
      continue;
    if (!IN_POOL(rec->iov_base)) {
      munmap(rec->iov_base, rec->iov_len / pool.pagesize);
    } else {
      bindex = ptr_diff((uintptr_t)rec->iov_base, (uintptr_t)pool.bpool) / MP_BLOCK;
      nblocks = rec->iov_len / MP_BLOCK;
      MP_free_blks(bindex, nblocks);
    }
    memset(iov, 0, sizeof(struct iovec));
    memset(rec, 0, sizeof(struct iovec));
    conn->nios--;
  }
}

static inline int MP_expand(conn_t *conn, size_t nblocks, bool once) {
  void *bptr;
  int iov_index, bindex;
  struct iovec *iov, *rec;

  iov_index = conn->nios++;
  iov = &conn->ios[iov_index];
  rec = &conn->rec[iov_index];

  if (nblocks == 0)
    return iov_index;

  if (once) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_base = bptr;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
    return iov_index;
  }

  bindex = MP_use_blks(nblocks);
  if (bindex < 0) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_len = iov->iov_len;
  } else {
    bptr = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_len = iov->iov_len;
  }

  iov->iov_base = bptr;
  rec->iov_base = iov->iov_base;
  return iov_index;
}

static inline int MP_free(conn_t *conn) {
  if (!conn)
    return -1;
  size_t bindex, nblocks;
  uint64_t *word;

  MP_shed(conn, 0, conn->nios);
  if (conn->flags & CF_IN_HEAP) {
    if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
      close(conn->fd);
    free(conn);
    return 0;
  }

  word = &pool.freecs[conn->cindex / 64];
  if (conn->cindex > MAX_CONNS)
    return -1;
  else if (BIT_IS_FREE(*word, conn->cindex))
    return 0;

  bindex = ptr_diff((uintptr_t)conn->ios, (uintptr_t)pool.bpool) / MP_BLOCK;
  nblocks = IOVEC_NBLOCKS;
  MP_free_blks(bindex, nblocks);

  bindex = ptr_diff((uintptr_t)conn->rec, (uintptr_t)pool.bpool) / MP_BLOCK;
  MP_free_blks(bindex, nblocks);

  if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
    close(conn->fd);

  MARK_BIT_FREE(*word, conn->cindex);
  memset(conn, 0, sizeof(conn_t));
  conn->fd = -1;
  conn->in_fd = -1;
  conn->out_fd = -1;
  return 0;
}

static inline void MP_clear(conn_t *conn) {
  conn_t *recv_conn = conn->recv_conn;
  conn_t *send_conn = conn->send_conn;
  if (recv_conn)
    MP_free(recv_conn);
  if (send_conn)
    MP_free(send_conn);
}

static inline void MP_exit(MPool *pool) {
  munmap(pool->bpool, pool->npages);
  free(pool->cpool);
  free(pool->blocks);
  free(pool->conns);
  free(pool->freebs);
  free(pool->freecs);
}

static inline void MP_timeout() {
  conn_t *conn;
  int16_t res;
  uint64_t now;
  size_t windex = 0;
  uint64_t *word = &pool.freecs[0];
  for (size_t i = 0; i < MAX_CONNS; i++) {
    if ((i / 64) < windex)
      word = &pool.freecs[++windex];

    if (*word == UINTMAX_MAX) {
      i = (i / 64) * 64 + 64;
      continue;
    }

    conn = pool.conns[i];
    if (!conn || conn->fd == -1)
      continue;

    res = pollevs(conn->fd);

    now = get_time();
    if (res & POLLERR) {
      MP_clear(conn);
      continue;
    }
    if (res & POLLIN) {
      if (pool.rtimeout > 0 && (now - conn->last_read) >= pool.rtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (res & POLLOUT) {
      if (pool.wtimeout > 0 && (now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (!(res & POLLIN || res & POLLOUT)) {
      if ((pool.rtimeout > 0 && now - conn->last_read) >= pool.rtimeout
          || (pool.wtimeout > 0 && now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
  }
}

/*
 * Calculate the length of a status string
 */
static inline size_t status_len(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return 8;
  case STATUSSWITCHINGPROTOCOLS:
    return 19;
  case STATUSPROCESSING:
    return 10;
  case STATUSEARLYHINTS:
    return 11;
  case STATUSOK:
    return 2;
  case STATUSCREATED:
    return 7;
  case STATUSACCEPTED:
    return 8;
  case STATUSNONAUTHORITATIVE:
    return 29;
  case STATUSNOCONTENT:
    return 10;
  case STATUSRESETCONTENT:
    return 13;
  case STATUSPARTIALCONTENT:
    return 15;
  case STATUSMULTISTATUS:
    return 12;
  case STATUSALREADYREPORTED:
    return 16;
  case STATUSIMUSED:
    return 7;
  case STATUSMULTIPLECHOICES:
    return 16;
  case STATUSMOVEDPERMANENTLY:
    return 17;
  case STATUSFOUND:
    return 5;
  case STATUSSEEOTHER:
    return 9;
  case STATUSNOTMODIFIED:
    return 12;
  case STATUSUSEPROXY:
    return 9;
  case STATUSTEMPORARYREDIRECT:
    return 18;
  case STATUSPERMANENTREDIRECT:
    return 18;
  case STATUSBADREQUEST:
    return 11;
  case STATUSUNAUTHORIZED:
    return 12;
  case STATUSPAYMENTREQUIRED:
    return 16;
  case STATUSFORBIDDEN:
    return 9;
  case STATUSNOTFOUND:
    return 9;
  case STATUSMETHODNOTALLOWED:
    return 18;
  case STATUSNOTACCEPTABLE:
    return 14;
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return 29;
  case STATUSREQUESTTIMEOUT:
    return 15;
  case STATUSCONFLICT:
    return 8;
  case STATUSGONE:
    return 4;
  case STATUSLENGTHREQUIRED:
    return 15;
  case STATUSPRECONDITIONFAILED:
    return 19;
  case CONTENTTOOLARGE:
    return 17;
  case STATUSURITOOLONG:
    return 12;
  case STATUSUNSUPPORTEDMEDIATYPE:
    return 22;
  case STATUSRANGENOTSATISFIABLE:
    return 21;
  case STATUSEXPECTATIONFAILED:
    return 18;
  case STATUSMISDIRECTEDREQUEST:
    return 19;
  case STATUSUNPROCESSABLECONTENT:
    return 21;
  case STATUSLOCKED:
    return 6;
  case STATUSFAILEDDEPENDENCY:
    return 17;
  case STATUSTOOEARLY:
    return 9;
  case STATUSUPGRADEREQUIRED:
    return 16;
  case STATUSPRECONDITIONREQUIRED:
    return 21;
  case STATUSTOOMANYREQUESTS:
    return 17;
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return 31;
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return 29;
  case STATUSInternalServerError:
    return 21;
  case STATUSNOTIMPLEMENTED:
    return 15;
  case STATUSBADGATEWAY:
    return 11;
  case STATUSSERVICEUNAVAILABLE:
    return 19;
  case STATUSGATEWAYTIMEOUT:
    return 15;
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return 26;
  case STATUSVARIANTALSONEGOTIATES:
    return 23;
  case STATUSINSUFFICIENTSTORAGE:
    return 20;
  case STATUSLOOPDETECTED:
    return 13;
  case STATUSNOTEXTENDED:
    return 12;
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return 31;
  default:
    return 0;
  }
}

/*
 * Return the status code string as string literal
 */
static inline char *status_str(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return "Continue";
  case STATUSSWITCHINGPROTOCOLS:
    return "Switching Protocols";
  case STATUSPROCESSING:
    return "Processing";
  case STATUSEARLYHINTS:
    return "Early Hints";
  case STATUSOK:
    return "OK";
  case STATUSCREATED:
    return "Created";
  case STATUSACCEPTED:
    return "Accepted";
  case STATUSNONAUTHORITATIVE:
    return "Non-Authoritative Information";
  case STATUSNOCONTENT:
    return "No Content";
  case STATUSRESETCONTENT:
    return "Reset Content";
  case STATUSPARTIALCONTENT:
    return "Partial Content";
  case STATUSMULTISTATUS:
    return "Multi-Status";
  case STATUSALREADYREPORTED:
    return "Already Reported";
  case STATUSIMUSED:
    return "Im Used";
  case STATUSMULTIPLECHOICES:
    return "Multiple Choices";
  case STATUSMOVEDPERMANENTLY:
    return "Moved Permanently";
  case STATUSFOUND:
    return "Found";
  case STATUSSEEOTHER:
    return "See Other";
  case STATUSNOTMODIFIED:
    return "Not Modified";
  case STATUSUSEPROXY:
    return "Use Proxy";
  case STATUSTEMPORARYREDIRECT:
    return "Temporary Redirect";
  case STATUSPERMANENTREDIRECT:
    return "Permanent Redirect";
  case STATUSBADREQUEST:
    return "Bad Request";
  case STATUSUNAUTHORIZED:
    return "Unauthorized";
  case STATUSPAYMENTREQUIRED:
    return "Payment Required";
  case STATUSFORBIDDEN:
    return "Forbidden";
  case STATUSNOTFOUND:
    return "Not Found";
  case STATUSMETHODNOTALLOWED:
    return "Method Not Allowed";
  case STATUSNOTACCEPTABLE:
    return "Not Acceptable";
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return "Proxy Authentication Required";
  case STATUSREQUESTTIMEOUT:
    return "Request Timeout";
  case STATUSCONFLICT:
    return "Conflict";
  case STATUSGONE:
    return "Gone";
  case STATUSLENGTHREQUIRED:
    return "Length Required";
  case STATUSPRECONDITIONFAILED:
    return "Precondition Failed";
  case CONTENTTOOLARGE:
    return "Content Too Large";
  case STATUSURITOOLONG:
    return "URI Too Long";
  case STATUSUNSUPPORTEDMEDIATYPE:
    return "Unsupported Media Type";
  case STATUSRANGENOTSATISFIABLE:
    return "Range Not Satisfiable";
  case STATUSEXPECTATIONFAILED:
    return "Expectation Failed";
  case STATUSMISDIRECTEDREQUEST:
    return "Misdirected Request";
  case STATUSUNPROCESSABLECONTENT:
    return "Unprocessable Content";
  case STATUSLOCKED:
    return "Locked";
  case STATUSFAILEDDEPENDENCY:
    return "Failed Dependency";
  case STATUSTOOEARLY:
    return "Too Early";
  case STATUSUPGRADEREQUIRED:
    return "Upgrade Required";
  case STATUSPRECONDITIONREQUIRED:
    return "Precondition Required";
  case STATUSTOOMANYREQUESTS:
    return "Too Many Requests";
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return "Request Header Fields Too Large";
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return "Unavailable For Legal Reasons";
  case STATUSInternalServerError:
    return "Internal Server Error";
  case STATUSNOTIMPLEMENTED:
    return "Not Implemented";
  case STATUSBADGATEWAY:
    return "Bad Gateway";
  case STATUSSERVICEUNAVAILABLE:
    return "Service Unavailable";
  case STATUSGATEWAYTIMEOUT:
    return "Gateway Timeout";
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return "HTTP Version Not Supported";
  case STATUSVARIANTALSONEGOTIATES:
    return "Variant Also Negotiates";
  case STATUSINSUFFICIENTSTORAGE:
    return "Insufficient Storage";
  case STATUSLOOPDETECTED:
    return "Loop Detected";
  case STATUSNOTEXTENDED:
    return "Not Extended";
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return "Network Authentication Required";
  default:
    return 0;
  }
}

/*
 * Return true if routes match
 */
static inline bool route_equ(Route *route, Request *req) {
  return route->method == req->method && strncmp(route->path, req->path, strlen(route->path)) == 0;
}

/*
 * Return the matching route index on success. -1 on failure
 */
static inline int match_route(Server *serv, Request *req) {
  for (size_t i = 0; i < serv->_nroutes; i++) {
    Route route = serv->routes[i];
    if (!req->path || !route.path)
      continue;
    if (route_equ(&route, req))
      return i;
    else if (req->method == HEAD && route.method == GET && strcmp(route.path, req->path) == 0)
      return i;
  }
  return -1;
}

/*
 * Return true if the response should contain the Content-Length header
 */
static inline bool should_have_content_length(Request *req, ResWriter *res) {
  return (req->method != CONNECT              // CONNECT request
          && res->status != STATUSNOCONTENT   // 204 response
          && res->status != STATUSNOTMODIFIED // 304 response
          && res->status >= 200);             // 1xx response
}

/*
 * Format http response from the ResWriter.
 * Return response size on success, 0 on failure.
 */
static inline size_t fmt_res(Request *req, ResWriter *res, char *buffer, size_t buffer_size) {
  if (!res || !buffer || buffer_size == 0)
    return 0;

  size_t res_len, total = 0;
  char *dst = buffer;
  size_t maxlen = buffer_size;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t body_length = res->len;

  res_len = snprintf(dst, maxlen, "HTTP/1.1 %d %s", (int)res->status, status_str(res->status));
  total += res_len;
  dst += res_len;
  maxlen -= res_len;

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    res_len = snprintf(dst, maxlen, "\r\n%s: %s", header->key, header->value);
    total += res_len;
    dst += res_len;
    maxlen -= res_len;
  }

  if (have_content_length) {
    res_len = snprintf(dst, maxlen, "\r\nContent-Length: %lu", body_length);
    total += res_len, dst += res_len, maxlen -= res_len;
  }

  memcpy(dst, "\r\n\r\n", 4);
  total += 4, dst += 4, maxlen -= 4;

  return total;
}

static inline size_t res_len(Request *req, ResWriter *res) {
  if (!req || !res)
    return 0;

  if (!res->status)
    res->status = STATUSOK;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t result = 0;
  result += STRLEN("HTTP/1.1 ");     // HTTP version
  result += 4;                       // Status code + space
  result += status_len(res->status); // Status name

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    result += 2;                       // "\r\n"
    result += strlen(header->key) + 2; // Header key + ':' + space
    result += strlen(header->value);   // header value
  }

  if (have_content_length) {
    result += 2;                          // "\r\n"
    result += STRLEN("Content-Length: "); // Header key
    result += countd(res->len);           // Header value
  }

  result += 4; // "\r\n\r\n"

  return result;
}

static inline int send_empty_res(Status status) {
  size_t res_len = STRLEN("HTTP/1.1 ")        // HTTP version
                   + countd((uint64_t)status) // status code
                   + 1                        // space
                   + (int)status_len(status)  // status string
                   + 4;                       // \r\n\r\n

  conn_t *conn = current_send;
  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, res_len);
  if (snprintf((char *)rec->iov_base, res_len + 1, "HTTP/1.1 %d %s\r\n\r\n", (int)status, status_str(status))
      != (int)res_len)
    return -1;

  return usendmsg(conn, 0, 1);
}

static inline ssize_t read_socket(int sockfd, size_t len) {
  if (len == 0 || sockfd <= 0)
    return 0;
  char buff[1024 * 8];
  return read(sockfd, buff, 1024 * 8);
}

static inline int read_method(Method *method, void *src) {
  if (memcmp(src, "GET", 3) == 0)
    *method = GET;
  else if (memcmp(src, "POST", 4) == 0)
    *method = POST;
  else if (memcmp(src, "HEAD", 4) == 0)
    *method = HEAD;
  else if (memcmp(src, "PUT", 3) == 0)
    *method = PUT;
  else if (memcmp(src, "DELETE", 6) == 0)
    *method = DELETE;
  else if (memcmp(src, "CONNECT", 7) == 0)
    *method = CONNECT;
  else if (memcmp(src, "OPTIONS", 7) == 0)
    *method = OPTIONS;
  else if (memcmp(src, "TRACE", 5) == 0)
    *method = TRACE;
  else if (memcmp(src, "PATCH", 5) == 0)
    *method = PATCH;
  else
    return -1;

  return 0;
}

static inline int sendmsg_res(Request *req, ResWriter *res) {
  conn_t *conn;
  size_t head_size, res_size;
  struct iovec *iov;

  conn = current_send;
  iov = &conn->ios[0];
  head_size = res_len(req, res);
  if (head_size == 0)
    return -1;

  conn->data_left += head_size;
  res_size = fmt_res(req, res, iov->iov_base, (head_size + 1));
  if (res_size != head_size)
    return -1;
  iov->iov_len = res_size;

  return usendmsg(conn, 0, conn->nios);
}

static inline int read_req(Request *req, char *req_buffer) {
  if (!req_buffer)
    return -1;
  /*** Method ***/
  char *sep = strchr(req_buffer, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }
  *sep = '\0';
  if (read_method(&req->method, req_buffer) < 0)
    return -1;

  /*** Path ***/
  char *fullpath = sep + 1;
  sep = strchr(fullpath, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }

  *sep = '\0';
  req->path = fullpath;
  /*** Params ***/
  char *paramStart = strchr(fullpath, '?');
  if (paramStart) {
    *paramStart++ = '\0';
    int params_count = 0;
    params_count = HK_parse_params(paramStart, req->params, MAX_URL_PARAMETERS);
    if (params_count > 0)
      req->params_count = params_count;
    else
      req->params_count = 0;
  } else {
    req->params = NULL;
    req->params_count = 0;
  }

  /*** Headers ***/
  char *headStart = strstr(sep + 1, "\r\n");
  char *headEnd = strstr(sep + 1, "\r\n\r\n");
  if (!headStart) {
    LOG("read_req: !headStart\n");
    return -1;
  };

  memset(headStart, 0, 2);
  headStart += 2;
  memset(headEnd, 0, 4);
  headEnd += 4;

  int headers_count = HK_parse_headers(headStart, req->headers, MAX_REQ_HEADERS);
  if (headers_count <= 0)
    return -1;
  req->headers_count = headers_count;

  /*** Host ***/
  int index = HK_get_header(req, "Host");
  if (index < 0)
    return -1;
  char *host = req->headers[index].value;
  req->hostname = host;

  /*** Port ***/
  char *colon = strchr(host, ':');
  if (colon) {
    *colon++ = '\0';
    req->port = atoi(colon);
  } else {
    req->port = PORT;
  }
  return 0;
}
static inline int process_req(Server *serv, conn_t *conn) {
  if (!conn || conn->fd == -1)
    return -1;

  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;
  if (read_req(&req, conn->ios[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    LOG("Err: route_index == -1\n");
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;
  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  sendmsg_res(&req, &res);

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int new_conn(int connfd) {
  if (connfd <= 0)
    return -1;

  current_recv = MP_use(KB * 2, connfd, false);
  current_send = MP_use(KB * 2, connfd, false);

  current_recv->recv_conn = current_recv;
  current_recv->send_conn = current_send;

  current_send->send_conn = current_send;
  current_send->recv_conn = current_recv;

  conn_t *conn = current_recv;
  if (ufrecvmsg(conn, 0, 1) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

static inline int resubmit_sendmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return usendmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int resubmir_recvmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    // FIXME the len should be increased
    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return urecvmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int handle_sendmsg_complete(conn_t *conn) {
  struct iovec *iov, *rec;

  MP_shed(conn, 1, conn->nios - 1);
  iov = &conn->ios[0];
  rec = &conn->rec[0];
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;

  return ufrecvmsg(conn->recv_conn, 0, 1);
}

static inline int handle_sendmsg(conn_t *conn, int res, bool zc) {
  if (!conn || conn->fd == -1)
    return -1;

  conn->data_left -= res;
  if (conn->data_left > 0)
    return resubmit_sendmsg(conn, res);

  if (zc)
    return 0;

  return handle_sendmsg_complete(conn);
}

static inline int handle_insplice(conn_t *conn) {
  conn->op = OUTSPLICE;
  return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
}
static inline int handle_outsplice(conn_t *conn, int res) {
  conn->data_left -= res;
  if (conn->data_left > 0) {
    conn->op = INSPLICE;
    return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
  }

  conn_t *recv_conn = conn->recv_conn;
  struct iovec *iov = &recv_conn->ios[0];
  memset(iov->iov_base, 0, iov->iov_len);
  if (urecv(recv_conn, iov->iov_base, iov->iov_len, MSG_PEEK) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

/*
static inline int handle_recv(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  void *bptr = conn->ios[0].iov_base;
  void *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  void *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  return process_req(serv, conn);
}
*/
static inline int find_route(Server *serv, char *bptr) {
  Request req = {0};
  if (read_method(&req.method, bptr) < 0) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  };
  char *space = strchr(bptr, ' ');
  req.path = (space + 1);
  space = strchr(req.path, ' ');
  *space = '\0';
  int route_index = match_route(serv, &req);
  *space = ' ';
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }
  return route_index;
}

static inline int run_handler(Server *serv, conn_t *conn, bool uses_body) {
  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;

  if (read_req(&req, conn->rec[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  if (uses_body) {
    int h_index = HK_get_header(&req, "Content-Length");
    long body_size = atol(req.headers[h_index].value);
    if (body_size >= 0) {
      req.body.ptr = conn->rec[1].iov_base;
      req.body.size = body_size;
    } else {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    }
  }

  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  if (sendmsg_res(&req, &res) < 0)
    return -1;

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int handle_frecvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  char *bptr = (char *)conn->ios[0].iov_base;
  char *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  char *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  size_t head_size = (headEnd + 4) - bptr;
  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  int route_index = find_route(serv, bptr);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  bool uses_body = serv->routes[route_index].uses_body;
  long body_size = get_content_length(headstart + 2, headEnd + 4);
  if (body_size == -1) {
    if (uses_body) {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    } else {
      body_size = 0;
    }
  }

  conn->head_size = head_size;
  if (!uses_body) {
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  if (res == (int)(head_size + body_size)) {
    size_t iov_index = MP_expand(conn, round_to_blocks(body_size), false);
    memcpy(conn->rec[iov_index].iov_base, headEnd + 4, body_size);
    conn->ios[iov_index].iov_len = body_size;
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  conn->data_left = body_size - (res - head_size);
  bool once = ((size_t)body_size > (size_t)((pool.nblocks * MP_BLOCK) / 10));
  size_t iov_index = MP_expand(conn, round_to_blocks(body_size), once);
  memcpy(conn->rec[iov_index].iov_base, headEnd + 4, (res - head_size));
  conn->ios[iov_index].iov_base += (res - head_size);

  return urecvmsg(conn, iov_index, 1);
}

static inline int handle_recvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  if (conn->data_left > 0) {
    conn->data_left -= res;
    if (conn->data_left == 0) {
      conn->flags &= CF_HANDLER_READY;
      return run_handler(serv, conn, true);
    }

    conn->flags &= ~CF_HANDLER_READY;
    conn->ios[1].iov_base += res;
    return urecvmsg(conn, 1, 1);
  }

  conn->flags &= CF_HANDLER_READY;
  return run_handler(serv, conn, true);
}

static inline int serv_init(Server *serv) {
#if DEBUG
  logfd = log_init("log.txt");
  if (!logfd) {
    printf("log_init failed");
    return -1;
  }
#endif
  serv->_nroutes = get_nroutes(serv->routes);

  int pipefd[2];
  if (pipe(pipefd) < 0)
    return -1;
  pipe_in = pipefd[0];
  pipe_out = pipefd[1];
  nullfd = open("/dev/null", O_WRONLY);
  pipe_sz = fcntl(pipefd[0], F_GETPIPE_SZ);
  if (pipe_sz < 0)
    return -1;

  pool.rtimeout = serv->rtimeout;
  pool.wtimeout = serv->wtimeout;
  if (MP_init(MAX_CONNS * 8) < 0)
    return -1;
  LOG("pool initialized\n");

  if (io_uring_queue_init(MAX_CONNS, &ring, 0) < 0)
    return -1;
  LOG("uring initialized\n");

  int listenfd;
  if ((listenfd = tcp_listen(serv->port)) < 0)
    return -1;
  LOG("socket initialized\n");

  return umaccept(listenfd);
}

static inline int serv_listen(Server *serv) {
  // uint64_t last_check = get_time();
  while (true) {
    // uint64_t now = get_time();
    // if ((now - last_check) >= 200) {
    //   last_check = now;
    //   LOG("CM: CM_check ran\n");
    //   MP_timeout();
    // }

    LOG("SQ ready: %u, CQ ready: %u\n", io_uring_sq_ready(&ring), io_uring_cq_ready(&ring));
    struct io_uring_cqe *cqe;
    if (io_uring_wait_cqe(&ring, &cqe) < 0)
      continue;

    int res = cqe->res;
    LOG("res = %d\n", res);
    conn_t *conn = NULL;
    if (cqe->user_data > 100) {
      conn = (conn_t *)cqe->user_data;
      current_recv = (conn_t *)conn->recv_conn;
      current_send = (conn_t *)conn->send_conn;
    }

    if (res > 0) {
      if (cqe->user_data == ACCEPT) {
        LOG("new conn created\n");
        new_conn(res);
      } else if (conn && conn->fd != -1) {
        LOG("conn[%d]: conn.fd = %d; conn.op = %d\n", conn->cindex, conn->fd, conn->op);
        switch (conn->op) {
        case FRECVMSG:
          if (handle_frecvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case RECVMSG:
          if (handle_recvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case SENDMSG:
        case SENDMSGZC:
          // conn->last_write = get_time();
          bool zc = (conn->op == SENDMSGZC);
          if (handle_sendmsg(conn, res, zc) < 0)
            MP_clear(conn);
          break;
        case INSPLICE:
          if (handle_insplice(conn) < 0)
            MP_clear(conn);
          break;
        case OUTSPLICE:
          if (handle_outsplice(conn, res) < 0)
            MP_clear(conn);
          break;
        }
      }
    } else if (res == 0) {
      if (conn && conn->fd != -1) {
        switch (conn->op) {
        case SENDMSGZC:
          conn->zc_notifs--;
          if (conn->zc_notifs == 0 && handle_sendmsg_complete(conn) < 0)
            MP_clear(conn);
          break;
        case RECV:
          MP_clear(conn);
          break;
        }
      }
    } else {
      if (conn && conn->fd != -1) {
        if (res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR) {
          LOG("conn && conn->fd != -1 && res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR\n");
          MP_clear(conn);
        } else {
          LOG("res == -EAGAIN || res == -EWOULDBLOCK || res == -EINTR\n");
          conn = conn->recv_conn;
          struct iovec *iov = &conn->ios[0];
          memset(iov->iov_base, 0, iov->iov_len);
          if (urecv(conn, iov->iov_base, iov->iov_len, 0) < 0)
            MP_clear(conn);
        }
      }
    }

    LOG("uring operation seen\n");
    io_uring_cqe_seen(&ring, cqe);
  }

  io_uring_queue_exit(&ring);
  MP_exit(&pool);
  return 0;
}

/*** Helper ***/
static inline int _HK_write(void *data, size_t size) {
  size_t nblocks;
  int iov_index;
  conn_t *conn;
  struct iovec *iov;
  bool once;

  conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  nblocks = round_to_blocks(size);
  iov_index = MP_expand(conn, nblocks, once);
  iov = &conn->ios[iov_index];

  memcpy(iov->iov_base, data, size);
  iov->iov_len = size;
  conn->data_left += size;

  return 0;
}
static inline int _HK_write_body(Request *req, size_t offset, size_t size) {
  if (size > req->body.size || offset > req->body.size)
    return -1;

  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  int iov_index = MP_expand(conn, 0, false);
  struct iovec *iov = &conn->ios[iov_index];
  struct iovec *rec = &conn->rec[iov_index];
  rec->iov_base = req->body.ptr + offset;
  rec->iov_len = size;
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;
  conn->data_left += rec->iov_len;
  return 0;
}
/*
static inline int _HK_mem(size_t size, HKMem *mem) {
  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  bool once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  size_t nblocks = round_to_blocks(size);
  int iov_index = MP_expand(conn, nblocks, once);
  struct iovec *iov = &conn->ios[iov_index];
  mem->ptr = iov->iov_base;
  mem->size = iov->iov_len;
  mem->_iov_index = iov_index;
  mem->_flags = (IN_POOL(iov->iov_base)) ? CF_IN_POOL : CF_IN_HEAP;
  return 0;
}

static inline void _HK_send(HKMem *mem, size_t size) {
  conn_t *conn = current_send;
  struct iovec *iov = &conn->ios[mem->_iov_index];
  iov->iov_len = size;
  conn->data_left += size;
}
  */
#endif
#define _GNU_SOURCE
#ifndef UTILS_H
#define UTILS_H

#include "hunk.h"
#include <arpa/inet.h>
#include <fcntl.h>
#include <liburing.h>
#include <netdb.h>
#include <signal.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/poll.h>
#include <sys/prctl.h>
#include <sys/socket.h>
#include <sys/sysinfo.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

#define MP_BLOCK  4
#define MAX_CONNS 4096
#define KB        1024
#define NIOS      32

#define IN_POOL(ptr)                 ((void *)ptr >= pool.bpool && (void *)ptr <= (pool.bpool + (pool.npages * pool.pagesize)))
#define ALIGN_TO_PAGESIZE(buff_size) (((buff_size) + (pool.pagesize - 1)) & ~(pool.pagesize - 1))
#define BYTES_TO_BLOCKS(buff_size)   (((buff_size) + (MP_BLOCK - 1)) / MP_BLOCK)
#define CEIL_BLOCKS(nblocks)         ((nblocks + 63) & ~63)
#define CEIL_PAGES(size)             (((size) + ((pool.pagesize) - 1)) & ~((pool.pagesize) - 1))

#define BIT_IS_FREE(word, bit)   (((word) >> (bit)) & 1)
#define MARK_BIT_USED(word, bit) ((word) &= ~(1ULL << (bit)))
#define MARK_BIT_FREE(word, bit) ((word) |= (1ULL << (bit)))
#define FIND_FREE_BIT(word)      ((uint64_t)(word) & -(uint64_t)(word))
#define STRLEN(s)                (sizeof(s) - 1)

#define IOVEC_NBLOCKS (BYTES_TO_BLOCKS(NIOS * sizeof(struct iovec)))
#define MSG_NBLOCKS   (BYTES_TO_BLOCKS(sizeof(struct msghdr)))
#define ZC_RES        KB *KB

#define DEBUG 0
#if DEBUG
#define LOG(...) fprintf(logfd, __VA_ARGS__)
#else
#define LOG(...) ((void)0)
#endif

typedef enum UOP {
  WRITEV = IORING_OP_WRITEV,
  SENDMSG = IORING_OP_SENDMSG,
  RECVMSG = IORING_OP_RECVMSG,
  ACCEPT = IORING_OP_ACCEPT,
  SEND = IORING_OP_SEND,
  RECV = IORING_OP_RECV,
  SENDZC = IORING_OP_SEND_ZC,
  SENDMSGZC = IORING_OP_SENDMSG_ZC,
  PEEK = 50,
  FRECVMSG,
  INSPLICE,
  OUTSPLICE
} UOP;

typedef enum CFS {
  CF_IN_POOL = (1 << 0),       // Connection is in the pool
  CF_IN_HEAP = (1 << 1),       // Connection is in the heap
  CF_SKIP_SOCK = (1 << 2),     // Don't close the socket
  CF_USE_ONCE = (1 << 3),      // Destroy after using
  CF_HANDLER_READY = (1 << 4), // Ready to call the handler
} CFS;

typedef struct conn_t {
  // Socket file descriptor
  int fd;

  // Amount of data left in the current operation
  uint64_t data_left;

  // The index of the connection struct
  uint32_t cindex;

  // The last time the connection was readable
  uint64_t last_read;

  // The last time the connection was writeable
  uint64_t last_write;

  // The operation currently being processed
  uint8_t op;

  // Connection flags
  int flags;

  // Splice fd_in
  int in_fd;

  // Splice fd_out
  int out_fd;

  void *recv_conn;
  void *send_conn;

  struct iovec *ios;
  struct iovec *rec;
  uint16_t nios;

  struct msghdr *msg;
  uint16_t zc_notifs;

  uint16_t head_size;
} conn_t;

typedef struct MPool {
  // The allocated pool of blocks
  void *bpool;

  // The allocated pool of connections
  conn_t *cpool;

  // The size of the pool in pages
  uint32_t npages;

  // The size of the pool in blocks
  uint32_t nblocks;

  // The locations of each page in the pool
  void **blocks;

  // The availability of each block
  uint64_t *freebs;

  // The locations of each conn in the pool
  conn_t **conns;

  // The availability of each conn
  uint64_t *freecs;

  // Clean up callback function
  void (*callback)(conn_t *conn);

  // The page size used
  uint32_t pagesize;

  // Socket read timeout
  uint32_t rtimeout;

  // Socket write timeout
  uint32_t wtimeout;
} MPool;

extern int pipe_sz;
extern int pipe_in, pipe_out, nullfd;
extern FILE *logfd;
extern struct io_uring ring;
extern MPool pool;
extern conn_t *current_recv;
extern conn_t *current_send;

/*
 * Prepare and submit a recv uring op
 */
static inline int urecv(conn_t *conn, void *buffer, size_t buff_size, int flags) {
  if (!conn || conn->fd == -1)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (flags == MSG_PEEK) ? PEEK : RECV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;

  io_uring_prep_recv(sqe, conn->fd, buffer, buff_size, flags);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a multi-shot accept uring op
 */
static inline int umaccept(int listenfd) {
  if (listenfd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = ACCEPT;
  io_uring_prep_multishot_accept(sqe, listenfd, NULL, NULL, SOCK_NONBLOCK);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a splice uring op
 */
static inline int usplice(conn_t *conn, int fd_in, int64_t off_in, int fd_out, int64_t off_out, size_t len) {
  if (!len || !conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = (__u64)conn;
  io_uring_prep_splice(sqe, fd_in, off_in, fd_out, off_out, len, 0);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a writev uring op
 */
static inline int uwritev(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = WRITEV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  io_uring_prep_writev(sqe, conn->fd, &conn->ios[iov_index], nios, -1);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a send uring op
 */
static inline int usend(conn_t *conn, char *res_buff, size_t buff_size, bool zc) {
  if (!conn || conn->fd <= 0 || buff_size == 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (zc) ? SENDZC : SEND;
  conn->data_left = buff_size;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  if (zc)
    io_uring_prep_send_zc(sqe, conn->fd, res_buff, buff_size, 0, 0);
  else
    io_uring_prep_send(sqe, conn->fd, res_buff, buff_size, 0);
  return io_uring_submit(&ring);
}

static inline int ufrecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = FRECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;

  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, rec->iov_len);
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int urecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = RECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int usendmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  bool zc = (conn->data_left > ZC_RES) ? true : false;
  conn->op = (zc) ? SENDMSGZC : SENDMSG;

  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  if (zc) {
    io_uring_prep_sendmsg_zc(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
    conn->zc_notifs++;
  } else {
    io_uring_prep_sendmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  }
  return io_uring_submit(&ring);
}

/*
 * Create and initialize a server socket
 */
static inline int tcp_listen(uint16_t port) {
  int enable;
  int listenfd;
  if ((listenfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    return -1;

  int flags = fcntl(listenfd, F_GETFL, 0);
  fcntl(listenfd, F_SETFL, flags | O_NONBLOCK);
  struct sockaddr_in servaddr;
  memset(&servaddr, 0, sizeof(servaddr));
  servaddr.sin_family = AF_INET;
  servaddr.sin_addr.s_addr = INADDR_ANY;
  servaddr.sin_port = htons(port);

  enable = 1;
  if (setsockopt(listenfd, SOL_SOCKET, SO_REUSEPORT, &enable, sizeof(enable)) < 0)
    return -1;

  if (bind(listenfd, (struct sockaddr *)&servaddr, sizeof(servaddr)) < 0)
    return -1;

  if (listen(listenfd, SOMAXCONN) < 0)
    return -1;

  return listenfd;
}

/*
 * Calculate the difference between two pointers
 */
static inline uintptr_t ptr_diff(uintptr_t p1, uintptr_t p2) { return (uintptr_t)(p1 > p2) ? (p1 - p2) : (p2 - p1); }

static inline size_t get_nroutes(Route *routes) {
  Route *route;
  for (size_t i = 0;; i++) {
    route = &routes[i];
    if (!route->path && !route->handler && !route->method)
      return i;
  }
}

static inline long get_content_length(char *src, char *end) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return -1;
    key = line;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, "Content-Length") != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;

    *line_end = '\0';
    long res = atol(value);
    *line_end = '\r';

    return res;
  }
  return -1;
}

static inline bool have_header(char *src, char *end, const char *header_key, const char *header_value) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    key = line;
    while (*key == ' ')
      key++;
    while (*header_key == ' ')
      header_key++;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return false;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, header_key) != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;
    while (*header_value == ' ')
      header_value++;

    *line_end = '\0';
    bool res = (strcasecmp(value, header_value) == 0);
    *line_end = '\r';

    return res;
  }

  return false;
}

static inline const char *method_str(Method method) {
  switch (method) {
  case GET:
    return "GET";
    break;
  case HEAD:
    return "HEAD";
    break;
  case POST:
    return "POST";
    break;
  case PUT:
    return "PUT";
    break;
  case DELETE:
    return "DELETE";
    break;
  case CONNECT:
    return "CONNECT";
    break;
  case OPTIONS:
    return "OPTIONS";
    break;
  case TRACE:
    return "TRACE";
    break;
  case PATCH:
    return "PATCH";
    break;
  default:
    return NULL;
  }
}

static inline uint8_t method_len(Method method) {
  switch (method) {
  case GET:
    return 3;
    break;
  case HEAD:
    return 4;
    break;
  case POST:
    return 4;
    break;
  case PUT:
    return 3;
    break;
  case DELETE:
    return 6;
    break;
  case CONNECT:
    return 7;
    break;
  case OPTIONS:
    return 7;
    break;
  case TRACE:
    return 5;
    break;
  case PATCH:
    return 5;
    break;
  default:
    return 0;
  }
}

static inline size_t round_to_blocks(size_t size) {
  size_t nblocks = BYTES_TO_BLOCKS(size);
  nblocks = CEIL_BLOCKS(nblocks);
  return nblocks;
}

/*
 * Count the digits in unsigned 64-bit int
 */
static inline int countd(uint64_t num) {
  if (num < 10ULL)
    return 1;
  if (num < 100ULL)
    return 2;
  if (num < 1000ULL)
    return 3;
  if (num < 10000ULL)
    return 4;
  if (num < 100000ULL)
    return 5;
  if (num < 1000000ULL)
    return 6;
  if (num < 10000000ULL)
    return 7;
  if (num < 100000000ULL)
    return 8;
  if (num < 1000000000ULL)
    return 9;
  if (num < 10000000000ULL)
    return 10;
  if (num < 100000000000ULL)
    return 11;
  if (num < 1000000000000ULL)
    return 12;
  if (num < 10000000000000ULL)
    return 13;
  if (num < 100000000000000ULL)
    return 14;
  if (num < 1000000000000000ULL)
    return 15;
  if (num < 10000000000000000ULL)
    return 16;
  if (num < 100000000000000000ULL)
    return 17;
  if (num < 1000000000000000000ULL)
    return 18;
  if (num < 10000000000000000000ULL)
    return 19;
  return 20;
}

/*
 * Get the time elabsed in ms
 */
static inline uint64_t get_time() {
  struct timespec ts;
  clock_gettime(CLOCK_MONOTONIC, &ts);
  return (uint64_t)(ts.tv_sec) * 1000 + (ts.tv_nsec / 1000000);
}

static inline FILE *log_init(const char *path) {
  FILE *res = fopen(path, "a+");
  setvbuf(res, NULL, _IONBF, 0);
  return res;
}

static inline int16_t pollevs(int connfd) {
  struct pollfd pfd;
  pfd.fd = connfd;
  pfd.events = POLLIN | POLLOUT | POLLERR;
  int res = poll(&pfd, 1, 0);
  if (res < 0)
    return POLLERR;
  return pfd.revents;
}

// FIXME This needs to be updated
static inline conn_t *MP_use_once(size_t nblocks, int fd) {

  void *mem = malloc(sizeof(conn_t) + 8 + (IOVEC_NBLOCKS * MP_BLOCK));
  struct conn_t *conn = (conn_t *)mem;
  memset(conn, 0, sizeof(conn_t));
  conn->ios = mem + sizeof(conn_t) + 8;

  if (nblocks > 0) {
    struct iovec *iov = &conn->ios[conn->nios++];
    mem = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (mem == MAP_FAILED)
      return NULL;
    iov->iov_base = mem;
    iov->iov_len = ALIGN_TO_PAGESIZE(nblocks * MP_BLOCK);
  }

  conn->flags |= CF_IN_HEAP;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;

  return conn;
}

static inline int find_freec() {
  uint64_t *word;
  size_t map_size = (sizeof(uint64_t) * 8);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    word = &pool.freecs[i / map_size];

    if (*word == 0) { // All used
      i += (map_size - 1);
      continue;
    }

    i += __builtin_ctzll(*word);
    MARK_BIT_USED(*word, i);
    return i;
  }

  return -1;
}

static inline int MP_init(size_t npages) {
  if (!npages)
    return -1;

  /*** Setup ***/
  pool.npages = npages;
  pool.pagesize = sysconf(_SC_PAGESIZE);

  /*** Pool ***/
  pool.bpool = mmap(NULL, pool.npages * pool.pagesize, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  if (pool.bpool == MAP_FAILED)
    return -1;
  pool.nblocks = (pool.npages * pool.pagesize) / MP_BLOCK;

  /*** Blocks ***/
  pool.blocks = malloc(sizeof(void *) * pool.nblocks);
  if (!pool.blocks)
    return -1;
  for (size_t i = 0; i < pool.nblocks; i++)
    pool.blocks[i] = pool.bpool + (i * MP_BLOCK);

  /*** Freebs ***/
  // if (posix_memalign((void **)&pool.freebs, 64, bitmap_size * sizeof(uint64_t)) < 0)
  size_t bitmap_size = (pool.nblocks + 63) / 64;
  pool.freebs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freebs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freebs[i] = UINT64_MAX;

  /*** Cpool ***/
  pool.cpool = (conn_t *)malloc(sizeof(conn_t) * MAX_CONNS);
  if (!pool.cpool)
    return -1;

  /*** Conns ***/
  pool.conns = (conn_t **)malloc(sizeof(conn_t *) * MAX_CONNS);
  if (!pool.conns)
    return -1;
  size_t conn_size = sizeof(conn_t);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    pool.conns[i] = (conn_t *)((char *)pool.cpool + (i * conn_size));
    pool.conns[i]->fd = -1;
    pool.conns[i]->in_fd = -1;
    pool.conns[i]->out_fd = -1;
  }

  /*** Freecs ***/
  bitmap_size = (MAX_CONNS + 63) / 64;
  pool.freecs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freecs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freecs[i] = UINT64_MAX;

  return 0;
}

static inline int MP_use_blks(size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t max_start = pool.nblocks - nblocks;
  size_t full_chunks = (nblocks / 64) * 64;

  for (size_t i = 0, c = 0; i <= max_start; i++, c++) {
    bool free = true;

    for (size_t j = 0; j < full_chunks; j += 64) {
      size_t word_index = (i + j) / 64;
      if (pool.freebs[word_index] != UINT64_MAX) {
        free = false;
        i += 63;
        break;
      }
    }

    for (size_t j = full_chunks; j < nblocks; j++) {
      size_t bit_index = i + j;
      size_t word_index = bit_index / 64;
      size_t bit_in_word = bit_index % 64;

      if (!BIT_IS_FREE(pool.freebs[word_index], bit_in_word)) {
        free = false;
        i += j;
        break;
      }
    }

    if (free) {
      for (size_t j = 0; j < full_chunks; j += 64) {
        size_t word_index = (i + j) / 64;
        pool.freebs[word_index] = 0;
      }

      for (size_t j = full_chunks; j < nblocks; j++) {
        size_t bit_index = i + j;
        size_t word_index = bit_index / 64;
        size_t bit_in_word = bit_index % 64;

        MARK_BIT_USED(pool.freebs[word_index], bit_in_word);
      }

      return i;
    }
  }

  return -1;
}

static inline int MP_free_blks(size_t bindex, size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t full_chunks = (nblocks / 64) * 64;
  for (size_t i = 0; i < full_chunks; i += 64) {
    size_t word_index = (bindex + i) / 64;
    pool.freebs[word_index] = UINT64_MAX;
  }

  for (size_t i = full_chunks; i < nblocks; i++) {
    size_t bit_index = bindex + i;
    size_t word_index = bit_index / 64;
    size_t bit_in_word = bit_index % 64;

    MARK_BIT_FREE(pool.freebs[word_index], bit_in_word);
  }

  memset(pool.blocks[bindex], 0, nblocks * MP_BLOCK);
  return 0;
}

static inline conn_t *MP_use(size_t nblocks, int fd, bool once) {
  if (fd <= 0)
    return NULL;
  if (once)
    return MP_use_once(nblocks, fd);

  int cindex = find_freec();
  if (cindex < 0) {
    LOG("Err: cindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  conn_t *conn = pool.conns[cindex];

  int ios_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (ios_bindex < 0) {
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }

  struct iovec *ios = pool.blocks[ios_bindex];
  conn->ios = ios;

  int rec_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (rec_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct iovec *rec = pool.blocks[rec_bindex];
  conn->rec = rec;

  int msg_bindex = MP_use_blks(MSG_NBLOCKS);
  if (msg_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct msghdr *msg = pool.blocks[msg_bindex];
  conn->msg = msg;

  if (nblocks > 0) {
    int bindex = MP_use_blks(nblocks);
    if (bindex < 0) {
      MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
      MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
      MP_free_blks(msg_bindex, IOVEC_NBLOCKS);
      MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
      LOG("Err: bindex < 0; will use MP_use_once\n");
      return MP_use_once(nblocks, fd);
    }

    size_t iov_index = conn->nios++;
    struct iovec *iov = &conn->ios[iov_index];
    struct iovec *rec = &conn->rec[iov_index];
    iov->iov_base = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
  }

  conn->msg->msg_iov = conn->ios;
  conn->msg->msg_iovlen = conn->nios;
  conn->cindex = cindex;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;
  return conn;
}

static inline void MP_shed(conn_t *conn, size_t iov_index, size_t nios) {
  struct iovec *iov, *rec;
  size_t bindex, nblocks, index;

  for (size_t i = 0; i < nios; i++) {
    index = iov_index + i;
    iov = &conn->ios[index];
    rec = &conn->rec[index];
    if (!rec || !rec->iov_base)
      continue;
    if (!IN_POOL(rec->iov_base)) {
      munmap(rec->iov_base, rec->iov_len / pool.pagesize);
    } else {
      bindex = ptr_diff((uintptr_t)rec->iov_base, (uintptr_t)pool.bpool) / MP_BLOCK;
      nblocks = rec->iov_len / MP_BLOCK;
      MP_free_blks(bindex, nblocks);
    }
    memset(iov, 0, sizeof(struct iovec));
    memset(rec, 0, sizeof(struct iovec));
    conn->nios--;
  }
}

static inline int MP_expand(conn_t *conn, size_t nblocks, bool once) {
  void *bptr;
  int iov_index, bindex;
  struct iovec *iov, *rec;

  iov_index = conn->nios++;
  iov = &conn->ios[iov_index];
  rec = &conn->rec[iov_index];

  if (nblocks == 0)
    return iov_index;

  if (once) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_base = bptr;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
    return iov_index;
  }

  bindex = MP_use_blks(nblocks);
  if (bindex < 0) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_len = iov->iov_len;
  } else {
    bptr = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_len = iov->iov_len;
  }

  iov->iov_base = bptr;
  rec->iov_base = iov->iov_base;
  return iov_index;
}

static inline int MP_free(conn_t *conn) {
  if (!conn)
    return -1;
  size_t bindex, nblocks;
  uint64_t *word;

  MP_shed(conn, 0, conn->nios);
  if (conn->flags & CF_IN_HEAP) {
    if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
      close(conn->fd);
    free(conn);
    return 0;
  }

  word = &pool.freecs[conn->cindex / 64];
  if (conn->cindex > MAX_CONNS)
    return -1;
  else if (BIT_IS_FREE(*word, conn->cindex))
    return 0;

  bindex = ptr_diff((uintptr_t)conn->ios, (uintptr_t)pool.bpool) / MP_BLOCK;
  nblocks = IOVEC_NBLOCKS;
  MP_free_blks(bindex, nblocks);

  bindex = ptr_diff((uintptr_t)conn->rec, (uintptr_t)pool.bpool) / MP_BLOCK;
  MP_free_blks(bindex, nblocks);

  if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
    close(conn->fd);

  MARK_BIT_FREE(*word, conn->cindex);
  memset(conn, 0, sizeof(conn_t));
  conn->fd = -1;
  conn->in_fd = -1;
  conn->out_fd = -1;
  return 0;
}

static inline void MP_clear(conn_t *conn) {
  conn_t *recv_conn = conn->recv_conn;
  conn_t *send_conn = conn->send_conn;
  if (recv_conn)
    MP_free(recv_conn);
  if (send_conn)
    MP_free(send_conn);
}

static inline void MP_exit(MPool *pool) {
  munmap(pool->bpool, pool->npages);
  free(pool->cpool);
  free(pool->blocks);
  free(pool->conns);
  free(pool->freebs);
  free(pool->freecs);
}

static inline void MP_timeout() {
  conn_t *conn;
  int16_t res;
  uint64_t now;
  size_t windex = 0;
  uint64_t *word = &pool.freecs[0];
  for (size_t i = 0; i < MAX_CONNS; i++) {
    if ((i / 64) < windex)
      word = &pool.freecs[++windex];

    if (*word == UINTMAX_MAX) {
      i = (i / 64) * 64 + 64;
      continue;
    }

    conn = pool.conns[i];
    if (!conn || conn->fd == -1)
      continue;

    res = pollevs(conn->fd);

    now = get_time();
    if (res & POLLERR) {
      MP_clear(conn);
      continue;
    }
    if (res & POLLIN) {
      if (pool.rtimeout > 0 && (now - conn->last_read) >= pool.rtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (res & POLLOUT) {
      if (pool.wtimeout > 0 && (now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (!(res & POLLIN || res & POLLOUT)) {
      if ((pool.rtimeout > 0 && now - conn->last_read) >= pool.rtimeout
          || (pool.wtimeout > 0 && now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
  }
}

/*
 * Calculate the length of a status string
 */
static inline size_t status_len(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return 8;
  case STATUSSWITCHINGPROTOCOLS:
    return 19;
  case STATUSPROCESSING:
    return 10;
  case STATUSEARLYHINTS:
    return 11;
  case STATUSOK:
    return 2;
  case STATUSCREATED:
    return 7;
  case STATUSACCEPTED:
    return 8;
  case STATUSNONAUTHORITATIVE:
    return 29;
  case STATUSNOCONTENT:
    return 10;
  case STATUSRESETCONTENT:
    return 13;
  case STATUSPARTIALCONTENT:
    return 15;
  case STATUSMULTISTATUS:
    return 12;
  case STATUSALREADYREPORTED:
    return 16;
  case STATUSIMUSED:
    return 7;
  case STATUSMULTIPLECHOICES:
    return 16;
  case STATUSMOVEDPERMANENTLY:
    return 17;
  case STATUSFOUND:
    return 5;
  case STATUSSEEOTHER:
    return 9;
  case STATUSNOTMODIFIED:
    return 12;
  case STATUSUSEPROXY:
    return 9;
  case STATUSTEMPORARYREDIRECT:
    return 18;
  case STATUSPERMANENTREDIRECT:
    return 18;
  case STATUSBADREQUEST:
    return 11;
  case STATUSUNAUTHORIZED:
    return 12;
  case STATUSPAYMENTREQUIRED:
    return 16;
  case STATUSFORBIDDEN:
    return 9;
  case STATUSNOTFOUND:
    return 9;
  case STATUSMETHODNOTALLOWED:
    return 18;
  case STATUSNOTACCEPTABLE:
    return 14;
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return 29;
  case STATUSREQUESTTIMEOUT:
    return 15;
  case STATUSCONFLICT:
    return 8;
  case STATUSGONE:
    return 4;
  case STATUSLENGTHREQUIRED:
    return 15;
  case STATUSPRECONDITIONFAILED:
    return 19;
  case CONTENTTOOLARGE:
    return 17;
  case STATUSURITOOLONG:
    return 12;
  case STATUSUNSUPPORTEDMEDIATYPE:
    return 22;
  case STATUSRANGENOTSATISFIABLE:
    return 21;
  case STATUSEXPECTATIONFAILED:
    return 18;
  case STATUSMISDIRECTEDREQUEST:
    return 19;
  case STATUSUNPROCESSABLECONTENT:
    return 21;
  case STATUSLOCKED:
    return 6;
  case STATUSFAILEDDEPENDENCY:
    return 17;
  case STATUSTOOEARLY:
    return 9;
  case STATUSUPGRADEREQUIRED:
    return 16;
  case STATUSPRECONDITIONREQUIRED:
    return 21;
  case STATUSTOOMANYREQUESTS:
    return 17;
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return 31;
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return 29;
  case STATUSInternalServerError:
    return 21;
  case STATUSNOTIMPLEMENTED:
    return 15;
  case STATUSBADGATEWAY:
    return 11;
  case STATUSSERVICEUNAVAILABLE:
    return 19;
  case STATUSGATEWAYTIMEOUT:
    return 15;
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return 26;
  case STATUSVARIANTALSONEGOTIATES:
    return 23;
  case STATUSINSUFFICIENTSTORAGE:
    return 20;
  case STATUSLOOPDETECTED:
    return 13;
  case STATUSNOTEXTENDED:
    return 12;
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return 31;
  default:
    return 0;
  }
}

/*
 * Return the status code string as string literal
 */
static inline char *status_str(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return "Continue";
  case STATUSSWITCHINGPROTOCOLS:
    return "Switching Protocols";
  case STATUSPROCESSING:
    return "Processing";
  case STATUSEARLYHINTS:
    return "Early Hints";
  case STATUSOK:
    return "OK";
  case STATUSCREATED:
    return "Created";
  case STATUSACCEPTED:
    return "Accepted";
  case STATUSNONAUTHORITATIVE:
    return "Non-Authoritative Information";
  case STATUSNOCONTENT:
    return "No Content";
  case STATUSRESETCONTENT:
    return "Reset Content";
  case STATUSPARTIALCONTENT:
    return "Partial Content";
  case STATUSMULTISTATUS:
    return "Multi-Status";
  case STATUSALREADYREPORTED:
    return "Already Reported";
  case STATUSIMUSED:
    return "Im Used";
  case STATUSMULTIPLECHOICES:
    return "Multiple Choices";
  case STATUSMOVEDPERMANENTLY:
    return "Moved Permanently";
  case STATUSFOUND:
    return "Found";
  case STATUSSEEOTHER:
    return "See Other";
  case STATUSNOTMODIFIED:
    return "Not Modified";
  case STATUSUSEPROXY:
    return "Use Proxy";
  case STATUSTEMPORARYREDIRECT:
    return "Temporary Redirect";
  case STATUSPERMANENTREDIRECT:
    return "Permanent Redirect";
  case STATUSBADREQUEST:
    return "Bad Request";
  case STATUSUNAUTHORIZED:
    return "Unauthorized";
  case STATUSPAYMENTREQUIRED:
    return "Payment Required";
  case STATUSFORBIDDEN:
    return "Forbidden";
  case STATUSNOTFOUND:
    return "Not Found";
  case STATUSMETHODNOTALLOWED:
    return "Method Not Allowed";
  case STATUSNOTACCEPTABLE:
    return "Not Acceptable";
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return "Proxy Authentication Required";
  case STATUSREQUESTTIMEOUT:
    return "Request Timeout";
  case STATUSCONFLICT:
    return "Conflict";
  case STATUSGONE:
    return "Gone";
  case STATUSLENGTHREQUIRED:
    return "Length Required";
  case STATUSPRECONDITIONFAILED:
    return "Precondition Failed";
  case CONTENTTOOLARGE:
    return "Content Too Large";
  case STATUSURITOOLONG:
    return "URI Too Long";
  case STATUSUNSUPPORTEDMEDIATYPE:
    return "Unsupported Media Type";
  case STATUSRANGENOTSATISFIABLE:
    return "Range Not Satisfiable";
  case STATUSEXPECTATIONFAILED:
    return "Expectation Failed";
  case STATUSMISDIRECTEDREQUEST:
    return "Misdirected Request";
  case STATUSUNPROCESSABLECONTENT:
    return "Unprocessable Content";
  case STATUSLOCKED:
    return "Locked";
  case STATUSFAILEDDEPENDENCY:
    return "Failed Dependency";
  case STATUSTOOEARLY:
    return "Too Early";
  case STATUSUPGRADEREQUIRED:
    return "Upgrade Required";
  case STATUSPRECONDITIONREQUIRED:
    return "Precondition Required";
  case STATUSTOOMANYREQUESTS:
    return "Too Many Requests";
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return "Request Header Fields Too Large";
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return "Unavailable For Legal Reasons";
  case STATUSInternalServerError:
    return "Internal Server Error";
  case STATUSNOTIMPLEMENTED:
    return "Not Implemented";
  case STATUSBADGATEWAY:
    return "Bad Gateway";
  case STATUSSERVICEUNAVAILABLE:
    return "Service Unavailable";
  case STATUSGATEWAYTIMEOUT:
    return "Gateway Timeout";
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return "HTTP Version Not Supported";
  case STATUSVARIANTALSONEGOTIATES:
    return "Variant Also Negotiates";
  case STATUSINSUFFICIENTSTORAGE:
    return "Insufficient Storage";
  case STATUSLOOPDETECTED:
    return "Loop Detected";
  case STATUSNOTEXTENDED:
    return "Not Extended";
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return "Network Authentication Required";
  default:
    return 0;
  }
}

/*
 * Return true if routes match
 */
static inline bool route_equ(Route *route, Request *req) {
  return route->method == req->method && strncmp(route->path, req->path, strlen(route->path)) == 0;
}

/*
 * Return the matching route index on success. -1 on failure
 */
static inline int match_route(Server *serv, Request *req) {
  for (size_t i = 0; i < serv->_nroutes; i++) {
    Route route = serv->routes[i];
    if (!req->path || !route.path)
      continue;
    if (route_equ(&route, req))
      return i;
    else if (req->method == HEAD && route.method == GET && strcmp(route.path, req->path) == 0)
      return i;
  }
  return -1;
}

/*
 * Return true if the response should contain the Content-Length header
 */
static inline bool should_have_content_length(Request *req, ResWriter *res) {
  return (req->method != CONNECT              // CONNECT request
          && res->status != STATUSNOCONTENT   // 204 response
          && res->status != STATUSNOTMODIFIED // 304 response
          && res->status >= 200);             // 1xx response
}

/*
 * Format http response from the ResWriter.
 * Return response size on success, 0 on failure.
 */
static inline size_t fmt_res(Request *req, ResWriter *res, char *buffer, size_t buffer_size) {
  if (!res || !buffer || buffer_size == 0)
    return 0;

  size_t res_len, total = 0;
  char *dst = buffer;
  size_t maxlen = buffer_size;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t body_length = res->len;

  res_len = snprintf(dst, maxlen, "HTTP/1.1 %d %s", (int)res->status, status_str(res->status));
  total += res_len;
  dst += res_len;
  maxlen -= res_len;

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    res_len = snprintf(dst, maxlen, "\r\n%s: %s", header->key, header->value);
    total += res_len;
    dst += res_len;
    maxlen -= res_len;
  }

  if (have_content_length) {
    res_len = snprintf(dst, maxlen, "\r\nContent-Length: %lu", body_length);
    total += res_len, dst += res_len, maxlen -= res_len;
  }

  memcpy(dst, "\r\n\r\n", 4);
  total += 4, dst += 4, maxlen -= 4;

  return total;
}

static inline size_t res_len(Request *req, ResWriter *res) {
  if (!req || !res)
    return 0;

  if (!res->status)
    res->status = STATUSOK;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t result = 0;
  result += STRLEN("HTTP/1.1 ");     // HTTP version
  result += 4;                       // Status code + space
  result += status_len(res->status); // Status name

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    result += 2;                       // "\r\n"
    result += strlen(header->key) + 2; // Header key + ':' + space
    result += strlen(header->value);   // header value
  }

  if (have_content_length) {
    result += 2;                          // "\r\n"
    result += STRLEN("Content-Length: "); // Header key
    result += countd(res->len);           // Header value
  }

  result += 4; // "\r\n\r\n"

  return result;
}

static inline int send_empty_res(Status status) {
  size_t res_len = STRLEN("HTTP/1.1 ")        // HTTP version
                   + countd((uint64_t)status) // status code
                   + 1                        // space
                   + (int)status_len(status)  // status string
                   + 4;                       // \r\n\r\n

  conn_t *conn = current_send;
  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, res_len);
  if (snprintf((char *)rec->iov_base, res_len + 1, "HTTP/1.1 %d %s\r\n\r\n", (int)status, status_str(status))
      != (int)res_len)
    return -1;

  return usendmsg(conn, 0, 1);
}

static inline ssize_t read_socket(int sockfd, size_t len) {
  if (len == 0 || sockfd <= 0)
    return 0;
  char buff[1024 * 8];
  return read(sockfd, buff, 1024 * 8);
}

static inline int read_method(Method *method, void *src) {
  if (memcmp(src, "GET", 3) == 0)
    *method = GET;
  else if (memcmp(src, "POST", 4) == 0)
    *method = POST;
  else if (memcmp(src, "HEAD", 4) == 0)
    *method = HEAD;
  else if (memcmp(src, "PUT", 3) == 0)
    *method = PUT;
  else if (memcmp(src, "DELETE", 6) == 0)
    *method = DELETE;
  else if (memcmp(src, "CONNECT", 7) == 0)
    *method = CONNECT;
  else if (memcmp(src, "OPTIONS", 7) == 0)
    *method = OPTIONS;
  else if (memcmp(src, "TRACE", 5) == 0)
    *method = TRACE;
  else if (memcmp(src, "PATCH", 5) == 0)
    *method = PATCH;
  else
    return -1;

  return 0;
}

static inline int sendmsg_res(Request *req, ResWriter *res) {
  conn_t *conn;
  size_t head_size, res_size;
  struct iovec *iov;

  conn = current_send;
  iov = &conn->ios[0];
  head_size = res_len(req, res);
  if (head_size == 0)
    return -1;

  conn->data_left += head_size;
  res_size = fmt_res(req, res, iov->iov_base, (head_size + 1));
  if (res_size != head_size)
    return -1;
  iov->iov_len = res_size;

  return usendmsg(conn, 0, conn->nios);
}

static inline int read_req(Request *req, char *req_buffer) {
  if (!req_buffer)
    return -1;
  /*** Method ***/
  char *sep = strchr(req_buffer, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }
  *sep = '\0';
  if (read_method(&req->method, req_buffer) < 0)
    return -1;

  /*** Path ***/
  char *fullpath = sep + 1;
  sep = strchr(fullpath, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }

  *sep = '\0';
  req->path = fullpath;
  /*** Params ***/
  char *paramStart = strchr(fullpath, '?');
  if (paramStart) {
    *paramStart++ = '\0';
    int params_count = 0;
    params_count = HK_parse_params(paramStart, req->params, MAX_URL_PARAMETERS);
    if (params_count > 0)
      req->params_count = params_count;
    else
      req->params_count = 0;
  } else {
    req->params = NULL;
    req->params_count = 0;
  }

  /*** Headers ***/
  char *headStart = strstr(sep + 1, "\r\n");
  char *headEnd = strstr(sep + 1, "\r\n\r\n");
  if (!headStart) {
    LOG("read_req: !headStart\n");
    return -1;
  };

  memset(headStart, 0, 2);
  headStart += 2;
  memset(headEnd, 0, 4);
  headEnd += 4;

  int headers_count = HK_parse_headers(headStart, req->headers, MAX_REQ_HEADERS);
  if (headers_count <= 0)
    return -1;
  req->headers_count = headers_count;

  /*** Host ***/
  int index = HK_get_header(req, "Host");
  if (index < 0)
    return -1;
  char *host = req->headers[index].value;
  req->hostname = host;

  /*** Port ***/
  char *colon = strchr(host, ':');
  if (colon) {
    *colon++ = '\0';
    req->port = atoi(colon);
  } else {
    req->port = PORT;
  }
  return 0;
}
static inline int process_req(Server *serv, conn_t *conn) {
  if (!conn || conn->fd == -1)
    return -1;

  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;
  if (read_req(&req, conn->ios[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    LOG("Err: route_index == -1\n");
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;
  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  sendmsg_res(&req, &res);

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int new_conn(int connfd) {
  if (connfd <= 0)
    return -1;

  current_recv = MP_use(KB * 2, connfd, false);
  current_send = MP_use(KB * 2, connfd, false);

  current_recv->recv_conn = current_recv;
  current_recv->send_conn = current_send;

  current_send->send_conn = current_send;
  current_send->recv_conn = current_recv;

  conn_t *conn = current_recv;
  if (ufrecvmsg(conn, 0, 1) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

static inline int resubmit_sendmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return usendmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int resubmir_recvmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    // FIXME the len should be increased
    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return urecvmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int handle_sendmsg_complete(conn_t *conn) {
  struct iovec *iov, *rec;

  MP_shed(conn, 1, conn->nios - 1);
  iov = &conn->ios[0];
  rec = &conn->rec[0];
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;

  return ufrecvmsg(conn->recv_conn, 0, 1);
}

static inline int handle_sendmsg(conn_t *conn, int res, bool zc) {
  if (!conn || conn->fd == -1)
    return -1;

  conn->data_left -= res;
  if (conn->data_left > 0)
    return resubmit_sendmsg(conn, res);

  if (zc)
    return 0;

  return handle_sendmsg_complete(conn);
}

static inline int handle_insplice(conn_t *conn) {
  conn->op = OUTSPLICE;
  return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
}
static inline int handle_outsplice(conn_t *conn, int res) {
  conn->data_left -= res;
  if (conn->data_left > 0) {
    conn->op = INSPLICE;
    return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
  }

  conn_t *recv_conn = conn->recv_conn;
  struct iovec *iov = &recv_conn->ios[0];
  memset(iov->iov_base, 0, iov->iov_len);
  if (urecv(recv_conn, iov->iov_base, iov->iov_len, MSG_PEEK) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

/*
static inline int handle_recv(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  void *bptr = conn->ios[0].iov_base;
  void *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  void *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  return process_req(serv, conn);
}
*/
static inline int find_route(Server *serv, char *bptr) {
  Request req = {0};
  if (read_method(&req.method, bptr) < 0) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  };
  char *space = strchr(bptr, ' ');
  req.path = (space + 1);
  space = strchr(req.path, ' ');
  *space = '\0';
  int route_index = match_route(serv, &req);
  *space = ' ';
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }
  return route_index;
}

static inline int run_handler(Server *serv, conn_t *conn, bool uses_body) {
  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;

  if (read_req(&req, conn->rec[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  if (uses_body) {
    int h_index = HK_get_header(&req, "Content-Length");
    long body_size = atol(req.headers[h_index].value);
    if (body_size >= 0) {
      req.body.ptr = conn->rec[1].iov_base;
      req.body.size = body_size;
    } else {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    }
  }

  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  if (sendmsg_res(&req, &res) < 0)
    return -1;

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int handle_frecvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  char *bptr = (char *)conn->ios[0].iov_base;
  char *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  char *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  size_t head_size = (headEnd + 4) - bptr;
  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  int route_index = find_route(serv, bptr);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  bool uses_body = serv->routes[route_index].uses_body;
  long body_size = get_content_length(headstart + 2, headEnd + 4);
  if (body_size == -1) {
    if (uses_body) {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    } else {
      body_size = 0;
    }
  }

  conn->head_size = head_size;
  if (!uses_body) {
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  if (res == (int)(head_size + body_size)) {
    size_t iov_index = MP_expand(conn, round_to_blocks(body_size), false);
    memcpy(conn->rec[iov_index].iov_base, headEnd + 4, body_size);
    conn->ios[iov_index].iov_len = body_size;
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  conn->data_left = body_size - (res - head_size);
  bool once = ((size_t)body_size > (size_t)((pool.nblocks * MP_BLOCK) / 10));
  size_t iov_index = MP_expand(conn, round_to_blocks(body_size), once);
  memcpy(conn->rec[iov_index].iov_base, headEnd + 4, (res - head_size));
  conn->ios[iov_index].iov_base += (res - head_size);

  return urecvmsg(conn, iov_index, 1);
}

static inline int handle_recvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  if (conn->data_left > 0) {
    conn->data_left -= res;
    if (conn->data_left == 0) {
      conn->flags &= CF_HANDLER_READY;
      return run_handler(serv, conn, true);
    }

    conn->flags &= ~CF_HANDLER_READY;
    conn->ios[1].iov_base += res;
    return urecvmsg(conn, 1, 1);
  }

  conn->flags &= CF_HANDLER_READY;
  return run_handler(serv, conn, true);
}

static inline int serv_init(Server *serv) {
#if DEBUG
  logfd = log_init("log.txt");
  if (!logfd) {
    printf("log_init failed");
    return -1;
  }
#endif
  serv->_nroutes = get_nroutes(serv->routes);

  int pipefd[2];
  if (pipe(pipefd) < 0)
    return -1;
  pipe_in = pipefd[0];
  pipe_out = pipefd[1];
  nullfd = open("/dev/null", O_WRONLY);
  pipe_sz = fcntl(pipefd[0], F_GETPIPE_SZ);
  if (pipe_sz < 0)
    return -1;

  pool.rtimeout = serv->rtimeout;
  pool.wtimeout = serv->wtimeout;
  if (MP_init(MAX_CONNS * 8) < 0)
    return -1;
  LOG("pool initialized\n");

  if (io_uring_queue_init(MAX_CONNS, &ring, 0) < 0)
    return -1;
  LOG("uring initialized\n");

  int listenfd;
  if ((listenfd = tcp_listen(serv->port)) < 0)
    return -1;
  LOG("socket initialized\n");

  return umaccept(listenfd);
}

static inline int serv_listen(Server *serv) {
  // uint64_t last_check = get_time();
  while (true) {
    // uint64_t now = get_time();
    // if ((now - last_check) >= 200) {
    //   last_check = now;
    //   LOG("CM: CM_check ran\n");
    //   MP_timeout();
    // }

    LOG("SQ ready: %u, CQ ready: %u\n", io_uring_sq_ready(&ring), io_uring_cq_ready(&ring));
    struct io_uring_cqe *cqe;
    if (io_uring_wait_cqe(&ring, &cqe) < 0)
      continue;

    int res = cqe->res;
    LOG("res = %d\n", res);
    conn_t *conn = NULL;
    if (cqe->user_data > 100) {
      conn = (conn_t *)cqe->user_data;
      current_recv = (conn_t *)conn->recv_conn;
      current_send = (conn_t *)conn->send_conn;
    }

    if (res > 0) {
      if (cqe->user_data == ACCEPT) {
        LOG("new conn created\n");
        new_conn(res);
      } else if (conn && conn->fd != -1) {
        LOG("conn[%d]: conn.fd = %d; conn.op = %d\n", conn->cindex, conn->fd, conn->op);
        switch (conn->op) {
        case FRECVMSG:
          if (handle_frecvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case RECVMSG:
          if (handle_recvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case SENDMSG:
        case SENDMSGZC:
          // conn->last_write = get_time();
          bool zc = (conn->op == SENDMSGZC);
          if (handle_sendmsg(conn, res, zc) < 0)
            MP_clear(conn);
          break;
        case INSPLICE:
          if (handle_insplice(conn) < 0)
            MP_clear(conn);
          break;
        case OUTSPLICE:
          if (handle_outsplice(conn, res) < 0)
            MP_clear(conn);
          break;
        }
      }
    } else if (res == 0) {
      if (conn && conn->fd != -1) {
        switch (conn->op) {
        case SENDMSGZC:
          conn->zc_notifs--;
          if (conn->zc_notifs == 0 && handle_sendmsg_complete(conn) < 0)
            MP_clear(conn);
          break;
        case RECV:
          MP_clear(conn);
          break;
        }
      }
    } else {
      if (conn && conn->fd != -1) {
        if (res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR) {
          LOG("conn && conn->fd != -1 && res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR\n");
          MP_clear(conn);
        } else {
          LOG("res == -EAGAIN || res == -EWOULDBLOCK || res == -EINTR\n");
          conn = conn->recv_conn;
          struct iovec *iov = &conn->ios[0];
          memset(iov->iov_base, 0, iov->iov_len);
          if (urecv(conn, iov->iov_base, iov->iov_len, 0) < 0)
            MP_clear(conn);
        }
      }
    }

    LOG("uring operation seen\n");
    io_uring_cqe_seen(&ring, cqe);
  }

  io_uring_queue_exit(&ring);
  MP_exit(&pool);
  return 0;
}

/*** Helper ***/
static inline int _HK_write(void *data, size_t size) {
  size_t nblocks;
  int iov_index;
  conn_t *conn;
  struct iovec *iov;
  bool once;

  conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  nblocks = round_to_blocks(size);
  iov_index = MP_expand(conn, nblocks, once);
  iov = &conn->ios[iov_index];

  memcpy(iov->iov_base, data, size);
  iov->iov_len = size;
  conn->data_left += size;

  return 0;
}
static inline int _HK_write_body(Request *req, size_t offset, size_t size) {
  if (size > req->body.size || offset > req->body.size)
    return -1;

  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  int iov_index = MP_expand(conn, 0, false);
  struct iovec *iov = &conn->ios[iov_index];
  struct iovec *rec = &conn->rec[iov_index];
  rec->iov_base = req->body.ptr + offset;
  rec->iov_len = size;
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;
  conn->data_left += rec->iov_len;
  return 0;
}
/*
static inline int _HK_mem(size_t size, HKMem *mem) {
  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  bool once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  size_t nblocks = round_to_blocks(size);
  int iov_index = MP_expand(conn, nblocks, once);
  struct iovec *iov = &conn->ios[iov_index];
  mem->ptr = iov->iov_base;
  mem->size = iov->iov_len;
  mem->_iov_index = iov_index;
  mem->_flags = (IN_POOL(iov->iov_base)) ? CF_IN_POOL : CF_IN_HEAP;
  return 0;
}

static inline void _HK_send(HKMem *mem, size_t size) {
  conn_t *conn = current_send;
  struct iovec *iov = &conn->ios[mem->_iov_index];
  iov->iov_len = size;
  conn->data_left += size;
}
  */
#endif#define _GNU_SOURCE
#ifndef UTILS_H
#define UTILS_H

#include "hunk.h"
#include <arpa/inet.h>
#include <fcntl.h>
#include <liburing.h>
#include <netdb.h>
#include <signal.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/poll.h>
#include <sys/prctl.h>
#include <sys/socket.h>
#include <sys/sysinfo.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

#define MP_BLOCK  4
#define MAX_CONNS 4096
#define KB        1024
#define NIOS      32

#define IN_POOL(ptr)                 ((void *)ptr >= pool.bpool && (void *)ptr <= (pool.bpool + (pool.npages * pool.pagesize)))
#define ALIGN_TO_PAGESIZE(buff_size) (((buff_size) + (pool.pagesize - 1)) & ~(pool.pagesize - 1))
#define BYTES_TO_BLOCKS(buff_size)   (((buff_size) + (MP_BLOCK - 1)) / MP_BLOCK)
#define CEIL_BLOCKS(nblocks)         ((nblocks + 63) & ~63)
#define CEIL_PAGES(size)             (((size) + ((pool.pagesize) - 1)) & ~((pool.pagesize) - 1))

#define BIT_IS_FREE(word, bit)   (((word) >> (bit)) & 1)
#define MARK_BIT_USED(word, bit) ((word) &= ~(1ULL << (bit)))
#define MARK_BIT_FREE(word, bit) ((word) |= (1ULL << (bit)))
#define FIND_FREE_BIT(word)      ((uint64_t)(word) & -(uint64_t)(word))
#define STRLEN(s)                (sizeof(s) - 1)

#define IOVEC_NBLOCKS (BYTES_TO_BLOCKS(NIOS * sizeof(struct iovec)))
#define MSG_NBLOCKS   (BYTES_TO_BLOCKS(sizeof(struct msghdr)))
#define ZC_RES        KB *KB

#define DEBUG 0
#if DEBUG
#define LOG(...) fprintf(logfd, __VA_ARGS__)
#else
#define LOG(...) ((void)0)
#endif

typedef enum UOP {
  WRITEV = IORING_OP_WRITEV,
  SENDMSG = IORING_OP_SENDMSG,
  RECVMSG = IORING_OP_RECVMSG,
  ACCEPT = IORING_OP_ACCEPT,
  SEND = IORING_OP_SEND,
  RECV = IORING_OP_RECV,
  SENDZC = IORING_OP_SEND_ZC,
  SENDMSGZC = IORING_OP_SENDMSG_ZC,
  PEEK = 50,
  FRECVMSG,
  INSPLICE,
  OUTSPLICE
} UOP;

typedef enum CFS {
  CF_IN_POOL = (1 << 0),       // Connection is in the pool
  CF_IN_HEAP = (1 << 1),       // Connection is in the heap
  CF_SKIP_SOCK = (1 << 2),     // Don't close the socket
  CF_USE_ONCE = (1 << 3),      // Destroy after using
  CF_HANDLER_READY = (1 << 4), // Ready to call the handler
} CFS;

typedef struct conn_t {
  // Socket file descriptor
  int fd;

  // Amount of data left in the current operation
  uint64_t data_left;

  // The index of the connection struct
  uint32_t cindex;

  // The last time the connection was readable
  uint64_t last_read;

  // The last time the connection was writeable
  uint64_t last_write;

  // The operation currently being processed
  uint8_t op;

  // Connection flags
  int flags;

  // Splice fd_in
  int in_fd;

  // Splice fd_out
  int out_fd;

  void *recv_conn;
  void *send_conn;

  struct iovec *ios;
  struct iovec *rec;
  uint16_t nios;

  struct msghdr *msg;
  uint16_t zc_notifs;

  uint16_t head_size;
} conn_t;

typedef struct MPool {
  // The allocated pool of blocks
  void *bpool;

  // The allocated pool of connections
  conn_t *cpool;

  // The size of the pool in pages
  uint32_t npages;

  // The size of the pool in blocks
  uint32_t nblocks;

  // The locations of each page in the pool
  void **blocks;

  // The availability of each block
  uint64_t *freebs;

  // The locations of each conn in the pool
  conn_t **conns;

  // The availability of each conn
  uint64_t *freecs;

  // Clean up callback function
  void (*callback)(conn_t *conn);

  // The page size used
  uint32_t pagesize;

  // Socket read timeout
  uint32_t rtimeout;

  // Socket write timeout
  uint32_t wtimeout;
} MPool;

extern int pipe_sz;
extern int pipe_in, pipe_out, nullfd;
extern FILE *logfd;
extern struct io_uring ring;
extern MPool pool;
extern conn_t *current_recv;
extern conn_t *current_send;

/*
 * Prepare and submit a recv uring op
 */
static inline int urecv(conn_t *conn, void *buffer, size_t buff_size, int flags) {
  if (!conn || conn->fd == -1)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (flags == MSG_PEEK) ? PEEK : RECV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;

  io_uring_prep_recv(sqe, conn->fd, buffer, buff_size, flags);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a multi-shot accept uring op
 */
static inline int umaccept(int listenfd) {
  if (listenfd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = ACCEPT;
  io_uring_prep_multishot_accept(sqe, listenfd, NULL, NULL, SOCK_NONBLOCK);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a splice uring op
 */
static inline int usplice(conn_t *conn, int fd_in, int64_t off_in, int fd_out, int64_t off_out, size_t len) {
  if (!len || !conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = (__u64)conn;
  io_uring_prep_splice(sqe, fd_in, off_in, fd_out, off_out, len, 0);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a writev uring op
 */
static inline int uwritev(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = WRITEV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  io_uring_prep_writev(sqe, conn->fd, &conn->ios[iov_index], nios, -1);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a send uring op
 */
static inline int usend(conn_t *conn, char *res_buff, size_t buff_size, bool zc) {
  if (!conn || conn->fd <= 0 || buff_size == 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (zc) ? SENDZC : SEND;
  conn->data_left = buff_size;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  if (zc)
    io_uring_prep_send_zc(sqe, conn->fd, res_buff, buff_size, 0, 0);
  else
    io_uring_prep_send(sqe, conn->fd, res_buff, buff_size, 0);
  return io_uring_submit(&ring);
}

static inline int ufrecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = FRECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;

  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, rec->iov_len);
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int urecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = RECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int usendmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  bool zc = (conn->data_left > ZC_RES) ? true : false;
  conn->op = (zc) ? SENDMSGZC : SENDMSG;

  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  if (zc) {
    io_uring_prep_sendmsg_zc(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
    conn->zc_notifs++;
  } else {
    io_uring_prep_sendmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  }
  return io_uring_submit(&ring);
}

/*
 * Create and initialize a server socket
 */
static inline int tcp_listen(uint16_t port) {
  int enable;
  int listenfd;
  if ((listenfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    return -1;

  int flags = fcntl(listenfd, F_GETFL, 0);
  fcntl(listenfd, F_SETFL, flags | O_NONBLOCK);
  struct sockaddr_in servaddr;
  memset(&servaddr, 0, sizeof(servaddr));
  servaddr.sin_family = AF_INET;
  servaddr.sin_addr.s_addr = INADDR_ANY;
  servaddr.sin_port = htons(port);

  enable = 1;
  if (setsockopt(listenfd, SOL_SOCKET, SO_REUSEPORT, &enable, sizeof(enable)) < 0)
    return -1;

  if (bind(listenfd, (struct sockaddr *)&servaddr, sizeof(servaddr)) < 0)
    return -1;

  if (listen(listenfd, SOMAXCONN) < 0)
    return -1;

  return listenfd;
}

/*
 * Calculate the difference between two pointers
 */
static inline uintptr_t ptr_diff(uintptr_t p1, uintptr_t p2) { return (uintptr_t)(p1 > p2) ? (p1 - p2) : (p2 - p1); }

static inline size_t get_nroutes(Route *routes) {
  Route *route;
  for (size_t i = 0;; i++) {
    route = &routes[i];
    if (!route->path && !route->handler && !route->method)
      return i;
  }
}

static inline long get_content_length(char *src, char *end) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return -1;
    key = line;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, "Content-Length") != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;

    *line_end = '\0';
    long res = atol(value);
    *line_end = '\r';

    return res;
  }
  return -1;
}

static inline bool have_header(char *src, char *end, const char *header_key, const char *header_value) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    key = line;
    while (*key == ' ')
      key++;
    while (*header_key == ' ')
      header_key++;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return false;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, header_key) != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;
    while (*header_value == ' ')
      header_value++;

    *line_end = '\0';
    bool res = (strcasecmp(value, header_value) == 0);
    *line_end = '\r';

    return res;
  }

  return false;
}

static inline const char *method_str(Method method) {
  switch (method) {
  case GET:
    return "GET";
    break;
  case HEAD:
    return "HEAD";
    break;
  case POST:
    return "POST";
    break;
  case PUT:
    return "PUT";
    break;
  case DELETE:
    return "DELETE";
    break;
  case CONNECT:
    return "CONNECT";
    break;
  case OPTIONS:
    return "OPTIONS";
    break;
  case TRACE:
    return "TRACE";
    break;
  case PATCH:
    return "PATCH";
    break;
  default:
    return NULL;
  }
}

static inline uint8_t method_len(Method method) {
  switch (method) {
  case GET:
    return 3;
    break;
  case HEAD:
    return 4;
    break;
  case POST:
    return 4;
    break;
  case PUT:
    return 3;
    break;
  case DELETE:
    return 6;
    break;
  case CONNECT:
    return 7;
    break;
  case OPTIONS:
    return 7;
    break;
  case TRACE:
    return 5;
    break;
  case PATCH:
    return 5;
    break;
  default:
    return 0;
  }
}

static inline size_t round_to_blocks(size_t size) {
  size_t nblocks = BYTES_TO_BLOCKS(size);
  nblocks = CEIL_BLOCKS(nblocks);
  return nblocks;
}

/*
 * Count the digits in unsigned 64-bit int
 */
static inline int countd(uint64_t num) {
  if (num < 10ULL)
    return 1;
  if (num < 100ULL)
    return 2;
  if (num < 1000ULL)
    return 3;
  if (num < 10000ULL)
    return 4;
  if (num < 100000ULL)
    return 5;
  if (num < 1000000ULL)
    return 6;
  if (num < 10000000ULL)
    return 7;
  if (num < 100000000ULL)
    return 8;
  if (num < 1000000000ULL)
    return 9;
  if (num < 10000000000ULL)
    return 10;
  if (num < 100000000000ULL)
    return 11;
  if (num < 1000000000000ULL)
    return 12;
  if (num < 10000000000000ULL)
    return 13;
  if (num < 100000000000000ULL)
    return 14;
  if (num < 1000000000000000ULL)
    return 15;
  if (num < 10000000000000000ULL)
    return 16;
  if (num < 100000000000000000ULL)
    return 17;
  if (num < 1000000000000000000ULL)
    return 18;
  if (num < 10000000000000000000ULL)
    return 19;
  return 20;
}

/*
 * Get the time elabsed in ms
 */
static inline uint64_t get_time() {
  struct timespec ts;
  clock_gettime(CLOCK_MONOTONIC, &ts);
  return (uint64_t)(ts.tv_sec) * 1000 + (ts.tv_nsec / 1000000);
}

static inline FILE *log_init(const char *path) {
  FILE *res = fopen(path, "a+");
  setvbuf(res, NULL, _IONBF, 0);
  return res;
}

static inline int16_t pollevs(int connfd) {
  struct pollfd pfd;
  pfd.fd = connfd;
  pfd.events = POLLIN | POLLOUT | POLLERR;
  int res = poll(&pfd, 1, 0);
  if (res < 0)
    return POLLERR;
  return pfd.revents;
}

// FIXME This needs to be updated
static inline conn_t *MP_use_once(size_t nblocks, int fd) {

  void *mem = malloc(sizeof(conn_t) + 8 + (IOVEC_NBLOCKS * MP_BLOCK));
  struct conn_t *conn = (conn_t *)mem;
  memset(conn, 0, sizeof(conn_t));
  conn->ios = mem + sizeof(conn_t) + 8;

  if (nblocks > 0) {
    struct iovec *iov = &conn->ios[conn->nios++];
    mem = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (mem == MAP_FAILED)
      return NULL;
    iov->iov_base = mem;
    iov->iov_len = ALIGN_TO_PAGESIZE(nblocks * MP_BLOCK);
  }

  conn->flags |= CF_IN_HEAP;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;

  return conn;
}

static inline int find_freec() {
  uint64_t *word;
  size_t map_size = (sizeof(uint64_t) * 8);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    word = &pool.freecs[i / map_size];

    if (*word == 0) { // All used
      i += (map_size - 1);
      continue;
    }

    i += __builtin_ctzll(*word);
    MARK_BIT_USED(*word, i);
    return i;
  }

  return -1;
}

static inline int MP_init(size_t npages) {
  if (!npages)
    return -1;

  /*** Setup ***/
  pool.npages = npages;
  pool.pagesize = sysconf(_SC_PAGESIZE);

  /*** Pool ***/
  pool.bpool = mmap(NULL, pool.npages * pool.pagesize, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  if (pool.bpool == MAP_FAILED)
    return -1;
  pool.nblocks = (pool.npages * pool.pagesize) / MP_BLOCK;

  /*** Blocks ***/
  pool.blocks = malloc(sizeof(void *) * pool.nblocks);
  if (!pool.blocks)
    return -1;
  for (size_t i = 0; i < pool.nblocks; i++)
    pool.blocks[i] = pool.bpool + (i * MP_BLOCK);

  /*** Freebs ***/
  // if (posix_memalign((void **)&pool.freebs, 64, bitmap_size * sizeof(uint64_t)) < 0)
  size_t bitmap_size = (pool.nblocks + 63) / 64;
  pool.freebs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freebs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freebs[i] = UINT64_MAX;

  /*** Cpool ***/
  pool.cpool = (conn_t *)malloc(sizeof(conn_t) * MAX_CONNS);
  if (!pool.cpool)
    return -1;

  /*** Conns ***/
  pool.conns = (conn_t **)malloc(sizeof(conn_t *) * MAX_CONNS);
  if (!pool.conns)
    return -1;
  size_t conn_size = sizeof(conn_t);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    pool.conns[i] = (conn_t *)((char *)pool.cpool + (i * conn_size));
    pool.conns[i]->fd = -1;
    pool.conns[i]->in_fd = -1;
    pool.conns[i]->out_fd = -1;
  }

  /*** Freecs ***/
  bitmap_size = (MAX_CONNS + 63) / 64;
  pool.freecs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freecs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freecs[i] = UINT64_MAX;

  return 0;
}

static inline int MP_use_blks(size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t max_start = pool.nblocks - nblocks;
  size_t full_chunks = (nblocks / 64) * 64;

  for (size_t i = 0, c = 0; i <= max_start; i++, c++) {
    bool free = true;

    for (size_t j = 0; j < full_chunks; j += 64) {
      size_t word_index = (i + j) / 64;
      if (pool.freebs[word_index] != UINT64_MAX) {
        free = false;
        i += 63;
        break;
      }
    }

    for (size_t j = full_chunks; j < nblocks; j++) {
      size_t bit_index = i + j;
      size_t word_index = bit_index / 64;
      size_t bit_in_word = bit_index % 64;

      if (!BIT_IS_FREE(pool.freebs[word_index], bit_in_word)) {
        free = false;
        i += j;
        break;
      }
    }

    if (free) {
      for (size_t j = 0; j < full_chunks; j += 64) {
        size_t word_index = (i + j) / 64;
        pool.freebs[word_index] = 0;
      }

      for (size_t j = full_chunks; j < nblocks; j++) {
        size_t bit_index = i + j;
        size_t word_index = bit_index / 64;
        size_t bit_in_word = bit_index % 64;

        MARK_BIT_USED(pool.freebs[word_index], bit_in_word);
      }

      return i;
    }
  }

  return -1;
}

static inline int MP_free_blks(size_t bindex, size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t full_chunks = (nblocks / 64) * 64;
  for (size_t i = 0; i < full_chunks; i += 64) {
    size_t word_index = (bindex + i) / 64;
    pool.freebs[word_index] = UINT64_MAX;
  }

  for (size_t i = full_chunks; i < nblocks; i++) {
    size_t bit_index = bindex + i;
    size_t word_index = bit_index / 64;
    size_t bit_in_word = bit_index % 64;

    MARK_BIT_FREE(pool.freebs[word_index], bit_in_word);
  }

  memset(pool.blocks[bindex], 0, nblocks * MP_BLOCK);
  return 0;
}

static inline conn_t *MP_use(size_t nblocks, int fd, bool once) {
  if (fd <= 0)
    return NULL;
  if (once)
    return MP_use_once(nblocks, fd);

  int cindex = find_freec();
  if (cindex < 0) {
    LOG("Err: cindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  conn_t *conn = pool.conns[cindex];

  int ios_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (ios_bindex < 0) {
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }

  struct iovec *ios = pool.blocks[ios_bindex];
  conn->ios = ios;

  int rec_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (rec_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct iovec *rec = pool.blocks[rec_bindex];
  conn->rec = rec;

  int msg_bindex = MP_use_blks(MSG_NBLOCKS);
  if (msg_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct msghdr *msg = pool.blocks[msg_bindex];
  conn->msg = msg;

  if (nblocks > 0) {
    int bindex = MP_use_blks(nblocks);
    if (bindex < 0) {
      MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
      MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
      MP_free_blks(msg_bindex, IOVEC_NBLOCKS);
      MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
      LOG("Err: bindex < 0; will use MP_use_once\n");
      return MP_use_once(nblocks, fd);
    }

    size_t iov_index = conn->nios++;
    struct iovec *iov = &conn->ios[iov_index];
    struct iovec *rec = &conn->rec[iov_index];
    iov->iov_base = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
  }

  conn->msg->msg_iov = conn->ios;
  conn->msg->msg_iovlen = conn->nios;
  conn->cindex = cindex;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;
  return conn;
}

static inline void MP_shed(conn_t *conn, size_t iov_index, size_t nios) {
  struct iovec *iov, *rec;
  size_t bindex, nblocks, index;

  for (size_t i = 0; i < nios; i++) {
    index = iov_index + i;
    iov = &conn->ios[index];
    rec = &conn->rec[index];
    if (!rec || !rec->iov_base)
      continue;
    if (!IN_POOL(rec->iov_base)) {
      munmap(rec->iov_base, rec->iov_len / pool.pagesize);
    } else {
      bindex = ptr_diff((uintptr_t)rec->iov_base, (uintptr_t)pool.bpool) / MP_BLOCK;
      nblocks = rec->iov_len / MP_BLOCK;
      MP_free_blks(bindex, nblocks);
    }
    memset(iov, 0, sizeof(struct iovec));
    memset(rec, 0, sizeof(struct iovec));
    conn->nios--;
  }
}

static inline int MP_expand(conn_t *conn, size_t nblocks, bool once) {
  void *bptr;
  int iov_index, bindex;
  struct iovec *iov, *rec;

  iov_index = conn->nios++;
  iov = &conn->ios[iov_index];
  rec = &conn->rec[iov_index];

  if (nblocks == 0)
    return iov_index;

  if (once) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_base = bptr;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
    return iov_index;
  }

  bindex = MP_use_blks(nblocks);
  if (bindex < 0) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_len = iov->iov_len;
  } else {
    bptr = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_len = iov->iov_len;
  }

  iov->iov_base = bptr;
  rec->iov_base = iov->iov_base;
  return iov_index;
}

static inline int MP_free(conn_t *conn) {
  if (!conn)
    return -1;
  size_t bindex, nblocks;
  uint64_t *word;

  MP_shed(conn, 0, conn->nios);
  if (conn->flags & CF_IN_HEAP) {
    if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
      close(conn->fd);
    free(conn);
    return 0;
  }

  word = &pool.freecs[conn->cindex / 64];
  if (conn->cindex > MAX_CONNS)
    return -1;
  else if (BIT_IS_FREE(*word, conn->cindex))
    return 0;

  bindex = ptr_diff((uintptr_t)conn->ios, (uintptr_t)pool.bpool) / MP_BLOCK;
  nblocks = IOVEC_NBLOCKS;
  MP_free_blks(bindex, nblocks);

  bindex = ptr_diff((uintptr_t)conn->rec, (uintptr_t)pool.bpool) / MP_BLOCK;
  MP_free_blks(bindex, nblocks);

  if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
    close(conn->fd);

  MARK_BIT_FREE(*word, conn->cindex);
  memset(conn, 0, sizeof(conn_t));
  conn->fd = -1;
  conn->in_fd = -1;
  conn->out_fd = -1;
  return 0;
}

static inline void MP_clear(conn_t *conn) {
  conn_t *recv_conn = conn->recv_conn;
  conn_t *send_conn = conn->send_conn;
  if (recv_conn)
    MP_free(recv_conn);
  if (send_conn)
    MP_free(send_conn);
}

static inline void MP_exit(MPool *pool) {
  munmap(pool->bpool, pool->npages);
  free(pool->cpool);
  free(pool->blocks);
  free(pool->conns);
  free(pool->freebs);
  free(pool->freecs);
}

static inline void MP_timeout() {
  conn_t *conn;
  int16_t res;
  uint64_t now;
  size_t windex = 0;
  uint64_t *word = &pool.freecs[0];
  for (size_t i = 0; i < MAX_CONNS; i++) {
    if ((i / 64) < windex)
      word = &pool.freecs[++windex];

    if (*word == UINTMAX_MAX) {
      i = (i / 64) * 64 + 64;
      continue;
    }

    conn = pool.conns[i];
    if (!conn || conn->fd == -1)
      continue;

    res = pollevs(conn->fd);

    now = get_time();
    if (res & POLLERR) {
      MP_clear(conn);
      continue;
    }
    if (res & POLLIN) {
      if (pool.rtimeout > 0 && (now - conn->last_read) >= pool.rtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (res & POLLOUT) {
      if (pool.wtimeout > 0 && (now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (!(res & POLLIN || res & POLLOUT)) {
      if ((pool.rtimeout > 0 && now - conn->last_read) >= pool.rtimeout
          || (pool.wtimeout > 0 && now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
  }
}

/*
 * Calculate the length of a status string
 */
static inline size_t status_len(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return 8;
  case STATUSSWITCHINGPROTOCOLS:
    return 19;
  case STATUSPROCESSING:
    return 10;
  case STATUSEARLYHINTS:
    return 11;
  case STATUSOK:
    return 2;
  case STATUSCREATED:
    return 7;
  case STATUSACCEPTED:
    return 8;
  case STATUSNONAUTHORITATIVE:
    return 29;
  case STATUSNOCONTENT:
    return 10;
  case STATUSRESETCONTENT:
    return 13;
  case STATUSPARTIALCONTENT:
    return 15;
  case STATUSMULTISTATUS:
    return 12;
  case STATUSALREADYREPORTED:
    return 16;
  case STATUSIMUSED:
    return 7;
  case STATUSMULTIPLECHOICES:
    return 16;
  case STATUSMOVEDPERMANENTLY:
    return 17;
  case STATUSFOUND:
    return 5;
  case STATUSSEEOTHER:
    return 9;
  case STATUSNOTMODIFIED:
    return 12;
  case STATUSUSEPROXY:
    return 9;
  case STATUSTEMPORARYREDIRECT:
    return 18;
  case STATUSPERMANENTREDIRECT:
    return 18;
  case STATUSBADREQUEST:
    return 11;
  case STATUSUNAUTHORIZED:
    return 12;
  case STATUSPAYMENTREQUIRED:
    return 16;
  case STATUSFORBIDDEN:
    return 9;
  case STATUSNOTFOUND:
    return 9;
  case STATUSMETHODNOTALLOWED:
    return 18;
  case STATUSNOTACCEPTABLE:
    return 14;
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return 29;
  case STATUSREQUESTTIMEOUT:
    return 15;
  case STATUSCONFLICT:
    return 8;
  case STATUSGONE:
    return 4;
  case STATUSLENGTHREQUIRED:
    return 15;
  case STATUSPRECONDITIONFAILED:
    return 19;
  case CONTENTTOOLARGE:
    return 17;
  case STATUSURITOOLONG:
    return 12;
  case STATUSUNSUPPORTEDMEDIATYPE:
    return 22;
  case STATUSRANGENOTSATISFIABLE:
    return 21;
  case STATUSEXPECTATIONFAILED:
    return 18;
  case STATUSMISDIRECTEDREQUEST:
    return 19;
  case STATUSUNPROCESSABLECONTENT:
    return 21;
  case STATUSLOCKED:
    return 6;
  case STATUSFAILEDDEPENDENCY:
    return 17;
  case STATUSTOOEARLY:
    return 9;
  case STATUSUPGRADEREQUIRED:
    return 16;
  case STATUSPRECONDITIONREQUIRED:
    return 21;
  case STATUSTOOMANYREQUESTS:
    return 17;
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return 31;
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return 29;
  case STATUSInternalServerError:
    return 21;
  case STATUSNOTIMPLEMENTED:
    return 15;
  case STATUSBADGATEWAY:
    return 11;
  case STATUSSERVICEUNAVAILABLE:
    return 19;
  case STATUSGATEWAYTIMEOUT:
    return 15;
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return 26;
  case STATUSVARIANTALSONEGOTIATES:
    return 23;
  case STATUSINSUFFICIENTSTORAGE:
    return 20;
  case STATUSLOOPDETECTED:
    return 13;
  case STATUSNOTEXTENDED:
    return 12;
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return 31;
  default:
    return 0;
  }
}

/*
 * Return the status code string as string literal
 */
static inline char *status_str(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return "Continue";
  case STATUSSWITCHINGPROTOCOLS:
    return "Switching Protocols";
  case STATUSPROCESSING:
    return "Processing";
  case STATUSEARLYHINTS:
    return "Early Hints";
  case STATUSOK:
    return "OK";
  case STATUSCREATED:
    return "Created";
  case STATUSACCEPTED:
    return "Accepted";
  case STATUSNONAUTHORITATIVE:
    return "Non-Authoritative Information";
  case STATUSNOCONTENT:
    return "No Content";
  case STATUSRESETCONTENT:
    return "Reset Content";
  case STATUSPARTIALCONTENT:
    return "Partial Content";
  case STATUSMULTISTATUS:
    return "Multi-Status";
  case STATUSALREADYREPORTED:
    return "Already Reported";
  case STATUSIMUSED:
    return "Im Used";
  case STATUSMULTIPLECHOICES:
    return "Multiple Choices";
  case STATUSMOVEDPERMANENTLY:
    return "Moved Permanently";
  case STATUSFOUND:
    return "Found";
  case STATUSSEEOTHER:
    return "See Other";
  case STATUSNOTMODIFIED:
    return "Not Modified";
  case STATUSUSEPROXY:
    return "Use Proxy";
  case STATUSTEMPORARYREDIRECT:
    return "Temporary Redirect";
  case STATUSPERMANENTREDIRECT:
    return "Permanent Redirect";
  case STATUSBADREQUEST:
    return "Bad Request";
  case STATUSUNAUTHORIZED:
    return "Unauthorized";
  case STATUSPAYMENTREQUIRED:
    return "Payment Required";
  case STATUSFORBIDDEN:
    return "Forbidden";
  case STATUSNOTFOUND:
    return "Not Found";
  case STATUSMETHODNOTALLOWED:
    return "Method Not Allowed";
  case STATUSNOTACCEPTABLE:
    return "Not Acceptable";
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return "Proxy Authentication Required";
  case STATUSREQUESTTIMEOUT:
    return "Request Timeout";
  case STATUSCONFLICT:
    return "Conflict";
  case STATUSGONE:
    return "Gone";
  case STATUSLENGTHREQUIRED:
    return "Length Required";
  case STATUSPRECONDITIONFAILED:
    return "Precondition Failed";
  case CONTENTTOOLARGE:
    return "Content Too Large";
  case STATUSURITOOLONG:
    return "URI Too Long";
  case STATUSUNSUPPORTEDMEDIATYPE:
    return "Unsupported Media Type";
  case STATUSRANGENOTSATISFIABLE:
    return "Range Not Satisfiable";
  case STATUSEXPECTATIONFAILED:
    return "Expectation Failed";
  case STATUSMISDIRECTEDREQUEST:
    return "Misdirected Request";
  case STATUSUNPROCESSABLECONTENT:
    return "Unprocessable Content";
  case STATUSLOCKED:
    return "Locked";
  case STATUSFAILEDDEPENDENCY:
    return "Failed Dependency";
  case STATUSTOOEARLY:
    return "Too Early";
  case STATUSUPGRADEREQUIRED:
    return "Upgrade Required";
  case STATUSPRECONDITIONREQUIRED:
    return "Precondition Required";
  case STATUSTOOMANYREQUESTS:
    return "Too Many Requests";
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return "Request Header Fields Too Large";
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return "Unavailable For Legal Reasons";
  case STATUSInternalServerError:
    return "Internal Server Error";
  case STATUSNOTIMPLEMENTED:
    return "Not Implemented";
  case STATUSBADGATEWAY:
    return "Bad Gateway";
  case STATUSSERVICEUNAVAILABLE:
    return "Service Unavailable";
  case STATUSGATEWAYTIMEOUT:
    return "Gateway Timeout";
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return "HTTP Version Not Supported";
  case STATUSVARIANTALSONEGOTIATES:
    return "Variant Also Negotiates";
  case STATUSINSUFFICIENTSTORAGE:
    return "Insufficient Storage";
  case STATUSLOOPDETECTED:
    return "Loop Detected";
  case STATUSNOTEXTENDED:
    return "Not Extended";
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return "Network Authentication Required";
  default:
    return 0;
  }
}

/*
 * Return true if routes match
 */
static inline bool route_equ(Route *route, Request *req) {
  return route->method == req->method && strncmp(route->path, req->path, strlen(route->path)) == 0;
}

/*
 * Return the matching route index on success. -1 on failure
 */
static inline int match_route(Server *serv, Request *req) {
  for (size_t i = 0; i < serv->_nroutes; i++) {
    Route route = serv->routes[i];
    if (!req->path || !route.path)
      continue;
    if (route_equ(&route, req))
      return i;
    else if (req->method == HEAD && route.method == GET && strcmp(route.path, req->path) == 0)
      return i;
  }
  return -1;
}

/*
 * Return true if the response should contain the Content-Length header
 */
static inline bool should_have_content_length(Request *req, ResWriter *res) {
  return (req->method != CONNECT              // CONNECT request
          && res->status != STATUSNOCONTENT   // 204 response
          && res->status != STATUSNOTMODIFIED // 304 response
          && res->status >= 200);             // 1xx response
}

/*
 * Format http response from the ResWriter.
 * Return response size on success, 0 on failure.
 */
static inline size_t fmt_res(Request *req, ResWriter *res, char *buffer, size_t buffer_size) {
  if (!res || !buffer || buffer_size == 0)
    return 0;

  size_t res_len, total = 0;
  char *dst = buffer;
  size_t maxlen = buffer_size;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t body_length = res->len;

  res_len = snprintf(dst, maxlen, "HTTP/1.1 %d %s", (int)res->status, status_str(res->status));
  total += res_len;
  dst += res_len;
  maxlen -= res_len;

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    res_len = snprintf(dst, maxlen, "\r\n%s: %s", header->key, header->value);
    total += res_len;
    dst += res_len;
    maxlen -= res_len;
  }

  if (have_content_length) {
    res_len = snprintf(dst, maxlen, "\r\nContent-Length: %lu", body_length);
    total += res_len, dst += res_len, maxlen -= res_len;
  }

  memcpy(dst, "\r\n\r\n", 4);
  total += 4, dst += 4, maxlen -= 4;

  return total;
}

static inline size_t res_len(Request *req, ResWriter *res) {
  if (!req || !res)
    return 0;

  if (!res->status)
    res->status = STATUSOK;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t result = 0;
  result += STRLEN("HTTP/1.1 ");     // HTTP version
  result += 4;                       // Status code + space
  result += status_len(res->status); // Status name

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    result += 2;                       // "\r\n"
    result += strlen(header->key) + 2; // Header key + ':' + space
    result += strlen(header->value);   // header value
  }

  if (have_content_length) {
    result += 2;                          // "\r\n"
    result += STRLEN("Content-Length: "); // Header key
    result += countd(res->len);           // Header value
  }

  result += 4; // "\r\n\r\n"

  return result;
}

static inline int send_empty_res(Status status) {
  size_t res_len = STRLEN("HTTP/1.1 ")        // HTTP version
                   + countd((uint64_t)status) // status code
                   + 1                        // space
                   + (int)status_len(status)  // status string
                   + 4;                       // \r\n\r\n

  conn_t *conn = current_send;
  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, res_len);
  if (snprintf((char *)rec->iov_base, res_len + 1, "HTTP/1.1 %d %s\r\n\r\n", (int)status, status_str(status))
      != (int)res_len)
    return -1;

  return usendmsg(conn, 0, 1);
}

static inline ssize_t read_socket(int sockfd, size_t len) {
  if (len == 0 || sockfd <= 0)
    return 0;
  char buff[1024 * 8];
  return read(sockfd, buff, 1024 * 8);
}

static inline int read_method(Method *method, void *src) {
  if (memcmp(src, "GET", 3) == 0)
    *method = GET;
  else if (memcmp(src, "POST", 4) == 0)
    *method = POST;
  else if (memcmp(src, "HEAD", 4) == 0)
    *method = HEAD;
  else if (memcmp(src, "PUT", 3) == 0)
    *method = PUT;
  else if (memcmp(src, "DELETE", 6) == 0)
    *method = DELETE;
  else if (memcmp(src, "CONNECT", 7) == 0)
    *method = CONNECT;
  else if (memcmp(src, "OPTIONS", 7) == 0)
    *method = OPTIONS;
  else if (memcmp(src, "TRACE", 5) == 0)
    *method = TRACE;
  else if (memcmp(src, "PATCH", 5) == 0)
    *method = PATCH;
  else
    return -1;

  return 0;
}

static inline int sendmsg_res(Request *req, ResWriter *res) {
  conn_t *conn;
  size_t head_size, res_size;
  struct iovec *iov;

  conn = current_send;
  iov = &conn->ios[0];
  head_size = res_len(req, res);
  if (head_size == 0)
    return -1;

  conn->data_left += head_size;
  res_size = fmt_res(req, res, iov->iov_base, (head_size + 1));
  if (res_size != head_size)
    return -1;
  iov->iov_len = res_size;

  return usendmsg(conn, 0, conn->nios);
}

static inline int read_req(Request *req, char *req_buffer) {
  if (!req_buffer)
    return -1;
  /*** Method ***/
  char *sep = strchr(req_buffer, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }
  *sep = '\0';
  if (read_method(&req->method, req_buffer) < 0)
    return -1;

  /*** Path ***/
  char *fullpath = sep + 1;
  sep = strchr(fullpath, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }

  *sep = '\0';
  req->path = fullpath;
  /*** Params ***/
  char *paramStart = strchr(fullpath, '?');
  if (paramStart) {
    *paramStart++ = '\0';
    int params_count = 0;
    params_count = HK_parse_params(paramStart, req->params, MAX_URL_PARAMETERS);
    if (params_count > 0)
      req->params_count = params_count;
    else
      req->params_count = 0;
  } else {
    req->params = NULL;
    req->params_count = 0;
  }

  /*** Headers ***/
  char *headStart = strstr(sep + 1, "\r\n");
  char *headEnd = strstr(sep + 1, "\r\n\r\n");
  if (!headStart) {
    LOG("read_req: !headStart\n");
    return -1;
  };

  memset(headStart, 0, 2);
  headStart += 2;
  memset(headEnd, 0, 4);
  headEnd += 4;

  int headers_count = HK_parse_headers(headStart, req->headers, MAX_REQ_HEADERS);
  if (headers_count <= 0)
    return -1;
  req->headers_count = headers_count;

  /*** Host ***/
  int index = HK_get_header(req, "Host");
  if (index < 0)
    return -1;
  char *host = req->headers[index].value;
  req->hostname = host;

  /*** Port ***/
  char *colon = strchr(host, ':');
  if (colon) {
    *colon++ = '\0';
    req->port = atoi(colon);
  } else {
    req->port = PORT;
  }
  return 0;
}
static inline int process_req(Server *serv, conn_t *conn) {
  if (!conn || conn->fd == -1)
    return -1;

  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;
  if (read_req(&req, conn->ios[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    LOG("Err: route_index == -1\n");
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;
  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  sendmsg_res(&req, &res);

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int new_conn(int connfd) {
  if (connfd <= 0)
    return -1;

  current_recv = MP_use(KB * 2, connfd, false);
  current_send = MP_use(KB * 2, connfd, false);

  current_recv->recv_conn = current_recv;
  current_recv->send_conn = current_send;

  current_send->send_conn = current_send;
  current_send->recv_conn = current_recv;

  conn_t *conn = current_recv;
  if (ufrecvmsg(conn, 0, 1) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

static inline int resubmit_sendmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return usendmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int resubmir_recvmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    // FIXME the len should be increased
    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return urecvmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int handle_sendmsg_complete(conn_t *conn) {
  struct iovec *iov, *rec;

  MP_shed(conn, 1, conn->nios - 1);
  iov = &conn->ios[0];
  rec = &conn->rec[0];
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;

  return ufrecvmsg(conn->recv_conn, 0, 1);
}

static inline int handle_sendmsg(conn_t *conn, int res, bool zc) {
  if (!conn || conn->fd == -1)
    return -1;

  conn->data_left -= res;
  if (conn->data_left > 0)
    return resubmit_sendmsg(conn, res);

  if (zc)
    return 0;

  return handle_sendmsg_complete(conn);
}

static inline int handle_insplice(conn_t *conn) {
  conn->op = OUTSPLICE;
  return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
}
static inline int handle_outsplice(conn_t *conn, int res) {
  conn->data_left -= res;
  if (conn->data_left > 0) {
    conn->op = INSPLICE;
    return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
  }

  conn_t *recv_conn = conn->recv_conn;
  struct iovec *iov = &recv_conn->ios[0];
  memset(iov->iov_base, 0, iov->iov_len);
  if (urecv(recv_conn, iov->iov_base, iov->iov_len, MSG_PEEK) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

/*
static inline int handle_recv(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  void *bptr = conn->ios[0].iov_base;
  void *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  void *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  return process_req(serv, conn);
}
*/
static inline int find_route(Server *serv, char *bptr) {
  Request req = {0};
  if (read_method(&req.method, bptr) < 0) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  };
  char *space = strchr(bptr, ' ');
  req.path = (space + 1);
  space = strchr(req.path, ' ');
  *space = '\0';
  int route_index = match_route(serv, &req);
  *space = ' ';
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }
  return route_index;
}

static inline int run_handler(Server *serv, conn_t *conn, bool uses_body) {
  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;

  if (read_req(&req, conn->rec[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  if (uses_body) {
    int h_index = HK_get_header(&req, "Content-Length");
    long body_size = atol(req.headers[h_index].value);
    if (body_size >= 0) {
      req.body.ptr = conn->rec[1].iov_base;
      req.body.size = body_size;
    } else {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    }
  }

  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  if (sendmsg_res(&req, &res) < 0)
    return -1;

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int handle_frecvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  char *bptr = (char *)conn->ios[0].iov_base;
  char *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  char *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  size_t head_size = (headEnd + 4) - bptr;
  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  int route_index = find_route(serv, bptr);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  bool uses_body = serv->routes[route_index].uses_body;
  long body_size = get_content_length(headstart + 2, headEnd + 4);
  if (body_size == -1) {
    if (uses_body) {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    } else {
      body_size = 0;
    }
  }

  conn->head_size = head_size;
  if (!uses_body) {
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  if (res == (int)(head_size + body_size)) {
    size_t iov_index = MP_expand(conn, round_to_blocks(body_size), false);
    memcpy(conn->rec[iov_index].iov_base, headEnd + 4, body_size);
    conn->ios[iov_index].iov_len = body_size;
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  conn->data_left = body_size - (res - head_size);
  bool once = ((size_t)body_size > (size_t)((pool.nblocks * MP_BLOCK) / 10));
  size_t iov_index = MP_expand(conn, round_to_blocks(body_size), once);
  memcpy(conn->rec[iov_index].iov_base, headEnd + 4, (res - head_size));
  conn->ios[iov_index].iov_base += (res - head_size);

  return urecvmsg(conn, iov_index, 1);
}

static inline int handle_recvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  if (conn->data_left > 0) {
    conn->data_left -= res;
    if (conn->data_left == 0) {
      conn->flags &= CF_HANDLER_READY;
      return run_handler(serv, conn, true);
    }

    conn->flags &= ~CF_HANDLER_READY;
    conn->ios[1].iov_base += res;
    return urecvmsg(conn, 1, 1);
  }

  conn->flags &= CF_HANDLER_READY;
  return run_handler(serv, conn, true);
}

static inline int serv_init(Server *serv) {
#if DEBUG
  logfd = log_init("log.txt");
  if (!logfd) {
    printf("log_init failed");
    return -1;
  }
#endif
  serv->_nroutes = get_nroutes(serv->routes);

  int pipefd[2];
  if (pipe(pipefd) < 0)
    return -1;
  pipe_in = pipefd[0];
  pipe_out = pipefd[1];
  nullfd = open("/dev/null", O_WRONLY);
  pipe_sz = fcntl(pipefd[0], F_GETPIPE_SZ);
  if (pipe_sz < 0)
    return -1;

  pool.rtimeout = serv->rtimeout;
  pool.wtimeout = serv->wtimeout;
  if (MP_init(MAX_CONNS * 8) < 0)
    return -1;
  LOG("pool initialized\n");

  if (io_uring_queue_init(MAX_CONNS, &ring, 0) < 0)
    return -1;
  LOG("uring initialized\n");

  int listenfd;
  if ((listenfd = tcp_listen(serv->port)) < 0)
    return -1;
  LOG("socket initialized\n");

  return umaccept(listenfd);
}

static inline int serv_listen(Server *serv) {
  // uint64_t last_check = get_time();
  while (true) {
    // uint64_t now = get_time();
    // if ((now - last_check) >= 200) {
    //   last_check = now;
    //   LOG("CM: CM_check ran\n");
    //   MP_timeout();
    // }

    LOG("SQ ready: %u, CQ ready: %u\n", io_uring_sq_ready(&ring), io_uring_cq_ready(&ring));
    struct io_uring_cqe *cqe;
    if (io_uring_wait_cqe(&ring, &cqe) < 0)
      continue;

    int res = cqe->res;
    LOG("res = %d\n", res);
    conn_t *conn = NULL;
    if (cqe->user_data > 100) {
      conn = (conn_t *)cqe->user_data;
      current_recv = (conn_t *)conn->recv_conn;
      current_send = (conn_t *)conn->send_conn;
    }

    if (res > 0) {
      if (cqe->user_data == ACCEPT) {
        LOG("new conn created\n");
        new_conn(res);
      } else if (conn && conn->fd != -1) {
        LOG("conn[%d]: conn.fd = %d; conn.op = %d\n", conn->cindex, conn->fd, conn->op);
        switch (conn->op) {
        case FRECVMSG:
          if (handle_frecvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case RECVMSG:
          if (handle_recvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case SENDMSG:
        case SENDMSGZC:
          // conn->last_write = get_time();
          bool zc = (conn->op == SENDMSGZC);
          if (handle_sendmsg(conn, res, zc) < 0)
            MP_clear(conn);
          break;
        case INSPLICE:
          if (handle_insplice(conn) < 0)
            MP_clear(conn);
          break;
        case OUTSPLICE:
          if (handle_outsplice(conn, res) < 0)
            MP_clear(conn);
          break;
        }
      }
    } else if (res == 0) {
      if (conn && conn->fd != -1) {
        switch (conn->op) {
        case SENDMSGZC:
          conn->zc_notifs--;
          if (conn->zc_notifs == 0 && handle_sendmsg_complete(conn) < 0)
            MP_clear(conn);
          break;
        case RECV:
          MP_clear(conn);
          break;
        }
      }
    } else {
      if (conn && conn->fd != -1) {
        if (res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR) {
          LOG("conn && conn->fd != -1 && res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR\n");
          MP_clear(conn);
        } else {
          LOG("res == -EAGAIN || res == -EWOULDBLOCK || res == -EINTR\n");
          conn = conn->recv_conn;
          struct iovec *iov = &conn->ios[0];
          memset(iov->iov_base, 0, iov->iov_len);
          if (urecv(conn, iov->iov_base, iov->iov_len, 0) < 0)
            MP_clear(conn);
        }
      }
    }

    LOG("uring operation seen\n");
    io_uring_cqe_seen(&ring, cqe);
  }

  io_uring_queue_exit(&ring);
  MP_exit(&pool);
  return 0;
}

/*** Helper ***/
static inline int _HK_write(void *data, size_t size) {
  size_t nblocks;
  int iov_index;
  conn_t *conn;
  struct iovec *iov;
  bool once;

  conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  nblocks = round_to_blocks(size);
  iov_index = MP_expand(conn, nblocks, once);
  iov = &conn->ios[iov_index];

  memcpy(iov->iov_base, data, size);
  iov->iov_len = size;
  conn->data_left += size;

  return 0;
}
static inline int _HK_write_body(Request *req, size_t offset, size_t size) {
  if (size > req->body.size || offset > req->body.size)
    return -1;

  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  int iov_index = MP_expand(conn, 0, false);
  struct iovec *iov = &conn->ios[iov_index];
  struct iovec *rec = &conn->rec[iov_index];
  rec->iov_base = req->body.ptr + offset;
  rec->iov_len = size;
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;
  conn->data_left += rec->iov_len;
  return 0;
}
/*
static inline int _HK_mem(size_t size, HKMem *mem) {
  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  bool once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  size_t nblocks = round_to_blocks(size);
  int iov_index = MP_expand(conn, nblocks, once);
  struct iovec *iov = &conn->ios[iov_index];
  mem->ptr = iov->iov_base;
  mem->size = iov->iov_len;
  mem->_iov_index = iov_index;
  mem->_flags = (IN_POOL(iov->iov_base)) ? CF_IN_POOL : CF_IN_HEAP;
  return 0;
}

static inline void _HK_send(HKMem *mem, size_t size) {
  conn_t *conn = current_send;
  struct iovec *iov = &conn->ios[mem->_iov_index];
  iov->iov_len = size;
  conn->data_left += size;
}
  */
#endif#define _GNU_SOURCE
#ifndef UTILS_H
#define UTILS_H

#include "hunk.h"
#include <arpa/inet.h>
#include <fcntl.h>
#include <liburing.h>
#include <netdb.h>
#include <signal.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/poll.h>
#include <sys/prctl.h>
#include <sys/socket.h>
#include <sys/sysinfo.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

#define MP_BLOCK  4
#define MAX_CONNS 4096
#define KB        1024
#define NIOS      32

#define IN_POOL(ptr)                 ((void *)ptr >= pool.bpool && (void *)ptr <= (pool.bpool + (pool.npages * pool.pagesize)))
#define ALIGN_TO_PAGESIZE(buff_size) (((buff_size) + (pool.pagesize - 1)) & ~(pool.pagesize - 1))
#define BYTES_TO_BLOCKS(buff_size)   (((buff_size) + (MP_BLOCK - 1)) / MP_BLOCK)
#define CEIL_BLOCKS(nblocks)         ((nblocks + 63) & ~63)
#define CEIL_PAGES(size)             (((size) + ((pool.pagesize) - 1)) & ~((pool.pagesize) - 1))

#define BIT_IS_FREE(word, bit)   (((word) >> (bit)) & 1)
#define MARK_BIT_USED(word, bit) ((word) &= ~(1ULL << (bit)))
#define MARK_BIT_FREE(word, bit) ((word) |= (1ULL << (bit)))
#define FIND_FREE_BIT(word)      ((uint64_t)(word) & -(uint64_t)(word))
#define STRLEN(s)                (sizeof(s) - 1)

#define IOVEC_NBLOCKS (BYTES_TO_BLOCKS(NIOS * sizeof(struct iovec)))
#define MSG_NBLOCKS   (BYTES_TO_BLOCKS(sizeof(struct msghdr)))
#define ZC_RES        KB *KB

#define DEBUG 0
#if DEBUG
#define LOG(...) fprintf(logfd, __VA_ARGS__)
#else
#define LOG(...) ((void)0)
#endif

typedef enum UOP {
  WRITEV = IORING_OP_WRITEV,
  SENDMSG = IORING_OP_SENDMSG,
  RECVMSG = IORING_OP_RECVMSG,
  ACCEPT = IORING_OP_ACCEPT,
  SEND = IORING_OP_SEND,
  RECV = IORING_OP_RECV,
  SENDZC = IORING_OP_SEND_ZC,
  SENDMSGZC = IORING_OP_SENDMSG_ZC,
  PEEK = 50,
  FRECVMSG,
  INSPLICE,
  OUTSPLICE
} UOP;

typedef enum CFS {
  CF_IN_POOL = (1 << 0),       // Connection is in the pool
  CF_IN_HEAP = (1 << 1),       // Connection is in the heap
  CF_SKIP_SOCK = (1 << 2),     // Don't close the socket
  CF_USE_ONCE = (1 << 3),      // Destroy after using
  CF_HANDLER_READY = (1 << 4), // Ready to call the handler
} CFS;

typedef struct conn_t {
  // Socket file descriptor
  int fd;

  // Amount of data left in the current operation
  uint64_t data_left;

  // The index of the connection struct
  uint32_t cindex;

  // The last time the connection was readable
  uint64_t last_read;

  // The last time the connection was writeable
  uint64_t last_write;

  // The operation currently being processed
  uint8_t op;

  // Connection flags
  int flags;

  // Splice fd_in
  int in_fd;

  // Splice fd_out
  int out_fd;

  void *recv_conn;
  void *send_conn;

  struct iovec *ios;
  struct iovec *rec;
  uint16_t nios;

  struct msghdr *msg;
  uint16_t zc_notifs;

  uint16_t head_size;
} conn_t;

typedef struct MPool {
  // The allocated pool of blocks
  void *bpool;

  // The allocated pool of connections
  conn_t *cpool;

  // The size of the pool in pages
  uint32_t npages;

  // The size of the pool in blocks
  uint32_t nblocks;

  // The locations of each page in the pool
  void **blocks;

  // The availability of each block
  uint64_t *freebs;

  // The locations of each conn in the pool
  conn_t **conns;

  // The availability of each conn
  uint64_t *freecs;

  // Clean up callback function
  void (*callback)(conn_t *conn);

  // The page size used
  uint32_t pagesize;

  // Socket read timeout
  uint32_t rtimeout;

  // Socket write timeout
  uint32_t wtimeout;
} MPool;

extern int pipe_sz;
extern int pipe_in, pipe_out, nullfd;
extern FILE *logfd;
extern struct io_uring ring;
extern MPool pool;
extern conn_t *current_recv;
extern conn_t *current_send;

/*
 * Prepare and submit a recv uring op
 */
static inline int urecv(conn_t *conn, void *buffer, size_t buff_size, int flags) {
  if (!conn || conn->fd == -1)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (flags == MSG_PEEK) ? PEEK : RECV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;

  io_uring_prep_recv(sqe, conn->fd, buffer, buff_size, flags);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a multi-shot accept uring op
 */
static inline int umaccept(int listenfd) {
  if (listenfd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = ACCEPT;
  io_uring_prep_multishot_accept(sqe, listenfd, NULL, NULL, SOCK_NONBLOCK);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a splice uring op
 */
static inline int usplice(conn_t *conn, int fd_in, int64_t off_in, int fd_out, int64_t off_out, size_t len) {
  if (!len || !conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = (__u64)conn;
  io_uring_prep_splice(sqe, fd_in, off_in, fd_out, off_out, len, 0);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a writev uring op
 */
static inline int uwritev(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = WRITEV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  io_uring_prep_writev(sqe, conn->fd, &conn->ios[iov_index], nios, -1);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a send uring op
 */
static inline int usend(conn_t *conn, char *res_buff, size_t buff_size, bool zc) {
  if (!conn || conn->fd <= 0 || buff_size == 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (zc) ? SENDZC : SEND;
  conn->data_left = buff_size;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  if (zc)
    io_uring_prep_send_zc(sqe, conn->fd, res_buff, buff_size, 0, 0);
  else
    io_uring_prep_send(sqe, conn->fd, res_buff, buff_size, 0);
  return io_uring_submit(&ring);
}

static inline int ufrecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = FRECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;

  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, rec->iov_len);
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int urecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = RECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int usendmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  bool zc = (conn->data_left > ZC_RES) ? true : false;
  conn->op = (zc) ? SENDMSGZC : SENDMSG;

  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  if (zc) {
    io_uring_prep_sendmsg_zc(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
    conn->zc_notifs++;
  } else {
    io_uring_prep_sendmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  }
  return io_uring_submit(&ring);
}

/*
 * Create and initialize a server socket
 */
static inline int tcp_listen(uint16_t port) {
  int enable;
  int listenfd;
  if ((listenfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    return -1;

  int flags = fcntl(listenfd, F_GETFL, 0);
  fcntl(listenfd, F_SETFL, flags | O_NONBLOCK);
  struct sockaddr_in servaddr;
  memset(&servaddr, 0, sizeof(servaddr));
  servaddr.sin_family = AF_INET;
  servaddr.sin_addr.s_addr = INADDR_ANY;
  servaddr.sin_port = htons(port);

  enable = 1;
  if (setsockopt(listenfd, SOL_SOCKET, SO_REUSEPORT, &enable, sizeof(enable)) < 0)
    return -1;

  if (bind(listenfd, (struct sockaddr *)&servaddr, sizeof(servaddr)) < 0)
    return -1;

  if (listen(listenfd, SOMAXCONN) < 0)
    return -1;

  return listenfd;
}

/*
 * Calculate the difference between two pointers
 */
static inline uintptr_t ptr_diff(uintptr_t p1, uintptr_t p2) { return (uintptr_t)(p1 > p2) ? (p1 - p2) : (p2 - p1); }

static inline size_t get_nroutes(Route *routes) {
  Route *route;
  for (size_t i = 0;; i++) {
    route = &routes[i];
    if (!route->path && !route->handler && !route->method)
      return i;
  }
}

static inline long get_content_length(char *src, char *end) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return -1;
    key = line;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, "Content-Length") != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;

    *line_end = '\0';
    long res = atol(value);
    *line_end = '\r';

    return res;
  }
  return -1;
}

static inline bool have_header(char *src, char *end, const char *header_key, const char *header_value) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    key = line;
    while (*key == ' ')
      key++;
    while (*header_key == ' ')
      header_key++;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return false;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, header_key) != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;
    while (*header_value == ' ')
      header_value++;

    *line_end = '\0';
    bool res = (strcasecmp(value, header_value) == 0);
    *line_end = '\r';

    return res;
  }

  return false;
}

static inline const char *method_str(Method method) {
  switch (method) {
  case GET:
    return "GET";
    break;
  case HEAD:
    return "HEAD";
    break;
  case POST:
    return "POST";
    break;
  case PUT:
    return "PUT";
    break;
  case DELETE:
    return "DELETE";
    break;
  case CONNECT:
    return "CONNECT";
    break;
  case OPTIONS:
    return "OPTIONS";
    break;
  case TRACE:
    return "TRACE";
    break;
  case PATCH:
    return "PATCH";
    break;
  default:
    return NULL;
  }
}

static inline uint8_t method_len(Method method) {
  switch (method) {
  case GET:
    return 3;
    break;
  case HEAD:
    return 4;
    break;
  case POST:
    return 4;
    break;
  case PUT:
    return 3;
    break;
  case DELETE:
    return 6;
    break;
  case CONNECT:
    return 7;
    break;
  case OPTIONS:
    return 7;
    break;
  case TRACE:
    return 5;
    break;
  case PATCH:
    return 5;
    break;
  default:
    return 0;
  }
}

static inline size_t round_to_blocks(size_t size) {
  size_t nblocks = BYTES_TO_BLOCKS(size);
  nblocks = CEIL_BLOCKS(nblocks);
  return nblocks;
}

/*
 * Count the digits in unsigned 64-bit int
 */
static inline int countd(uint64_t num) {
  if (num < 10ULL)
    return 1;
  if (num < 100ULL)
    return 2;
  if (num < 1000ULL)
    return 3;
  if (num < 10000ULL)
    return 4;
  if (num < 100000ULL)
    return 5;
  if (num < 1000000ULL)
    return 6;
  if (num < 10000000ULL)
    return 7;
  if (num < 100000000ULL)
    return 8;
  if (num < 1000000000ULL)
    return 9;
  if (num < 10000000000ULL)
    return 10;
  if (num < 100000000000ULL)
    return 11;
  if (num < 1000000000000ULL)
    return 12;
  if (num < 10000000000000ULL)
    return 13;
  if (num < 100000000000000ULL)
    return 14;
  if (num < 1000000000000000ULL)
    return 15;
  if (num < 10000000000000000ULL)
    return 16;
  if (num < 100000000000000000ULL)
    return 17;
  if (num < 1000000000000000000ULL)
    return 18;
  if (num < 10000000000000000000ULL)
    return 19;
  return 20;
}

/*
 * Get the time elabsed in ms
 */
static inline uint64_t get_time() {
  struct timespec ts;
  clock_gettime(CLOCK_MONOTONIC, &ts);
  return (uint64_t)(ts.tv_sec) * 1000 + (ts.tv_nsec / 1000000);
}

static inline FILE *log_init(const char *path) {
  FILE *res = fopen(path, "a+");
  setvbuf(res, NULL, _IONBF, 0);
  return res;
}

static inline int16_t pollevs(int connfd) {
  struct pollfd pfd;
  pfd.fd = connfd;
  pfd.events = POLLIN | POLLOUT | POLLERR;
  int res = poll(&pfd, 1, 0);
  if (res < 0)
    return POLLERR;
  return pfd.revents;
}

// FIXME This needs to be updated
static inline conn_t *MP_use_once(size_t nblocks, int fd) {

  void *mem = malloc(sizeof(conn_t) + 8 + (IOVEC_NBLOCKS * MP_BLOCK));
  struct conn_t *conn = (conn_t *)mem;
  memset(conn, 0, sizeof(conn_t));
  conn->ios = mem + sizeof(conn_t) + 8;

  if (nblocks > 0) {
    struct iovec *iov = &conn->ios[conn->nios++];
    mem = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (mem == MAP_FAILED)
      return NULL;
    iov->iov_base = mem;
    iov->iov_len = ALIGN_TO_PAGESIZE(nblocks * MP_BLOCK);
  }

  conn->flags |= CF_IN_HEAP;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;

  return conn;
}

static inline int find_freec() {
  uint64_t *word;
  size_t map_size = (sizeof(uint64_t) * 8);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    word = &pool.freecs[i / map_size];

    if (*word == 0) { // All used
      i += (map_size - 1);
      continue;
    }

    i += __builtin_ctzll(*word);
    MARK_BIT_USED(*word, i);
    return i;
  }

  return -1;
}

static inline int MP_init(size_t npages) {
  if (!npages)
    return -1;

  /*** Setup ***/
  pool.npages = npages;
  pool.pagesize = sysconf(_SC_PAGESIZE);

  /*** Pool ***/
  pool.bpool = mmap(NULL, pool.npages * pool.pagesize, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  if (pool.bpool == MAP_FAILED)
    return -1;
  pool.nblocks = (pool.npages * pool.pagesize) / MP_BLOCK;

  /*** Blocks ***/
  pool.blocks = malloc(sizeof(void *) * pool.nblocks);
  if (!pool.blocks)
    return -1;
  for (size_t i = 0; i < pool.nblocks; i++)
    pool.blocks[i] = pool.bpool + (i * MP_BLOCK);

  /*** Freebs ***/
  // if (posix_memalign((void **)&pool.freebs, 64, bitmap_size * sizeof(uint64_t)) < 0)
  size_t bitmap_size = (pool.nblocks + 63) / 64;
  pool.freebs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freebs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freebs[i] = UINT64_MAX;

  /*** Cpool ***/
  pool.cpool = (conn_t *)malloc(sizeof(conn_t) * MAX_CONNS);
  if (!pool.cpool)
    return -1;

  /*** Conns ***/
  pool.conns = (conn_t **)malloc(sizeof(conn_t *) * MAX_CONNS);
  if (!pool.conns)
    return -1;
  size_t conn_size = sizeof(conn_t);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    pool.conns[i] = (conn_t *)((char *)pool.cpool + (i * conn_size));
    pool.conns[i]->fd = -1;
    pool.conns[i]->in_fd = -1;
    pool.conns[i]->out_fd = -1;
  }

  /*** Freecs ***/
  bitmap_size = (MAX_CONNS + 63) / 64;
  pool.freecs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freecs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freecs[i] = UINT64_MAX;

  return 0;
}

static inline int MP_use_blks(size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t max_start = pool.nblocks - nblocks;
  size_t full_chunks = (nblocks / 64) * 64;

  for (size_t i = 0, c = 0; i <= max_start; i++, c++) {
    bool free = true;

    for (size_t j = 0; j < full_chunks; j += 64) {
      size_t word_index = (i + j) / 64;
      if (pool.freebs[word_index] != UINT64_MAX) {
        free = false;
        i += 63;
        break;
      }
    }

    for (size_t j = full_chunks; j < nblocks; j++) {
      size_t bit_index = i + j;
      size_t word_index = bit_index / 64;
      size_t bit_in_word = bit_index % 64;

      if (!BIT_IS_FREE(pool.freebs[word_index], bit_in_word)) {
        free = false;
        i += j;
        break;
      }
    }

    if (free) {
      for (size_t j = 0; j < full_chunks; j += 64) {
        size_t word_index = (i + j) / 64;
        pool.freebs[word_index] = 0;
      }

      for (size_t j = full_chunks; j < nblocks; j++) {
        size_t bit_index = i + j;
        size_t word_index = bit_index / 64;
        size_t bit_in_word = bit_index % 64;

        MARK_BIT_USED(pool.freebs[word_index], bit_in_word);
      }

      return i;
    }
  }

  return -1;
}

static inline int MP_free_blks(size_t bindex, size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t full_chunks = (nblocks / 64) * 64;
  for (size_t i = 0; i < full_chunks; i += 64) {
    size_t word_index = (bindex + i) / 64;
    pool.freebs[word_index] = UINT64_MAX;
  }

  for (size_t i = full_chunks; i < nblocks; i++) {
    size_t bit_index = bindex + i;
    size_t word_index = bit_index / 64;
    size_t bit_in_word = bit_index % 64;

    MARK_BIT_FREE(pool.freebs[word_index], bit_in_word);
  }

  memset(pool.blocks[bindex], 0, nblocks * MP_BLOCK);
  return 0;
}

static inline conn_t *MP_use(size_t nblocks, int fd, bool once) {
  if (fd <= 0)
    return NULL;
  if (once)
    return MP_use_once(nblocks, fd);

  int cindex = find_freec();
  if (cindex < 0) {
    LOG("Err: cindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  conn_t *conn = pool.conns[cindex];

  int ios_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (ios_bindex < 0) {
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }

  struct iovec *ios = pool.blocks[ios_bindex];
  conn->ios = ios;

  int rec_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (rec_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct iovec *rec = pool.blocks[rec_bindex];
  conn->rec = rec;

  int msg_bindex = MP_use_blks(MSG_NBLOCKS);
  if (msg_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct msghdr *msg = pool.blocks[msg_bindex];
  conn->msg = msg;

  if (nblocks > 0) {
    int bindex = MP_use_blks(nblocks);
    if (bindex < 0) {
      MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
      MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
      MP_free_blks(msg_bindex, IOVEC_NBLOCKS);
      MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
      LOG("Err: bindex < 0; will use MP_use_once\n");
      return MP_use_once(nblocks, fd);
    }

    size_t iov_index = conn->nios++;
    struct iovec *iov = &conn->ios[iov_index];
    struct iovec *rec = &conn->rec[iov_index];
    iov->iov_base = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
  }

  conn->msg->msg_iov = conn->ios;
  conn->msg->msg_iovlen = conn->nios;
  conn->cindex = cindex;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;
  return conn;
}

static inline void MP_shed(conn_t *conn, size_t iov_index, size_t nios) {
  struct iovec *iov, *rec;
  size_t bindex, nblocks, index;

  for (size_t i = 0; i < nios; i++) {
    index = iov_index + i;
    iov = &conn->ios[index];
    rec = &conn->rec[index];
    if (!rec || !rec->iov_base)
      continue;
    if (!IN_POOL(rec->iov_base)) {
      munmap(rec->iov_base, rec->iov_len / pool.pagesize);
    } else {
      bindex = ptr_diff((uintptr_t)rec->iov_base, (uintptr_t)pool.bpool) / MP_BLOCK;
      nblocks = rec->iov_len / MP_BLOCK;
      MP_free_blks(bindex, nblocks);
    }
    memset(iov, 0, sizeof(struct iovec));
    memset(rec, 0, sizeof(struct iovec));
    conn->nios--;
  }
}

static inline int MP_expand(conn_t *conn, size_t nblocks, bool once) {
  void *bptr;
  int iov_index, bindex;
  struct iovec *iov, *rec;

  iov_index = conn->nios++;
  iov = &conn->ios[iov_index];
  rec = &conn->rec[iov_index];

  if (nblocks == 0)
    return iov_index;

  if (once) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_base = bptr;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
    return iov_index;
  }

  bindex = MP_use_blks(nblocks);
  if (bindex < 0) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_len = iov->iov_len;
  } else {
    bptr = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_len = iov->iov_len;
  }

  iov->iov_base = bptr;
  rec->iov_base = iov->iov_base;
  return iov_index;
}

static inline int MP_free(conn_t *conn) {
  if (!conn)
    return -1;
  size_t bindex, nblocks;
  uint64_t *word;

  MP_shed(conn, 0, conn->nios);
  if (conn->flags & CF_IN_HEAP) {
    if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
      close(conn->fd);
    free(conn);
    return 0;
  }

  word = &pool.freecs[conn->cindex / 64];
  if (conn->cindex > MAX_CONNS)
    return -1;
  else if (BIT_IS_FREE(*word, conn->cindex))
    return 0;

  bindex = ptr_diff((uintptr_t)conn->ios, (uintptr_t)pool.bpool) / MP_BLOCK;
  nblocks = IOVEC_NBLOCKS;
  MP_free_blks(bindex, nblocks);

  bindex = ptr_diff((uintptr_t)conn->rec, (uintptr_t)pool.bpool) / MP_BLOCK;
  MP_free_blks(bindex, nblocks);

  if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
    close(conn->fd);

  MARK_BIT_FREE(*word, conn->cindex);
  memset(conn, 0, sizeof(conn_t));
  conn->fd = -1;
  conn->in_fd = -1;
  conn->out_fd = -1;
  return 0;
}

static inline void MP_clear(conn_t *conn) {
  conn_t *recv_conn = conn->recv_conn;
  conn_t *send_conn = conn->send_conn;
  if (recv_conn)
    MP_free(recv_conn);
  if (send_conn)
    MP_free(send_conn);
}

static inline void MP_exit(MPool *pool) {
  munmap(pool->bpool, pool->npages);
  free(pool->cpool);
  free(pool->blocks);
  free(pool->conns);
  free(pool->freebs);
  free(pool->freecs);
}

static inline void MP_timeout() {
  conn_t *conn;
  int16_t res;
  uint64_t now;
  size_t windex = 0;
  uint64_t *word = &pool.freecs[0];
  for (size_t i = 0; i < MAX_CONNS; i++) {
    if ((i / 64) < windex)
      word = &pool.freecs[++windex];

    if (*word == UINTMAX_MAX) {
      i = (i / 64) * 64 + 64;
      continue;
    }

    conn = pool.conns[i];
    if (!conn || conn->fd == -1)
      continue;

    res = pollevs(conn->fd);

    now = get_time();
    if (res & POLLERR) {
      MP_clear(conn);
      continue;
    }
    if (res & POLLIN) {
      if (pool.rtimeout > 0 && (now - conn->last_read) >= pool.rtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (res & POLLOUT) {
      if (pool.wtimeout > 0 && (now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (!(res & POLLIN || res & POLLOUT)) {
      if ((pool.rtimeout > 0 && now - conn->last_read) >= pool.rtimeout
          || (pool.wtimeout > 0 && now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
  }
}

/*
 * Calculate the length of a status string
 */
static inline size_t status_len(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return 8;
  case STATUSSWITCHINGPROTOCOLS:
    return 19;
  case STATUSPROCESSING:
    return 10;
  case STATUSEARLYHINTS:
    return 11;
  case STATUSOK:
    return 2;
  case STATUSCREATED:
    return 7;
  case STATUSACCEPTED:
    return 8;
  case STATUSNONAUTHORITATIVE:
    return 29;
  case STATUSNOCONTENT:
    return 10;
  case STATUSRESETCONTENT:
    return 13;
  case STATUSPARTIALCONTENT:
    return 15;
  case STATUSMULTISTATUS:
    return 12;
  case STATUSALREADYREPORTED:
    return 16;
  case STATUSIMUSED:
    return 7;
  case STATUSMULTIPLECHOICES:
    return 16;
  case STATUSMOVEDPERMANENTLY:
    return 17;
  case STATUSFOUND:
    return 5;
  case STATUSSEEOTHER:
    return 9;
  case STATUSNOTMODIFIED:
    return 12;
  case STATUSUSEPROXY:
    return 9;
  case STATUSTEMPORARYREDIRECT:
    return 18;
  case STATUSPERMANENTREDIRECT:
    return 18;
  case STATUSBADREQUEST:
    return 11;
  case STATUSUNAUTHORIZED:
    return 12;
  case STATUSPAYMENTREQUIRED:
    return 16;
  case STATUSFORBIDDEN:
    return 9;
  case STATUSNOTFOUND:
    return 9;
  case STATUSMETHODNOTALLOWED:
    return 18;
  case STATUSNOTACCEPTABLE:
    return 14;
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return 29;
  case STATUSREQUESTTIMEOUT:
    return 15;
  case STATUSCONFLICT:
    return 8;
  case STATUSGONE:
    return 4;
  case STATUSLENGTHREQUIRED:
    return 15;
  case STATUSPRECONDITIONFAILED:
    return 19;
  case CONTENTTOOLARGE:
    return 17;
  case STATUSURITOOLONG:
    return 12;
  case STATUSUNSUPPORTEDMEDIATYPE:
    return 22;
  case STATUSRANGENOTSATISFIABLE:
    return 21;
  case STATUSEXPECTATIONFAILED:
    return 18;
  case STATUSMISDIRECTEDREQUEST:
    return 19;
  case STATUSUNPROCESSABLECONTENT:
    return 21;
  case STATUSLOCKED:
    return 6;
  case STATUSFAILEDDEPENDENCY:
    return 17;
  case STATUSTOOEARLY:
    return 9;
  case STATUSUPGRADEREQUIRED:
    return 16;
  case STATUSPRECONDITIONREQUIRED:
    return 21;
  case STATUSTOOMANYREQUESTS:
    return 17;
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return 31;
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return 29;
  case STATUSInternalServerError:
    return 21;
  case STATUSNOTIMPLEMENTED:
    return 15;
  case STATUSBADGATEWAY:
    return 11;
  case STATUSSERVICEUNAVAILABLE:
    return 19;
  case STATUSGATEWAYTIMEOUT:
    return 15;
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return 26;
  case STATUSVARIANTALSONEGOTIATES:
    return 23;
  case STATUSINSUFFICIENTSTORAGE:
    return 20;
  case STATUSLOOPDETECTED:
    return 13;
  case STATUSNOTEXTENDED:
    return 12;
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return 31;
  default:
    return 0;
  }
}

/*
 * Return the status code string as string literal
 */
static inline char *status_str(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return "Continue";
  case STATUSSWITCHINGPROTOCOLS:
    return "Switching Protocols";
  case STATUSPROCESSING:
    return "Processing";
  case STATUSEARLYHINTS:
    return "Early Hints";
  case STATUSOK:
    return "OK";
  case STATUSCREATED:
    return "Created";
  case STATUSACCEPTED:
    return "Accepted";
  case STATUSNONAUTHORITATIVE:
    return "Non-Authoritative Information";
  case STATUSNOCONTENT:
    return "No Content";
  case STATUSRESETCONTENT:
    return "Reset Content";
  case STATUSPARTIALCONTENT:
    return "Partial Content";
  case STATUSMULTISTATUS:
    return "Multi-Status";
  case STATUSALREADYREPORTED:
    return "Already Reported";
  case STATUSIMUSED:
    return "Im Used";
  case STATUSMULTIPLECHOICES:
    return "Multiple Choices";
  case STATUSMOVEDPERMANENTLY:
    return "Moved Permanently";
  case STATUSFOUND:
    return "Found";
  case STATUSSEEOTHER:
    return "See Other";
  case STATUSNOTMODIFIED:
    return "Not Modified";
  case STATUSUSEPROXY:
    return "Use Proxy";
  case STATUSTEMPORARYREDIRECT:
    return "Temporary Redirect";
  case STATUSPERMANENTREDIRECT:
    return "Permanent Redirect";
  case STATUSBADREQUEST:
    return "Bad Request";
  case STATUSUNAUTHORIZED:
    return "Unauthorized";
  case STATUSPAYMENTREQUIRED:
    return "Payment Required";
  case STATUSFORBIDDEN:
    return "Forbidden";
  case STATUSNOTFOUND:
    return "Not Found";
  case STATUSMETHODNOTALLOWED:
    return "Method Not Allowed";
  case STATUSNOTACCEPTABLE:
    return "Not Acceptable";
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return "Proxy Authentication Required";
  case STATUSREQUESTTIMEOUT:
    return "Request Timeout";
  case STATUSCONFLICT:
    return "Conflict";
  case STATUSGONE:
    return "Gone";
  case STATUSLENGTHREQUIRED:
    return "Length Required";
  case STATUSPRECONDITIONFAILED:
    return "Precondition Failed";
  case CONTENTTOOLARGE:
    return "Content Too Large";
  case STATUSURITOOLONG:
    return "URI Too Long";
  case STATUSUNSUPPORTEDMEDIATYPE:
    return "Unsupported Media Type";
  case STATUSRANGENOTSATISFIABLE:
    return "Range Not Satisfiable";
  case STATUSEXPECTATIONFAILED:
    return "Expectation Failed";
  case STATUSMISDIRECTEDREQUEST:
    return "Misdirected Request";
  case STATUSUNPROCESSABLECONTENT:
    return "Unprocessable Content";
  case STATUSLOCKED:
    return "Locked";
  case STATUSFAILEDDEPENDENCY:
    return "Failed Dependency";
  case STATUSTOOEARLY:
    return "Too Early";
  case STATUSUPGRADEREQUIRED:
    return "Upgrade Required";
  case STATUSPRECONDITIONREQUIRED:
    return "Precondition Required";
  case STATUSTOOMANYREQUESTS:
    return "Too Many Requests";
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return "Request Header Fields Too Large";
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return "Unavailable For Legal Reasons";
  case STATUSInternalServerError:
    return "Internal Server Error";
  case STATUSNOTIMPLEMENTED:
    return "Not Implemented";
  case STATUSBADGATEWAY:
    return "Bad Gateway";
  case STATUSSERVICEUNAVAILABLE:
    return "Service Unavailable";
  case STATUSGATEWAYTIMEOUT:
    return "Gateway Timeout";
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return "HTTP Version Not Supported";
  case STATUSVARIANTALSONEGOTIATES:
    return "Variant Also Negotiates";
  case STATUSINSUFFICIENTSTORAGE:
    return "Insufficient Storage";
  case STATUSLOOPDETECTED:
    return "Loop Detected";
  case STATUSNOTEXTENDED:
    return "Not Extended";
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return "Network Authentication Required";
  default:
    return 0;
  }
}

/*
 * Return true if routes match
 */
static inline bool route_equ(Route *route, Request *req) {
  return route->method == req->method && strncmp(route->path, req->path, strlen(route->path)) == 0;
}

/*
 * Return the matching route index on success. -1 on failure
 */
static inline int match_route(Server *serv, Request *req) {
  for (size_t i = 0; i < serv->_nroutes; i++) {
    Route route = serv->routes[i];
    if (!req->path || !route.path)
      continue;
    if (route_equ(&route, req))
      return i;
    else if (req->method == HEAD && route.method == GET && strcmp(route.path, req->path) == 0)
      return i;
  }
  return -1;
}

/*
 * Return true if the response should contain the Content-Length header
 */
static inline bool should_have_content_length(Request *req, ResWriter *res) {
  return (req->method != CONNECT              // CONNECT request
          && res->status != STATUSNOCONTENT   // 204 response
          && res->status != STATUSNOTMODIFIED // 304 response
          && res->status >= 200);             // 1xx response
}

/*
 * Format http response from the ResWriter.
 * Return response size on success, 0 on failure.
 */
static inline size_t fmt_res(Request *req, ResWriter *res, char *buffer, size_t buffer_size) {
  if (!res || !buffer || buffer_size == 0)
    return 0;

  size_t res_len, total = 0;
  char *dst = buffer;
  size_t maxlen = buffer_size;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t body_length = res->len;

  res_len = snprintf(dst, maxlen, "HTTP/1.1 %d %s", (int)res->status, status_str(res->status));
  total += res_len;
  dst += res_len;
  maxlen -= res_len;

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    res_len = snprintf(dst, maxlen, "\r\n%s: %s", header->key, header->value);
    total += res_len;
    dst += res_len;
    maxlen -= res_len;
  }

  if (have_content_length) {
    res_len = snprintf(dst, maxlen, "\r\nContent-Length: %lu", body_length);
    total += res_len, dst += res_len, maxlen -= res_len;
  }

  memcpy(dst, "\r\n\r\n", 4);
  total += 4, dst += 4, maxlen -= 4;

  return total;
}

static inline size_t res_len(Request *req, ResWriter *res) {
  if (!req || !res)
    return 0;

  if (!res->status)
    res->status = STATUSOK;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t result = 0;
  result += STRLEN("HTTP/1.1 ");     // HTTP version
  result += 4;                       // Status code + space
  result += status_len(res->status); // Status name

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    result += 2;                       // "\r\n"
    result += strlen(header->key) + 2; // Header key + ':' + space
    result += strlen(header->value);   // header value
  }

  if (have_content_length) {
    result += 2;                          // "\r\n"
    result += STRLEN("Content-Length: "); // Header key
    result += countd(res->len);           // Header value
  }

  result += 4; // "\r\n\r\n"

  return result;
}

static inline int send_empty_res(Status status) {
  size_t res_len = STRLEN("HTTP/1.1 ")        // HTTP version
                   + countd((uint64_t)status) // status code
                   + 1                        // space
                   + (int)status_len(status)  // status string
                   + 4;                       // \r\n\r\n

  conn_t *conn = current_send;
  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, res_len);
  if (snprintf((char *)rec->iov_base, res_len + 1, "HTTP/1.1 %d %s\r\n\r\n", (int)status, status_str(status))
      != (int)res_len)
    return -1;

  return usendmsg(conn, 0, 1);
}

static inline ssize_t read_socket(int sockfd, size_t len) {
  if (len == 0 || sockfd <= 0)
    return 0;
  char buff[1024 * 8];
  return read(sockfd, buff, 1024 * 8);
}

static inline int read_method(Method *method, void *src) {
  if (memcmp(src, "GET", 3) == 0)
    *method = GET;
  else if (memcmp(src, "POST", 4) == 0)
    *method = POST;
  else if (memcmp(src, "HEAD", 4) == 0)
    *method = HEAD;
  else if (memcmp(src, "PUT", 3) == 0)
    *method = PUT;
  else if (memcmp(src, "DELETE", 6) == 0)
    *method = DELETE;
  else if (memcmp(src, "CONNECT", 7) == 0)
    *method = CONNECT;
  else if (memcmp(src, "OPTIONS", 7) == 0)
    *method = OPTIONS;
  else if (memcmp(src, "TRACE", 5) == 0)
    *method = TRACE;
  else if (memcmp(src, "PATCH", 5) == 0)
    *method = PATCH;
  else
    return -1;

  return 0;
}

static inline int sendmsg_res(Request *req, ResWriter *res) {
  conn_t *conn;
  size_t head_size, res_size;
  struct iovec *iov;

  conn = current_send;
  iov = &conn->ios[0];
  head_size = res_len(req, res);
  if (head_size == 0)
    return -1;

  conn->data_left += head_size;
  res_size = fmt_res(req, res, iov->iov_base, (head_size + 1));
  if (res_size != head_size)
    return -1;
  iov->iov_len = res_size;

  return usendmsg(conn, 0, conn->nios);
}

static inline int read_req(Request *req, char *req_buffer) {
  if (!req_buffer)
    return -1;
  /*** Method ***/
  char *sep = strchr(req_buffer, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }
  *sep = '\0';
  if (read_method(&req->method, req_buffer) < 0)
    return -1;

  /*** Path ***/
  char *fullpath = sep + 1;
  sep = strchr(fullpath, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }

  *sep = '\0';
  req->path = fullpath;
  /*** Params ***/
  char *paramStart = strchr(fullpath, '?');
  if (paramStart) {
    *paramStart++ = '\0';
    int params_count = 0;
    params_count = HK_parse_params(paramStart, req->params, MAX_URL_PARAMETERS);
    if (params_count > 0)
      req->params_count = params_count;
    else
      req->params_count = 0;
  } else {
    req->params = NULL;
    req->params_count = 0;
  }

  /*** Headers ***/
  char *headStart = strstr(sep + 1, "\r\n");
  char *headEnd = strstr(sep + 1, "\r\n\r\n");
  if (!headStart) {
    LOG("read_req: !headStart\n");
    return -1;
  };

  memset(headStart, 0, 2);
  headStart += 2;
  memset(headEnd, 0, 4);
  headEnd += 4;

  int headers_count = HK_parse_headers(headStart, req->headers, MAX_REQ_HEADERS);
  if (headers_count <= 0)
    return -1;
  req->headers_count = headers_count;

  /*** Host ***/
  int index = HK_get_header(req, "Host");
  if (index < 0)
    return -1;
  char *host = req->headers[index].value;
  req->hostname = host;

  /*** Port ***/
  char *colon = strchr(host, ':');
  if (colon) {
    *colon++ = '\0';
    req->port = atoi(colon);
  } else {
    req->port = PORT;
  }
  return 0;
}
static inline int process_req(Server *serv, conn_t *conn) {
  if (!conn || conn->fd == -1)
    return -1;

  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;
  if (read_req(&req, conn->ios[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    LOG("Err: route_index == -1\n");
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;
  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  sendmsg_res(&req, &res);

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int new_conn(int connfd) {
  if (connfd <= 0)
    return -1;

  current_recv = MP_use(KB * 2, connfd, false);
  current_send = MP_use(KB * 2, connfd, false);

  current_recv->recv_conn = current_recv;
  current_recv->send_conn = current_send;

  current_send->send_conn = current_send;
  current_send->recv_conn = current_recv;

  conn_t *conn = current_recv;
  if (ufrecvmsg(conn, 0, 1) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

static inline int resubmit_sendmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return usendmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int resubmir_recvmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    // FIXME the len should be increased
    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return urecvmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int handle_sendmsg_complete(conn_t *conn) {
  struct iovec *iov, *rec;

  MP_shed(conn, 1, conn->nios - 1);
  iov = &conn->ios[0];
  rec = &conn->rec[0];
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;

  return ufrecvmsg(conn->recv_conn, 0, 1);
}

static inline int handle_sendmsg(conn_t *conn, int res, bool zc) {
  if (!conn || conn->fd == -1)
    return -1;

  conn->data_left -= res;
  if (conn->data_left > 0)
    return resubmit_sendmsg(conn, res);

  if (zc)
    return 0;

  return handle_sendmsg_complete(conn);
}

static inline int handle_insplice(conn_t *conn) {
  conn->op = OUTSPLICE;
  return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
}
static inline int handle_outsplice(conn_t *conn, int res) {
  conn->data_left -= res;
  if (conn->data_left > 0) {
    conn->op = INSPLICE;
    return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
  }

  conn_t *recv_conn = conn->recv_conn;
  struct iovec *iov = &recv_conn->ios[0];
  memset(iov->iov_base, 0, iov->iov_len);
  if (urecv(recv_conn, iov->iov_base, iov->iov_len, MSG_PEEK) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

/*
static inline int handle_recv(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  void *bptr = conn->ios[0].iov_base;
  void *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  void *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  return process_req(serv, conn);
}
*/
static inline int find_route(Server *serv, char *bptr) {
  Request req = {0};
  if (read_method(&req.method, bptr) < 0) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  };
  char *space = strchr(bptr, ' ');
  req.path = (space + 1);
  space = strchr(req.path, ' ');
  *space = '\0';
  int route_index = match_route(serv, &req);
  *space = ' ';
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }
  return route_index;
}

static inline int run_handler(Server *serv, conn_t *conn, bool uses_body) {
  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;

  if (read_req(&req, conn->rec[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  if (uses_body) {
    int h_index = HK_get_header(&req, "Content-Length");
    long body_size = atol(req.headers[h_index].value);
    if (body_size >= 0) {
      req.body.ptr = conn->rec[1].iov_base;
      req.body.size = body_size;
    } else {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    }
  }

  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  if (sendmsg_res(&req, &res) < 0)
    return -1;

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int handle_frecvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  char *bptr = (char *)conn->ios[0].iov_base;
  char *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  char *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  size_t head_size = (headEnd + 4) - bptr;
  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  int route_index = find_route(serv, bptr);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  bool uses_body = serv->routes[route_index].uses_body;
  long body_size = get_content_length(headstart + 2, headEnd + 4);
  if (body_size == -1) {
    if (uses_body) {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    } else {
      body_size = 0;
    }
  }

  conn->head_size = head_size;
  if (!uses_body) {
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  if (res == (int)(head_size + body_size)) {
    size_t iov_index = MP_expand(conn, round_to_blocks(body_size), false);
    memcpy(conn->rec[iov_index].iov_base, headEnd + 4, body_size);
    conn->ios[iov_index].iov_len = body_size;
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  conn->data_left = body_size - (res - head_size);
  bool once = ((size_t)body_size > (size_t)((pool.nblocks * MP_BLOCK) / 10));
  size_t iov_index = MP_expand(conn, round_to_blocks(body_size), once);
  memcpy(conn->rec[iov_index].iov_base, headEnd + 4, (res - head_size));
  conn->ios[iov_index].iov_base += (res - head_size);

  return urecvmsg(conn, iov_index, 1);
}

static inline int handle_recvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  if (conn->data_left > 0) {
    conn->data_left -= res;
    if (conn->data_left == 0) {
      conn->flags &= CF_HANDLER_READY;
      return run_handler(serv, conn, true);
    }

    conn->flags &= ~CF_HANDLER_READY;
    conn->ios[1].iov_base += res;
    return urecvmsg(conn, 1, 1);
  }

  conn->flags &= CF_HANDLER_READY;
  return run_handler(serv, conn, true);
}

static inline int serv_init(Server *serv) {
#if DEBUG
  logfd = log_init("log.txt");
  if (!logfd) {
    printf("log_init failed");
    return -1;
  }
#endif
  serv->_nroutes = get_nroutes(serv->routes);

  int pipefd[2];
  if (pipe(pipefd) < 0)
    return -1;
  pipe_in = pipefd[0];
  pipe_out = pipefd[1];
  nullfd = open("/dev/null", O_WRONLY);
  pipe_sz = fcntl(pipefd[0], F_GETPIPE_SZ);
  if (pipe_sz < 0)
    return -1;

  pool.rtimeout = serv->rtimeout;
  pool.wtimeout = serv->wtimeout;
  if (MP_init(MAX_CONNS * 8) < 0)
    return -1;
  LOG("pool initialized\n");

  if (io_uring_queue_init(MAX_CONNS, &ring, 0) < 0)
    return -1;
  LOG("uring initialized\n");

  int listenfd;
  if ((listenfd = tcp_listen(serv->port)) < 0)
    return -1;
  LOG("socket initialized\n");

  return umaccept(listenfd);
}

static inline int serv_listen(Server *serv) {
  // uint64_t last_check = get_time();
  while (true) {
    // uint64_t now = get_time();
    // if ((now - last_check) >= 200) {
    //   last_check = now;
    //   LOG("CM: CM_check ran\n");
    //   MP_timeout();
    // }

    LOG("SQ ready: %u, CQ ready: %u\n", io_uring_sq_ready(&ring), io_uring_cq_ready(&ring));
    struct io_uring_cqe *cqe;
    if (io_uring_wait_cqe(&ring, &cqe) < 0)
      continue;

    int res = cqe->res;
    LOG("res = %d\n", res);
    conn_t *conn = NULL;
    if (cqe->user_data > 100) {
      conn = (conn_t *)cqe->user_data;
      current_recv = (conn_t *)conn->recv_conn;
      current_send = (conn_t *)conn->send_conn;
    }

    if (res > 0) {
      if (cqe->user_data == ACCEPT) {
        LOG("new conn created\n");
        new_conn(res);
      } else if (conn && conn->fd != -1) {
        LOG("conn[%d]: conn.fd = %d; conn.op = %d\n", conn->cindex, conn->fd, conn->op);
        switch (conn->op) {
        case FRECVMSG:
          if (handle_frecvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case RECVMSG:
          if (handle_recvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case SENDMSG:
        case SENDMSGZC:
          // conn->last_write = get_time();
          bool zc = (conn->op == SENDMSGZC);
          if (handle_sendmsg(conn, res, zc) < 0)
            MP_clear(conn);
          break;
        case INSPLICE:
          if (handle_insplice(conn) < 0)
            MP_clear(conn);
          break;
        case OUTSPLICE:
          if (handle_outsplice(conn, res) < 0)
            MP_clear(conn);
          break;
        }
      }
    } else if (res == 0) {
      if (conn && conn->fd != -1) {
        switch (conn->op) {
        case SENDMSGZC:
          conn->zc_notifs--;
          if (conn->zc_notifs == 0 && handle_sendmsg_complete(conn) < 0)
            MP_clear(conn);
          break;
        case RECV:
          MP_clear(conn);
          break;
        }
      }
    } else {
      if (conn && conn->fd != -1) {
        if (res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR) {
          LOG("conn && conn->fd != -1 && res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR\n");
          MP_clear(conn);
        } else {
          LOG("res == -EAGAIN || res == -EWOULDBLOCK || res == -EINTR\n");
          conn = conn->recv_conn;
          struct iovec *iov = &conn->ios[0];
          memset(iov->iov_base, 0, iov->iov_len);
          if (urecv(conn, iov->iov_base, iov->iov_len, 0) < 0)
            MP_clear(conn);
        }
      }
    }

    LOG("uring operation seen\n");
    io_uring_cqe_seen(&ring, cqe);
  }

  io_uring_queue_exit(&ring);
  MP_exit(&pool);
  return 0;
}

/*** Helper ***/
static inline int _HK_write(void *data, size_t size) {
  size_t nblocks;
  int iov_index;
  conn_t *conn;
  struct iovec *iov;
  bool once;

  conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  nblocks = round_to_blocks(size);
  iov_index = MP_expand(conn, nblocks, once);
  iov = &conn->ios[iov_index];

  memcpy(iov->iov_base, data, size);
  iov->iov_len = size;
  conn->data_left += size;

  return 0;
}
static inline int _HK_write_body(Request *req, size_t offset, size_t size) {
  if (size > req->body.size || offset > req->body.size)
    return -1;

  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  int iov_index = MP_expand(conn, 0, false);
  struct iovec *iov = &conn->ios[iov_index];
  struct iovec *rec = &conn->rec[iov_index];
  rec->iov_base = req->body.ptr + offset;
  rec->iov_len = size;
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;
  conn->data_left += rec->iov_len;
  return 0;
}
/*
static inline int _HK_mem(size_t size, HKMem *mem) {
  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  bool once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  size_t nblocks = round_to_blocks(size);
  int iov_index = MP_expand(conn, nblocks, once);
  struct iovec *iov = &conn->ios[iov_index];
  mem->ptr = iov->iov_base;
  mem->size = iov->iov_len;
  mem->_iov_index = iov_index;
  mem->_flags = (IN_POOL(iov->iov_base)) ? CF_IN_POOL : CF_IN_HEAP;
  return 0;
}

static inline void _HK_send(HKMem *mem, size_t size) {
  conn_t *conn = current_send;
  struct iovec *iov = &conn->ios[mem->_iov_index];
  iov->iov_len = size;
  conn->data_left += size;
}
  */
#endif#define _GNU_SOURCE
#ifndef UTILS_H
#define UTILS_H

#include "hunk.h"
#include <arpa/inet.h>
#include <fcntl.h>
#include <liburing.h>
#include <netdb.h>
#include <signal.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/poll.h>
#include <sys/prctl.h>
#include <sys/socket.h>
#include <sys/sysinfo.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

#define MP_BLOCK  4
#define MAX_CONNS 4096
#define KB        1024
#define NIOS      32

#define IN_POOL(ptr)                 ((void *)ptr >= pool.bpool && (void *)ptr <= (pool.bpool + (pool.npages * pool.pagesize)))
#define ALIGN_TO_PAGESIZE(buff_size) (((buff_size) + (pool.pagesize - 1)) & ~(pool.pagesize - 1))
#define BYTES_TO_BLOCKS(buff_size)   (((buff_size) + (MP_BLOCK - 1)) / MP_BLOCK)
#define CEIL_BLOCKS(nblocks)         ((nblocks + 63) & ~63)
#define CEIL_PAGES(size)             (((size) + ((pool.pagesize) - 1)) & ~((pool.pagesize) - 1))

#define BIT_IS_FREE(word, bit)   (((word) >> (bit)) & 1)
#define MARK_BIT_USED(word, bit) ((word) &= ~(1ULL << (bit)))
#define MARK_BIT_FREE(word, bit) ((word) |= (1ULL << (bit)))
#define FIND_FREE_BIT(word)      ((uint64_t)(word) & -(uint64_t)(word))
#define STRLEN(s)                (sizeof(s) - 1)

#define IOVEC_NBLOCKS (BYTES_TO_BLOCKS(NIOS * sizeof(struct iovec)))
#define MSG_NBLOCKS   (BYTES_TO_BLOCKS(sizeof(struct msghdr)))
#define ZC_RES        KB *KB

#define DEBUG 0
#if DEBUG
#define LOG(...) fprintf(logfd, __VA_ARGS__)
#else
#define LOG(...) ((void)0)
#endif

typedef enum UOP {
  WRITEV = IORING_OP_WRITEV,
  SENDMSG = IORING_OP_SENDMSG,
  RECVMSG = IORING_OP_RECVMSG,
  ACCEPT = IORING_OP_ACCEPT,
  SEND = IORING_OP_SEND,
  RECV = IORING_OP_RECV,
  SENDZC = IORING_OP_SEND_ZC,
  SENDMSGZC = IORING_OP_SENDMSG_ZC,
  PEEK = 50,
  FRECVMSG,
  INSPLICE,
  OUTSPLICE
} UOP;

typedef enum CFS {
  CF_IN_POOL = (1 << 0),       // Connection is in the pool
  CF_IN_HEAP = (1 << 1),       // Connection is in the heap
  CF_SKIP_SOCK = (1 << 2),     // Don't close the socket
  CF_USE_ONCE = (1 << 3),      // Destroy after using
  CF_HANDLER_READY = (1 << 4), // Ready to call the handler
} CFS;

typedef struct conn_t {
  // Socket file descriptor
  int fd;

  // Amount of data left in the current operation
  uint64_t data_left;

  // The index of the connection struct
  uint32_t cindex;

  // The last time the connection was readable
  uint64_t last_read;

  // The last time the connection was writeable
  uint64_t last_write;

  // The operation currently being processed
  uint8_t op;

  // Connection flags
  int flags;

  // Splice fd_in
  int in_fd;

  // Splice fd_out
  int out_fd;

  void *recv_conn;
  void *send_conn;

  struct iovec *ios;
  struct iovec *rec;
  uint16_t nios;

  struct msghdr *msg;
  uint16_t zc_notifs;

  uint16_t head_size;
} conn_t;

typedef struct MPool {
  // The allocated pool of blocks
  void *bpool;

  // The allocated pool of connections
  conn_t *cpool;

  // The size of the pool in pages
  uint32_t npages;

  // The size of the pool in blocks
  uint32_t nblocks;

  // The locations of each page in the pool
  void **blocks;

  // The availability of each block
  uint64_t *freebs;

  // The locations of each conn in the pool
  conn_t **conns;

  // The availability of each conn
  uint64_t *freecs;

  // Clean up callback function
  void (*callback)(conn_t *conn);

  // The page size used
  uint32_t pagesize;

  // Socket read timeout
  uint32_t rtimeout;

  // Socket write timeout
  uint32_t wtimeout;
} MPool;

extern int pipe_sz;
extern int pipe_in, pipe_out, nullfd;
extern FILE *logfd;
extern struct io_uring ring;
extern MPool pool;
extern conn_t *current_recv;
extern conn_t *current_send;

/*
 * Prepare and submit a recv uring op
 */
static inline int urecv(conn_t *conn, void *buffer, size_t buff_size, int flags) {
  if (!conn || conn->fd == -1)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (flags == MSG_PEEK) ? PEEK : RECV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;

  io_uring_prep_recv(sqe, conn->fd, buffer, buff_size, flags);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a multi-shot accept uring op
 */
static inline int umaccept(int listenfd) {
  if (listenfd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = ACCEPT;
  io_uring_prep_multishot_accept(sqe, listenfd, NULL, NULL, SOCK_NONBLOCK);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a splice uring op
 */
static inline int usplice(conn_t *conn, int fd_in, int64_t off_in, int fd_out, int64_t off_out, size_t len) {
  if (!len || !conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = (__u64)conn;
  io_uring_prep_splice(sqe, fd_in, off_in, fd_out, off_out, len, 0);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a writev uring op
 */
static inline int uwritev(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = WRITEV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  io_uring_prep_writev(sqe, conn->fd, &conn->ios[iov_index], nios, -1);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a send uring op
 */
static inline int usend(conn_t *conn, char *res_buff, size_t buff_size, bool zc) {
  if (!conn || conn->fd <= 0 || buff_size == 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (zc) ? SENDZC : SEND;
  conn->data_left = buff_size;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  if (zc)
    io_uring_prep_send_zc(sqe, conn->fd, res_buff, buff_size, 0, 0);
  else
    io_uring_prep_send(sqe, conn->fd, res_buff, buff_size, 0);
  return io_uring_submit(&ring);
}

static inline int ufrecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = FRECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;

  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, rec->iov_len);
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int urecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = RECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int usendmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  bool zc = (conn->data_left > ZC_RES) ? true : false;
  conn->op = (zc) ? SENDMSGZC : SENDMSG;

  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  if (zc) {
    io_uring_prep_sendmsg_zc(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
    conn->zc_notifs++;
  } else {
    io_uring_prep_sendmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  }
  return io_uring_submit(&ring);
}

/*
 * Create and initialize a server socket
 */
static inline int tcp_listen(uint16_t port) {
  int enable;
  int listenfd;
  if ((listenfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    return -1;

  int flags = fcntl(listenfd, F_GETFL, 0);
  fcntl(listenfd, F_SETFL, flags | O_NONBLOCK);
  struct sockaddr_in servaddr;
  memset(&servaddr, 0, sizeof(servaddr));
  servaddr.sin_family = AF_INET;
  servaddr.sin_addr.s_addr = INADDR_ANY;
  servaddr.sin_port = htons(port);

  enable = 1;
  if (setsockopt(listenfd, SOL_SOCKET, SO_REUSEPORT, &enable, sizeof(enable)) < 0)
    return -1;

  if (bind(listenfd, (struct sockaddr *)&servaddr, sizeof(servaddr)) < 0)
    return -1;

  if (listen(listenfd, SOMAXCONN) < 0)
    return -1;

  return listenfd;
}

/*
 * Calculate the difference between two pointers
 */
static inline uintptr_t ptr_diff(uintptr_t p1, uintptr_t p2) { return (uintptr_t)(p1 > p2) ? (p1 - p2) : (p2 - p1); }

static inline size_t get_nroutes(Route *routes) {
  Route *route;
  for (size_t i = 0;; i++) {
    route = &routes[i];
    if (!route->path && !route->handler && !route->method)
      return i;
  }
}

static inline long get_content_length(char *src, char *end) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return -1;
    key = line;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, "Content-Length") != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;

    *line_end = '\0';
    long res = atol(value);
    *line_end = '\r';

    return res;
  }
  return -1;
}

static inline bool have_header(char *src, char *end, const char *header_key, const char *header_value) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    key = line;
    while (*key == ' ')
      key++;
    while (*header_key == ' ')
      header_key++;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return false;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, header_key) != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;
    while (*header_value == ' ')
      header_value++;

    *line_end = '\0';
    bool res = (strcasecmp(value, header_value) == 0);
    *line_end = '\r';

    return res;
  }

  return false;
}

static inline const char *method_str(Method method) {
  switch (method) {
  case GET:
    return "GET";
    break;
  case HEAD:
    return "HEAD";
    break;
  case POST:
    return "POST";
    break;
  case PUT:
    return "PUT";
    break;
  case DELETE:
    return "DELETE";
    break;
  case CONNECT:
    return "CONNECT";
    break;
  case OPTIONS:
    return "OPTIONS";
    break;
  case TRACE:
    return "TRACE";
    break;
  case PATCH:
    return "PATCH";
    break;
  default:
    return NULL;
  }
}

static inline uint8_t method_len(Method method) {
  switch (method) {
  case GET:
    return 3;
    break;
  case HEAD:
    return 4;
    break;
  case POST:
    return 4;
    break;
  case PUT:
    return 3;
    break;
  case DELETE:
    return 6;
    break;
  case CONNECT:
    return 7;
    break;
  case OPTIONS:
    return 7;
    break;
  case TRACE:
    return 5;
    break;
  case PATCH:
    return 5;
    break;
  default:
    return 0;
  }
}

static inline size_t round_to_blocks(size_t size) {
  size_t nblocks = BYTES_TO_BLOCKS(size);
  nblocks = CEIL_BLOCKS(nblocks);
  return nblocks;
}

/*
 * Count the digits in unsigned 64-bit int
 */
static inline int countd(uint64_t num) {
  if (num < 10ULL)
    return 1;
  if (num < 100ULL)
    return 2;
  if (num < 1000ULL)
    return 3;
  if (num < 10000ULL)
    return 4;
  if (num < 100000ULL)
    return 5;
  if (num < 1000000ULL)
    return 6;
  if (num < 10000000ULL)
    return 7;
  if (num < 100000000ULL)
    return 8;
  if (num < 1000000000ULL)
    return 9;
  if (num < 10000000000ULL)
    return 10;
  if (num < 100000000000ULL)
    return 11;
  if (num < 1000000000000ULL)
    return 12;
  if (num < 10000000000000ULL)
    return 13;
  if (num < 100000000000000ULL)
    return 14;
  if (num < 1000000000000000ULL)
    return 15;
  if (num < 10000000000000000ULL)
    return 16;
  if (num < 100000000000000000ULL)
    return 17;
  if (num < 1000000000000000000ULL)
    return 18;
  if (num < 10000000000000000000ULL)
    return 19;
  return 20;
}

/*
 * Get the time elabsed in ms
 */
static inline uint64_t get_time() {
  struct timespec ts;
  clock_gettime(CLOCK_MONOTONIC, &ts);
  return (uint64_t)(ts.tv_sec) * 1000 + (ts.tv_nsec / 1000000);
}

static inline FILE *log_init(const char *path) {
  FILE *res = fopen(path, "a+");
  setvbuf(res, NULL, _IONBF, 0);
  return res;
}

static inline int16_t pollevs(int connfd) {
  struct pollfd pfd;
  pfd.fd = connfd;
  pfd.events = POLLIN | POLLOUT | POLLERR;
  int res = poll(&pfd, 1, 0);
  if (res < 0)
    return POLLERR;
  return pfd.revents;
}

// FIXME This needs to be updated
static inline conn_t *MP_use_once(size_t nblocks, int fd) {

  void *mem = malloc(sizeof(conn_t) + 8 + (IOVEC_NBLOCKS * MP_BLOCK));
  struct conn_t *conn = (conn_t *)mem;
  memset(conn, 0, sizeof(conn_t));
  conn->ios = mem + sizeof(conn_t) + 8;

  if (nblocks > 0) {
    struct iovec *iov = &conn->ios[conn->nios++];
    mem = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (mem == MAP_FAILED)
      return NULL;
    iov->iov_base = mem;
    iov->iov_len = ALIGN_TO_PAGESIZE(nblocks * MP_BLOCK);
  }

  conn->flags |= CF_IN_HEAP;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;

  return conn;
}

static inline int find_freec() {
  uint64_t *word;
  size_t map_size = (sizeof(uint64_t) * 8);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    word = &pool.freecs[i / map_size];

    if (*word == 0) { // All used
      i += (map_size - 1);
      continue;
    }

    i += __builtin_ctzll(*word);
    MARK_BIT_USED(*word, i);
    return i;
  }

  return -1;
}

static inline int MP_init(size_t npages) {
  if (!npages)
    return -1;

  /*** Setup ***/
  pool.npages = npages;
  pool.pagesize = sysconf(_SC_PAGESIZE);

  /*** Pool ***/
  pool.bpool = mmap(NULL, pool.npages * pool.pagesize, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  if (pool.bpool == MAP_FAILED)
    return -1;
  pool.nblocks = (pool.npages * pool.pagesize) / MP_BLOCK;

  /*** Blocks ***/
  pool.blocks = malloc(sizeof(void *) * pool.nblocks);
  if (!pool.blocks)
    return -1;
  for (size_t i = 0; i < pool.nblocks; i++)
    pool.blocks[i] = pool.bpool + (i * MP_BLOCK);

  /*** Freebs ***/
  // if (posix_memalign((void **)&pool.freebs, 64, bitmap_size * sizeof(uint64_t)) < 0)
  size_t bitmap_size = (pool.nblocks + 63) / 64;
  pool.freebs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freebs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freebs[i] = UINT64_MAX;

  /*** Cpool ***/
  pool.cpool = (conn_t *)malloc(sizeof(conn_t) * MAX_CONNS);
  if (!pool.cpool)
    return -1;

  /*** Conns ***/
  pool.conns = (conn_t **)malloc(sizeof(conn_t *) * MAX_CONNS);
  if (!pool.conns)
    return -1;
  size_t conn_size = sizeof(conn_t);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    pool.conns[i] = (conn_t *)((char *)pool.cpool + (i * conn_size));
    pool.conns[i]->fd = -1;
    pool.conns[i]->in_fd = -1;
    pool.conns[i]->out_fd = -1;
  }

  /*** Freecs ***/
  bitmap_size = (MAX_CONNS + 63) / 64;
  pool.freecs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freecs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freecs[i] = UINT64_MAX;

  return 0;
}

static inline int MP_use_blks(size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t max_start = pool.nblocks - nblocks;
  size_t full_chunks = (nblocks / 64) * 64;

  for (size_t i = 0, c = 0; i <= max_start; i++, c++) {
    bool free = true;

    for (size_t j = 0; j < full_chunks; j += 64) {
      size_t word_index = (i + j) / 64;
      if (pool.freebs[word_index] != UINT64_MAX) {
        free = false;
        i += 63;
        break;
      }
    }

    for (size_t j = full_chunks; j < nblocks; j++) {
      size_t bit_index = i + j;
      size_t word_index = bit_index / 64;
      size_t bit_in_word = bit_index % 64;

      if (!BIT_IS_FREE(pool.freebs[word_index], bit_in_word)) {
        free = false;
        i += j;
        break;
      }
    }

    if (free) {
      for (size_t j = 0; j < full_chunks; j += 64) {
        size_t word_index = (i + j) / 64;
        pool.freebs[word_index] = 0;
      }

      for (size_t j = full_chunks; j < nblocks; j++) {
        size_t bit_index = i + j;
        size_t word_index = bit_index / 64;
        size_t bit_in_word = bit_index % 64;

        MARK_BIT_USED(pool.freebs[word_index], bit_in_word);
      }

      return i;
    }
  }

  return -1;
}

static inline int MP_free_blks(size_t bindex, size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t full_chunks = (nblocks / 64) * 64;
  for (size_t i = 0; i < full_chunks; i += 64) {
    size_t word_index = (bindex + i) / 64;
    pool.freebs[word_index] = UINT64_MAX;
  }

  for (size_t i = full_chunks; i < nblocks; i++) {
    size_t bit_index = bindex + i;
    size_t word_index = bit_index / 64;
    size_t bit_in_word = bit_index % 64;

    MARK_BIT_FREE(pool.freebs[word_index], bit_in_word);
  }

  memset(pool.blocks[bindex], 0, nblocks * MP_BLOCK);
  return 0;
}

static inline conn_t *MP_use(size_t nblocks, int fd, bool once) {
  if (fd <= 0)
    return NULL;
  if (once)
    return MP_use_once(nblocks, fd);

  int cindex = find_freec();
  if (cindex < 0) {
    LOG("Err: cindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  conn_t *conn = pool.conns[cindex];

  int ios_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (ios_bindex < 0) {
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }

  struct iovec *ios = pool.blocks[ios_bindex];
  conn->ios = ios;

  int rec_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (rec_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct iovec *rec = pool.blocks[rec_bindex];
  conn->rec = rec;

  int msg_bindex = MP_use_blks(MSG_NBLOCKS);
  if (msg_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct msghdr *msg = pool.blocks[msg_bindex];
  conn->msg = msg;

  if (nblocks > 0) {
    int bindex = MP_use_blks(nblocks);
    if (bindex < 0) {
      MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
      MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
      MP_free_blks(msg_bindex, IOVEC_NBLOCKS);
      MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
      LOG("Err: bindex < 0; will use MP_use_once\n");
      return MP_use_once(nblocks, fd);
    }

    size_t iov_index = conn->nios++;
    struct iovec *iov = &conn->ios[iov_index];
    struct iovec *rec = &conn->rec[iov_index];
    iov->iov_base = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
  }

  conn->msg->msg_iov = conn->ios;
  conn->msg->msg_iovlen = conn->nios;
  conn->cindex = cindex;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;
  return conn;
}

static inline void MP_shed(conn_t *conn, size_t iov_index, size_t nios) {
  struct iovec *iov, *rec;
  size_t bindex, nblocks, index;

  for (size_t i = 0; i < nios; i++) {
    index = iov_index + i;
    iov = &conn->ios[index];
    rec = &conn->rec[index];
    if (!rec || !rec->iov_base)
      continue;
    if (!IN_POOL(rec->iov_base)) {
      munmap(rec->iov_base, rec->iov_len / pool.pagesize);
    } else {
      bindex = ptr_diff((uintptr_t)rec->iov_base, (uintptr_t)pool.bpool) / MP_BLOCK;
      nblocks = rec->iov_len / MP_BLOCK;
      MP_free_blks(bindex, nblocks);
    }
    memset(iov, 0, sizeof(struct iovec));
    memset(rec, 0, sizeof(struct iovec));
    conn->nios--;
  }
}

static inline int MP_expand(conn_t *conn, size_t nblocks, bool once) {
  void *bptr;
  int iov_index, bindex;
  struct iovec *iov, *rec;

  iov_index = conn->nios++;
  iov = &conn->ios[iov_index];
  rec = &conn->rec[iov_index];

  if (nblocks == 0)
    return iov_index;

  if (once) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_base = bptr;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
    return iov_index;
  }

  bindex = MP_use_blks(nblocks);
  if (bindex < 0) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_len = iov->iov_len;
  } else {
    bptr = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_len = iov->iov_len;
  }

  iov->iov_base = bptr;
  rec->iov_base = iov->iov_base;
  return iov_index;
}

static inline int MP_free(conn_t *conn) {
  if (!conn)
    return -1;
  size_t bindex, nblocks;
  uint64_t *word;

  MP_shed(conn, 0, conn->nios);
  if (conn->flags & CF_IN_HEAP) {
    if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
      close(conn->fd);
    free(conn);
    return 0;
  }

  word = &pool.freecs[conn->cindex / 64];
  if (conn->cindex > MAX_CONNS)
    return -1;
  else if (BIT_IS_FREE(*word, conn->cindex))
    return 0;

  bindex = ptr_diff((uintptr_t)conn->ios, (uintptr_t)pool.bpool) / MP_BLOCK;
  nblocks = IOVEC_NBLOCKS;
  MP_free_blks(bindex, nblocks);

  bindex = ptr_diff((uintptr_t)conn->rec, (uintptr_t)pool.bpool) / MP_BLOCK;
  MP_free_blks(bindex, nblocks);

  if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
    close(conn->fd);

  MARK_BIT_FREE(*word, conn->cindex);
  memset(conn, 0, sizeof(conn_t));
  conn->fd = -1;
  conn->in_fd = -1;
  conn->out_fd = -1;
  return 0;
}

static inline void MP_clear(conn_t *conn) {
  conn_t *recv_conn = conn->recv_conn;
  conn_t *send_conn = conn->send_conn;
  if (recv_conn)
    MP_free(recv_conn);
  if (send_conn)
    MP_free(send_conn);
}

static inline void MP_exit(MPool *pool) {
  munmap(pool->bpool, pool->npages);
  free(pool->cpool);
  free(pool->blocks);
  free(pool->conns);
  free(pool->freebs);
  free(pool->freecs);
}

static inline void MP_timeout() {
  conn_t *conn;
  int16_t res;
  uint64_t now;
  size_t windex = 0;
  uint64_t *word = &pool.freecs[0];
  for (size_t i = 0; i < MAX_CONNS; i++) {
    if ((i / 64) < windex)
      word = &pool.freecs[++windex];

    if (*word == UINTMAX_MAX) {
      i = (i / 64) * 64 + 64;
      continue;
    }

    conn = pool.conns[i];
    if (!conn || conn->fd == -1)
      continue;

    res = pollevs(conn->fd);

    now = get_time();
    if (res & POLLERR) {
      MP_clear(conn);
      continue;
    }
    if (res & POLLIN) {
      if (pool.rtimeout > 0 && (now - conn->last_read) >= pool.rtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (res & POLLOUT) {
      if (pool.wtimeout > 0 && (now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (!(res & POLLIN || res & POLLOUT)) {
      if ((pool.rtimeout > 0 && now - conn->last_read) >= pool.rtimeout
          || (pool.wtimeout > 0 && now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
  }
}

/*
 * Calculate the length of a status string
 */
static inline size_t status_len(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return 8;
  case STATUSSWITCHINGPROTOCOLS:
    return 19;
  case STATUSPROCESSING:
    return 10;
  case STATUSEARLYHINTS:
    return 11;
  case STATUSOK:
    return 2;
  case STATUSCREATED:
    return 7;
  case STATUSACCEPTED:
    return 8;
  case STATUSNONAUTHORITATIVE:
    return 29;
  case STATUSNOCONTENT:
    return 10;
  case STATUSRESETCONTENT:
    return 13;
  case STATUSPARTIALCONTENT:
    return 15;
  case STATUSMULTISTATUS:
    return 12;
  case STATUSALREADYREPORTED:
    return 16;
  case STATUSIMUSED:
    return 7;
  case STATUSMULTIPLECHOICES:
    return 16;
  case STATUSMOVEDPERMANENTLY:
    return 17;
  case STATUSFOUND:
    return 5;
  case STATUSSEEOTHER:
    return 9;
  case STATUSNOTMODIFIED:
    return 12;
  case STATUSUSEPROXY:
    return 9;
  case STATUSTEMPORARYREDIRECT:
    return 18;
  case STATUSPERMANENTREDIRECT:
    return 18;
  case STATUSBADREQUEST:
    return 11;
  case STATUSUNAUTHORIZED:
    return 12;
  case STATUSPAYMENTREQUIRED:
    return 16;
  case STATUSFORBIDDEN:
    return 9;
  case STATUSNOTFOUND:
    return 9;
  case STATUSMETHODNOTALLOWED:
    return 18;
  case STATUSNOTACCEPTABLE:
    return 14;
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return 29;
  case STATUSREQUESTTIMEOUT:
    return 15;
  case STATUSCONFLICT:
    return 8;
  case STATUSGONE:
    return 4;
  case STATUSLENGTHREQUIRED:
    return 15;
  case STATUSPRECONDITIONFAILED:
    return 19;
  case CONTENTTOOLARGE:
    return 17;
  case STATUSURITOOLONG:
    return 12;
  case STATUSUNSUPPORTEDMEDIATYPE:
    return 22;
  case STATUSRANGENOTSATISFIABLE:
    return 21;
  case STATUSEXPECTATIONFAILED:
    return 18;
  case STATUSMISDIRECTEDREQUEST:
    return 19;
  case STATUSUNPROCESSABLECONTENT:
    return 21;
  case STATUSLOCKED:
    return 6;
  case STATUSFAILEDDEPENDENCY:
    return 17;
  case STATUSTOOEARLY:
    return 9;
  case STATUSUPGRADEREQUIRED:
    return 16;
  case STATUSPRECONDITIONREQUIRED:
    return 21;
  case STATUSTOOMANYREQUESTS:
    return 17;
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return 31;
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return 29;
  case STATUSInternalServerError:
    return 21;
  case STATUSNOTIMPLEMENTED:
    return 15;
  case STATUSBADGATEWAY:
    return 11;
  case STATUSSERVICEUNAVAILABLE:
    return 19;
  case STATUSGATEWAYTIMEOUT:
    return 15;
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return 26;
  case STATUSVARIANTALSONEGOTIATES:
    return 23;
  case STATUSINSUFFICIENTSTORAGE:
    return 20;
  case STATUSLOOPDETECTED:
    return 13;
  case STATUSNOTEXTENDED:
    return 12;
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return 31;
  default:
    return 0;
  }
}

/*
 * Return the status code string as string literal
 */
static inline char *status_str(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return "Continue";
  case STATUSSWITCHINGPROTOCOLS:
    return "Switching Protocols";
  case STATUSPROCESSING:
    return "Processing";
  case STATUSEARLYHINTS:
    return "Early Hints";
  case STATUSOK:
    return "OK";
  case STATUSCREATED:
    return "Created";
  case STATUSACCEPTED:
    return "Accepted";
  case STATUSNONAUTHORITATIVE:
    return "Non-Authoritative Information";
  case STATUSNOCONTENT:
    return "No Content";
  case STATUSRESETCONTENT:
    return "Reset Content";
  case STATUSPARTIALCONTENT:
    return "Partial Content";
  case STATUSMULTISTATUS:
    return "Multi-Status";
  case STATUSALREADYREPORTED:
    return "Already Reported";
  case STATUSIMUSED:
    return "Im Used";
  case STATUSMULTIPLECHOICES:
    return "Multiple Choices";
  case STATUSMOVEDPERMANENTLY:
    return "Moved Permanently";
  case STATUSFOUND:
    return "Found";
  case STATUSSEEOTHER:
    return "See Other";
  case STATUSNOTMODIFIED:
    return "Not Modified";
  case STATUSUSEPROXY:
    return "Use Proxy";
  case STATUSTEMPORARYREDIRECT:
    return "Temporary Redirect";
  case STATUSPERMANENTREDIRECT:
    return "Permanent Redirect";
  case STATUSBADREQUEST:
    return "Bad Request";
  case STATUSUNAUTHORIZED:
    return "Unauthorized";
  case STATUSPAYMENTREQUIRED:
    return "Payment Required";
  case STATUSFORBIDDEN:
    return "Forbidden";
  case STATUSNOTFOUND:
    return "Not Found";
  case STATUSMETHODNOTALLOWED:
    return "Method Not Allowed";
  case STATUSNOTACCEPTABLE:
    return "Not Acceptable";
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return "Proxy Authentication Required";
  case STATUSREQUESTTIMEOUT:
    return "Request Timeout";
  case STATUSCONFLICT:
    return "Conflict";
  case STATUSGONE:
    return "Gone";
  case STATUSLENGTHREQUIRED:
    return "Length Required";
  case STATUSPRECONDITIONFAILED:
    return "Precondition Failed";
  case CONTENTTOOLARGE:
    return "Content Too Large";
  case STATUSURITOOLONG:
    return "URI Too Long";
  case STATUSUNSUPPORTEDMEDIATYPE:
    return "Unsupported Media Type";
  case STATUSRANGENOTSATISFIABLE:
    return "Range Not Satisfiable";
  case STATUSEXPECTATIONFAILED:
    return "Expectation Failed";
  case STATUSMISDIRECTEDREQUEST:
    return "Misdirected Request";
  case STATUSUNPROCESSABLECONTENT:
    return "Unprocessable Content";
  case STATUSLOCKED:
    return "Locked";
  case STATUSFAILEDDEPENDENCY:
    return "Failed Dependency";
  case STATUSTOOEARLY:
    return "Too Early";
  case STATUSUPGRADEREQUIRED:
    return "Upgrade Required";
  case STATUSPRECONDITIONREQUIRED:
    return "Precondition Required";
  case STATUSTOOMANYREQUESTS:
    return "Too Many Requests";
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return "Request Header Fields Too Large";
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return "Unavailable For Legal Reasons";
  case STATUSInternalServerError:
    return "Internal Server Error";
  case STATUSNOTIMPLEMENTED:
    return "Not Implemented";
  case STATUSBADGATEWAY:
    return "Bad Gateway";
  case STATUSSERVICEUNAVAILABLE:
    return "Service Unavailable";
  case STATUSGATEWAYTIMEOUT:
    return "Gateway Timeout";
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return "HTTP Version Not Supported";
  case STATUSVARIANTALSONEGOTIATES:
    return "Variant Also Negotiates";
  case STATUSINSUFFICIENTSTORAGE:
    return "Insufficient Storage";
  case STATUSLOOPDETECTED:
    return "Loop Detected";
  case STATUSNOTEXTENDED:
    return "Not Extended";
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return "Network Authentication Required";
  default:
    return 0;
  }
}

/*
 * Return true if routes match
 */
static inline bool route_equ(Route *route, Request *req) {
  return route->method == req->method && strncmp(route->path, req->path, strlen(route->path)) == 0;
}

/*
 * Return the matching route index on success. -1 on failure
 */
static inline int match_route(Server *serv, Request *req) {
  for (size_t i = 0; i < serv->_nroutes; i++) {
    Route route = serv->routes[i];
    if (!req->path || !route.path)
      continue;
    if (route_equ(&route, req))
      return i;
    else if (req->method == HEAD && route.method == GET && strcmp(route.path, req->path) == 0)
      return i;
  }
  return -1;
}

/*
 * Return true if the response should contain the Content-Length header
 */
static inline bool should_have_content_length(Request *req, ResWriter *res) {
  return (req->method != CONNECT              // CONNECT request
          && res->status != STATUSNOCONTENT   // 204 response
          && res->status != STATUSNOTMODIFIED // 304 response
          && res->status >= 200);             // 1xx response
}

/*
 * Format http response from the ResWriter.
 * Return response size on success, 0 on failure.
 */
static inline size_t fmt_res(Request *req, ResWriter *res, char *buffer, size_t buffer_size) {
  if (!res || !buffer || buffer_size == 0)
    return 0;

  size_t res_len, total = 0;
  char *dst = buffer;
  size_t maxlen = buffer_size;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t body_length = res->len;

  res_len = snprintf(dst, maxlen, "HTTP/1.1 %d %s", (int)res->status, status_str(res->status));
  total += res_len;
  dst += res_len;
  maxlen -= res_len;

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    res_len = snprintf(dst, maxlen, "\r\n%s: %s", header->key, header->value);
    total += res_len;
    dst += res_len;
    maxlen -= res_len;
  }

  if (have_content_length) {
    res_len = snprintf(dst, maxlen, "\r\nContent-Length: %lu", body_length);
    total += res_len, dst += res_len, maxlen -= res_len;
  }

  memcpy(dst, "\r\n\r\n", 4);
  total += 4, dst += 4, maxlen -= 4;

  return total;
}

static inline size_t res_len(Request *req, ResWriter *res) {
  if (!req || !res)
    return 0;

  if (!res->status)
    res->status = STATUSOK;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t result = 0;
  result += STRLEN("HTTP/1.1 ");     // HTTP version
  result += 4;                       // Status code + space
  result += status_len(res->status); // Status name

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    result += 2;                       // "\r\n"
    result += strlen(header->key) + 2; // Header key + ':' + space
    result += strlen(header->value);   // header value
  }

  if (have_content_length) {
    result += 2;                          // "\r\n"
    result += STRLEN("Content-Length: "); // Header key
    result += countd(res->len);           // Header value
  }

  result += 4; // "\r\n\r\n"

  return result;
}

static inline int send_empty_res(Status status) {
  size_t res_len = STRLEN("HTTP/1.1 ")        // HTTP version
                   + countd((uint64_t)status) // status code
                   + 1                        // space
                   + (int)status_len(status)  // status string
                   + 4;                       // \r\n\r\n

  conn_t *conn = current_send;
  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, res_len);
  if (snprintf((char *)rec->iov_base, res_len + 1, "HTTP/1.1 %d %s\r\n\r\n", (int)status, status_str(status))
      != (int)res_len)
    return -1;

  return usendmsg(conn, 0, 1);
}

static inline ssize_t read_socket(int sockfd, size_t len) {
  if (len == 0 || sockfd <= 0)
    return 0;
  char buff[1024 * 8];
  return read(sockfd, buff, 1024 * 8);
}

static inline int read_method(Method *method, void *src) {
  if (memcmp(src, "GET", 3) == 0)
    *method = GET;
  else if (memcmp(src, "POST", 4) == 0)
    *method = POST;
  else if (memcmp(src, "HEAD", 4) == 0)
    *method = HEAD;
  else if (memcmp(src, "PUT", 3) == 0)
    *method = PUT;
  else if (memcmp(src, "DELETE", 6) == 0)
    *method = DELETE;
  else if (memcmp(src, "CONNECT", 7) == 0)
    *method = CONNECT;
  else if (memcmp(src, "OPTIONS", 7) == 0)
    *method = OPTIONS;
  else if (memcmp(src, "TRACE", 5) == 0)
    *method = TRACE;
  else if (memcmp(src, "PATCH", 5) == 0)
    *method = PATCH;
  else
    return -1;

  return 0;
}

static inline int sendmsg_res(Request *req, ResWriter *res) {
  conn_t *conn;
  size_t head_size, res_size;
  struct iovec *iov;

  conn = current_send;
  iov = &conn->ios[0];
  head_size = res_len(req, res);
  if (head_size == 0)
    return -1;

  conn->data_left += head_size;
  res_size = fmt_res(req, res, iov->iov_base, (head_size + 1));
  if (res_size != head_size)
    return -1;
  iov->iov_len = res_size;

  return usendmsg(conn, 0, conn->nios);
}

static inline int read_req(Request *req, char *req_buffer) {
  if (!req_buffer)
    return -1;
  /*** Method ***/
  char *sep = strchr(req_buffer, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }
  *sep = '\0';
  if (read_method(&req->method, req_buffer) < 0)
    return -1;

  /*** Path ***/
  char *fullpath = sep + 1;
  sep = strchr(fullpath, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }

  *sep = '\0';
  req->path = fullpath;
  /*** Params ***/
  char *paramStart = strchr(fullpath, '?');
  if (paramStart) {
    *paramStart++ = '\0';
    int params_count = 0;
    params_count = HK_parse_params(paramStart, req->params, MAX_URL_PARAMETERS);
    if (params_count > 0)
      req->params_count = params_count;
    else
      req->params_count = 0;
  } else {
    req->params = NULL;
    req->params_count = 0;
  }

  /*** Headers ***/
  char *headStart = strstr(sep + 1, "\r\n");
  char *headEnd = strstr(sep + 1, "\r\n\r\n");
  if (!headStart) {
    LOG("read_req: !headStart\n");
    return -1;
  };

  memset(headStart, 0, 2);
  headStart += 2;
  memset(headEnd, 0, 4);
  headEnd += 4;

  int headers_count = HK_parse_headers(headStart, req->headers, MAX_REQ_HEADERS);
  if (headers_count <= 0)
    return -1;
  req->headers_count = headers_count;

  /*** Host ***/
  int index = HK_get_header(req, "Host");
  if (index < 0)
    return -1;
  char *host = req->headers[index].value;
  req->hostname = host;

  /*** Port ***/
  char *colon = strchr(host, ':');
  if (colon) {
    *colon++ = '\0';
    req->port = atoi(colon);
  } else {
    req->port = PORT;
  }
  return 0;
}
static inline int process_req(Server *serv, conn_t *conn) {
  if (!conn || conn->fd == -1)
    return -1;

  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;
  if (read_req(&req, conn->ios[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    LOG("Err: route_index == -1\n");
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;
  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  sendmsg_res(&req, &res);

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int new_conn(int connfd) {
  if (connfd <= 0)
    return -1;

  current_recv = MP_use(KB * 2, connfd, false);
  current_send = MP_use(KB * 2, connfd, false);

  current_recv->recv_conn = current_recv;
  current_recv->send_conn = current_send;

  current_send->send_conn = current_send;
  current_send->recv_conn = current_recv;

  conn_t *conn = current_recv;
  if (ufrecvmsg(conn, 0, 1) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

static inline int resubmit_sendmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return usendmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int resubmir_recvmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    // FIXME the len should be increased
    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return urecvmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int handle_sendmsg_complete(conn_t *conn) {
  struct iovec *iov, *rec;

  MP_shed(conn, 1, conn->nios - 1);
  iov = &conn->ios[0];
  rec = &conn->rec[0];
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;

  return ufrecvmsg(conn->recv_conn, 0, 1);
}

static inline int handle_sendmsg(conn_t *conn, int res, bool zc) {
  if (!conn || conn->fd == -1)
    return -1;

  conn->data_left -= res;
  if (conn->data_left > 0)
    return resubmit_sendmsg(conn, res);

  if (zc)
    return 0;

  return handle_sendmsg_complete(conn);
}

static inline int handle_insplice(conn_t *conn) {
  conn->op = OUTSPLICE;
  return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
}
static inline int handle_outsplice(conn_t *conn, int res) {
  conn->data_left -= res;
  if (conn->data_left > 0) {
    conn->op = INSPLICE;
    return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
  }

  conn_t *recv_conn = conn->recv_conn;
  struct iovec *iov = &recv_conn->ios[0];
  memset(iov->iov_base, 0, iov->iov_len);
  if (urecv(recv_conn, iov->iov_base, iov->iov_len, MSG_PEEK) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

/*
static inline int handle_recv(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  void *bptr = conn->ios[0].iov_base;
  void *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  void *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  return process_req(serv, conn);
}
*/
static inline int find_route(Server *serv, char *bptr) {
  Request req = {0};
  if (read_method(&req.method, bptr) < 0) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  };
  char *space = strchr(bptr, ' ');
  req.path = (space + 1);
  space = strchr(req.path, ' ');
  *space = '\0';
  int route_index = match_route(serv, &req);
  *space = ' ';
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }
  return route_index;
}

static inline int run_handler(Server *serv, conn_t *conn, bool uses_body) {
  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;

  if (read_req(&req, conn->rec[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  if (uses_body) {
    int h_index = HK_get_header(&req, "Content-Length");
    long body_size = atol(req.headers[h_index].value);
    if (body_size >= 0) {
      req.body.ptr = conn->rec[1].iov_base;
      req.body.size = body_size;
    } else {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    }
  }

  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  if (sendmsg_res(&req, &res) < 0)
    return -1;

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int handle_frecvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  char *bptr = (char *)conn->ios[0].iov_base;
  char *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  char *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  size_t head_size = (headEnd + 4) - bptr;
  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  int route_index = find_route(serv, bptr);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  bool uses_body = serv->routes[route_index].uses_body;
  long body_size = get_content_length(headstart + 2, headEnd + 4);
  if (body_size == -1) {
    if (uses_body) {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    } else {
      body_size = 0;
    }
  }

  conn->head_size = head_size;
  if (!uses_body) {
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  if (res == (int)(head_size + body_size)) {
    size_t iov_index = MP_expand(conn, round_to_blocks(body_size), false);
    memcpy(conn->rec[iov_index].iov_base, headEnd + 4, body_size);
    conn->ios[iov_index].iov_len = body_size;
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  conn->data_left = body_size - (res - head_size);
  bool once = ((size_t)body_size > (size_t)((pool.nblocks * MP_BLOCK) / 10));
  size_t iov_index = MP_expand(conn, round_to_blocks(body_size), once);
  memcpy(conn->rec[iov_index].iov_base, headEnd + 4, (res - head_size));
  conn->ios[iov_index].iov_base += (res - head_size);

  return urecvmsg(conn, iov_index, 1);
}

static inline int handle_recvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  if (conn->data_left > 0) {
    conn->data_left -= res;
    if (conn->data_left == 0) {
      conn->flags &= CF_HANDLER_READY;
      return run_handler(serv, conn, true);
    }

    conn->flags &= ~CF_HANDLER_READY;
    conn->ios[1].iov_base += res;
    return urecvmsg(conn, 1, 1);
  }

  conn->flags &= CF_HANDLER_READY;
  return run_handler(serv, conn, true);
}

static inline int serv_init(Server *serv) {
#if DEBUG
  logfd = log_init("log.txt");
  if (!logfd) {
    printf("log_init failed");
    return -1;
  }
#endif
  serv->_nroutes = get_nroutes(serv->routes);

  int pipefd[2];
  if (pipe(pipefd) < 0)
    return -1;
  pipe_in = pipefd[0];
  pipe_out = pipefd[1];
  nullfd = open("/dev/null", O_WRONLY);
  pipe_sz = fcntl(pipefd[0], F_GETPIPE_SZ);
  if (pipe_sz < 0)
    return -1;

  pool.rtimeout = serv->rtimeout;
  pool.wtimeout = serv->wtimeout;
  if (MP_init(MAX_CONNS * 8) < 0)
    return -1;
  LOG("pool initialized\n");

  if (io_uring_queue_init(MAX_CONNS, &ring, 0) < 0)
    return -1;
  LOG("uring initialized\n");

  int listenfd;
  if ((listenfd = tcp_listen(serv->port)) < 0)
    return -1;
  LOG("socket initialized\n");

  return umaccept(listenfd);
}

static inline int serv_listen(Server *serv) {
  // uint64_t last_check = get_time();
  while (true) {
    // uint64_t now = get_time();
    // if ((now - last_check) >= 200) {
    //   last_check = now;
    //   LOG("CM: CM_check ran\n");
    //   MP_timeout();
    // }

    LOG("SQ ready: %u, CQ ready: %u\n", io_uring_sq_ready(&ring), io_uring_cq_ready(&ring));
    struct io_uring_cqe *cqe;
    if (io_uring_wait_cqe(&ring, &cqe) < 0)
      continue;

    int res = cqe->res;
    LOG("res = %d\n", res);
    conn_t *conn = NULL;
    if (cqe->user_data > 100) {
      conn = (conn_t *)cqe->user_data;
      current_recv = (conn_t *)conn->recv_conn;
      current_send = (conn_t *)conn->send_conn;
    }

    if (res > 0) {
      if (cqe->user_data == ACCEPT) {
        LOG("new conn created\n");
        new_conn(res);
      } else if (conn && conn->fd != -1) {
        LOG("conn[%d]: conn.fd = %d; conn.op = %d\n", conn->cindex, conn->fd, conn->op);
        switch (conn->op) {
        case FRECVMSG:
          if (handle_frecvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case RECVMSG:
          if (handle_recvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case SENDMSG:
        case SENDMSGZC:
          // conn->last_write = get_time();
          bool zc = (conn->op == SENDMSGZC);
          if (handle_sendmsg(conn, res, zc) < 0)
            MP_clear(conn);
          break;
        case INSPLICE:
          if (handle_insplice(conn) < 0)
            MP_clear(conn);
          break;
        case OUTSPLICE:
          if (handle_outsplice(conn, res) < 0)
            MP_clear(conn);
          break;
        }
      }
    } else if (res == 0) {
      if (conn && conn->fd != -1) {
        switch (conn->op) {
        case SENDMSGZC:
          conn->zc_notifs--;
          if (conn->zc_notifs == 0 && handle_sendmsg_complete(conn) < 0)
            MP_clear(conn);
          break;
        case RECV:
          MP_clear(conn);
          break;
        }
      }
    } else {
      if (conn && conn->fd != -1) {
        if (res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR) {
          LOG("conn && conn->fd != -1 && res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR\n");
          MP_clear(conn);
        } else {
          LOG("res == -EAGAIN || res == -EWOULDBLOCK || res == -EINTR\n");
          conn = conn->recv_conn;
          struct iovec *iov = &conn->ios[0];
          memset(iov->iov_base, 0, iov->iov_len);
          if (urecv(conn, iov->iov_base, iov->iov_len, 0) < 0)
            MP_clear(conn);
        }
      }
    }

    LOG("uring operation seen\n");
    io_uring_cqe_seen(&ring, cqe);
  }

  io_uring_queue_exit(&ring);
  MP_exit(&pool);
  return 0;
}

/*** Helper ***/
static inline int _HK_write(void *data, size_t size) {
  size_t nblocks;
  int iov_index;
  conn_t *conn;
  struct iovec *iov;
  bool once;

  conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  nblocks = round_to_blocks(size);
  iov_index = MP_expand(conn, nblocks, once);
  iov = &conn->ios[iov_index];

  memcpy(iov->iov_base, data, size);
  iov->iov_len = size;
  conn->data_left += size;

  return 0;
}
static inline int _HK_write_body(Request *req, size_t offset, size_t size) {
  if (size > req->body.size || offset > req->body.size)
    return -1;

  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  int iov_index = MP_expand(conn, 0, false);
  struct iovec *iov = &conn->ios[iov_index];
  struct iovec *rec = &conn->rec[iov_index];
  rec->iov_base = req->body.ptr + offset;
  rec->iov_len = size;
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;
  conn->data_left += rec->iov_len;
  return 0;
}
/*
static inline int _HK_mem(size_t size, HKMem *mem) {
  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  bool once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  size_t nblocks = round_to_blocks(size);
  int iov_index = MP_expand(conn, nblocks, once);
  struct iovec *iov = &conn->ios[iov_index];
  mem->ptr = iov->iov_base;
  mem->size = iov->iov_len;
  mem->_iov_index = iov_index;
  mem->_flags = (IN_POOL(iov->iov_base)) ? CF_IN_POOL : CF_IN_HEAP;
  return 0;
}

static inline void _HK_send(HKMem *mem, size_t size) {
  conn_t *conn = current_send;
  struct iovec *iov = &conn->ios[mem->_iov_index];
  iov->iov_len = size;
  conn->data_left += size;
}
  */
#endif#define _GNU_SOURCE
#ifndef UTILS_H
#define UTILS_H

#include "hunk.h"
#include <arpa/inet.h>
#include <fcntl.h>
#include <liburing.h>
#include <netdb.h>
#include <signal.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/poll.h>
#include <sys/prctl.h>
#include <sys/socket.h>
#include <sys/sysinfo.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

#define MP_BLOCK  4
#define MAX_CONNS 4096
#define KB        1024
#define NIOS      32

#define IN_POOL(ptr)                 ((void *)ptr >= pool.bpool && (void *)ptr <= (pool.bpool + (pool.npages * pool.pagesize)))
#define ALIGN_TO_PAGESIZE(buff_size) (((buff_size) + (pool.pagesize - 1)) & ~(pool.pagesize - 1))
#define BYTES_TO_BLOCKS(buff_size)   (((buff_size) + (MP_BLOCK - 1)) / MP_BLOCK)
#define CEIL_BLOCKS(nblocks)         ((nblocks + 63) & ~63)
#define CEIL_PAGES(size)             (((size) + ((pool.pagesize) - 1)) & ~((pool.pagesize) - 1))

#define BIT_IS_FREE(word, bit)   (((word) >> (bit)) & 1)
#define MARK_BIT_USED(word, bit) ((word) &= ~(1ULL << (bit)))
#define MARK_BIT_FREE(word, bit) ((word) |= (1ULL << (bit)))
#define FIND_FREE_BIT(word)      ((uint64_t)(word) & -(uint64_t)(word))
#define STRLEN(s)                (sizeof(s) - 1)

#define IOVEC_NBLOCKS (BYTES_TO_BLOCKS(NIOS * sizeof(struct iovec)))
#define MSG_NBLOCKS   (BYTES_TO_BLOCKS(sizeof(struct msghdr)))
#define ZC_RES        KB *KB

#define DEBUG 0
#if DEBUG
#define LOG(...) fprintf(logfd, __VA_ARGS__)
#else
#define LOG(...) ((void)0)
#endif

typedef enum UOP {
  WRITEV = IORING_OP_WRITEV,
  SENDMSG = IORING_OP_SENDMSG,
  RECVMSG = IORING_OP_RECVMSG,
  ACCEPT = IORING_OP_ACCEPT,
  SEND = IORING_OP_SEND,
  RECV = IORING_OP_RECV,
  SENDZC = IORING_OP_SEND_ZC,
  SENDMSGZC = IORING_OP_SENDMSG_ZC,
  PEEK = 50,
  FRECVMSG,
  INSPLICE,
  OUTSPLICE
} UOP;

typedef enum CFS {
  CF_IN_POOL = (1 << 0),       // Connection is in the pool
  CF_IN_HEAP = (1 << 1),       // Connection is in the heap
  CF_SKIP_SOCK = (1 << 2),     // Don't close the socket
  CF_USE_ONCE = (1 << 3),      // Destroy after using
  CF_HANDLER_READY = (1 << 4), // Ready to call the handler
} CFS;

typedef struct conn_t {
  // Socket file descriptor
  int fd;

  // Amount of data left in the current operation
  uint64_t data_left;

  // The index of the connection struct
  uint32_t cindex;

  // The last time the connection was readable
  uint64_t last_read;

  // The last time the connection was writeable
  uint64_t last_write;

  // The operation currently being processed
  uint8_t op;

  // Connection flags
  int flags;

  // Splice fd_in
  int in_fd;

  // Splice fd_out
  int out_fd;

  void *recv_conn;
  void *send_conn;

  struct iovec *ios;
  struct iovec *rec;
  uint16_t nios;

  struct msghdr *msg;
  uint16_t zc_notifs;

  uint16_t head_size;
} conn_t;

typedef struct MPool {
  // The allocated pool of blocks
  void *bpool;

  // The allocated pool of connections
  conn_t *cpool;

  // The size of the pool in pages
  uint32_t npages;

  // The size of the pool in blocks
  uint32_t nblocks;

  // The locations of each page in the pool
  void **blocks;

  // The availability of each block
  uint64_t *freebs;

  // The locations of each conn in the pool
  conn_t **conns;

  // The availability of each conn
  uint64_t *freecs;

  // Clean up callback function
  void (*callback)(conn_t *conn);

  // The page size used
  uint32_t pagesize;

  // Socket read timeout
  uint32_t rtimeout;

  // Socket write timeout
  uint32_t wtimeout;
} MPool;

extern int pipe_sz;
extern int pipe_in, pipe_out, nullfd;
extern FILE *logfd;
extern struct io_uring ring;
extern MPool pool;
extern conn_t *current_recv;
extern conn_t *current_send;

/*
 * Prepare and submit a recv uring op
 */
static inline int urecv(conn_t *conn, void *buffer, size_t buff_size, int flags) {
  if (!conn || conn->fd == -1)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (flags == MSG_PEEK) ? PEEK : RECV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;

  io_uring_prep_recv(sqe, conn->fd, buffer, buff_size, flags);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a multi-shot accept uring op
 */
static inline int umaccept(int listenfd) {
  if (listenfd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = ACCEPT;
  io_uring_prep_multishot_accept(sqe, listenfd, NULL, NULL, SOCK_NONBLOCK);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a splice uring op
 */
static inline int usplice(conn_t *conn, int fd_in, int64_t off_in, int fd_out, int64_t off_out, size_t len) {
  if (!len || !conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  sqe->user_data = (__u64)conn;
  io_uring_prep_splice(sqe, fd_in, off_in, fd_out, off_out, len, 0);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a writev uring op
 */
static inline int uwritev(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = WRITEV;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  io_uring_prep_writev(sqe, conn->fd, &conn->ios[iov_index], nios, -1);
  return io_uring_submit(&ring);
}

/*
 * Prepare and submit a send uring op
 */
static inline int usend(conn_t *conn, char *res_buff, size_t buff_size, bool zc) {
  if (!conn || conn->fd <= 0 || buff_size == 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = (zc) ? SENDZC : SEND;
  conn->data_left = buff_size;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  if (zc)
    io_uring_prep_send_zc(sqe, conn->fd, res_buff, buff_size, 0, 0);
  else
    io_uring_prep_send(sqe, conn->fd, res_buff, buff_size, 0);
  return io_uring_submit(&ring);
}

static inline int ufrecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = FRECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;

  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, rec->iov_len);
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int urecvmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  conn->op = RECVMSG;
  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  io_uring_prep_recvmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  return io_uring_submit(&ring);
}

static inline int usendmsg(conn_t *conn, size_t iov_index, size_t nios) {
  if (!conn || conn->fd <= 0)
    return -1;

  struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
  if (!sqe)
    return -1;

  bool zc = (conn->data_left > ZC_RES) ? true : false;
  conn->op = (zc) ? SENDMSGZC : SENDMSG;

  sqe->user_data = (__u64)conn;
  sqe->rw_flags = IORING_RECVSEND_POLL_FIRST;
  conn->msg->msg_iov = &conn->ios[iov_index];
  conn->msg->msg_iovlen = nios;
  if (zc) {
    io_uring_prep_sendmsg_zc(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
    conn->zc_notifs++;
  } else {
    io_uring_prep_sendmsg(sqe, conn->fd, conn->msg, MSG_NOSIGNAL);
  }
  return io_uring_submit(&ring);
}

/*
 * Create and initialize a server socket
 */
static inline int tcp_listen(uint16_t port) {
  int enable;
  int listenfd;
  if ((listenfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    return -1;

  int flags = fcntl(listenfd, F_GETFL, 0);
  fcntl(listenfd, F_SETFL, flags | O_NONBLOCK);
  struct sockaddr_in servaddr;
  memset(&servaddr, 0, sizeof(servaddr));
  servaddr.sin_family = AF_INET;
  servaddr.sin_addr.s_addr = INADDR_ANY;
  servaddr.sin_port = htons(port);

  enable = 1;
  if (setsockopt(listenfd, SOL_SOCKET, SO_REUSEPORT, &enable, sizeof(enable)) < 0)
    return -1;

  if (bind(listenfd, (struct sockaddr *)&servaddr, sizeof(servaddr)) < 0)
    return -1;

  if (listen(listenfd, SOMAXCONN) < 0)
    return -1;

  return listenfd;
}

/*
 * Calculate the difference between two pointers
 */
static inline uintptr_t ptr_diff(uintptr_t p1, uintptr_t p2) { return (uintptr_t)(p1 > p2) ? (p1 - p2) : (p2 - p1); }

static inline size_t get_nroutes(Route *routes) {
  Route *route;
  for (size_t i = 0;; i++) {
    route = &routes[i];
    if (!route->path && !route->handler && !route->method)
      return i;
  }
}

static inline long get_content_length(char *src, char *end) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return -1;
    key = line;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, "Content-Length") != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;

    *line_end = '\0';
    long res = atol(value);
    *line_end = '\r';

    return res;
  }
  return -1;
}

static inline bool have_header(char *src, char *end, const char *header_key, const char *header_value) {
  char *line = src;
  char *key, *colon, *value;
  if (memcmp(line, "\r\n", 2) == 0)
    line += 2;
  while (line && line < end) {
    if (memcmp(line, "\r\n", 2) == 0)
      break;

    key = line;
    while (*key == ' ')
      key++;
    while (*header_key == ' ')
      header_key++;

    char *line_end = memchr(line, '\r', end - line);
    if (!line_end)
      return false;

    colon = memchr(key, ':', line_end - key);
    if (!colon)
      return -1;

    *colon = '\0';
    if (strcasecmp(key, header_key) != 0) {
      line = line_end + 2;
      *colon = ':';
      continue;
    }
    *colon = ':';

    value = (colon + 1);
    while (*value == ' ')
      value++;
    while (*header_value == ' ')
      header_value++;

    *line_end = '\0';
    bool res = (strcasecmp(value, header_value) == 0);
    *line_end = '\r';

    return res;
  }

  return false;
}

static inline const char *method_str(Method method) {
  switch (method) {
  case GET:
    return "GET";
    break;
  case HEAD:
    return "HEAD";
    break;
  case POST:
    return "POST";
    break;
  case PUT:
    return "PUT";
    break;
  case DELETE:
    return "DELETE";
    break;
  case CONNECT:
    return "CONNECT";
    break;
  case OPTIONS:
    return "OPTIONS";
    break;
  case TRACE:
    return "TRACE";
    break;
  case PATCH:
    return "PATCH";
    break;
  default:
    return NULL;
  }
}

static inline uint8_t method_len(Method method) {
  switch (method) {
  case GET:
    return 3;
    break;
  case HEAD:
    return 4;
    break;
  case POST:
    return 4;
    break;
  case PUT:
    return 3;
    break;
  case DELETE:
    return 6;
    break;
  case CONNECT:
    return 7;
    break;
  case OPTIONS:
    return 7;
    break;
  case TRACE:
    return 5;
    break;
  case PATCH:
    return 5;
    break;
  default:
    return 0;
  }
}

static inline size_t round_to_blocks(size_t size) {
  size_t nblocks = BYTES_TO_BLOCKS(size);
  nblocks = CEIL_BLOCKS(nblocks);
  return nblocks;
}

/*
 * Count the digits in unsigned 64-bit int
 */
static inline int countd(uint64_t num) {
  if (num < 10ULL)
    return 1;
  if (num < 100ULL)
    return 2;
  if (num < 1000ULL)
    return 3;
  if (num < 10000ULL)
    return 4;
  if (num < 100000ULL)
    return 5;
  if (num < 1000000ULL)
    return 6;
  if (num < 10000000ULL)
    return 7;
  if (num < 100000000ULL)
    return 8;
  if (num < 1000000000ULL)
    return 9;
  if (num < 10000000000ULL)
    return 10;
  if (num < 100000000000ULL)
    return 11;
  if (num < 1000000000000ULL)
    return 12;
  if (num < 10000000000000ULL)
    return 13;
  if (num < 100000000000000ULL)
    return 14;
  if (num < 1000000000000000ULL)
    return 15;
  if (num < 10000000000000000ULL)
    return 16;
  if (num < 100000000000000000ULL)
    return 17;
  if (num < 1000000000000000000ULL)
    return 18;
  if (num < 10000000000000000000ULL)
    return 19;
  return 20;
}

/*
 * Get the time elabsed in ms
 */
static inline uint64_t get_time() {
  struct timespec ts;
  clock_gettime(CLOCK_MONOTONIC, &ts);
  return (uint64_t)(ts.tv_sec) * 1000 + (ts.tv_nsec / 1000000);
}

static inline FILE *log_init(const char *path) {
  FILE *res = fopen(path, "a+");
  setvbuf(res, NULL, _IONBF, 0);
  return res;
}

static inline int16_t pollevs(int connfd) {
  struct pollfd pfd;
  pfd.fd = connfd;
  pfd.events = POLLIN | POLLOUT | POLLERR;
  int res = poll(&pfd, 1, 0);
  if (res < 0)
    return POLLERR;
  return pfd.revents;
}

// FIXME This needs to be updated
static inline conn_t *MP_use_once(size_t nblocks, int fd) {

  void *mem = malloc(sizeof(conn_t) + 8 + (IOVEC_NBLOCKS * MP_BLOCK));
  struct conn_t *conn = (conn_t *)mem;
  memset(conn, 0, sizeof(conn_t));
  conn->ios = mem + sizeof(conn_t) + 8;

  if (nblocks > 0) {
    struct iovec *iov = &conn->ios[conn->nios++];
    mem = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (mem == MAP_FAILED)
      return NULL;
    iov->iov_base = mem;
    iov->iov_len = ALIGN_TO_PAGESIZE(nblocks * MP_BLOCK);
  }

  conn->flags |= CF_IN_HEAP;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;

  return conn;
}

static inline int find_freec() {
  uint64_t *word;
  size_t map_size = (sizeof(uint64_t) * 8);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    word = &pool.freecs[i / map_size];

    if (*word == 0) { // All used
      i += (map_size - 1);
      continue;
    }

    i += __builtin_ctzll(*word);
    MARK_BIT_USED(*word, i);
    return i;
  }

  return -1;
}

static inline int MP_init(size_t npages) {
  if (!npages)
    return -1;

  /*** Setup ***/
  pool.npages = npages;
  pool.pagesize = sysconf(_SC_PAGESIZE);

  /*** Pool ***/
  pool.bpool = mmap(NULL, pool.npages * pool.pagesize, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  if (pool.bpool == MAP_FAILED)
    return -1;
  pool.nblocks = (pool.npages * pool.pagesize) / MP_BLOCK;

  /*** Blocks ***/
  pool.blocks = malloc(sizeof(void *) * pool.nblocks);
  if (!pool.blocks)
    return -1;
  for (size_t i = 0; i < pool.nblocks; i++)
    pool.blocks[i] = pool.bpool + (i * MP_BLOCK);

  /*** Freebs ***/
  // if (posix_memalign((void **)&pool.freebs, 64, bitmap_size * sizeof(uint64_t)) < 0)
  size_t bitmap_size = (pool.nblocks + 63) / 64;
  pool.freebs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freebs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freebs[i] = UINT64_MAX;

  /*** Cpool ***/
  pool.cpool = (conn_t *)malloc(sizeof(conn_t) * MAX_CONNS);
  if (!pool.cpool)
    return -1;

  /*** Conns ***/
  pool.conns = (conn_t **)malloc(sizeof(conn_t *) * MAX_CONNS);
  if (!pool.conns)
    return -1;
  size_t conn_size = sizeof(conn_t);
  for (size_t i = 0; i < MAX_CONNS; i++) {
    pool.conns[i] = (conn_t *)((char *)pool.cpool + (i * conn_size));
    pool.conns[i]->fd = -1;
    pool.conns[i]->in_fd = -1;
    pool.conns[i]->out_fd = -1;
  }

  /*** Freecs ***/
  bitmap_size = (MAX_CONNS + 63) / 64;
  pool.freecs = malloc(sizeof(uint64_t) * bitmap_size);
  if (!pool.freecs)
    return -1;
  for (size_t i = 0; i < bitmap_size; i++)
    pool.freecs[i] = UINT64_MAX;

  return 0;
}

static inline int MP_use_blks(size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t max_start = pool.nblocks - nblocks;
  size_t full_chunks = (nblocks / 64) * 64;

  for (size_t i = 0, c = 0; i <= max_start; i++, c++) {
    bool free = true;

    for (size_t j = 0; j < full_chunks; j += 64) {
      size_t word_index = (i + j) / 64;
      if (pool.freebs[word_index] != UINT64_MAX) {
        free = false;
        i += 63;
        break;
      }
    }

    for (size_t j = full_chunks; j < nblocks; j++) {
      size_t bit_index = i + j;
      size_t word_index = bit_index / 64;
      size_t bit_in_word = bit_index % 64;

      if (!BIT_IS_FREE(pool.freebs[word_index], bit_in_word)) {
        free = false;
        i += j;
        break;
      }
    }

    if (free) {
      for (size_t j = 0; j < full_chunks; j += 64) {
        size_t word_index = (i + j) / 64;
        pool.freebs[word_index] = 0;
      }

      for (size_t j = full_chunks; j < nblocks; j++) {
        size_t bit_index = i + j;
        size_t word_index = bit_index / 64;
        size_t bit_in_word = bit_index % 64;

        MARK_BIT_USED(pool.freebs[word_index], bit_in_word);
      }

      return i;
    }
  }

  return -1;
}

static inline int MP_free_blks(size_t bindex, size_t nblocks) {
  if (!nblocks || nblocks > pool.nblocks)
    return -1;

  size_t full_chunks = (nblocks / 64) * 64;
  for (size_t i = 0; i < full_chunks; i += 64) {
    size_t word_index = (bindex + i) / 64;
    pool.freebs[word_index] = UINT64_MAX;
  }

  for (size_t i = full_chunks; i < nblocks; i++) {
    size_t bit_index = bindex + i;
    size_t word_index = bit_index / 64;
    size_t bit_in_word = bit_index % 64;

    MARK_BIT_FREE(pool.freebs[word_index], bit_in_word);
  }

  memset(pool.blocks[bindex], 0, nblocks * MP_BLOCK);
  return 0;
}

static inline conn_t *MP_use(size_t nblocks, int fd, bool once) {
  if (fd <= 0)
    return NULL;
  if (once)
    return MP_use_once(nblocks, fd);

  int cindex = find_freec();
  if (cindex < 0) {
    LOG("Err: cindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  conn_t *conn = pool.conns[cindex];

  int ios_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (ios_bindex < 0) {
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }

  struct iovec *ios = pool.blocks[ios_bindex];
  conn->ios = ios;

  int rec_bindex = MP_use_blks(IOVEC_NBLOCKS);
  if (rec_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct iovec *rec = pool.blocks[rec_bindex];
  conn->rec = rec;

  int msg_bindex = MP_use_blks(MSG_NBLOCKS);
  if (msg_bindex < 0) {
    MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
    MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
    MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
    LOG("Err: bindex < 0; will use MP_use_once\n");
    return MP_use_once(nblocks, fd);
  }
  struct msghdr *msg = pool.blocks[msg_bindex];
  conn->msg = msg;

  if (nblocks > 0) {
    int bindex = MP_use_blks(nblocks);
    if (bindex < 0) {
      MP_free_blks(ios_bindex, IOVEC_NBLOCKS);
      MP_free_blks(rec_bindex, IOVEC_NBLOCKS);
      MP_free_blks(msg_bindex, IOVEC_NBLOCKS);
      MARK_BIT_FREE(pool.freecs[cindex / 64], cindex);
      LOG("Err: bindex < 0; will use MP_use_once\n");
      return MP_use_once(nblocks, fd);
    }

    size_t iov_index = conn->nios++;
    struct iovec *iov = &conn->ios[iov_index];
    struct iovec *rec = &conn->rec[iov_index];
    iov->iov_base = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
  }

  conn->msg->msg_iov = conn->ios;
  conn->msg->msg_iovlen = conn->nios;
  conn->cindex = cindex;
  conn->fd = fd;
  conn->in_fd = -1;
  conn->out_fd = -1;
  // uint64_t now = get_time();
  // conn->last_read = now;
  // conn->last_write = now;
  return conn;
}

static inline void MP_shed(conn_t *conn, size_t iov_index, size_t nios) {
  struct iovec *iov, *rec;
  size_t bindex, nblocks, index;

  for (size_t i = 0; i < nios; i++) {
    index = iov_index + i;
    iov = &conn->ios[index];
    rec = &conn->rec[index];
    if (!rec || !rec->iov_base)
      continue;
    if (!IN_POOL(rec->iov_base)) {
      munmap(rec->iov_base, rec->iov_len / pool.pagesize);
    } else {
      bindex = ptr_diff((uintptr_t)rec->iov_base, (uintptr_t)pool.bpool) / MP_BLOCK;
      nblocks = rec->iov_len / MP_BLOCK;
      MP_free_blks(bindex, nblocks);
    }
    memset(iov, 0, sizeof(struct iovec));
    memset(rec, 0, sizeof(struct iovec));
    conn->nios--;
  }
}

static inline int MP_expand(conn_t *conn, size_t nblocks, bool once) {
  void *bptr;
  int iov_index, bindex;
  struct iovec *iov, *rec;

  iov_index = conn->nios++;
  iov = &conn->ios[iov_index];
  rec = &conn->rec[iov_index];

  if (nblocks == 0)
    return iov_index;

  if (once) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_base = bptr;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_base = iov->iov_base;
    rec->iov_len = iov->iov_len;
    return iov_index;
  }

  bindex = MP_use_blks(nblocks);
  if (bindex < 0) {
    bptr = mmap(NULL, nblocks * MP_BLOCK, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (bptr == MAP_FAILED)
      return -1;
    iov->iov_len = CEIL_PAGES(nblocks * MP_BLOCK);
    rec->iov_len = iov->iov_len;
  } else {
    bptr = pool.blocks[bindex];
    iov->iov_len = nblocks * MP_BLOCK;
    rec->iov_len = iov->iov_len;
  }

  iov->iov_base = bptr;
  rec->iov_base = iov->iov_base;
  return iov_index;
}

static inline int MP_free(conn_t *conn) {
  if (!conn)
    return -1;
  size_t bindex, nblocks;
  uint64_t *word;

  MP_shed(conn, 0, conn->nios);
  if (conn->flags & CF_IN_HEAP) {
    if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
      close(conn->fd);
    free(conn);
    return 0;
  }

  word = &pool.freecs[conn->cindex / 64];
  if (conn->cindex > MAX_CONNS)
    return -1;
  else if (BIT_IS_FREE(*word, conn->cindex))
    return 0;

  bindex = ptr_diff((uintptr_t)conn->ios, (uintptr_t)pool.bpool) / MP_BLOCK;
  nblocks = IOVEC_NBLOCKS;
  MP_free_blks(bindex, nblocks);

  bindex = ptr_diff((uintptr_t)conn->rec, (uintptr_t)pool.bpool) / MP_BLOCK;
  MP_free_blks(bindex, nblocks);

  if (conn->fd != -1 && !(conn->flags & CF_SKIP_SOCK))
    close(conn->fd);

  MARK_BIT_FREE(*word, conn->cindex);
  memset(conn, 0, sizeof(conn_t));
  conn->fd = -1;
  conn->in_fd = -1;
  conn->out_fd = -1;
  return 0;
}

static inline void MP_clear(conn_t *conn) {
  conn_t *recv_conn = conn->recv_conn;
  conn_t *send_conn = conn->send_conn;
  if (recv_conn)
    MP_free(recv_conn);
  if (send_conn)
    MP_free(send_conn);
}

static inline void MP_exit(MPool *pool) {
  munmap(pool->bpool, pool->npages);
  free(pool->cpool);
  free(pool->blocks);
  free(pool->conns);
  free(pool->freebs);
  free(pool->freecs);
}

static inline void MP_timeout() {
  conn_t *conn;
  int16_t res;
  uint64_t now;
  size_t windex = 0;
  uint64_t *word = &pool.freecs[0];
  for (size_t i = 0; i < MAX_CONNS; i++) {
    if ((i / 64) < windex)
      word = &pool.freecs[++windex];

    if (*word == UINTMAX_MAX) {
      i = (i / 64) * 64 + 64;
      continue;
    }

    conn = pool.conns[i];
    if (!conn || conn->fd == -1)
      continue;

    res = pollevs(conn->fd);

    now = get_time();
    if (res & POLLERR) {
      MP_clear(conn);
      continue;
    }
    if (res & POLLIN) {
      if (pool.rtimeout > 0 && (now - conn->last_read) >= pool.rtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (res & POLLOUT) {
      if (pool.wtimeout > 0 && (now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
    if (!(res & POLLIN || res & POLLOUT)) {
      if ((pool.rtimeout > 0 && now - conn->last_read) >= pool.rtimeout
          || (pool.wtimeout > 0 && now - conn->last_write) >= pool.wtimeout) {
        MP_clear(conn);
        continue;
      }
    }
  }
}

/*
 * Calculate the length of a status string
 */
static inline size_t status_len(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return 8;
  case STATUSSWITCHINGPROTOCOLS:
    return 19;
  case STATUSPROCESSING:
    return 10;
  case STATUSEARLYHINTS:
    return 11;
  case STATUSOK:
    return 2;
  case STATUSCREATED:
    return 7;
  case STATUSACCEPTED:
    return 8;
  case STATUSNONAUTHORITATIVE:
    return 29;
  case STATUSNOCONTENT:
    return 10;
  case STATUSRESETCONTENT:
    return 13;
  case STATUSPARTIALCONTENT:
    return 15;
  case STATUSMULTISTATUS:
    return 12;
  case STATUSALREADYREPORTED:
    return 16;
  case STATUSIMUSED:
    return 7;
  case STATUSMULTIPLECHOICES:
    return 16;
  case STATUSMOVEDPERMANENTLY:
    return 17;
  case STATUSFOUND:
    return 5;
  case STATUSSEEOTHER:
    return 9;
  case STATUSNOTMODIFIED:
    return 12;
  case STATUSUSEPROXY:
    return 9;
  case STATUSTEMPORARYREDIRECT:
    return 18;
  case STATUSPERMANENTREDIRECT:
    return 18;
  case STATUSBADREQUEST:
    return 11;
  case STATUSUNAUTHORIZED:
    return 12;
  case STATUSPAYMENTREQUIRED:
    return 16;
  case STATUSFORBIDDEN:
    return 9;
  case STATUSNOTFOUND:
    return 9;
  case STATUSMETHODNOTALLOWED:
    return 18;
  case STATUSNOTACCEPTABLE:
    return 14;
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return 29;
  case STATUSREQUESTTIMEOUT:
    return 15;
  case STATUSCONFLICT:
    return 8;
  case STATUSGONE:
    return 4;
  case STATUSLENGTHREQUIRED:
    return 15;
  case STATUSPRECONDITIONFAILED:
    return 19;
  case CONTENTTOOLARGE:
    return 17;
  case STATUSURITOOLONG:
    return 12;
  case STATUSUNSUPPORTEDMEDIATYPE:
    return 22;
  case STATUSRANGENOTSATISFIABLE:
    return 21;
  case STATUSEXPECTATIONFAILED:
    return 18;
  case STATUSMISDIRECTEDREQUEST:
    return 19;
  case STATUSUNPROCESSABLECONTENT:
    return 21;
  case STATUSLOCKED:
    return 6;
  case STATUSFAILEDDEPENDENCY:
    return 17;
  case STATUSTOOEARLY:
    return 9;
  case STATUSUPGRADEREQUIRED:
    return 16;
  case STATUSPRECONDITIONREQUIRED:
    return 21;
  case STATUSTOOMANYREQUESTS:
    return 17;
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return 31;
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return 29;
  case STATUSInternalServerError:
    return 21;
  case STATUSNOTIMPLEMENTED:
    return 15;
  case STATUSBADGATEWAY:
    return 11;
  case STATUSSERVICEUNAVAILABLE:
    return 19;
  case STATUSGATEWAYTIMEOUT:
    return 15;
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return 26;
  case STATUSVARIANTALSONEGOTIATES:
    return 23;
  case STATUSINSUFFICIENTSTORAGE:
    return 20;
  case STATUSLOOPDETECTED:
    return 13;
  case STATUSNOTEXTENDED:
    return 12;
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return 31;
  default:
    return 0;
  }
}

/*
 * Return the status code string as string literal
 */
static inline char *status_str(Status status) {
  switch (status) {
  case STATUSCONTINUE:
    return "Continue";
  case STATUSSWITCHINGPROTOCOLS:
    return "Switching Protocols";
  case STATUSPROCESSING:
    return "Processing";
  case STATUSEARLYHINTS:
    return "Early Hints";
  case STATUSOK:
    return "OK";
  case STATUSCREATED:
    return "Created";
  case STATUSACCEPTED:
    return "Accepted";
  case STATUSNONAUTHORITATIVE:
    return "Non-Authoritative Information";
  case STATUSNOCONTENT:
    return "No Content";
  case STATUSRESETCONTENT:
    return "Reset Content";
  case STATUSPARTIALCONTENT:
    return "Partial Content";
  case STATUSMULTISTATUS:
    return "Multi-Status";
  case STATUSALREADYREPORTED:
    return "Already Reported";
  case STATUSIMUSED:
    return "Im Used";
  case STATUSMULTIPLECHOICES:
    return "Multiple Choices";
  case STATUSMOVEDPERMANENTLY:
    return "Moved Permanently";
  case STATUSFOUND:
    return "Found";
  case STATUSSEEOTHER:
    return "See Other";
  case STATUSNOTMODIFIED:
    return "Not Modified";
  case STATUSUSEPROXY:
    return "Use Proxy";
  case STATUSTEMPORARYREDIRECT:
    return "Temporary Redirect";
  case STATUSPERMANENTREDIRECT:
    return "Permanent Redirect";
  case STATUSBADREQUEST:
    return "Bad Request";
  case STATUSUNAUTHORIZED:
    return "Unauthorized";
  case STATUSPAYMENTREQUIRED:
    return "Payment Required";
  case STATUSFORBIDDEN:
    return "Forbidden";
  case STATUSNOTFOUND:
    return "Not Found";
  case STATUSMETHODNOTALLOWED:
    return "Method Not Allowed";
  case STATUSNOTACCEPTABLE:
    return "Not Acceptable";
  case STATUSPROXYAUTHENTICATIONREQUIRED:
    return "Proxy Authentication Required";
  case STATUSREQUESTTIMEOUT:
    return "Request Timeout";
  case STATUSCONFLICT:
    return "Conflict";
  case STATUSGONE:
    return "Gone";
  case STATUSLENGTHREQUIRED:
    return "Length Required";
  case STATUSPRECONDITIONFAILED:
    return "Precondition Failed";
  case CONTENTTOOLARGE:
    return "Content Too Large";
  case STATUSURITOOLONG:
    return "URI Too Long";
  case STATUSUNSUPPORTEDMEDIATYPE:
    return "Unsupported Media Type";
  case STATUSRANGENOTSATISFIABLE:
    return "Range Not Satisfiable";
  case STATUSEXPECTATIONFAILED:
    return "Expectation Failed";
  case STATUSMISDIRECTEDREQUEST:
    return "Misdirected Request";
  case STATUSUNPROCESSABLECONTENT:
    return "Unprocessable Content";
  case STATUSLOCKED:
    return "Locked";
  case STATUSFAILEDDEPENDENCY:
    return "Failed Dependency";
  case STATUSTOOEARLY:
    return "Too Early";
  case STATUSUPGRADEREQUIRED:
    return "Upgrade Required";
  case STATUSPRECONDITIONREQUIRED:
    return "Precondition Required";
  case STATUSTOOMANYREQUESTS:
    return "Too Many Requests";
  case STATUSREQUESTHEADERFIELDSTOOLARGE:
    return "Request Header Fields Too Large";
  case STATUSUNAVAILABLEFORLEGALREASONS:
    return "Unavailable For Legal Reasons";
  case STATUSInternalServerError:
    return "Internal Server Error";
  case STATUSNOTIMPLEMENTED:
    return "Not Implemented";
  case STATUSBADGATEWAY:
    return "Bad Gateway";
  case STATUSSERVICEUNAVAILABLE:
    return "Service Unavailable";
  case STATUSGATEWAYTIMEOUT:
    return "Gateway Timeout";
  case STATUSHTTPVERSIONNOTSUPPORTED:
    return "HTTP Version Not Supported";
  case STATUSVARIANTALSONEGOTIATES:
    return "Variant Also Negotiates";
  case STATUSINSUFFICIENTSTORAGE:
    return "Insufficient Storage";
  case STATUSLOOPDETECTED:
    return "Loop Detected";
  case STATUSNOTEXTENDED:
    return "Not Extended";
  case STATUSNETWORKAUTHENTICATIONREQUIRED:
    return "Network Authentication Required";
  default:
    return 0;
  }
}

/*
 * Return true if routes match
 */
static inline bool route_equ(Route *route, Request *req) {
  return route->method == req->method && strncmp(route->path, req->path, strlen(route->path)) == 0;
}

/*
 * Return the matching route index on success. -1 on failure
 */
static inline int match_route(Server *serv, Request *req) {
  for (size_t i = 0; i < serv->_nroutes; i++) {
    Route route = serv->routes[i];
    if (!req->path || !route.path)
      continue;
    if (route_equ(&route, req))
      return i;
    else if (req->method == HEAD && route.method == GET && strcmp(route.path, req->path) == 0)
      return i;
  }
  return -1;
}

/*
 * Return true if the response should contain the Content-Length header
 */
static inline bool should_have_content_length(Request *req, ResWriter *res) {
  return (req->method != CONNECT              // CONNECT request
          && res->status != STATUSNOCONTENT   // 204 response
          && res->status != STATUSNOTMODIFIED // 304 response
          && res->status >= 200);             // 1xx response
}

/*
 * Format http response from the ResWriter.
 * Return response size on success, 0 on failure.
 */
static inline size_t fmt_res(Request *req, ResWriter *res, char *buffer, size_t buffer_size) {
  if (!res || !buffer || buffer_size == 0)
    return 0;

  size_t res_len, total = 0;
  char *dst = buffer;
  size_t maxlen = buffer_size;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t body_length = res->len;

  res_len = snprintf(dst, maxlen, "HTTP/1.1 %d %s", (int)res->status, status_str(res->status));
  total += res_len;
  dst += res_len;
  maxlen -= res_len;

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    res_len = snprintf(dst, maxlen, "\r\n%s: %s", header->key, header->value);
    total += res_len;
    dst += res_len;
    maxlen -= res_len;
  }

  if (have_content_length) {
    res_len = snprintf(dst, maxlen, "\r\nContent-Length: %lu", body_length);
    total += res_len, dst += res_len, maxlen -= res_len;
  }

  memcpy(dst, "\r\n\r\n", 4);
  total += 4, dst += 4, maxlen -= 4;

  return total;
}

static inline size_t res_len(Request *req, ResWriter *res) {
  if (!req || !res)
    return 0;

  if (!res->status)
    res->status = STATUSOK;
  bool have_content_length = should_have_content_length(req, res);
  uint64_t result = 0;
  result += STRLEN("HTTP/1.1 ");     // HTTP version
  result += 4;                       // Status code + space
  result += status_len(res->status); // Status name

  for (size_t i = 0; i < res->_nheaders; i++) {
    Header *header = &res->headers[i];
    result += 2;                       // "\r\n"
    result += strlen(header->key) + 2; // Header key + ':' + space
    result += strlen(header->value);   // header value
  }

  if (have_content_length) {
    result += 2;                          // "\r\n"
    result += STRLEN("Content-Length: "); // Header key
    result += countd(res->len);           // Header value
  }

  result += 4; // "\r\n\r\n"

  return result;
}

static inline int send_empty_res(Status status) {
  size_t res_len = STRLEN("HTTP/1.1 ")        // HTTP version
                   + countd((uint64_t)status) // status code
                   + 1                        // space
                   + (int)status_len(status)  // status string
                   + 4;                       // \r\n\r\n

  conn_t *conn = current_send;
  struct iovec *rec = &conn->rec[0];
  memset(rec->iov_base, 0, res_len);
  if (snprintf((char *)rec->iov_base, res_len + 1, "HTTP/1.1 %d %s\r\n\r\n", (int)status, status_str(status))
      != (int)res_len)
    return -1;

  return usendmsg(conn, 0, 1);
}

static inline ssize_t read_socket(int sockfd, size_t len) {
  if (len == 0 || sockfd <= 0)
    return 0;
  char buff[1024 * 8];
  return read(sockfd, buff, 1024 * 8);
}

static inline int read_method(Method *method, void *src) {
  if (memcmp(src, "GET", 3) == 0)
    *method = GET;
  else if (memcmp(src, "POST", 4) == 0)
    *method = POST;
  else if (memcmp(src, "HEAD", 4) == 0)
    *method = HEAD;
  else if (memcmp(src, "PUT", 3) == 0)
    *method = PUT;
  else if (memcmp(src, "DELETE", 6) == 0)
    *method = DELETE;
  else if (memcmp(src, "CONNECT", 7) == 0)
    *method = CONNECT;
  else if (memcmp(src, "OPTIONS", 7) == 0)
    *method = OPTIONS;
  else if (memcmp(src, "TRACE", 5) == 0)
    *method = TRACE;
  else if (memcmp(src, "PATCH", 5) == 0)
    *method = PATCH;
  else
    return -1;

  return 0;
}

static inline int sendmsg_res(Request *req, ResWriter *res) {
  conn_t *conn;
  size_t head_size, res_size;
  struct iovec *iov;

  conn = current_send;
  iov = &conn->ios[0];
  head_size = res_len(req, res);
  if (head_size == 0)
    return -1;

  conn->data_left += head_size;
  res_size = fmt_res(req, res, iov->iov_base, (head_size + 1));
  if (res_size != head_size)
    return -1;
  iov->iov_len = res_size;

  return usendmsg(conn, 0, conn->nios);
}

static inline int read_req(Request *req, char *req_buffer) {
  if (!req_buffer)
    return -1;
  /*** Method ***/
  char *sep = strchr(req_buffer, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }
  *sep = '\0';
  if (read_method(&req->method, req_buffer) < 0)
    return -1;

  /*** Path ***/
  char *fullpath = sep + 1;
  sep = strchr(fullpath, ' ');
  if (!sep) {
    LOG("read_req: !sep\n");
    return -1;
  }

  *sep = '\0';
  req->path = fullpath;
  /*** Params ***/
  char *paramStart = strchr(fullpath, '?');
  if (paramStart) {
    *paramStart++ = '\0';
    int params_count = 0;
    params_count = HK_parse_params(paramStart, req->params, MAX_URL_PARAMETERS);
    if (params_count > 0)
      req->params_count = params_count;
    else
      req->params_count = 0;
  } else {
    req->params = NULL;
    req->params_count = 0;
  }

  /*** Headers ***/
  char *headStart = strstr(sep + 1, "\r\n");
  char *headEnd = strstr(sep + 1, "\r\n\r\n");
  if (!headStart) {
    LOG("read_req: !headStart\n");
    return -1;
  };

  memset(headStart, 0, 2);
  headStart += 2;
  memset(headEnd, 0, 4);
  headEnd += 4;

  int headers_count = HK_parse_headers(headStart, req->headers, MAX_REQ_HEADERS);
  if (headers_count <= 0)
    return -1;
  req->headers_count = headers_count;

  /*** Host ***/
  int index = HK_get_header(req, "Host");
  if (index < 0)
    return -1;
  char *host = req->headers[index].value;
  req->hostname = host;

  /*** Port ***/
  char *colon = strchr(host, ':');
  if (colon) {
    *colon++ = '\0';
    req->port = atoi(colon);
  } else {
    req->port = PORT;
  }
  return 0;
}
static inline int process_req(Server *serv, conn_t *conn) {
  if (!conn || conn->fd == -1)
    return -1;

  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;
  if (read_req(&req, conn->ios[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    LOG("Err: route_index == -1\n");
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;
  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  sendmsg_res(&req, &res);

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int new_conn(int connfd) {
  if (connfd <= 0)
    return -1;

  current_recv = MP_use(KB * 2, connfd, false);
  current_send = MP_use(KB * 2, connfd, false);

  current_recv->recv_conn = current_recv;
  current_recv->send_conn = current_send;

  current_send->send_conn = current_send;
  current_send->recv_conn = current_recv;

  conn_t *conn = current_recv;
  if (ufrecvmsg(conn, 0, 1) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

static inline int resubmit_sendmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return usendmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int resubmir_recvmsg(conn_t *conn, int res) {
  struct iovec *iov;
  size_t nbytes = res;
  size_t iov_index = 0;
  while (conn->ios[iov_index].iov_base == NULL)
    iov_index++;

  for (size_t i = iov_index; nbytes > 0; i++) {
    iov = &conn->ios[i];

    // FIXME the len should be increased
    if (nbytes >= iov->iov_len) {
      nbytes -= iov->iov_len;
      memset(iov, 0, sizeof(struct iovec));
      continue;
    }

    iov->iov_base += nbytes;
    iov->iov_len -= nbytes;
    iov_index = i;
    break;
  }

  return urecvmsg(conn, iov_index, conn->nios - iov_index);
}

static inline int handle_sendmsg_complete(conn_t *conn) {
  struct iovec *iov, *rec;

  MP_shed(conn, 1, conn->nios - 1);
  iov = &conn->ios[0];
  rec = &conn->rec[0];
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;

  return ufrecvmsg(conn->recv_conn, 0, 1);
}

static inline int handle_sendmsg(conn_t *conn, int res, bool zc) {
  if (!conn || conn->fd == -1)
    return -1;

  conn->data_left -= res;
  if (conn->data_left > 0)
    return resubmit_sendmsg(conn, res);

  if (zc)
    return 0;

  return handle_sendmsg_complete(conn);
}

static inline int handle_insplice(conn_t *conn) {
  conn->op = OUTSPLICE;
  return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
}
static inline int handle_outsplice(conn_t *conn, int res) {
  conn->data_left -= res;
  if (conn->data_left > 0) {
    conn->op = INSPLICE;
    return usplice(conn, pipe_in, -1, conn->out_fd, -1, pipe_sz);
  }

  conn_t *recv_conn = conn->recv_conn;
  struct iovec *iov = &recv_conn->ios[0];
  memset(iov->iov_base, 0, iov->iov_len);
  if (urecv(recv_conn, iov->iov_base, iov->iov_len, MSG_PEEK) < 0) {
    MP_clear(conn);
    return -1;
  }
  return 0;
}

/*
static inline int handle_recv(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  void *bptr = conn->ios[0].iov_base;
  void *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  void *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  return process_req(serv, conn);
}
*/
static inline int find_route(Server *serv, char *bptr) {
  Request req = {0};
  if (read_method(&req.method, bptr) < 0) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  };
  char *space = strchr(bptr, ' ');
  req.path = (space + 1);
  space = strchr(req.path, ' ');
  *space = '\0';
  int route_index = match_route(serv, &req);
  *space = ' ';
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }
  return route_index;
}

static inline int run_handler(Server *serv, conn_t *conn, bool uses_body) {
  Param params[MAX_URL_PARAMETERS];
  Header headers[MAX_REQ_HEADERS];
  Request req = {0};
  req.params = params;
  req.headers = headers;

  ResWriter res = {0};
  Header resHeaders[MAX_REQ_HEADERS];
  res.headers = resHeaders;

  if (read_req(&req, conn->rec[0].iov_base) < 0) {
    LOG("Err: read_req failed at conn[%d]\n", conn->cindex);
    return -1;
  }

  int route_index = match_route(serv, &req);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  if (uses_body) {
    int h_index = HK_get_header(&req, "Content-Length");
    long body_size = atol(req.headers[h_index].value);
    if (body_size >= 0) {
      req.body.ptr = conn->rec[1].iov_base;
      req.body.size = body_size;
    } else {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    }
  }

  serv->routes[route_index].handler(conn->fd, &req, &res);
  conn_t *send_conn = conn->send_conn;
  res.len = send_conn->data_left;

  if (sendmsg_res(&req, &res) < 0)
    return -1;

  int index = HK_get_header(&req, "connection");
  if (index != -1 && strcasecmp(req.headers[index].value, "close") == 0) {
    LOG("found Connection: close\n");
    return -1;
  }
  return 0;
}

static inline int handle_frecvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  char *bptr = (char *)conn->ios[0].iov_base;
  char *headEnd = memmem(bptr, res, "\r\n\r\n", 4);
  if (!headEnd) {
    send_empty_res(STATUSREQUESTHEADERFIELDSTOOLARGE);
    return -1;
  }

  char *headstart = memmem(bptr, res, "\r\n", 2);
  if (!headstart) {
    send_empty_res(STATUSBADREQUEST);
    return -1;
  }

  size_t head_size = (headEnd + 4) - bptr;
  if (have_header(headstart, headEnd, "Expect", "100-Continue"))
    send_empty_res(STATUSCONTINUE);

  int route_index = find_route(serv, bptr);
  if (route_index == -1) {
    send_empty_res(STATUSNOTFOUND);
    return -1;
  }

  bool uses_body = serv->routes[route_index].uses_body;
  long body_size = get_content_length(headstart + 2, headEnd + 4);
  if (body_size == -1) {
    if (uses_body) {
      send_empty_res(STATUSLENGTHREQUIRED);
      return -1;
    } else {
      body_size = 0;
    }
  }

  conn->head_size = head_size;
  if (!uses_body) {
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  if (res == (int)(head_size + body_size)) {
    size_t iov_index = MP_expand(conn, round_to_blocks(body_size), false);
    memcpy(conn->rec[iov_index].iov_base, headEnd + 4, body_size);
    conn->ios[iov_index].iov_len = body_size;
    conn->flags &= CF_HANDLER_READY;
    return run_handler(serv, conn, uses_body);
  }

  conn->data_left = body_size - (res - head_size);
  bool once = ((size_t)body_size > (size_t)((pool.nblocks * MP_BLOCK) / 10));
  size_t iov_index = MP_expand(conn, round_to_blocks(body_size), once);
  memcpy(conn->rec[iov_index].iov_base, headEnd + 4, (res - head_size));
  conn->ios[iov_index].iov_base += (res - head_size);

  return urecvmsg(conn, iov_index, 1);
}

static inline int handle_recvmsg(Server *serv, conn_t *conn, int res) {
  if (!conn || conn->fd == -1)
    return -1;

  if (conn->data_left > 0) {
    conn->data_left -= res;
    if (conn->data_left == 0) {
      conn->flags &= CF_HANDLER_READY;
      return run_handler(serv, conn, true);
    }

    conn->flags &= ~CF_HANDLER_READY;
    conn->ios[1].iov_base += res;
    return urecvmsg(conn, 1, 1);
  }

  conn->flags &= CF_HANDLER_READY;
  return run_handler(serv, conn, true);
}

static inline int serv_init(Server *serv) {
#if DEBUG
  logfd = log_init("log.txt");
  if (!logfd) {
    printf("log_init failed");
    return -1;
  }
#endif
  serv->_nroutes = get_nroutes(serv->routes);

  int pipefd[2];
  if (pipe(pipefd) < 0)
    return -1;
  pipe_in = pipefd[0];
  pipe_out = pipefd[1];
  nullfd = open("/dev/null", O_WRONLY);
  pipe_sz = fcntl(pipefd[0], F_GETPIPE_SZ);
  if (pipe_sz < 0)
    return -1;

  pool.rtimeout = serv->rtimeout;
  pool.wtimeout = serv->wtimeout;
  if (MP_init(MAX_CONNS * 8) < 0)
    return -1;
  LOG("pool initialized\n");

  if (io_uring_queue_init(MAX_CONNS, &ring, 0) < 0)
    return -1;
  LOG("uring initialized\n");

  int listenfd;
  if ((listenfd = tcp_listen(serv->port)) < 0)
    return -1;
  LOG("socket initialized\n");

  return umaccept(listenfd);
}

static inline int serv_listen(Server *serv) {
  // uint64_t last_check = get_time();
  while (true) {
    // uint64_t now = get_time();
    // if ((now - last_check) >= 200) {
    //   last_check = now;
    //   LOG("CM: CM_check ran\n");
    //   MP_timeout();
    // }

    LOG("SQ ready: %u, CQ ready: %u\n", io_uring_sq_ready(&ring), io_uring_cq_ready(&ring));
    struct io_uring_cqe *cqe;
    if (io_uring_wait_cqe(&ring, &cqe) < 0)
      continue;

    int res = cqe->res;
    LOG("res = %d\n", res);
    conn_t *conn = NULL;
    if (cqe->user_data > 100) {
      conn = (conn_t *)cqe->user_data;
      current_recv = (conn_t *)conn->recv_conn;
      current_send = (conn_t *)conn->send_conn;
    }

    if (res > 0) {
      if (cqe->user_data == ACCEPT) {
        LOG("new conn created\n");
        new_conn(res);
      } else if (conn && conn->fd != -1) {
        LOG("conn[%d]: conn.fd = %d; conn.op = %d\n", conn->cindex, conn->fd, conn->op);
        switch (conn->op) {
        case FRECVMSG:
          if (handle_frecvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case RECVMSG:
          if (handle_recvmsg(serv, conn, res) < 0)
            MP_clear(conn);
          break;
        case SENDMSG:
        case SENDMSGZC:
          // conn->last_write = get_time();
          bool zc = (conn->op == SENDMSGZC);
          if (handle_sendmsg(conn, res, zc) < 0)
            MP_clear(conn);
          break;
        case INSPLICE:
          if (handle_insplice(conn) < 0)
            MP_clear(conn);
          break;
        case OUTSPLICE:
          if (handle_outsplice(conn, res) < 0)
            MP_clear(conn);
          break;
        }
      }
    } else if (res == 0) {
      if (conn && conn->fd != -1) {
        switch (conn->op) {
        case SENDMSGZC:
          conn->zc_notifs--;
          if (conn->zc_notifs == 0 && handle_sendmsg_complete(conn) < 0)
            MP_clear(conn);
          break;
        case RECV:
          MP_clear(conn);
          break;
        }
      }
    } else {
      if (conn && conn->fd != -1) {
        if (res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR) {
          LOG("conn && conn->fd != -1 && res != -EAGAIN && res != -EWOULDBLOCK && res != -EINTR\n");
          MP_clear(conn);
        } else {
          LOG("res == -EAGAIN || res == -EWOULDBLOCK || res == -EINTR\n");
          conn = conn->recv_conn;
          struct iovec *iov = &conn->ios[0];
          memset(iov->iov_base, 0, iov->iov_len);
          if (urecv(conn, iov->iov_base, iov->iov_len, 0) < 0)
            MP_clear(conn);
        }
      }
    }

    LOG("uring operation seen\n");
    io_uring_cqe_seen(&ring, cqe);
  }

  io_uring_queue_exit(&ring);
  MP_exit(&pool);
  return 0;
}

/*** Helper ***/
static inline int _HK_write(void *data, size_t size) {
  size_t nblocks;
  int iov_index;
  conn_t *conn;
  struct iovec *iov;
  bool once;

  conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  nblocks = round_to_blocks(size);
  iov_index = MP_expand(conn, nblocks, once);
  iov = &conn->ios[iov_index];

  memcpy(iov->iov_base, data, size);
  iov->iov_len = size;
  conn->data_left += size;

  return 0;
}
static inline int _HK_write_body(Request *req, size_t offset, size_t size) {
  if (size > req->body.size || offset > req->body.size)
    return -1;

  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  int iov_index = MP_expand(conn, 0, false);
  struct iovec *iov = &conn->ios[iov_index];
  struct iovec *rec = &conn->rec[iov_index];
  rec->iov_base = req->body.ptr + offset;
  rec->iov_len = size;
  iov->iov_base = rec->iov_base;
  iov->iov_len = rec->iov_len;
  conn->data_left += rec->iov_len;
  return 0;
}
/*
static inline int _HK_mem(size_t size, HKMem *mem) {
  conn_t *conn = current_send;
  if (conn->nios >= NIOS)
    return -1;

  bool once = (size >= ((pool.npages * pool.pagesize) / 10)) ? true : false;
  size_t nblocks = round_to_blocks(size);
  int iov_index = MP_expand(conn, nblocks, once);
  struct iovec *iov = &conn->ios[iov_index];
  mem->ptr = iov->iov_base;
  mem->size = iov->iov_len;
  mem->_iov_index = iov_index;
  mem->_flags = (IN_POOL(iov->iov_base)) ? CF_IN_POOL : CF_IN_HEAP;
  return 0;
}

static inline void _HK_send(HKMem *mem, size_t size) {
  conn_t *conn = current_send;
  struct iovec *iov = &conn->ios[mem->_iov_index];
  iov->iov_len = size;
  conn->data_left += size;
}
  */
#endif